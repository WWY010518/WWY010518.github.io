<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪夜</title>
  
  <subtitle>雪夜の博客</subtitle>
  <link href="https://wwy.wwywy.com/atom.xml" rel="self"/>
  
  <link href="https://wwy.wwywy.com/"/>
  <updated>2022-03-10T06:09:17.003Z</updated>
  <id>https://wwy.wwywy.com/</id>
  
  <author>
    <name>雪夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="https://wwy.wwywy.com/posts/544.html"/>
    <id>https://wwy.wwywy.com/posts/544.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-10T06:09:17.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构概论"><a href="#数据结构概论" class="headerlink" title="数据结构概论"></a>数据结构概论</h2><h3 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h3><p>1.数据：描述客观事物的数和字符的集合；</p><p>2.数据项：数据最小单位；</p><p>3.数据对象：性质相同的数据元素集合；</p><p>4.数据结构：数据元素之间的关系；</p><ul><li>数据逻辑结构：由数据元素之间的逻辑关系组成；</li><li>数据的存储结构：数据元素以及其关系的物理结构；</li><li>数据的运算：施加在该数据上的操作；</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>1.定义：数据之间的抽象逻辑关系；</p><p>2.表示方法：图表表示、二元组表示；</p><p>3.逻辑结构类型：</p><ul><li>集合：同属集合，无关系；</li><li>线性结构：一对一；</li><li>树形结构：一对多；</li><li>图：多对多；</li></ul><h3 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h3><p>1.定义：指数据的实际存储，逻辑结构在计算机存储实现；</p><p>2.物理存输类型：</p><ul><li>顺序存储结构：连续存储</li><li>链式存储结构：非连续存储</li><li>索引存储结构：键值对</li><li>哈希（散列）存储：计算关键字哈希值仅存数据<h3 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h3></li></ul><p>1.定义：对数据实施的操作；</p><p>运算定义和运算实现分离：基于逻辑结构定义运算，基于存储结构实现运算</p><p>2.常用数据运算类型：增删改查以及排序；</p><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><p>1.数据类型：值类型，引用类型等；</p><p>2.抽象数据类型：从求解问题抽象出来的数据逻辑结构和抽象运算，与具体实现无关（重要特征是数据抽象和数据封装），算法就是抽象运算的实现；</p><h2 id="算法概论"><a href="#算法概论" class="headerlink" title="算法概论"></a>算法概论</h2><p>1.算法的定义：对特定问题的一种描叙，是指令的有限序列，应具有以下特征；</p><ul><li>有穷性：是可以终止结束的算法；</li><li>确定性：相同输入相同输出；</li><li>可行性：算法每一步都必须是可行的，每一步都能执行有限次数完成；</li><li>有输入输出：输入加工对象，加功得到结果；</li></ul><p>2.算法的设计目标：如下几点</p><ul><li>正确性：对于非法的数据能够得到满足规格的结果；</li><li>可读可使用性：便于阅读、交流和使用；</li><li>健壮性：数据不合法时，也能做出相应处理；</li><li>时间高效率和低存储：满足时间高效率和低存储；</li></ul><p>3.算法的描述：采用计算机语言描叙算法；</p><h2 id="算法分析概论"><a href="#算法分析概论" class="headerlink" title="算法分析概论"></a>算法分析概论</h2><p>1.算法分析的定义：分析算法占用的计算机CPU时间和内存空间的多少；</p><h3 id="算法时间性能分析（重点理解）"><a href="#算法时间性能分析（重点理解）" class="headerlink" title="算法时间性能分析（重点理解）"></a>算法时间性能分析（重点理解）</h3><p>1.时间算法类型：</p><ul><li>事后统计法：统计执行时间，必须执行程序且很多因素掩盖了算法本质，如计算机速度、语言、问题规模等；</li><li>事前估计法：抛开问题，仅考虑算法本身的效率；</li></ul><p>2.算法时间复杂度定义：平均情况下的问题规模n的函数的最高阶表示，推导如下</p><ul><li>执行次数T(n) ==&gt; 问题规模n的函数；</li><li>总算法执行时间 ==&gt; 原操作+ T(n)(执行次数或算法频率)；</li><li>简化算法执行时间 ==&gt;  仅考虑执行次数T(n)  ；</li><li>上界f(n) ==&gt; 由T(n)对于n的阶级函数的拆解，是问题规模n的某个函数；</li><li>问题阶级增率比较 ==&gt; 1(仅原操作)&lt;${log}<em>{2}$n&lt;n&lt;n${log}</em>{2}$n&lt;$n^2$&lt;$n^3$&lt;$2^n$&lt;n!&lt;$n^n$；</li><li>渐进时间复杂度（函数渐进增长问题） ==&gt; O(f(n))（O是找出T(n)最高阶或者说最紧凑的上界）；</li><li>平均时间复杂度 ==&gt;最好时间复杂度（算法运气好的时间）与最坏时间复杂度（算法运气坏的时候）的折中考虑；</li></ul><p>3.推导大O阶的方法：</p><ul><li>用常数1取代运行时间中所有加法常数；</li><li>修改后的运行次数函数，只保留最高阶数；</li><li>去除最高阶的相乘系数，得到的就是大O阶；</li></ul><p>4.算法复杂度求和求积：</p><ul><li>T1(n)+T2(n)=O(Max(fn,g(n)))  例如并列循环</li><li>T1(n) * T2(n) = O(f(n)*g(n)) 例如多层嵌套循环</li></ul><p>5.递归算法时间复杂度：自己调用自己，不能采用前面的分析方法；</p><h3 id="算法空间性能分析"><a href="#算法空间性能分析" class="headerlink" title="算法空间性能分析"></a>算法空间性能分析</h3><p>1.算法空间复杂度：记作S(n) = O(g(n))，n为问题的规模，f(n)为语句所占用的存储空间函数，解释如下；</p><ul><li>局部空间：初始只分配一次空间，参与原操作完继续使用，如果算法只有该形式空间分配，即问题规模n为常数，则该算法为原地工作或就地工作算法，空间复杂度为O(1)；</li><li>临时空间：原操作时才分配空间，原操作完即可释放，基本是其算法执行次数的考虑，空间复杂度和时间复杂度相关；</li></ul><p>2.递归算法空间复杂度：待记；</p><h2 id="程序概论"><a href="#程序概论" class="headerlink" title="程序概论"></a>程序概论</h2><p>1.程序=数据结构+算法；</p><p>2.数据结构和算法的联系：数据存储结构会影响算法的好坏，不能只单单考虑一种，存储强、信息多的存储结构，算法会比较好设计，反而相对简单的存储结构可能要设计一套复杂的算法；</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h1 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h1><h1 id="数和二叉树"><a href="#数和二叉树" class="headerlink" title="数和二叉树"></a>数和二叉树</h1><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h1 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h1><h1 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;数据结构概论&quot;&gt;&lt;a href=&quot;#数据结构概论&quot; class=&quot;headerlink&quot; title=&quot;数据结构概论&quot;&gt;&lt;/a&gt;数</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="https://wwy.wwywy.com/posts/520.html"/>
    <id>https://wwy.wwywy.com/posts/520.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-10T11:41:36.247Z</updated>
    
    <content type="html"><![CDATA[<p>重要信息：老师电话13574404624</p><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>编译器前端主要知识：词法分析、语法分析、语义处理；</p><p>编译器后端主要知识：中间代码生成、代码优化、目标代码生成；</p><h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><p>文法的定义：文法是语言的抽象规则（例如我们的语言都是遵守主谓宾这个文法）；</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h1 id="自顶向下语法分析方法（重点）"><a href="#自顶向下语法分析方法（重点）" class="headerlink" title="自顶向下语法分析方法（重点）"></a>自顶向下语法分析方法（重点）</h1><h2 id="确定的自顶向下分析思想"><a href="#确定的自顶向下分析思想" class="headerlink" title="确定的自顶向下分析思想"></a>确定的自顶向下分析思想</h2><h2 id="LL-1-文法的判别"><a href="#LL-1-文法的判别" class="headerlink" title="LL(1)文法的判别"></a>LL(1)文法的判别</h2><h1 id="自顶向上优先分析"><a href="#自顶向上优先分析" class="headerlink" title="自顶向上优先分析"></a>自顶向上优先分析</h1><h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><h1 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h1><h1 id="静态语义分析和中间代码生成"><a href="#静态语义分析和中间代码生成" class="headerlink" title="静态语义分析和中间代码生成"></a>静态语义分析和中间代码生成</h1><h1 id="运行时存储组织"><a href="#运行时存储组织" class="headerlink" title="运行时存储组织"></a>运行时存储组织</h1><h1 id="代码优化和目标代码生成"><a href="#代码优化和目标代码生成" class="headerlink" title="代码优化和目标代码生成"></a>代码优化和目标代码生成</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重要信息：老师电话13574404624&lt;/p&gt;
&lt;h1 id=&quot;引论&quot;&gt;&lt;a href=&quot;#引论&quot; class=&quot;headerlink&quot; title=&quot;引论&quot;&gt;&lt;/a&gt;引论&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编译原理" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://wwy.wwywy.com/posts/528.html"/>
    <id>https://wwy.wwywy.com/posts/528.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-10T11:54:54.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机软硬件概念"><a href="#计算机软硬件概念" class="headerlink" title="计算机软硬件概念"></a>计算机软硬件概念</h2><p>1.软硬件概念：计算机系统由软件和硬件俩大部分组成，如下；</p><ul><li>硬件：是计算机的实体部分；</li><li>软件：由各类特殊功能的程序组成，通常存放在计算机的主存或者辅存中，通常分为系统软件和应用软件；</li></ul><h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><p>1冯·诺依曼计算机：1945年提出“存储程序”概念设计的计算机，冯·诺依曼计算机是以运算器为中心的，现代的计算机已经转化为以存储器为中心，如下图；<br><img src="https://s1.ax1x.com/2022/03/06/bBXj7F.png" alt="冯·诺依曼计算机"></p><p>2计算机组成：以下五部分组成</p><ul><li>输入设备：将程序和数据以机器所能识别和接受的信息形式输入到计算机内（键盘、鼠标、扫描仪、语音输入设备、手写笔、触摸屏、数码摄像设备等）；</li><li>输出设备：将计算机处理的结果以人们所能接受的信息形式或其它系统所要求的信息形式输出（显示器、打印机、绘图仪 、音箱）；</li><li>存储器：用于存放程序和数据。存储器是计算机存储信息的核心，一般分为如下主存和外存。<ul><li>主存储器(主存，内存)：CPU能直接访问，主存分为若干个存储单元，每个单元都有唯一的地址编码，通常是按字节或字节的整数倍编码。存储器总是按地址访问的；</li><li>辅助存储器(外存，辅存)：CPU不能直接访问，辅存中的信息必须调入主存后，才能为CPU所使用，辅存速度较慢，但容量大，用于存放CPU暂时不用的程序和数据（软盘、硬盘、光盘、磁带机）；</li></ul></li><li>运算器：用于完成算术和逻辑运算，核心是算术逻辑部件(ALU)，是CPU的核心部件，还有若干寄存器，用于存放操作数、中间结果或最终结果；</li><li>控制器：控制器是整个计算机的指挥中心，通过实现编好的程序用于控制整个计算机系统中的各部件有条不紊地进行工作，其控制部件（CU）是CPU的核心部件，运作如下。<ul><li>程序计数器PC（Program Counter）：存放将要执行的指令的地址（指向存储单元），具有自增功能；</li><li>指令寄存器IR（ Instruction Register）： 存放当前正在执行的指令；</li><li>指令译码器ID（Instruction Decoder）：分析指令；</li><li>时序部件（Sequencer）：分析指令时序；</li><li>控制信号发生器：运作；<br><img src="https://s1.ax1x.com/2022/03/06/bBXrYd.png" alt="计算机五大组成部件"></li></ul></li></ul><p>3.计算机硬件技术指标：</p><ul><li>机器字长：数据的位数，一般和CPU寄存器有关；</li><li>存储容量：存储器的容量；</li><li>运算速度：计算机运行速度；</li></ul><h1 id="计算计信息和运算"><a href="#计算计信息和运算" class="headerlink" title="计算计信息和运算"></a>计算计信息和运算</h1><h2 id="常用进位计数制"><a href="#常用进位计数制" class="headerlink" title="常用进位计数制"></a>常用进位计数制</h2><p>1.定义：用进位的原则进行计数称为进位计数制，简称进制；</p><p>2.有关的概念：</p><ul><li>数码：一组用来表示某种数制的符号，eg：二进制的0和1；</li><li>基数：数制所使用的数码个数，常用R表示，称为R进制；</li><li>位权：数码在不同位置的权值 eg：十进制的位权就是10的几次方；</li></ul><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>1.定义：</p><ul><li>数码：1，2，3，4，5，6，7，8，9；</li><li>基数：10；</li><li>位权：10为底的幂；</li><li>写法规则：2022 D （D是DEC，可以省略）；</li></ul><p>2.转二进制：转换规则：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来，如下图： 180（十进制）转换二进制为：10110100<br><img src="https://s1.ax1x.com/2022/03/06/bDda79.png" alt="十进制转二进制"></p><p>3.转八进制：按照8除十进制整数取余，直到商为0为止；<br><img src="https://s1.ax1x.com/2022/03/06/bD0yee.png" alt="十进制转八进制"></p><p>4.转十六进制：转换规则：用16整除十进制整数，可以得到一个商和余数；再用16去除商，又会得到一个商和余数，如此进行；<br><img src="https://s1.ax1x.com/2022/03/06/bD0Hoj.png" alt="十进制转十六进制"></p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>1.定义：</p><ul><li>数码：0，1；</li><li>基数： R= 2；</li><li>位权：2为底的幂；</li><li>写法规则：0B 10010101 B （0B是c#中s使用二进制的前缀，D是BIN，可以省略）；</li></ul><p>2.转十进制：把二进制按权展开，相加即得十进制数<br><img src="https://s1.ax1x.com/2022/03/06/bDaTeJ.png" alt="二进制转十进制"></p><p>3.转八进制：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。<br><img src="https://s1.ax1x.com/2022/03/06/bDd9wd.png" alt="二进制转八进制"></p><p>4.转十六进制：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。<br><img src="https://s1.ax1x.com/2022/03/06/bDwG4I.png" alt="二进制转十六进制"></p><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>1.定义：</p><ul><li>数码：0,1,2,3,4,5,6,7；</li><li>基数：8；</li><li>位权：8为底的幂；</li><li>写法规则：0 720 O （0是c#中使用八进制的前缀，O是OCT，可以省略）；</li></ul><p>2.转十进制：把八进制数按权展开、相加即得十进制数。<br><img src="https://s1.ax1x.com/2022/03/06/bDBFYR.png" alt="八进制转十进制"></p><p>3.转二进制：八进制通过除二取余，得到二进制数，对每个八进制为3个二进制，不足在最左边补零；<br><img src="https://s1.ax1x.com/2022/03/06/bDdkfP.png" alt="八进制转二进制"></p><p>4.转十六进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换；</p><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>1.定义：</p><ul><li>数码：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F;</li><li>基数：16;</li><li>位权：16为底的幂；</li><li>写法规则：0X 1AF H （0X是c#中使用十六进制的前缀，D是HEX，可以省略）；</li></ul><p>2.转十进制：把十六进制数按权展开、相加即得十进制数。<br><img src="https://s1.ax1x.com/2022/03/06/bDBu0e.png" alt="十六进制转十进制"></p><p>3.转二进制：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。<br><img src="https://s1.ax1x.com/2022/03/06/bDw0bQ.png" alt="十六进制转二进制"></p><p>4.转八进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换</p><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h1 id="控制器和中央处理器"><a href="#控制器和中央处理器" class="headerlink" title="控制器和中央处理器"></a>控制器和中央处理器</h1><h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h1 id="补充附录"><a href="#补充附录" class="headerlink" title="补充附录"></a>补充附录</h1><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><p>1.ASCII 码说明：ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符 [1]  。其中：</p><ul><li>0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 。</li><li>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。</li><li>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</li><li>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1 [1]  。</li><li>后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1]  。</li></ul><p>2.ASCII码表具体如下所示 :</p><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>缩写/字符</th><th>解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>00</td><td>0</td><td>0x00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>0000 0001</td><td>01</td><td>1</td><td>0x01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>0000 0010</td><td>02</td><td>2</td><td>0x02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>0000 0011</td><td>03</td><td>3</td><td>0x03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>0000 0100</td><td>04</td><td>4</td><td>0x04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>0000 0101</td><td>05</td><td>5</td><td>0x05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>0000 0110</td><td>06</td><td>6</td><td>0x06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>0000 0111</td><td>07</td><td>7</td><td>0x07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>0000 1000</td><td>010</td><td>8</td><td>0x08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>0000 1001</td><td>011</td><td>9</td><td>0x09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>0000 1010</td><td>012</td><td>10</td><td>0x0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>0000 1011</td><td>013</td><td>11</td><td>0x0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>0000 1100</td><td>014</td><td>12</td><td>0x0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>0000 1101</td><td>015</td><td>13</td><td>0x0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>0000 1110</td><td>016</td><td>14</td><td>0x0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>0000 1111</td><td>017</td><td>15</td><td>0x0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>0001 0000</td><td>020</td><td>16</td><td>0x10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>0001 0001</td><td>021</td><td>17</td><td>0x11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>0001 0010</td><td>022</td><td>18</td><td>0x12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>0001 0011</td><td>023</td><td>19</td><td>0x13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>0001 0100</td><td>024</td><td>20</td><td>0x14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>0001 0101</td><td>025</td><td>21</td><td>0x15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>0001 0110</td><td>026</td><td>22</td><td>0x16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>0001 0111</td><td>027</td><td>23</td><td>0x17</td><td>ETB (end of trans. block)</td><td>结束传输块</td></tr><tr><td>0001 1000</td><td>030</td><td>24</td><td>0x18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>0001 1001</td><td>031</td><td>25</td><td>0x19</td><td>EM (end of medium)</td><td>媒介结束</td></tr><tr><td>0001 1010</td><td>032</td><td>26</td><td>0x1A</td><td>SUB (substitute)</td><td>代替</td></tr><tr><td>0001 1011</td><td>033</td><td>27</td><td>0x1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>0001 1100</td><td>034</td><td>28</td><td>0x1C</td><td>FS (file separator)</td><td>文件分隔符</td></tr><tr><td>0001 1101</td><td>035</td><td>29</td><td>0x1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>0001 1110</td><td>036</td><td>30</td><td>0x1E</td><td>RS (record separator)</td><td>记录分隔符</td></tr><tr><td>0001 1111</td><td>037</td><td>31</td><td>0x1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>0010 0000</td><td>040</td><td>32</td><td>0x20</td><td>(space)</td><td>空格</td></tr><tr><td>0010 0001</td><td>041</td><td>33</td><td>0x21</td><td>!</td><td>叹号</td></tr><tr><td>0010 0010</td><td>042</td><td>34</td><td>0x22</td><td>“</td><td>双引号</td></tr><tr><td>0010 0011</td><td>043</td><td>35</td><td>0x23</td><td>#</td><td>井号</td></tr><tr><td>0010 0100</td><td>044</td><td>36</td><td>0x24</td><td>$</td><td>美元符</td></tr><tr><td>0010 0101</td><td>045</td><td>37</td><td>0x25</td><td>%</td><td>百分号</td></tr><tr><td>0010 0110</td><td>046</td><td>38</td><td>0x26</td><td>&amp;</td><td>和号</td></tr><tr><td>0010 0111</td><td>047</td><td>39</td><td>0x27</td><td>‘</td><td>闭单引号</td></tr><tr><td>0010 1000</td><td>050</td><td>40</td><td>0x28</td><td>(</td><td>开括号</td></tr><tr><td>0010 1001</td><td>051</td><td>41</td><td>0x29</td><td>)</td><td>闭括号</td></tr><tr><td>0010 1010</td><td>052</td><td>42</td><td>0x2A</td><td>*</td><td>星号</td></tr><tr><td>0010 1011</td><td>053</td><td>43</td><td>0x2B</td><td>+</td><td>加号</td></tr><tr><td>0010 1100</td><td>054</td><td>44</td><td>0x2C</td><td>,</td><td>逗号</td></tr><tr><td>0010 1101</td><td>055</td><td>45</td><td>0x2D</td><td>-</td><td>减号/破折号</td></tr><tr><td>0010 1110</td><td>056</td><td>46</td><td>0x2E</td><td>.</td><td>句号</td></tr><tr><td>0010 1111</td><td>057</td><td>47</td><td>0x2F</td><td>/</td><td>斜杠</td></tr><tr><td>0011 0000</td><td>060</td><td>48</td><td>0x30</td><td>0</td><td>字符0</td></tr><tr><td>0011 0001</td><td>061</td><td>49</td><td>0x31</td><td>1</td><td>字符1</td></tr><tr><td>0011 0010</td><td>062</td><td>50</td><td>0x32</td><td>2</td><td>字符2</td></tr><tr><td>0011 0011</td><td>063</td><td>51</td><td>0x33</td><td>3</td><td>字符3</td></tr><tr><td>0011 0100</td><td>064</td><td>52</td><td>0x34</td><td>4</td><td>字符4</td></tr><tr><td>0011 0101</td><td>065</td><td>53</td><td>0x35</td><td>5</td><td>字符5</td></tr><tr><td>0011 0110</td><td>066</td><td>54</td><td>0x36</td><td>6</td><td>字符6</td></tr><tr><td>0011 0111</td><td>067</td><td>55</td><td>0x37</td><td>7</td><td>字符7</td></tr><tr><td>0011 1000</td><td>070</td><td>56</td><td>0x38</td><td>8</td><td>字符8</td></tr><tr><td>0011 1001</td><td>071</td><td>57</td><td>0x39</td><td>9</td><td>字符9</td></tr><tr><td>0011 1010</td><td>072</td><td>58</td><td>0x3A</td><td>:</td><td>冒号</td></tr><tr><td>0011 1011</td><td>073</td><td>59</td><td>0x3B</td><td>;</td><td>分号</td></tr><tr><td>0011 1100</td><td>074</td><td>60</td><td>0x3C</td><td>&lt;</td><td>小于</td></tr><tr><td>0011 1101</td><td>075</td><td>61</td><td>0x3D</td><td>=</td><td>等号</td></tr><tr><td>0011 1110</td><td>076</td><td>62</td><td>0x3E</td><td>&gt;</td><td>大于</td></tr><tr><td>0011 1111</td><td>077</td><td>63</td><td>0x3F</td><td>?</td><td>问号</td></tr><tr><td>0100 0000</td><td>0100</td><td>64</td><td>0x40</td><td>@</td><td>电子邮件符号</td></tr><tr><td>0100 0001</td><td>0101</td><td>65</td><td>0x41</td><td>A</td><td>大写字母A</td></tr><tr><td>0100 0010</td><td>0102</td><td>66</td><td>0x42</td><td>B</td><td>大写字母B</td></tr><tr><td>0100 0011</td><td>0103</td><td>67</td><td>0x43</td><td>C</td><td>大写字母C</td></tr><tr><td>0100 0100</td><td>0104</td><td>68</td><td>0x44</td><td>D</td><td>大写字母D</td></tr><tr><td>0100 0101</td><td>0105</td><td>69</td><td>0x45</td><td>E</td><td>大写字母E</td></tr><tr><td>0100 0110</td><td>0106</td><td>70</td><td>0x46</td><td>F</td><td>大写字母F</td></tr><tr><td>0100 0111</td><td>0107</td><td>71</td><td>0x47</td><td>G</td><td>大写字母G</td></tr><tr><td>0100 1000</td><td>0110</td><td>72</td><td>0x48</td><td>H</td><td>大写字母H</td></tr><tr><td>0100 1001</td><td>0111</td><td>73</td><td>0x49</td><td>I</td><td>大写字母I</td></tr><tr><td>01001010</td><td>0112</td><td>74</td><td>0x4A</td><td>J</td><td>大写字母J</td></tr><tr><td>0100 1011</td><td>0113</td><td>75</td><td>0x4B</td><td>K</td><td>大写字母K</td></tr><tr><td>0100 1100</td><td>0114</td><td>76</td><td>0x4C</td><td>L</td><td>大写字母L</td></tr><tr><td>0100 1101</td><td>0115</td><td>77</td><td>0x4D</td><td>M</td><td>大写字母M</td></tr><tr><td>0100 1110</td><td>0116</td><td>78</td><td>0x4E</td><td>N</td><td>大写字母N</td></tr><tr><td>0100 1111</td><td>0117</td><td>79</td><td>0x4F</td><td>O</td><td>大写字母O</td></tr><tr><td>0101 0000</td><td>0120</td><td>80</td><td>0x50</td><td>P</td><td>大写字母P</td></tr><tr><td>0101 0001</td><td>0121</td><td>81</td><td>0x51</td><td>Q</td><td>大写字母Q</td></tr><tr><td>0101 0010</td><td>0122</td><td>82</td><td>0x52</td><td>R</td><td>大写字母R</td></tr><tr><td>0101 0011</td><td>0123</td><td>83</td><td>0x53</td><td>S</td><td>大写字母S</td></tr><tr><td>0101 0100</td><td>0124</td><td>84</td><td>0x54</td><td>T</td><td>大写字母T</td></tr><tr><td>0101 0101</td><td>0125</td><td>85</td><td>0x55</td><td>U</td><td>大写字母U</td></tr><tr><td>0101 0110</td><td>0126</td><td>86</td><td>0x56</td><td>V</td><td>大写字母V</td></tr><tr><td>0101 0111</td><td>0127</td><td>87</td><td>0x57</td><td>W</td><td>大写字母W</td></tr><tr><td>0101 1000</td><td>0130</td><td>88</td><td>0x58</td><td>X</td><td>大写字母X</td></tr><tr><td>0101 1001</td><td>0131</td><td>89</td><td>0x59</td><td>Y</td><td>大写字母Y</td></tr><tr><td>0101 1010</td><td>0132</td><td>90</td><td>0x5A</td><td>Z</td><td>大写字母Z</td></tr><tr><td>0101 1011</td><td>0133</td><td>91</td><td>0x5B</td><td>[</td><td>开方括号</td></tr><tr><td>0101 1100</td><td>0134</td><td>92</td><td>0x5C</td><td>\</td><td>反斜杠</td></tr><tr><td>0101 1101</td><td>0135</td><td>93</td><td>0x5D</td><td>]</td><td>闭方括号</td></tr><tr><td>0101 1110</td><td>0136</td><td>94</td><td>0x5E</td><td>^</td><td>脱字符</td></tr><tr><td>0101 1111</td><td>0137</td><td>95</td><td>0x5F</td><td>_</td><td>下划线</td></tr><tr><td>0110 0000</td><td>0140</td><td>96</td><td>0x60</td><td>`</td><td>开单引号</td></tr><tr><td>0110 0001</td><td>0141</td><td>97</td><td>0x61</td><td>a</td><td>小写字母a</td></tr><tr><td>0110 0010</td><td>0142</td><td>98</td><td>0x62</td><td>b</td><td>小写字母b</td></tr><tr><td>0110 0011</td><td>0143</td><td>99</td><td>0x63</td><td>c</td><td>小写字母c</td></tr><tr><td>0110 0100</td><td>0144</td><td>100</td><td>0x64</td><td>d</td><td>小写字母d</td></tr><tr><td>0110 0101</td><td>0145</td><td>101</td><td>0x65</td><td>e</td><td>小写字母e</td></tr><tr><td>0110 0110</td><td>0146</td><td>102</td><td>0x66</td><td>f</td><td>小写字母f</td></tr><tr><td>0110 0111</td><td>0147</td><td>103</td><td>0x67</td><td>g</td><td>小写字母g</td></tr><tr><td>0110 1000</td><td>0150</td><td>104</td><td>0x68</td><td>h</td><td>小写字母h</td></tr><tr><td>0110 1001</td><td>0151</td><td>105</td><td>0x69</td><td>i</td><td>小写字母i</td></tr><tr><td>0110 1010</td><td>0152</td><td>106</td><td>0x6A</td><td>j</td><td>小写字母j</td></tr><tr><td>0110 1011</td><td>0153</td><td>107</td><td>0x6B</td><td>k</td><td>小写字母k</td></tr><tr><td>0110 1100</td><td>0154</td><td>108</td><td>0x6C</td><td>l</td><td>小写字母l</td></tr><tr><td>0110 1101</td><td>0155</td><td>109</td><td>0x6D</td><td>m</td><td>小写字母m</td></tr><tr><td>0110 1110</td><td>0156</td><td>110</td><td>0x6E</td><td>n</td><td>小写字母n</td></tr><tr><td>0110 1111</td><td>0157</td><td>111</td><td>0x6F</td><td>o</td><td>小写字母o</td></tr><tr><td>0111 0000</td><td>0160</td><td>112</td><td>0x70</td><td>p</td><td>小写字母p</td></tr><tr><td>0111 0001</td><td>0161</td><td>113</td><td>0x71</td><td>q</td><td>小写字母q</td></tr><tr><td>0111 0010</td><td>0162</td><td>114</td><td>0x72</td><td>r</td><td>小写字母r</td></tr><tr><td>0111 0011</td><td>0163</td><td>115</td><td>0x73</td><td>s</td><td>小写字母s</td></tr><tr><td>0111 0100</td><td>0164</td><td>116</td><td>0x74</td><td>t</td><td>小写字母t</td></tr><tr><td>0111 0101</td><td>0165</td><td>117</td><td>0x75</td><td>u</td><td>小写字母u</td></tr><tr><td>0111 0110</td><td>0166</td><td>118</td><td>0x76</td><td>v</td><td>小写字母v</td></tr><tr><td>0111 0111</td><td>0167</td><td>119</td><td>0x77</td><td>w</td><td>小写字母w</td></tr><tr><td>0111 1000</td><td>0170</td><td>120</td><td>0x78</td><td>x</td><td>小写字母x</td></tr><tr><td>0111 1001</td><td>0171</td><td>121</td><td>0x79</td><td>y</td><td>小写字母y</td></tr><tr><td>0111 1010</td><td>0172</td><td>122</td><td>0x7A</td><td>z</td><td>小写字母z</td></tr><tr><td>0111 1011</td><td>0173</td><td>123</td><td>0x7B</td><td>{</td><td>开花括号</td></tr><tr><td>0111 1100</td><td>0174</td><td>124</td><td>0x7C</td><td>|</td><td>垂线</td></tr><tr><td>0111 1101</td><td>0175</td><td>125</td><td>0x7D</td><td>}</td><td>闭花括号</td></tr><tr><td>0111 1110</td><td>0176</td><td>126</td><td>0x7E</td><td>~</td><td>波浪号</td></tr><tr><td>0111 1111</td><td>0177</td><td>127</td><td>0x7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机概论&quot;&gt;&lt;a href=&quot;#计算机概论&quot; class=&quot;headerlink&quot; title=&quot;计算机概论&quot;&gt;&lt;/a&gt;计算机概论&lt;/h1&gt;&lt;h2 id=&quot;计算机软硬件概念&quot;&gt;&lt;a href=&quot;#计算机软硬件概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机组成原理" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络技术</title>
    <link href="https://wwy.wwywy.com/posts/536.html"/>
    <id>https://wwy.wwywy.com/posts/536.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-09T02:12:38.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概叙"><a href="#计算机网络概叙" class="headerlink" title="计算机网络概叙"></a>计算机网络概叙</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.定义：一些互连的、独立自治的计算机集合；</p><p>2.目的：资源共享、数据通信、负载均衡和分布式计算、数据信息集中处理；</p><p>3.一般分类：</p><ul><li>按通信媒体：有线网络、无线网络；</li><li>按使用对象：公众网络、专用网络、接入网；</li><li>网络传输技术：广播式网络、点到点网络；</li><li>按地理覆盖（常用）：<ul><li>局域网：几十米到几千米之间；</li><li>城域网：几千米到几十千米；</li><li>广域网 ：几十千米到几千千米，例如Internet；</li></ul></li></ul><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><p>1.常见的拓扑结构：</p><ul><li>总线型拓扑结构：结构简单、易于阔充、属于广播网络；</li><li>星型拓扑结构：结构简单、易于实现和管理、但是耗费电缆、中心出问题会带动其他地方；</li><li>树形拓扑结构：易于分级管理和控制；</li><li>环形拓扑结构：结构简单、易于实现、传输时延确定和路径选择简单；</li><li>网状拓扑结构：充分利用网络资源，但是成本高；</li></ul><h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><p>1.比特的概念：比特(bit)意思是一个二进制数字（0或1）。 B为字节(Byte)，b为比特(bit)，一字节为8比特，即1B = 8b。 网络技术中的数率指的是数据的传送速率，当数据率较高时，常常在bit/s前面加上字母，比如k = $10^3$,M = $10^6$,G = $10^9$,T = $10^{12}$等。 （注意区分网络传输和文件系统中的数据后缀字母，文件系统一般是字节。比如一个100MB的文件，这里的M就是$2^{20}$，传输率为100Mbit/s，这里的M为$10^6$）</p><p>2.数据传输率：又叫比特率，指连接在网络上的主机在数字信道上传送数据的速率。 速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等；</p><p>3.信道容量：信道容量即是指最大的数据传输速率，通常说数字通信系统所说的带宽与数据传输速率相等，注意这个数据传输速率是实际的传输速率，实际与最大的数据传输速率二者之间满足香农公式，具体如下俩种情况</p><ul><li>在有噪声的情况下即信道不是理想信道，信道容量是信道能够达到的最大数据速率，此时数字信道的带宽W与信道容量C满足香农公式C=W${Log}_{2}$（1+S/N） ;</li><li>理想信道时，根据奈奎斯特定理，C=最大的数据传输速率=2W；</li></ul><p>4.带宽：分以下俩种情况</p><ul><li>对于模拟通信或传输介质，带宽指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）；</li><li>而数字通信系统中“带宽”，理论上是指传输信道的信道容量，也即信道中传递信息的最大值，单位为“比特/秒”。由于数字系统中的信道多指逻辑信道，而信道容量又是理论上的最大值(不可能达到)，所以平时我们使用的“带宽”一词，是指信道中数据的实际传输速率；</li></ul><p>5.误码率：误码指信号传输过程中受干扰的和衰减的数据传输错误，是衡量传输可靠性的主要观测点，误码率${P}_{e}$=接受的错位数  除以   传输总数；</p><p>6.时延：</p><ul><li>发送时延：发送数据时，数据帧从结点进入到传输媒体所需要的时间。 $\mathrm{发送时延};=;\frac{\mathrm{数据帧长度}(b)}{\mathrm{发送速率}(b/s)}$</li><li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间。 $\mathrm{传播时延};=;\frac{\mathrm{信道长度}(米)}{\mathrm{信号在信道上的传输速率}(b/s)}$</li><li>处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间；</li><li>排队时延：结点缓存队列中分组排队所经历的时延.</li><li>总时延：总时延 = 发送时延+传播时延+处理时延+处理时延</li></ul><p>7.利用率：信道利用率指出某信道有百分之几的时间是被利用的。 网络利用率则是全网络的信道利用率的加权平均值. $D;=;\frac{D_0}{1;-;U}$ $D_0$为网络空闲时的时延，$D$为当前时延，U为利用率。</p><h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h1><h2 id="ISO-OSI七层模型"><a href="#ISO-OSI七层模型" class="headerlink" title="ISO/OSI七层模型"></a>ISO/OSI七层模型</h2><p>1.专业术语</p><ul><li>实体和对等实体：每一层中，用于实现该层功能的活动元素被称为实体，不同机器同一层、完成相同功能的实体称为对等实体；</li><li>协议：对等实体之间交换数据的约定；</li><li>服务和接口：下层为上层提供的功能叫服务，通过上下层之间的接口实现；</li></ul><p>2.OSI理想模型层级（由上到下）：</p><ul><li>应用层（APDU）：负责为用户程序提供网络服务；</li><li>表示层（PPDU）：表示层以下关心可靠的数据传输，而表示层关心传输数据的语法和语义；</li><li>会话层（SPDU）：在俩个节点之间建立、维护和释放用户连接；</li><li>传输层（分段）：该层负责两台主机中进程之间的通信，而传输层上三层主要面向用户提供服务，下三层面向网络通信；</li><li>网络层（分组）：端到端的主机通信；</li><li>数据链路层（帧）：解决相邻节点的数据传输等问题；</li><li>物理层（比特流）：直接面向原始比特流的传输；</li></ul><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>1.TCP\IP模型层级（从上到下）：应用层、传输层、网络层、网络访问层；</p><p>2.OSI模型和TCP/IP模型比较：</p><ul><li>相同点：<ul><li>均采用层次结构，并具有可比的运输层和网络层；</li><li>都基于协议数据单元的包交换网络，且分别作为概念模型和事实标准；</li></ul></li><li>不同点：<ul><li>OSI七层，TCP四层，TCP应用层中包含了OSI上三层的功能，网络访问层包含了下俩层的功能；</li><li>OSI对分层很好的说明服务、协议、接口的概念，是最重要的计算机网络概念模型，但是每层都存在寻址、流量控制、差错控制等机制，所以比较复杂，缺乏实现上的操作性；</li><li>TCP/IP层次较少，显得更加简洁，容易实现，但是服务、协议、接口区分并不是很清晰。</li></ul></li></ul><p><img src="https://s1.ax1x.com/2022/03/08/bgleBj.jpg" alt="OSI模型和TCP/IP模型比较"></p><h2 id="五层结构（OSI和TCP-IP折中方案）"><a href="#五层结构（OSI和TCP-IP折中方案）" class="headerlink" title="五层结构（OSI和TCP/IP折中方案）"></a>五层结构（OSI和TCP/IP折中方案）</h2><p>1.五层结构（从上到下）：</p><ul><li>应用层：是体系中的最高层，任务是通过应用进程间的交互来完成特定网络应用，把应用层交互的数据单元称为报文。</li><li>运输层：负责两台主机中进程之间的通信提供通用的数据传输服务。主要用到以下两种协议;<ul><li>TCP：传输控制协议（Transmission Control Protocol），提供面向连接，可靠地数据传输服务，其数据传输的单位是报文段。</li><li>UDP：用户数据报协议（User Datagram Protocol）,提供无连接的，尽最大努力的数据传输服务，是不可靠的。其数据传输的单位是用户数据报。</li></ul></li><li>网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。在TCP/IP体系中使用IP协议，因此分组也叫做IP数据报。</li><li>数据链路层：两台主机之间的数据传输，总是在一段一段的链路上进行传送的，需要使用专门的链路层协议，在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点之间的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样数据链路层在接收到一个帧后，就可以从中提取出数据部分，上交给网络层。</li><li>物理层：物理层上所传数据的单位是比特。传递信息所用的载体（比如双绞线，光缆等）不属于物理层，是物理层下面一层。</li></ul><h2 id="分组交换技术☆"><a href="#分组交换技术☆" class="headerlink" title="分组交换技术☆"></a>分组交换技术☆</h2><p>1.介绍：提高信道利用率，提高抗毁性 端到端数据流被划分为若干数据块，添加首部形成若干分组，分组首部中携带地址、长度等控制信息 主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。 路由器的用途则是用来转发分组的，即进行分组交换的，分组交换也称包交换，它是将用户传送的数据划分成一定的长度，每个部分叫做一个分组。在每个分组的前面加上一个分组头，用以指明该分组发往何地址，然后由交换机根据每个分组的地址标志，将他们转发至目的地，这一过程称为分组交换。进行分组交换的通信网称为分组交换网。从交换技术的发展历史看，数据交换经历了电路交换、报文交换、分组交换和综合业务数字交换的发展过程。分组交换实质上是在“存储—转发”基础上发展起来的。它兼有电路交换和报文交换的优点。分组交换在线路上采用动态复用技术传送按一定长度分割为许多小段的数据—分组。每个分组标识后，在一条物理线路上采用动态复用的技术，同时传送多个数据分组。把来自用户发端的数据暂存在交换机的存储器内，接着在网内转发。到达接收端，再去掉分组头将各数据字段按顺序重新装配成完整的报文。分组交换比电路交换的电路利用率高，比报文交换的传输时延小，交互性好，如下图所示；</p><p><img src="https://s1.ax1x.com/2022/03/06/bDzxmt.png" alt="分组交换技术"></p><p>2.存储转发：路由器在输入链路上接收整个分组 存储接收的分组 然后选择输出链路，并以最大传输速率向输出链路转发；</p><p>3.优点：</p><ul><li>高效：动态分配传输带宽，对通信链路是逐段占用；</li><li>灵活：以分组为传送单位和查找路由；</li><li>迅速：不必先建立连接就能向其他主机发送分组；</li><li>可靠：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性；</li></ul><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h2><p>1.说明：物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p><p>2.物理层主要问题：</p><ul><li>信号和信道类型选择</li><li>传输媒体选择</li><li>提高传输媒体的利用率</li><li>关于衰减和噪音影响的处理</li><li>通信方式的选择</li><li>物理互通的实现</li></ul><p>3.物理层传输质量的评估：通过数据传输速率和误码率作为评估主要标准；</p><h2 id="基带传输和数字数据编码"><a href="#基带传输和数字数据编码" class="headerlink" title="基带传输和数字数据编码"></a>基带传输和数字数据编码</h2><p>1.基本概念：二进制数字数据利用脉冲信号（数字信号和信道）来进行传输和编码，数字信号是离散的电压或电流脉冲序列，常用方法是使用脉冲信号来表示二进制数字字符“0”和“1”；</p><p>2.数字信号编码方式：如下</p><ul><li>不归零制：正电平代表1，负电平代表0；</li><li>归零制：正脉冲代表1，负脉冲代表0；</li><li>曼彻斯特编码：位周期中心的向上跳代表0，位周期中心的向下跳代表1，也可以反过来定义；</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1；<br>  <img src="https://s1.ax1x.com/2022/03/08/bgBGHP.png" alt="数字信号编码方式"></li></ul><h2 id="频带传输和调制解调"><a href="#频带传输和调制解调" class="headerlink" title="频带传输和调制解调"></a>频带传输和调制解调</h2><p>1.频带传输基本概念：基带传输受到距离限制，所以远距离一般采用模拟通信；</p><p>2.调制解调方法：如下三种</p><ul><li>幅度调制</li><li>频率调制</li><li>相位调制</li></ul><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>1.分类：如下几种</p><ul><li>有线传输媒体：<ul><li>双绞线：最古老又最常用、价格便宜，但是对电磁干扰敏感，主要用于室内；</li><li>同轴电缆：新标准已经不再推荐；</li><li>光纤：传输带宽大，传输损耗小，中继距离长，抗干扰能力强（雷电和电磁干扰），保密性好（不易被窃听）体积小，重量轻。精确对接困难。</li></ul></li><li>无线传输媒体：<ul><li>无线电波：通过空间电磁传播、无需安装物理线路，频率范围再30kHz到30000MHz之间，波长10km~0.1mm；</li><li>微波（卫星）： 带宽高，容量大，不受环境影响，且不需实现铺好电缆，但是需要相关部门许可；</li><li>红外线：通过空间电磁传播、不受电磁干扰和射频干扰，但是必须再直线视距之间，且数据传输速率相对较低；</li><li>激光通信：短距离传输，但是受天气影响大；</li></ul></li></ul><p><img src="https://s1.ax1x.com/2022/03/08/bgsM3F.png" alt="无线传输媒体"></p><p>2.传输媒体的比较和选用：如下图<br><img src="https://s1.ax1x.com/2022/03/08/bgyP56.png" alt="传输媒体的比较"></p><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><p>1.基本概念：指在一条物理线路上建立多条通信信道；</p><p>2.分类：</p><ul><li> 频分复用（FDM）：将线路带宽划分成若干较小带宽来达到多路复用目的，用户在分配在一定频宽后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。</li><li> 时分复用（TDM）：将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占领固定序号的时隙，时分复用的所有用户是在不同的时间占用同样的频带宽度，时分复用分为同步（STDM）和异步（ATDM）技术。</li><li> 波分复用（WDM）：采用光波波长的分隔的多路复用方法；</li><li> 码分复用（CDM）：是一种移动通信系统的复用技术，基于码型分割信道，每个用户可以在同样时间使用同样频带进行通信，具有很强的抗干扰性。</li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>1.串行通信和并行通信：</p><ul><li>串行通信：指发送端所发送和的数据，按照数据位的先后顺序，依次通过信源和信宿之间的单条信道到达接收端；</li><li>并行通信：发送端和接受端之间多条并行信道实现一个节拍下多个数据位的并行传送；</li></ul><p>2.全双工通信和半双工通信</p><ul><li>单工通信：能有一个方向的通信而没有反方向的交互（广播和电视节目）；</li><li>半双工通信：通信的双方都可以发送信息，但不能双方同时发送和同时接收（对讲机）；</li><li>全双工通信：通信的双方可以同时发送和接收信息（手机）；</li></ul><h2 id="常见物理层组件和设备"><a href="#常见物理层组件和设备" class="headerlink" title="常见物理层组件和设备"></a>常见物理层组件和设备</h2><p>1.常见的物理组件设备：指物理层提供的无源器件，如下所示</p><ul><li>端接器件：为网络线缆连接提供良好的端接，不同线缆对应的连接头不能通用；</li><li>转换器：用于不同接口或媒体之间进行信号转换；</li></ul><p>2.常见的物理组件：用于增强网络覆盖和传输距离的网络互联网设施</p><ul><li>中继器：对物理信号进行放大再生，单进单出，网络规模增加时，需要多个中继器；</li><li>集线器：拥有多个接端口，但是只能提供一路的信号放大、整形和转发，否则会出问题；</li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>1.基本概念：</p><ul><li>使用一对一的点对点通信方式；</li><li>数据链路=物理链路+数据链路协议；</li><li>数据链路层是为了克服物理层的不足而建立的，旨在实现网络俩个相邻节点之间的无差错传输；</li></ul><p>2.待解决主要问题：</p><ul><li>物理寻址：</li><li>​</li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络概叙&quot;&gt;&lt;a href=&quot;#计算机网络概叙&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概叙&quot;&gt;&lt;/a&gt;计算机网络概叙&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络技术" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机网络技术" scheme="https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论</title>
    <link href="https://wwy.wwywy.com/posts/517.html"/>
    <id>https://wwy.wwywy.com/posts/517.html</id>
    <published>2022-03-02T13:00:00.000Z</published>
    <updated>2022-03-10T09:50:27.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="人工智能基本概念"><a href="#人工智能基本概念" class="headerlink" title="人工智能基本概念"></a>人工智能基本概念</h2><p>1.自然界四大奥秘：物质的本质、宇宙的起源、生命的本质、智能的发生；</p><p>2.智能的定义：智能是只是和智力的总和；</p><p>3.智能的特征：</p><ul><li>感知能力（游戏AI必须品）：主动信息的输入，实现视觉、听觉、触觉、嗅觉等感觉器官；</li><li>记忆力和思维能力：信息的存储和信息的模拟，记忆存储由感知器官感知到的外部信息以及由思维所产生的知识，思维能力对记忆的信息进行处理；<ul><li>逻辑思维（抽象思维）：例如理科生通过逻辑去肢解一道数学题；</li><li>形象思维（直感思维）：例如人的第五感；</li><li>顿悟思维（灵感思维）：例如牛顿如何发现了力学；</li></ul></li><li>学习能力：被动信息的输入，学习既可能是自觉的、有意识的，也可能是不自觉的、无意识的；既可以是有教师指导的，也可以是通过自己实践的；</li><li>行为能力（表达能力）：信息的输入，人工智能实现的目的；</li></ul><h2 id="人工智能发展简史"><a href="#人工智能发展简史" class="headerlink" title="人工智能发展简史"></a>人工智能发展简史</h2><p>人工智能发展史：了解就好了，知乎看看就好；<br><a href="https://zhuanlan.zhihu.com/p/43599960">人工智能发展史 - 知乎 (zhihu.com)</a></p><h2 id="人工智能研究的基本内容"><a href="#人工智能研究的基本内容" class="headerlink" title="人工智能研究的基本内容"></a>人工智能研究的基本内容</h2><p>1.知识表达：将人类知识形式化或者模型化，方法有符号表示法、连接机制表示法，简单点说就是建立一个能把人懂的东西弄成机器能懂的东西的东西；</p><p>2.机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主；</p><p>3.机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理；</p><p>4.机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识；</p><p>5.机器行为：计算机的表达能力，即“说”、“写”、“画”等能力；</p><h2 id="人工智能的主要研究领域"><a href="#人工智能的主要研究领域" class="headerlink" title="人工智能的主要研究领域"></a>人工智能的主要研究领域</h2><p>主要领域：自动定理证明、博弈、模式识别、机器视觉 、自然语言理解、机器翻译、智能信息检索 、数据挖掘与知识发现、专家系统、自动程序设计、机器人、组合优化问题、人工神经网络；</p><p>其他领域：分布式人工智能与多智能体、智能控制、智能仿真、智能CAD 、智能CAI  、智能管理与智能决策 、智能多媒体系统 、智能操作系统、智能计算机系统 、智能通信 、智能网络系统、人工生命 ；</p><h1 id="知识表示与知识图谱"><a href="#知识表示与知识图谱" class="headerlink" title="知识表示与知识图谱"></a>知识表示与知识图谱</h1><h2 id="知识和知识表示"><a href="#知识和知识表示" class="headerlink" title="知识和知识表示"></a>知识和知识表示</h2><h3 id="知识的概念"><a href="#知识的概念" class="headerlink" title="知识的概念"></a>知识的概念</h3><p>1.知识的定义：把有关信息关联在一起所形成的信息结构；</p><p>2.知识的作用：反映了客观世界中事物之间的关系；</p><p>3.知识的特性：</p><ul><li>相对正确性：知识在一定的条件及环境下产生的才是正确的；</li><li>不确定性：<ul><li>随机性引起的不确定性 ：清明一般都会下雨，但是也有不下雨的时候；</li><li>模糊性引起的不确定性 ：根据人的外貌去判断年龄；</li><li>经验引起的不确定性：经历丰富的人相对知识也更加丰富；</li><li>不完全性引起的不确定性：比如对人类对宇宙的了解并不完整；</li></ul></li><li>可表示性和可利用性：知识可以用适当形式表示和利用；</li></ul><h3 id="知识表示的概念"><a href="#知识表示的概念" class="headerlink" title="知识表示的概念"></a>知识表示的概念</h3><p>1.知识表示的定义：将人类的知识形式化或者模型化（人类划重点）；</p><p>2.知识表示的作用：计算机可以接受的描述知识的数据结构</p><p>3.知识选择方法的原则：有利于知识的充分表示和分利用、便于组织、维护、管理、理解和实现；</p><h2 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/thsrobot/article/details/85211896"> 人工智能一阶谓词逻辑表示法</a></p><h2 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h2><p>非专业作了解：<br><a href="http://www.360doc.com/content/11/0502/21/2097544_113822638.shtml">产生式表示法</a></p><h2 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h2><p>非专业作了解：<br><a href="https://www.cnblogs.com/cy0628/p/13905601.html">知识表示之框架表示法</a></p><h2 id="知识图谱（推荐学习）"><a href="#知识图谱（推荐学习）" class="headerlink" title="知识图谱（推荐学习）"></a>知识图谱（推荐学习）</h2><p>定义：是一种揭示实体之间关系的语义网络；<br>目的：知识图谱的目的是为了提高搜索引擎的能力，改善用户的搜索质量以及搜索体验；</p><p>1.知识图谱的逻辑结构：</p><ul><li>数据层：主要是由一系列的事实组成，而知识以事实为单位进行存储。</li><li>模式层：构建在数据层之上，是知识图谱的核心。</li></ul><p>2.知识图谱的原始数据类型：</p><ul><li>结构化数据：是指知识定义和表示都比较完备的数据，如关系数据库；</li><li>半结构化数据：是指部分数据是结构化的，但存在大量结构化程度较低的数据，如XML、JSON；</li><li>非结构化数据：是指没有定义和规范约束的“自由”数据，如文本、视频、音频、图片；</li></ul><p>了解更多：<br><a href="http://www.360doc.com/content/20/0525/00/43535834_914347385.shtml">通俗易懂解释知识图谱</a></p><h2 id="确定性推导方法"><a href="#确定性推导方法" class="headerlink" title="确定性推导方法"></a>确定性推导方法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/lagoon_lala/article/details/85133897">确定性推理方法</a></p><h2 id="不确定性推导方法"><a href="#不确定性推导方法" class="headerlink" title="不确定性推导方法"></a>不确定性推导方法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/qq_31456593/article/details/78623871">不确定推理方法</a></p><h1 id="搜索求解策略"><a href="#搜索求解策略" class="headerlink" title="搜索求解策略"></a>搜索求解策略</h1><h2 id="搜索的概念"><a href="#搜索的概念" class="headerlink" title="搜索的概念"></a>搜索的概念</h2><p>1.搜索算法主要解决问题：</p><ul><li>是否一定能找到一个解。</li><li>找到的解是否是最佳解。</li><li>时间与空间复杂性如何。</li><li>是否终止运行或是否会陷入一个死循环</li></ul><p>2.搜索方向：</p><ul><li>从初始给出的条件出发；</li><li>从目的地出发，进行逆推算；</li><li>（A*算法）从开始状态出发作正向搜索，同时又从目的状态出发作逆向搜索，直到两条路径在中间的某处汇合为止；<h2 id="状态空间的搜索策略"><a href="#状态空间的搜索策略" class="headerlink" title="状态空间的搜索策略"></a>状态空间的搜索策略</h2>非专业作了解：<br><a href="https://blog.csdn.net/weixin_48615832/article/details/120330789">状态空间表示法</a></li></ul><h2 id="盲目的图搜索策略"><a href="#盲目的图搜索策略" class="headerlink" title="盲目的图搜索策略"></a>盲目的图搜索策略</h2><h3 id="回溯策略"><a href="#回溯策略" class="headerlink" title="回溯策略"></a>回溯策略</h3><p>1.回溯策略的数据结构：</p><ul><li>Pass集合：记录寻路算法中的可走路径，保存搜索路径的状态，如果找到了目的，该集合就是解；</li><li>Open集合：等待搜索或者待访问的状态集合；</li><li>Close集合：已经被访问的状态集合；</li></ul><h3 id="广度优先搜索策略"><a href="#广度优先搜索策略" class="headerlink" title="广度优先搜索策略"></a>广度优先搜索策略</h3><p>1.算法特点：如下俩点</p><ul><li>每次选择深度最浅的节点首先扩展，搜索是逐层进行的，如图5.6所示；</li><li>一种高价搜索，会遍历所有节点，但若有解存在，则必能找到它，且是最短路径（可以理解很多人沿着不同的方向走，人多力量大）；<br>  <img src="https://s1.ax1x.com/2022/03/09/bWbIYV.png" alt="广度优先算法搜索次序"></li></ul><p>2.算法描述如下：</p><ul><li>a：选择一个未访问的顶点入队；</li><li>b：从队里选出一个顶点V出队，并且标记为已经访问；</li><li>c：将顶点V的所有未被访问的邻接顶点入队并且设置该节点父节点为顶点V；</li><li>d：重复步骤a~b，直到所有顶点都已经被访问；</li><li>e：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）</li></ul><p>3.核心算法实现：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">/// &lt;summary&gt;/// 广度优先算法BFS/// &lt;/summary&gt;/// &lt;param name="originNode"&gt;起点位置&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标位置&lt;/param&gt;/// &lt;param name="passNodeList"&gt;可走路径&lt;/param&gt;public static void BFSSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeList){    Queue&lt;Node&gt; openQue = new Queue&lt;Node&gt;();    openQue.Enqueue(originNode);    while (openQue.Count &gt; 0)    {        Node head = openQue.Dequeue();        //获取该节点周围的节点        List&lt;Node&gt; neighborLst = Program.GetNeighbor(head);        //检查周围的节点        for (int i = 0; i &lt; neighborLst.Count; i++)        {            Node neighborNode = neighborLst[i];            //节点被访问或者是障碍物的直接继续            if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue;            //记录节点被访问            neighborNode.isVisit = true;            //记录父节点            neighborNode.parent = head;            openQue.Enqueue(neighborNode);            //这个时候整个地图已经遍历完了            if (neighborNode.Equals(targetNode))            {                //反向输出父节点，就是要找的路径                while (!neighborNode.Equals(originNode))                {                    neighborNode = neighborNode.parent;                    passNodeList.Add(neighborNode);                    neighborNode.nodeType = NodeType.Pass;                }                //最后添加目标点（其实直接返回目标节点也是可以的）                passNodeList.Add(targetNode);                targetNode.nodeType = NodeType.Pass;                return;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深度优先搜索策略"><a href="#深度优先搜索策略" class="headerlink" title="深度优先搜索策略"></a>深度优先搜索策略</h3><p>1.算法特点：</p><ul><li>扩展最深的节点的结果使得搜索沿着状态空间某条单一的路径从起始节点向下进行下去；仅当搜索到达一个没有后裔的状态时，才考虑另一条替代的路径；</li><li>为了保证找到解，应选择合适的深度限制值，或采取不断加大深度限制值的办法，反复搜索，直到找到解；</li><li>深度优先搜索并不能保证第一次搜索到的某个状态时的路径是到这个状态的最短路径，如果路径距离很重要的话，它应该尝试保留最短路径；</li></ul><p><img src="https://s1.ax1x.com/2022/03/09/bfMTyT.png" alt="深度优先算法搜索次序"></p><p>2.算法描述如下：</p><ul><li>a：选择传入的起始顶点，并将顶点标记已经访问；</li><li>b：访问邻接顶点，直到某个顶点没有邻接顶点再继续下一步；</li><li>c：回溯到上一层顶点，重复b步，直到所有顶点都被访问；</li><li>d：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）；</li></ul><p>3.核心算法实现：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">   /// &lt;summary&gt;   /// 深度优先算法BFS（简单实现，非最优路径）   /// &lt;/summary&gt;   /// &lt;param name="currentNode"&gt;当前位置&lt;/param&gt;   /// &lt;param name="originNode"&gt;起点位置&lt;/param&gt;   /// &lt;param name="targetNode"&gt;目标位置&lt;/param&gt;   /// &lt;param name="passNodeList"&gt;可走路径&lt;/param&gt;public static void DFSSearch(Node currentNode, Node originNode, Node targetNode,ref List&lt;Node&gt; passNodeList)   {       //标记该节点已经被访问currentNode.isVisit = true;       //获取该节点周围的节点List&lt;Node&gt; neighborLst = Program.GetNeighbor(currentNode);for(int i = 0; i &lt; neighborLst.Count; i++)       {Node neighborNode = neighborLst[i];           //节点被访问或者是障碍物的直接继续           if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue;           //记录父节点           neighborNode.parent = currentNode;           //递归调用,先深再广           DFSSearch(neighborNode, originNode, targetNode, ref passNodeList);           //这个时候已经找到目标节点了           if (neighborNode.Equals(targetNode))           {               //反向输出父节点，就是要找的路径               while (!neighborNode.Equals(originNode))               {                   neighborNode = neighborNode.parent;                   passNodeList.Add(neighborNode);                   neighborNode.nodeType = NodeType.Pass;               }               //最后添加目标点（其实直接返回目标节点也是可以的）               passNodeList.Add(targetNode);               targetNode.nodeType = NodeType.Pass;               return;           }       }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="启发式图搜索策略"><a href="#启发式图搜索策略" class="headerlink" title="启发式图搜索策略"></a>启发式图搜索策略</h2><h3 id="启发式策略"><a href="#启发式策略" class="headerlink" title="启发式策略"></a>启发式策略</h3><p>1.启发式信息定义：用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息；</p><p>2.启发式策略特点：重排Open表，选择最有希望的节点加以扩展；</p><p>3.启发信息分类：按以下俩种情况考虑</p><ul><li>按运用的方法分类：<ul><li>陈述性启发信息：用于更准确、更精炼地描述状态；</li><li>过程性启发信息：用于构造操作算子；</li><li>控制性启发信息：表示控制策略的知识；</li></ul></li><li>按作用分类：<ul><li>用于扩展节点的选择，即用于决定应先扩展哪一个节点，以免盲目扩展；</li><li>用于生成节点的选择，即用于决定要生成哪些后继节点，以免盲目生成过多无用的节点；</li><li>用于删除节点的选择，即用于决定删除哪些无用节点，以免造成进一步的时空浪费；   </li></ul></li></ul><p>4.估价函数：用来估算初始节点经过 n节点到达目标节点的路径的最小代价，如下推理</p><ul><li>估价函数值f(n) ==&gt; g(n) + h(n);</li><li>g(n) ==&gt; 从当前节点到待访问节点n的实际代价（其实就是距离）</li><li>h(n) ==&gt; 从待访问节点n到目标距离的估算代价（其实就是方向）<ul><li>h(n) 比重大：降低搜索工作量，但可能导致找不到最优解；</li><li>h(n) 比重小：一般导致工作量加大，极限情况下变为盲目搜索，但可能可以找到最优解；</li></ul></li></ul><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;人工智能基本概念&quot;&gt;&lt;a href=&quot;#人工智能基本概念&quot; class=&quot;headerlink&quot; title=&quot;人工智能基本概念&quot;</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="人工智能" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>定点数数学库</title>
    <link href="https://wwy.wwywy.com/posts/2178.html"/>
    <id>https://wwy.wwywy.com/posts/2178.html</id>
    <published>2022-03-01T13:00:00.000Z</published>
    <updated>2022-03-06T14:09:52.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定点数FInt"><a href="#定点数FInt" class="headerlink" title="定点数FInt"></a>定点数FInt</h1><p>基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化，使用位运算来直接操作二进制进行放大缩小，这里可以放大1024倍，也就是1&lt;&lt;10，使用完之后在缩小1024倍还原即可;<br>乘法还原正负不同问题：按照上面的流程，乘法运算后绝对值相同的正负数值经过还原后会出现不对等的问题，比如500乘FInt(0.3f)的RawInt值是是14，但是500乘FInt(-0.3f)的RawInt值却是-15，这是因为二进制中，正数由原码表示，负数由补码表示，补码是在原码的反码上再加一得来的，要简单的解决这一个问题可以对值进行取反运算再取反，让已经实现好的底层去解决；</p><h1 id="定点向量FVector3"><a href="#定点向量FVector3" class="headerlink" title="定点向量FVector3"></a>定点向量FVector3</h1><h1 id="常用运算FCalc"><a href="#常用运算FCalc" class="headerlink" title="常用运算FCalc"></a>常用运算FCalc</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定点数FInt&quot;&gt;&lt;a href=&quot;#定点数FInt&quot; class=&quot;headerlink&quot; title=&quot;定点数FInt&quot;&gt;&lt;/a&gt;定点数FInt&lt;/h1&gt;&lt;p&gt;基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="帧同步" scheme="https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="定点数数学库" scheme="https://wwy.wwywy.com/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>确定性物理库</title>
    <link href="https://wwy.wwywy.com/posts/2179.html"/>
    <id>https://wwy.wwywy.com/posts/2179.html</id>
    <published>2022-03-01T13:00:00.000Z</published>
    <updated>2022-03-06T14:09:35.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="帧同步" scheme="https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="确定性物理库" scheme="https://wwy.wwywy.com/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ET6.0框架Demo源码解析</title>
    <link href="https://wwy.wwywy.com/posts/2052.html"/>
    <id>https://wwy.wwywy.com/posts/2052.html</id>
    <published>2022-02-28T13:00:00.000Z</published>
    <updated>2022-03-03T08:03:42.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="ET" scheme="https://wwy.wwywy.com/tags/ET/"/>
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关-角色换装</title>
    <link href="https://wwy.wwywy.com/posts/1600.html"/>
    <id>https://wwy.wwywy.com/posts/1600.html</id>
    <published>2022-02-18T13:00:00.000Z</published>
    <updated>2022-03-03T10:03:36.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待写&quot;&gt;&lt;a href=&quot;#待写&quot; class=&quot;headerlink&quot; title=&quot;待写&quot;&gt;&lt;/a&gt;待写&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="换装" scheme="https://wwy.wwywy.com/tags/%E6%8D%A2%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件-Animancer插件使用</title>
    <link href="https://wwy.wwywy.com/posts/1577.html"/>
    <id>https://wwy.wwywy.com/posts/1577.html</id>
    <published>2022-01-29T13:00:00.000Z</published>
    <updated>2022-03-03T10:05:30.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Animancer介绍"><a href="#Animancer介绍" class="headerlink" title="Animancer介绍"></a>Animancer介绍</h1><h1 id="Animancer初步使用"><a href="#Animancer初步使用" class="headerlink" title="Animancer初步使用"></a>Animancer初步使用</h1><p>使用方法：添加Animator组件和AnimancerComponent相关组件，再编写脚本控制动画；</p><p>脚本案例：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public sealed class PlayAnimation : MonoBehaviour{    [SerializeField] private AnimancerComponent _Animancer;    [SerializeField] private AnimationClip _Clip;    private void OnEnable()    {        _Animancer.Play(_Clip);        var state = _Animancer.Play(_Clip);        state.Speed = ...                        state.Time = ...                     state.NormalizedTime = ...              state.Events.OnEnd = ...                   _Animancer.Play(_Clip).Time = 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer核心组件"><a href="#Animancer核心组件" class="headerlink" title="Animancer核心组件"></a>Animancer核心组件</h1><h2 id="AnimancerComponent"><a href="#AnimancerComponent" class="headerlink" title="AnimancerComponent"></a>AnimancerComponent</h2><p>说明：普通的动画师组件</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取Animator Controller组件animancer.Animator//2.获取Playableanimancer.Playable//3.获取该组件上的动画状态字典animancer.States//4.获取该组件上的动画层级animancer.Layers成员方法：//1.播放动画animancer.Play(AnimationClip, float, FadeMode)//2.使用键值播放动画。如果该键没有注册，返回nullanimancer.TryPlay(Object, float, FadeMode)//3.停止当前动画或者目标动画animancer.Stop(参数)//4.判断是否播放当前动画或者目标动画animancer.IsPlaying()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="NamedAnimancerComponent"><a href="#NamedAnimancerComponent" class="headerlink" title="NamedAnimancerComponent"></a>NamedAnimancerComponent</h2><p>说明：继承自AnimancerComponent并添加一个数组，并按名称注册动画，可以使用名字播放动画，这与 Unity 的旧版组件非常相似；</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">增加的成员变量：//1.获取动画源列表animancer.Animations//1.获取默认动画源animancer.DefaultAnimation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HybridAnimancerComponent"><a href="#HybridAnimancerComponent" class="headerlink" title="HybridAnimancerComponent"></a>HybridAnimancerComponent</h2><p>说明：继承自NamedAnimancerComponent，并且添加了控制器，可以融合Animator Controller组件和Animancer；</p><h1 id="Animancer动画状态"><a href="#Animancer动画状态" class="headerlink" title="Animancer动画状态"></a>Animancer动画状态</h1><p>动画状态说明：播放动画时，Animancer会创建一个状态来管理它并跟踪它的进度，如果以后再次播放相同的动画，它将重用相同的状态；</p><p>AnimancerState类API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取动画源文件state.Clip//2.动画事件集合state.Events//3.动画的长度state.Length//4.动画的速度state.Speed//5.状态的开始时间，该变量改变，动画事件也会变state.NormalizedTime//6.状态的结束时间，该变量改变，动画事件也会变state.NormalizedEndTime//7.状态的事件集合state.Events成员方法：//1.销毁动画state.Destroy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要访问和创建状态的方法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.此属性存储该方法最近返回的状态var state = animancer.States.Current;//2.此属性存储最近由 Layer 的方法返回的状态var state = animancer.Layers[x].CurrentState;//3.索引器获取var state = animancer.States[clip];//4.方法获取animancer.States.TryGet(clip, out var state);//5.如果已存在的状态，则此方法将返回该状态。否则它将创建并返回一个新的var state = animancer.States.GetOrCreate(clip);//6.创建新状态，即使该动画已存在一个状态。请注意，每个状态必须具有不同的密钥，否则将引发，注意key时object类型，所以会有装拆箱问题var state = animancer.States.Create(key, clip);//7.创建新状态，而不为其提供键。var state = new ClipState(clip);//8.如果存在的状态，则此方法将销毁该状态并返回，否则，它将返回falseanimancer.States.Destroy(clip);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer动画过渡"><a href="#Animancer动画过渡" class="headerlink" title="Animancer动画过渡"></a>Animancer动画过渡</h1><p>过渡说明：Animancer中除了使用Clip动画源文件来进行使用，也可以使用ClipTransition播放动画，并且这样效果更好；</p><p>过渡类类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//基本过渡：1.ClipTransition：实现ITransition接口，最基本的过渡类型，FadeDuration可以控制动画淡入淡出过渡的时长，Speed控制速度，StartTime和EndTime控制起始时间，同时动画支持添加帧事件；2.ClipTransitionSequence：继承自ClipTransition并简单地添加一个数组，这些数组将在第一个之后按顺序播放（使用他们的每个结束事件来播放下一个）；3.PlayableAssetTransition//混合过渡：1.ManualMixerTransition：简单的混合动画；2.LinearMixerTransition：1D混合动画，用一个参数控制，参数信息和Animator里的混合一致；3.MixerTransition2D：2D混合模式，用俩个参数控制，参数信息和Animator里的混合一致；//控制器过渡：1.ControllerTransition：使用控制器文件；//过渡资源1.过渡类+Asset：过渡资源在资源面板下可以创建该过渡资源文件，和上面不同的时，过渡文件整个项目全局共享，而不是每个对象都有自己单独的过渡。它们都遵循相同的命名约定；2.过渡类+Asset.UnShared:不共享分过渡资源，一般用不着；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer混合"><a href="#Animancer混合" class="headerlink" title="Animancer混合"></a>Animancer混合</h1><h2 id="动画淡入淡出"><a href="#动画淡入淡出" class="headerlink" title="动画淡入淡出"></a>动画淡入淡出</h2><p>淡入淡出说明：淡入淡出通常不用于动画，因为它们不能混合，但是对于骨架动画非常有用，因为它允许角色模型从一个动画的结束姿势平滑地过渡到另一个动画的起始姿势，而不需要两个姿势完全相同。这也意味着，如果动画在任何时候被中断，过渡仍然可以是平滑的；</p><p>常用淡入淡出类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.参数值按百分比计算下标0:FadeMode.FixedSpeed//2.参数根据事件计算下标1:FadeMode.FixedDuration//3.好像是不会创建的新的状态下标2:FadeMode.FromStart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画的层"><a href="#动画的层" class="headerlink" title="动画的层"></a>动画的层</h2><p>层说明：基本和Animator使用方法一致；</p><p>AnimancerLayer类API说明</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">重要成员变量：//1.层级下标layer.Index//2.层级叠加模式还是覆盖模式layer.IsAdditive//3.层权重layer.Weight重要成员方法：//1.设置骨骼蒙版layer.SetMask(AvatarMask)//2.设置层权重layer.SetWeight(float)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>混合树说明：基本和Animator使用方法一致；</p><p>混合树使用：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//混合类类型说明1.ManualMixerState：没有参数2.LinearMixerState：float参数，线性插值算法3.CartesianMixerState：Vector参数，梯度波段O(n2)插值算法4.DirectionalMixerState：Vector参数，极地梯度波段O(n2)插值算法//案例public sealed class LinearMixerExample : MonoBehaviour{    private AnimancerComponent _Animancer;    private AnimationClip _back;    private AnimationClip _forward;    private AnimationClip _left;    private AnimationClip _right;    private float _MovementSpeed;    public CartesianMixerState mixState;    private void Awake()    {        mixState = new CartesianMixerState();        //初始化混合动画        mixState.Initialize(_back, _forward，_left，_right);        //设置动画参数        mixState.SetThreshold(0, new Vector2(0, 0));        mixState.SetThreshold(1,new Vector2(0,-1));        mixState.SetThreshold(2, new Vector2(0, 1));        mixState.SetThreshold(3, new Vector2(-1, 0));        mixState.SetThreshold(4, new Vector2(1, 0));        //设置混合动画的同步，同步适用于移动，但对于空闲动画，通常应禁用同步        MixerState.AutoSynchronizeChildren = false;        mixer.DontSynchronizeChildren();        mixer.DontSynchronize(mixer.GetChild(0));        mixer.Synchronize(mixer.GetChild(1));        //播放        _Animancer.Play(mixState);    }    private void Update()    {            var input = new Vector2(    Input.GetAxisRaw("Horizontal"),    Input.GetAxisRaw("Vertical"));            mixState.Parameter = Vector2.MoveTowards(                mixState.Parameter,                input,                _MovementSpeed * Time.deltaTime);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer事件"><a href="#Animancer事件" class="headerlink" title="Animancer事件"></a>Animancer事件</h1><p>事件说明：基本和Animator使用方法一致，但是性能更好，且使用Clip文件使用时，每次都会创建垃圾，除非您缓存事件回调，而ClipTransition访问它将直接引用ClipTransition拥有的，因此当您再次播放时，您所做的任何修改都将保留。这意味着修改通常只应在启动时执行一次，而不是每次播放时都重复进行；</p><p>用法说明：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.添加事件state.Events.Add(0.4f, 事件);//2.结束事件，结束一定会调用  state.Events.OnEnd = 事件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer搭配推荐"><a href="#Animancer搭配推荐" class="headerlink" title="Animancer搭配推荐"></a>Animancer搭配推荐</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Animancer介绍&quot;&gt;&lt;a href=&quot;#Animancer介绍&quot; class=&quot;headerlink&quot; title=&quot;Animancer介绍&quot;&gt;&lt;/a&gt;Animancer介绍&lt;/h1&gt;&lt;h1 id=&quot;Animancer初步使用&quot;&gt;&lt;a href=&quot;#Anim</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="插件" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Animancer" scheme="https://wwy.wwywy.com/tags/Animancer/"/>
    
    <category term="Playable" scheme="https://wwy.wwywy.com/tags/Playable/"/>
    
  </entry>
  
  <entry>
    <title>ET6.0框架笔记</title>
    <link href="https://wwy.wwywy.com/posts/2049.html"/>
    <id>https://wwy.wwywy.com/posts/2049.html</id>
    <published>2022-01-24T13:00:00.000Z</published>
    <updated>2022-03-03T08:03:32.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ET6-0框架介绍"><a href="#ET6-0框架介绍" class="headerlink" title="ET6.0框架介绍"></a>ET6.0框架介绍</h1><h1 id="项目的初步运行"><a href="#项目的初步运行" class="headerlink" title="项目的初步运行"></a>项目的初步运行</h1><p>1.运行Unity客户端项目，并且打开编程软件进行初步编译；<br>2.打开服务端项目，第一次打开编译Client下的Mono文件夹；<br>3.重新编译整个解决方案；<br>4.客户端F5生成代码；</p><h1 id="ET前后端通讯机制"><a href="#ET前后端通讯机制" class="headerlink" title="ET前后端通讯机制"></a>ET前后端通讯机制</h1><p>登录实例：<br>1.通过NetKcpComponent组件创建Session会话连接；<br>2.Session（由ET框架管理）会话的Id和TChannel进行绑定；<br>3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；<br>4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器；</p><h1 id="ET的多线程和分布式"><a href="#ET的多线程和分布式" class="headerlink" title="ET的多线程和分布式"></a>ET的多线程和分布式</h1><p>第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；<br>第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；<br>第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；<br>第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；<br>ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构</p><p>登录实例（接上）：<br>1.网关负载均衡服务器随机分配网关配置；<br>2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；<br>3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；<br>4.游戏客户端和游戏网关建立正式连接；<br>5.登录进Map服务器<br>注意：C就是客户端，R是网关负载均衡服务器，G是网关；<br><img src="https://s4.ax1x.com/2022/02/21/HveY4J.png" alt="ET分布式说明"></p><h1 id="ET的ECS组件编程"><a href="#ET的ECS组件编程" class="headerlink" title="ET的ECS组件编程"></a>ET的ECS组件编程</h1><p>ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）；</p><p>遵守的编程原则：<br>1.实体即组件、组件即实体；<br>2.编写一个实体或者组件，绝不继承除Entity外的任何父类；<br>3.不使用任何虚函数，使用逻辑分发替代；<br>4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；<br>5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；<br>6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；<br>7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误；</p><p>其他原则：<br>1.系统命名必须是实体名+System；<br>2.系统必须是静态类；<br>3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；<br>4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.实体或者组件    public class Computer: Entity,IAwake,IUpdate,IDestroy    public class MouseComponent : Entity, IAwake    //2.系统    public static class ComputerSystem    {       //需要使用拓展方法        public static void Start(this Computer self)        {            Log.Debug("计算机启动");//这里可以调用身上的组件            self.GetComponent&lt;PCCaseComponent&gt;().StartPower();            self.GetComponent&lt;MonitorsComponent&gt;().DisPlay();        }    }//3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上    Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;();computer.AddComponent&lt;PCCaseComponent&gt;();computer.AddComponent&lt;MonitorsComponent&gt;();computer.AddComponent&lt;KeyBoardComponent&gt;();computer.AddComponent&lt;MouseComponent&gt;();computer.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中ECS编程的生命周期"><a href="#ET中ECS编程的生命周期" class="headerlink" title="ET中ECS编程的生命周期"></a>ET中ECS编程的生命周期</h1><p>  ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.生命周期函数类    public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt;    public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt;    public class ComputerDestroySystem : DestroySystem&lt;Computer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET的逻辑分发"><a href="#ET的逻辑分发" class="headerlink" title="ET的逻辑分发"></a>ET的逻辑分发</h1><p>OOP面向对象的缺点：继承层次过深时，牵一发而动全身；</p><p>ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承；</p><h1 id="ET的Scene层级树"><a href="#ET的Scene层级树" class="headerlink" title="ET的Scene层级树"></a>ET的Scene层级树</h1><p>Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id；</p><p>客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）:<br><img src="https://s4.ax1x.com/2022/02/20/HO46xg.png" alt="ET框架客户端Scene的层级关系"></p><p>服务端Scene的层级关系:<br><img src="https://s4.ax1x.com/2022/02/20/HOIEX4.png" alt="ET框架服务端Scene的层级关系"></p><p>服务端机器人Scene的层级关系<br><img src="https://s4.ax1x.com/2022/02/20/HOT9zT.png" alt="ET框架服务端机器人Scene的层级关系"></p><h1 id="ET的Excel配置工具"><a href="#ET的Excel配置工具" class="headerlink" title="ET的Excel配置工具"></a>ET的Excel配置工具</h1><p>Excel配置工具注意事项：<br>1.配置文件从第三行第三列开始写，跟VBA宏有关；<br>2.第一个类型字段名必须是Id；<br>3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；<br>4.加#是注释，仅给策划使用，不会添加到游戏数据中；<br>5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\Assets\Bundles\Config下；可以查看文本形式在Bin\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；<br>6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；<br>7.行是可以空行的，可以用来分类注释，目测加#；<br>8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；<br>9.配置工具支持的导表类型可以在Tools\Apps\EXcelExporter文件下的Convert静态类中定义或查看；<br>10.数组类型默认在配置文件中加英文,配置;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型//获取单个UnitConfig config = UnitConfigCategory.Instance.Get(1001)//获取所有var configs = UnitConfigCategory.Instance.GetAll()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的事件系统"><a href="#ET中的事件系统" class="headerlink" title="ET中的事件系统"></a>ET中的事件系统</h1><p>1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；<br>2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；<br>3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.定义事件，添加事件,必须EventType命名空间下进行定义        public struct InstallComputer        {            //定义参数            public Computer computer;        }        //2.调用事件，触发事件//同步PublishGame.EventSystem.Publish(new EventType.InstallComputer() { computer = computer });//同步PublishAnycsawait Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer });//异步PublishAnycsGame.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine();//3.编写事件触发逻辑    public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt;    {        //必须添加async        protected async override ETTask Run(InstallComputer arg)        {            Computer computer = arg.computer;            computer.AddComponent&lt;PCCaseComponent&gt;();            computer.AddComponent&lt;MonitorsComponent&gt;();            computer.AddComponent&lt;KeyBoardComponent&gt;();            computer.AddComponent&lt;MouseComponent&gt;();            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的ETTask异步编程"><a href="#ET中的ETTask异步编程" class="headerlink" title="ET中的ETTask异步编程"></a>ET中的ETTask异步编程</h1><p>同步操作：先完成其全部工作在返回调用者；<br>异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；<br>ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.ETTask函数编写//无返回值,参数类型用来控制取消异步函数public async ETTask TestAsync(ETCancellationToken cancellationToken)        {//表明该函数可能是同步函数await ETTask.CompletedTask;//第二参数同上bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken);//根据返回值控制if (rt) Log.Debug("函数取消了");else Log.Debug("继续执行下面逻辑");}//有返回值        public async ETTask&lt;int&gt; TestResultAsync()        {            await TimerComponent.Instance.WaitAsync(1000);return 10;        }        2.ETTask函数的调用//定义取消异步函数实例ETCancellationToken cancellationToken=new ETCancellationToken();//等待无返回值函数调用完成await TestAsync(cancellationToken);//不等待无返回值函数完成，执行下面逻辑TestAsync(cancellationToken).Coroutine();//等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题int value = await TestResultAsync();//取消函数cancellationToken.Cancel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Protobuf通讯消息"><a href="#ET中的Protobuf通讯消息" class="headerlink" title="ET中的Protobuf通讯消息"></a>ET中的Protobuf通讯消息</h1><p>Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。<br>Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；<br>Protobuf的Github开源地址 :<a href="https://github.com/protocolbuffers/protobuf">GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式</a></p><p>ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\Apps\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版;</p><p>.proto描叙文件编写的的注意事项：<br>1.Proto数据结构描叙文件存放在Proto文件夹下；<br>2.OuterMessage是定义客户端和服务端通信的消息；<br>3.InnerMessage是服务端内部通信的消息；<br>4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；<br>5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；<br>6.消息定义体中的Id不能重复；<br>7.生成的转换类型列表可以在Tools\Apps\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\Generate\Message下；<br>8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；<br>9.字符之间必须要留空格；<br>10.proto文件中的注释意义重大；</p><p>网络Handler消息编写注意事项<br>1.类名定义务必以消息类名+Handler作为声明<br>2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；<br>3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用<br>4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与；</p><h1 id="ET普通网络消息编写"><a href="#ET普通网络消息编写" class="headerlink" title="ET普通网络消息编写"></a>ET普通网络消息编写</h1><p>普通消息.proto文件编写：</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">// ResponseType R2C_LoginTest（普通请求消息一定要注释返回类）message C2R_LoginTest  // IRequest（普通请求消息必须注释）{    int32 RpcId = 90;（普通请求消息必须声明该字段）string Account = 1;string Password = 2;}message R2C_LoginTest  // IResponse（普通响应消息必须注释）{    int32 RpcId = 90;（普通响应消息必须声明该字段）int32 Error = 91;string Message = 92;string GateAddress = 1;string Key = 2;}message C2R_SayHello // IMessage（一般消息必须注释）{string Hello = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通消息C#代码：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.客户端编写登录逻辑        public static async ETTask LoginTest(Scene zoneScene, string address)        {            try            {                Session session = null;                R2C_LoginTest r2C_LoginTest = null;                try                {                    session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address));                    {                        r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = "123", Password = "456" });                        Log.Debug(r2C_LoginTest.Key);                        session.Send(new C2R_SayHello() { Hello = "你好" });                    }                }                finally                {                    session?.Dispose();                }            }            catch(Exception e)            {                Log.Error(e.ToString());            }        }//2.普通请求消息逻辑    [MessageHandler]    public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt;    {        protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply)        {            response.Key = "110";            reply();            await ETTask.CompletedTask;        }    }    //3.一般消息（不用响应）    [MessageHandler]    public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt;    {        protected override async ETTask Run(Session session, C2R_SayHello message)        {            Log.Debug(message.Hello);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Actor通信模型"><a href="#ET中的Actor通信模型" class="headerlink" title="ET中的Actor通信模型"></a>ET中的Actor通信模型</h1><p>Actor模型：<img src="https://s4.ax1x.com/2022/02/21/Hvl1zQ.png" alt="Actor模型"></p><p>Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。</p><p>ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生<br>动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理；</p><p>ActorLocation消息Proto文件编写:</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">//ResponseType M2C_TestActorLocationResponsemessage C2M_TestActorLocationReqeust // IActorLocationRequest{int32 RpcId = 90;string Content = 1;}message M2C_TestActorLocationResponse // IActorLocationResponse{int32 RpcId = 90;int32 Error = 91;string Message = 92;string Content = 1;}message C2M_TestActorLocationMessage // IActorLocationMessage{int32 RpcId = 90;string Content = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ActorLocation消息C#代码编写:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.客户端场景切换逻辑            try            {                Session session = zoneScene.GetComponent&lt;Session&gt;();                var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = "111" });                Log.Debug(message.Content);                session.Send(new C2M_TestActorLocationMessage() { Content = "22222" });            }            catch (Exception e)            {                Log.Error(e);            }            2.ActorLocation请求消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt;    {        protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply)        {            Log.Debug(request.Content);            response.Content = "333333";            reply();            await ETTask.CompletedTask;        }    }3.ActorLocation一般消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt;    {        protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message)        {            Log.Debug(message.Content);            //MessageHelper.SendToClient(entity, 发送给客户端的消息);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET教程登录实例"><a href="#ET教程登录实例" class="headerlink" title="ET教程登录实例"></a>ET教程登录实例</h1><p>实例步骤：<br>1.编写账号登录请求和响应俩条协议Proto；<br>2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；<br>3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;<br>4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）;</p><p>事后心得：<br>1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；<br>2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；<br>3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；<br>4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；<br>5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；<br>6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ET6-0框架介绍&quot;&gt;&lt;a href=&quot;#ET6-0框架介绍&quot; class=&quot;headerlink&quot; title=&quot;ET6.0框架介绍&quot;&gt;&lt;/a&gt;ET6.0框架介绍&lt;/h1&gt;&lt;h1 id=&quot;项目的初步运行&quot;&gt;&lt;a href=&quot;#项目的初步运行&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="ET" scheme="https://wwy.wwywy.com/tags/ET/"/>
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统原理笔记</title>
    <link href="https://wwy.wwywy.com/posts/513.html"/>
    <id>https://wwy.wwywy.com/posts/513.html</id>
    <published>2022-01-08T13:00:00.000Z</published>
    <updated>2022-03-03T09:51:20.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统绪论"><a href="#1-操作系统绪论" class="headerlink" title="1   操作系统绪论"></a>1   操作系统绪论</h1><h2 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1  操作系统概念"></a>1.1  操作系统概念</h2><p>定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。</p><p><strong>特征：</strong>并发、共享、虚拟、异步。</p><h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2  操作系统发展历程"></a>1.2  操作系统发展历程</h2><p>手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。</p><h3 id="1-2-1单道批处理"><a href="#1-2-1单道批处理" class="headerlink" title="1.2.1单道批处理"></a>1.2.1单道批处理</h3><p><strong>原理：</strong>计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。</p><p><strong>特征：</strong>内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。</p><h3 id="1-2-2多道批处理"><a href="#1-2-2多道批处理" class="headerlink" title="1.2.2多道批处理"></a>1.2.2多道批处理</h3><p>原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。</p><p>特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。</p><h3 id="1-2-3分时系统"><a href="#1-2-3分时系统" class="headerlink" title="1.2.3分时系统"></a>1.2.3分时系统</h3><p>特征：多路性、独立性、及时性、交互性。</p><h3 id="1-2-4实时系统"><a href="#1-2-4实时系统" class="headerlink" title="1.2.4实时系统"></a>1.2.4实时系统</h3><p><strong>特征：</strong>多路性、独立性、及时性、交互性、可靠性。</p><h1 id="2-操作系统用户界面"><a href="#2-操作系统用户界面" class="headerlink" title="2   操作系统用户界面"></a>2   操作系统用户界面</h1><h2 id="2-1-作业"><a href="#2-1-作业" class="headerlink" title="2.1  作业"></a>2.1  作业</h2><p><strong>定义：</strong>分用户和系统角度去理解</p><p>a)     用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业；</p><p>b)     系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL)</p><h2 id="2-2-一般用户输入输出方式"><a href="#2-2-一般用户输入输出方式" class="headerlink" title="2.2  一般用户输入输出方式"></a>2.2  一般用户输入输出方式</h2><h3 id="2-2-1联机输入输出方式"><a href="#2-2-1联机输入输出方式" class="headerlink" title="2.2.1联机输入输出方式"></a>2.2.1联机输入输出方式</h3><h3 id="2-2-2脱机输入输出方式"><a href="#2-2-2脱机输入输出方式" class="headerlink" title="2.2.2脱机输入输出方式"></a>2.2.2脱机输入输出方式</h3><h3 id="2-2-3直接耦合方式"><a href="#2-2-3直接耦合方式" class="headerlink" title="2.2.3直接耦合方式"></a>2.2.3直接耦合方式</h3><h3 id="2-2-4Spooling系统"><a href="#2-2-4Spooling系统" class="headerlink" title="2.2.4Spooling系统"></a>2.2.4Spooling系统</h3><p><strong>原理：</strong>todo。</p><p><strong>特点：</strong>系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。</p><h3 id="2-2-5网络联机方式"><a href="#2-2-5网络联机方式" class="headerlink" title="2.2.5网络联机方式"></a>2.2.5网络联机方式</h3><h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3  系统调用"></a>2.3  系统调用</h2><p><strong>定义：</strong>系统调用是操作系统留给编程人员的唯一接口。</p><p><strong>原理：</strong>todo</p><h3 id="2-3-1系统调用指令"><a href="#2-3-1系统调用指令" class="headerlink" title="2.3.1系统调用指令"></a>2.3.1系统调用指令</h3><p>int和trap指令进行系统调用。</p><p>call和jmp指令进入普通过程调用(子调用)。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3   进程管理"></a>3   进程管理</h1><h2 id="3-1-进程的概念"><a href="#3-1-进程的概念" class="headerlink" title="3.1  进程的概念"></a>3.1  进程的概念</h2><p><strong>组成：</strong>进程=程序+数据+进程控制块(进程状态信息PCB)</p><p><strong>定义：</strong>进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p><strong>目的：</strong>对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性；</p><p><strong>优缺点：</strong>引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。</p><h2 id="3-2-进程和程序的区别"><a href="#3-2-进程和程序的区别" class="headerlink" title="3.2  进程和程序的区别"></a>3.2  进程和程序的区别</h2><p>a)     进程是动态的，程序是静态的；</p><p>b)     进程是暂时的，程序是永久的；</p><p>c)     组成不同，进程的组成包括程序；</p><p>d)    对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序；</p><p>e)    进程可以并行，具有独立性、异步性。</p><p>f)    进程是竞争计算机资源的基本单位。</p><h2 id="3-3-进程控制块-PCB"><a href="#3-3-进程控制块-PCB" class="headerlink" title="3.3  进程控制块(PCB)"></a>3.3  进程控制块(PCB)</h2><p>进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。</p><h3 id="3-3-1描述信息"><a href="#3-3-1描述信息" class="headerlink" title="3.3.1描述信息"></a>3.3.1描述信息</h3><h3 id="3-3-2控制信息"><a href="#3-3-2控制信息" class="headerlink" title="3.3.2控制信息"></a>3.3.2控制信息</h3><h3 id="3-3-3资源管理信息"><a href="#3-3-3资源管理信息" class="headerlink" title="3.3.3资源管理信息"></a>3.3.3资源管理信息</h3><h3 id="3-3-4CPU保护现场结构"><a href="#3-3-4CPU保护现场结构" class="headerlink" title="3.3.4CPU保护现场结构"></a>3.3.4CPU保护现场结构</h3><h2 id="3-4-进程上下文切换"><a href="#3-4-进程上下文切换" class="headerlink" title="3.4  进程上下文切换"></a>3.4  进程上下文切换</h2><p><strong>原因：</strong>进程中断、超时、进程调用。</p><p><strong>步骤：</strong></p><p>a)    保存被切换进程的正文部分到有关存储区。</p><p>b)    进程有关调度和资源分配程序执行，选取新的进程。</p><p>c)    新进程正文部分从存储区取出，激活选中进程执行。</p><h2 id="3-5-进程的状态和进程转换"><a href="#3-5-进程的状态和进程转换" class="headerlink" title="3.5  进程的状态和进程转换"></a>3.5  进程的状态和进程转换</h2><h3 id="3-5-1进程状态"><a href="#3-5-1进程状态" class="headerlink" title="3.5.1进程状态"></a>3.5.1进程状态</h3><p>初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止))</p><h3 id="3-5-2进程状态转换"><a href="#3-5-2进程状态转换" class="headerlink" title="3.5.2进程状态转换"></a>3.5.2进程状态转换</h3><h2 id="3-6-进程控制"><a href="#3-6-进程控制" class="headerlink" title="3.6  进程控制"></a>3.6  进程控制</h2><h3 id="3-6-1进程创建和撤销"><a href="#3-6-1进程创建和撤销" class="headerlink" title="3.6.1进程创建和撤销"></a>3.6.1进程创建和撤销</h3><h3 id="3-6-2进程阻塞和唤醒"><a href="#3-6-2进程阻塞和唤醒" class="headerlink" title="3.6.2进程阻塞和唤醒"></a>3.6.2进程阻塞和唤醒</h3><h3 id="3-6-3进程的挂起和激活"><a href="#3-6-3进程的挂起和激活" class="headerlink" title="3.6.3进程的挂起和激活"></a>3.6.3进程的挂起和激活</h3><h2 id="3-7-进程互斥和同步"><a href="#3-7-进程互斥和同步" class="headerlink" title="3.7  进程互斥和同步"></a>3.7  进程互斥和同步</h2><h3 id="3-7-1临界区和临界资源"><a href="#3-7-1临界区和临界资源" class="headerlink" title="3.7.1临界区和临界资源"></a>3.7.1临界区和临界资源</h3><p>临界资源是一次仅允许一个进程使用的共享资源。</p><p>临界区是每个进程访问临界资源的那段代码。</p><h3 id="3-7-2信号量和PV原语"><a href="#3-7-2信号量和PV原语" class="headerlink" title="3.7.2信号量和PV原语"></a>3.7.2信号量和PV原语</h3><p>信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。</p><p>信号量的数值仅能由P、V原语操作改变。</p><h3 id="3-7-3互斥的概念"><a href="#3-7-3互斥的概念" class="headerlink" title="3.7.3互斥的概念"></a>3.7.3互斥的概念</h3><p><strong>定义：</strong>不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。</p><h3 id="3-7-4同步的概念"><a href="#3-7-4同步的概念" class="headerlink" title="3.7.4同步的概念"></a>3.7.4同步的概念</h3><p><strong>定义：</strong>对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。</p><h2 id="3-8-进程通信"><a href="#3-8-进程通信" class="headerlink" title="3.8  进程通信"></a>3.8  进程通信</h2><p>Todo</p><h2 id="3-9-死锁问题"><a href="#3-9-死锁问题" class="headerlink" title="3.9  死锁问题"></a>3.9  死锁问题</h2><h3 id="3-9-1死锁的概念"><a href="#3-9-1死锁的概念" class="headerlink" title="3.9.1死锁的概念"></a>3.9.1死锁的概念</h3><p><strong>定义：</strong> 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。</p><p><strong>起因：</strong>并发进程的资源竞争</p><p><strong>条件：</strong>同时具备互斥条件、不剥夺条件、部分分配、环路条件。</p><h3 id="3-9-2死锁的解决方案"><a href="#3-9-2死锁的解决方案" class="headerlink" title="3.9.2死锁的解决方案"></a>3.9.2死锁的解决方案</h3><h4 id="3-9-2-1-死锁预防"><a href="#3-9-2-1-死锁预防" class="headerlink" title="3.9.2.1    死锁预防"></a>3.9.2.1    死锁预防</h4><h4 id="3-9-2-2-死锁避免"><a href="#3-9-2-2-死锁避免" class="headerlink" title="3.9.2.2    死锁避免"></a>3.9.2.2    死锁避免</h4><p>最具代表性的避免算法-银行家算法</p><h4 id="3-9-2-3-死锁的检测和恢复"><a href="#3-9-2-3-死锁的检测和恢复" class="headerlink" title="3.9.2.3    死锁的检测和恢复"></a>3.9.2.3    死锁的检测和恢复</h4><h2 id="3-10-线程"><a href="#3-10-线程" class="headerlink" title="3.10    线程"></a>3.10    线程</h2><h3 id="3-10-1-线程的基本概念"><a href="#3-10-1-线程的基本概念" class="headerlink" title="3.10.1 线程的基本概念"></a>3.10.1 线程的基本概念</h3><p>定义：引入线程后，线程是操作系统调度和分配的基本单位。</p><p>组成：线程=？+线程控制块(TCB)</p><h3 id="3-10-2-线程状态和线程控制块-TCB"><a href="#3-10-2-线程状态和线程控制块-TCB" class="headerlink" title="3.10.2 线程状态和线程控制块(TCB)"></a>3.10.2 线程状态和线程控制块(TCB)</h3><p>线程状态：执行状态、就绪状态、阻塞(等待)状态</p><p>线程控制块数据结构包括：</p><p>a)     线程标识符</p><p>b)     一组寄存器</p><p>c)     线程执行状态</p><p>d)     优先级</p><p>e)     线程专有存储区</p><p>f)     信号屏蔽</p><p>g)    堆栈指针</p><h3 id="3-10-3-线程和进程的区别"><a href="#3-10-3-线程和进程的区别" class="headerlink" title="3.10.3 线程和进程的区别"></a>3.10.3 线程和进程的区别</h3><p>从以下六点讨论</p><p>a)     调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。</p><p>b)     并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。</p><p>c)     拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。</p><p>d)     独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。</p><p>e)     系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。</p><p>f)     支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。</p><h1 id="4-处理机调度"><a href="#4-处理机调度" class="headerlink" title="4   处理机调度"></a>4   处理机调度</h1><h2 id="4-1-调度层级"><a href="#4-1-调度层级" class="headerlink" title="4.1  调度层级"></a>4.1  调度层级</h2><p>一个作业提交后，往往会经历三种层级（加线程四种）</p><h3 id="4-1-1作业调度"><a href="#4-1-1作业调度" class="headerlink" title="4.1.1作业调度"></a>4.1.1作业调度</h3><p>又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。</p><h4 id="4-1-1-1-周转时间相关"><a href="#4-1-1-1-周转时间相关" class="headerlink" title="4.1.1.1    周转时间相关"></a>4.1.1.1    周转时间相关</h4><p>周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间</p><p>平均周转时间=所有作业周转时间之和/总作业数</p><p>带权周转时间=作业周转时间/作业执行时间</p><p>平均带权周转时间=所有带权作业周转时间之和/总作业数</p><h4 id="4-1-1-2-响应时间，截止时间和系统吞吐量"><a href="#4-1-1-2-响应时间，截止时间和系统吞吐量" class="headerlink" title="4.1.1.2     响应时间，截止时间和系统吞吐量"></a>4.1.1.2     响应时间，截止时间和系统吞吐量</h4><p>响应时间是提交请求和返回该请求的响应之间使用的时间<br>截止时间是某任务必须开始执行或者必须完成的最迟时间<br>吞吐量是对单位时间内完成的工作量的量度</p><h3 id="4-1-2交换调度"><a href="#4-1-2交换调度" class="headerlink" title="4.1.2交换调度"></a>4.1.2交换调度</h3><p>又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存</p><h3 id="4-1-3进程调度"><a href="#4-1-3进程调度" class="headerlink" title="4.1.3进程调度"></a>4.1.3进程调度</h3><p>又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式</p><h4 id="4-1-3-1-非抢占方式"><a href="#4-1-3-1-非抢占方式" class="headerlink" title="4.1.3.1    非抢占方式"></a>4.1.3.1    非抢占方式</h4><p>一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。</p><h4 id="4-1-3-2-抢占方式"><a href="#4-1-3-2-抢占方式" class="headerlink" title="4.1.3.2     抢占方式"></a>4.1.3.2     抢占方式</h4><p>系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程</p><p>a)     优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU</p><p>b)     短作业优先原则：就绪的短进程有权抢占长进程的CPU</p><p>c)     时间片原则：一个时间片用完后，系统重新进行进程调度</p><h3 id="4-1-4线程调度"><a href="#4-1-4线程调度" class="headerlink" title="4.1.4线程调度"></a>4.1.4线程调度</h3><p>Todo</p><h2 id="4-2-作业和进程的关系"><a href="#4-2-作业和进程的关系" class="headerlink" title="4.2  作业和进程的关系"></a>4.2  作业和进程的关系</h2><p>系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。</p><h2 id="4-3-调度算法"><a href="#4-3-调度算法" class="headerlink" title="4.3  调度算法"></a>4.3  调度算法</h2><p>宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。</p><p>​    微观调度：轮转法、优先级法、多级反馈轮转法。</p><h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5   存储管理"></a>5   存储管理</h1><h2 id="5-1-存储器结构"><a href="#5-1-存储器结构" class="headerlink" title="5.1  存储器结构"></a>5.1  存储器结构</h2><p>由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。</p><h3 id="5-1-1寄存器"><a href="#5-1-1寄存器" class="headerlink" title="5.1.1寄存器"></a>5.1.1寄存器</h3><p>寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。</p><h3 id="5-1-2高速缓存"><a href="#5-1-2高速缓存" class="headerlink" title="5.1.2高速缓存"></a>5.1.2高速缓存</h3><p>它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。</p><h3 id="5-1-3主存输器"><a href="#5-1-3主存输器" class="headerlink" title="5.1.3主存输器"></a>5.1.3主存输器</h3><p>简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。</p><h3 id="5-1-4磁盘缓存"><a href="#5-1-4磁盘缓存" class="headerlink" title="5.1.4磁盘缓存"></a>5.1.4磁盘缓存</h3><p>目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。</p><h2 id="5-2-程序的处理阶段"><a href="#5-2-程序的处理阶段" class="headerlink" title="5.2  程序的处理阶段"></a>5.2  程序的处理阶段</h2><p>主要有编译，链接，装入，下面主要讲链接和装入。</p><h3 id="5-2-1程序的链接"><a href="#5-2-1程序的链接" class="headerlink" title="5.2.1程序的链接"></a>5.2.1程序的链接</h3><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。<br>链接又可分为静态链接，装入时动态链接，运行时动态链接。</p><h3 id="5-2-2程序的装入"><a href="#5-2-2程序的装入" class="headerlink" title="5.2.2程序的装入"></a>5.2.2程序的装入</h3><p>分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。</p><h2 id="5-3-地址变换"><a href="#5-3-地址变换" class="headerlink" title="5.3  地址变换"></a>5.3  地址变换</h2><h3 id="5-3-1静态地址重定向"><a href="#5-3-1静态地址重定向" class="headerlink" title="5.3.1静态地址重定向"></a>5.3.1静态地址重定向</h3><p><strong>原理：</strong>Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。</p><h3 id="5-3-2动态地址重定位"><a href="#5-3-2动态地址重定位" class="headerlink" title="5.3.2动态地址重定位"></a>5.3.2动态地址重定位</h3><p><strong>关系：</strong>MA(物理地址)=BR(基址地址)+VR(虚拟地址)。</p><p>原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。</p><h2 id="5-4-分区存储管理"><a href="#5-4-分区存储管理" class="headerlink" title="5.4  分区存储管理"></a>5.4  分区存储管理</h2><p>分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。</p><h3 id="5-4-1固态分区法"><a href="#5-4-1固态分区法" class="headerlink" title="5.4.1固态分区法"></a>5.4.1固态分区法</h3><p>原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。</p><p>优点:易于实现，开销小。</p><p>缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。</p><h3 id="5-4-2动态分区法"><a href="#5-4-2动态分区法" class="headerlink" title="5.4.2动态分区法"></a>5.4.2动态分区法</h3><p><strong>原理：</strong>动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。</p><p><strong>优点：</strong>没有内碎片；</p><p><strong>缺点：</strong>有外碎片；</p><p><strong>算法：</strong>根据情况有以下俩种，着重介绍三种</p><p>a)     基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法</p><p>b)     基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法</p><h4 id="5-4-2-2-最先适应法"><a href="#5-4-2-2-最先适应法" class="headerlink" title="5.4.2.2     最先适应法"></a>5.4.2.2     最先适应法</h4><h4 id="5-4-2-3-最佳适应法"><a href="#5-4-2-3-最佳适应法" class="headerlink" title="5.4.2.3     最佳适应法"></a>5.4.2.3     最佳适应法</h4><h4 id="5-4-2-4-最坏适应法"><a href="#5-4-2-4-最坏适应法" class="headerlink" title="5.4.2.4     最坏适应法"></a>5.4.2.4     最坏适应法</h4><h3 id="5-4-3页式管理（离散分配）"><a href="#5-4-3页式管理（离散分配）" class="headerlink" title="5.4.3页式管理（离散分配）"></a>5.4.3页式管理（离散分配）</h3><p>基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。</p><h4 id="5-4-3-1-静态页式管理"><a href="#5-4-3-1-静态页式管理" class="headerlink" title="5.4.3.1    静态页式管理"></a>5.4.3.1    静态页式管理</h4><p>原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。</p><h4 id="5-4-3-2-动态页式管理"><a href="#5-4-3-2-动态页式管理" class="headerlink" title="5.4.3.2    动态页式管理"></a>5.4.3.2    动态页式管理</h4><h3 id="5-4-4段式和段页式管理"><a href="#5-4-4段式和段页式管理" class="headerlink" title="5.4.4段式和段页式管理"></a>5.4.4段式和段页式管理</h3><p>基本思想：todo</p><h4 id="5-4-4-1-段式管理"><a href="#5-4-4-1-段式管理" class="headerlink" title="5.4.4.1     段式管理"></a>5.4.4.1     段式管理</h4><p>原理：todo</p><h4 id="5-4-4-2-段页式管理"><a href="#5-4-4-2-段页式管理" class="headerlink" title="5.4.4.2     段页式管理"></a>5.4.4.2     段页式管理</h4><p>原理：todo</p><h3 id="5-4-5覆盖和交换技术"><a href="#5-4-5覆盖和交换技术" class="headerlink" title="5.4.5覆盖和交换技术"></a>5.4.5覆盖和交换技术</h3><h2 id="5-5-虚拟存输器"><a href="#5-5-虚拟存输器" class="headerlink" title="5.5  虚拟存输器"></a>5.5  虚拟存输器</h2><h3 id="5-5-1虚拟存储的实现方式"><a href="#5-5-1虚拟存储的实现方式" class="headerlink" title="5.5.1虚拟存储的实现方式"></a>5.5.1虚拟存储的实现方式</h3><p>虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式：</p><h4 id="5-5-1-1-分页请求系统"><a href="#5-5-1-1-分页请求系统" class="headerlink" title="5.5.1.1     分页请求系统"></a>5.5.1.1     分页请求系统</h4><p>在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。<br>  硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上</p><h4 id="5-5-1-2-请求分段系统"><a href="#5-5-1-2-请求分段系统" class="headerlink" title="5.5.1.2     请求分段系统"></a>5.5.1.2     请求分段系统</h4><p>在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页”</p><h3 id="5-5-2页面置换算法"><a href="#5-5-2页面置换算法" class="headerlink" title="5.5.2页面置换算法"></a>5.5.2页面置换算法</h3><h4 id="5-5-2-1-随机淘汰算法"><a href="#5-5-2-1-随机淘汰算法" class="headerlink" title="5.5.2.1     随机淘汰算法"></a>5.5.2.1     随机淘汰算法</h4><p>随机地选择某个用户地页面并将其换出。</p><h4 id="5-5-2-2-最佳置换算法（理想型淘汰算法OPT）"><a href="#5-5-2-2-最佳置换算法（理想型淘汰算法OPT）" class="headerlink" title="5.5.2.2     最佳置换算法（理想型淘汰算法OPT）"></a>5.5.2.2     最佳置换算法（理想型淘汰算法OPT）</h4><p>其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。</p><h4 id="5-5-2-3-先进先出置换算法（FIFO）"><a href="#5-5-2-3-先进先出置换算法（FIFO）" class="headerlink" title="5.5.2.3     先进先出置换算法（FIFO）"></a>5.5.2.3     先进先出置换算法（FIFO）</h4><p>总是先淘汰最先进入内存的页面。</p><h4 id="5-5-2-4-最近最久未使用算法（LRU）"><a href="#5-5-2-4-最近最久未使用算法（LRU）" class="headerlink" title="5.5.2.4     最近最久未使用算法（LRU）"></a>5.5.2.4     最近最久未使用算法（LRU）</h4><p>选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。</p><h4 id="5-5-2-5-最少使用置换算法（LFU）"><a href="#5-5-2-5-最少使用置换算法（LFU）" class="headerlink" title="5.5.2.5     最少使用置换算法（LFU）"></a>5.5.2.5     最少使用置换算法（LFU）</h4><p>在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。</p><h4 id="5-5-2-6-Clock置换算法"><a href="#5-5-2-6-Clock置换算法" class="headerlink" title="5.5.2.6     Clock置换算法"></a>5.5.2.6     Clock置换算法</h4><p>是一种LRU算法<br>每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；<br>当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；<br>再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面；</p><h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6   文件系统"></a>6   文件系统</h1><h2 id="6-1-文件系统基本概念"><a href="#6-1-文件系统基本概念" class="headerlink" title="6.1  文件系统基本概念"></a>6.1  文件系统基本概念</h2><p><strong>目的：</strong>文件系统地出现是为了更好地管理软件资源</p><p><strong>文件系统的定义：</strong>操作系统中与管理文件有关的软件和数据称为文件系统</p><p><strong>文件的定义：</strong>文件时一段程序和数据的集合</p><p><strong>文件的分类：</strong>按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。</p><h2 id="6-2-文件的逻辑结构和存取方式"><a href="#6-2-文件的逻辑结构和存取方式" class="headerlink" title="6.2  文件的逻辑结构和存取方式"></a>6.2  文件的逻辑结构和存取方式</h2><h3 id="6-2-1逻辑结构"><a href="#6-2-1逻辑结构" class="headerlink" title="6.2.1逻辑结构"></a>6.2.1逻辑结构</h3><p><strong>字符流的无结构文件：</strong>管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。</p><p><strong>记录式的有结构文件：</strong>把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。</p><h4 id="6-2-1-1-连续结构"><a href="#6-2-1-1-连续结构" class="headerlink" title="6.2.1.1     连续结构"></a>6.2.1.1     连续结构</h4><h4 id="6-2-1-2-多重结构"><a href="#6-2-1-2-多重结构" class="headerlink" title="6.2.1.2     多重结构"></a>6.2.1.2     多重结构</h4><h4 id="6-2-1-3-转置结构"><a href="#6-2-1-3-转置结构" class="headerlink" title="6.2.1.3     转置结构"></a>6.2.1.3     转置结构</h4><h4 id="6-2-1-4-顺序结构"><a href="#6-2-1-4-顺序结构" class="headerlink" title="6.2.1.4     顺序结构"></a>6.2.1.4     顺序结构</h4><h3 id="6-2-2逻辑存储方法"><a href="#6-2-2逻辑存储方法" class="headerlink" title="6.2.2逻辑存储方法"></a>6.2.2逻辑存储方法</h3><h4 id="6-2-2-1-顺序存输方法"><a href="#6-2-2-1-顺序存输方法" class="headerlink" title="6.2.2.1     顺序存输方法"></a>6.2.2.1     顺序存输方法</h4><h4 id="6-2-2-2-随机存输方法"><a href="#6-2-2-2-随机存输方法" class="headerlink" title="6.2.2.2     随机存输方法"></a>6.2.2.2     随机存输方法</h4><h4 id="6-2-2-3-按关键字存输方法"><a href="#6-2-2-3-按关键字存输方法" class="headerlink" title="6.2.2.3    按关键字存输方法"></a>6.2.2.3    按关键字存输方法</h4><p>多用于复杂文件系统。</p><h3 id="6-2-3逻辑搜索方式"><a href="#6-2-3逻辑搜索方式" class="headerlink" title="6.2.3逻辑搜索方式"></a>6.2.3逻辑搜索方式</h3><p>文件的获取是要找到文件内容所在的逻辑地址</p><h4 id="6-2-3-1-线性搜索法"><a href="#6-2-3-1-线性搜索法" class="headerlink" title="6.2.3.1     线性搜索法"></a>6.2.3.1     线性搜索法</h4><h4 id="6-2-3-2-散列法"><a href="#6-2-3-2-散列法" class="headerlink" title="6.2.3.2     散列法"></a>6.2.3.2     散列法</h4><h4 id="6-2-3-3-二分搜索法"><a href="#6-2-3-3-二分搜索法" class="headerlink" title="6.2.3.3     二分搜索法"></a>6.2.3.3     二分搜索法</h4><h2 id="6-3-文件的物理结构和存储设备"><a href="#6-3-文件的物理结构和存储设备" class="headerlink" title="6.3  文件的物理结构和存储设备"></a>6.3  文件的物理结构和存储设备</h2><h3 id="6-3-1文件物理结构"><a href="#6-3-1文件物理结构" class="headerlink" title="6.3.1文件物理结构"></a>6.3.1文件物理结构</h3><h4 id="6-3-1-1-连续文件"><a href="#6-3-1-1-连续文件" class="headerlink" title="6.3.1.1    连续文件"></a>6.3.1.1    连续文件</h4><p>连续文件采用连续分配方式：</p><p><strong>特点：</strong>为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。<br><strong>优点：</strong>顺序访问容易; 顺序访问速度快;<br><strong>缺点：</strong>要求有连续的存储空间; 必须事先知道文件的长度;</p><h4 id="6-3-1-2-串联文件"><a href="#6-3-1-2-串联文件" class="headerlink" title="6.3.1.2    串联文件"></a>6.3.1.2    串联文件</h4><p>串联文件采用链接分配</p><p><strong>特点：</strong>文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；<br><strong>优点：</strong>没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间;</p><h4 id="6-3-1-3-索引文件"><a href="#6-3-1-3-索引文件" class="headerlink" title="6.3.1.3    索引文件"></a>6.3.1.3    索引文件</h4><p>索引文件采用索引分配</p><p><strong>特点：</strong>每个文件都有自己的索引块，这是一个磁盘块地址的数组。</p><h3 id="6-3-2文件存储设备"><a href="#6-3-2文件存储设备" class="headerlink" title="6.3.2文件存储设备"></a>6.3.2文件存储设备</h3><p>存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。</p><h4 id="6-3-2-1-顺序存取存储设备—磁带"><a href="#6-3-2-1-顺序存取存储设备—磁带" class="headerlink" title="6.3.2.1    顺序存取存储设备—磁带"></a>6.3.2.1    顺序存取存储设备—磁带</h4><p><strong>特点：</strong>只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。</p><p><strong>影响因素：</strong>信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。</p><h4 id="6-3-2-2-直接存取存储设备—磁盘"><a href="#6-3-2-2-直接存取存储设备—磁盘" class="headerlink" title="6.3.2.2     直接存取存储设备—磁盘"></a>6.3.2.2     直接存取存储设备—磁盘</h4><h2 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4  文件存储空间管理"></a>6.4  文件存储空间管理</h2><p>文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。</p><h3 id="6-4-1空闲目录管理"><a href="#6-4-1空闲目录管理" class="headerlink" title="6.4.1空闲目录管理"></a>6.4.1空闲目录管理</h3><h3 id="6-4-2空闲链块法"><a href="#6-4-2空闲链块法" class="headerlink" title="6.4.2空闲链块法"></a>6.4.2空闲链块法</h3><h3 id="6-4-3位示图"><a href="#6-4-3位示图" class="headerlink" title="6.4.3位示图"></a>6.4.3位示图</h3><h2 id="6-5-文件目录管理"><a href="#6-5-文件目录管理" class="headerlink" title="6.5  文件目录管理"></a>6.5  文件目录管理</h2><p>从文件管理角度看，一个文件包括文件说明和文件体。</p><h3 id="6-5-1文件目录的种类"><a href="#6-5-1文件目录的种类" class="headerlink" title="6.5.1文件目录的种类"></a>6.5.1文件目录的种类</h3><h4 id="6-5-1-1-单级文件目录"><a href="#6-5-1-1-单级文件目录" class="headerlink" title="6.5.1.1     单级文件目录"></a>6.5.1.1     单级文件目录</h4><p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。</p><h4 id="6-5-1-2-两级文件目录"><a href="#6-5-1-2-两级文件目录" class="headerlink" title="6.5.1.2     两级文件目录"></a>6.5.1.2     两级文件目录</h4><p>目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB；</p><h4 id="6-5-1-3-树形结构目录"><a href="#6-5-1-3-树形结构目录" class="headerlink" title="6.5.1.3     树形结构目录"></a>6.5.1.3     树形结构目录</h4><p>多级目录结构又称为树型目录结构；<br>主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点；</p><h3 id="6-5-2文件目录的共享"><a href="#6-5-2文件目录的共享" class="headerlink" title="6.5.2文件目录的共享"></a>6.5.2文件目录的共享</h3><p>从系统管理的方式来看，有三种方法可以实现文件共享</p><h4 id="6-5-2-1-绕道法"><a href="#6-5-2-1-绕道法" class="headerlink" title="6.5.2.1     绕道法"></a>6.5.2.1     绕道法</h4><h4 id="6-5-2-2-链接法"><a href="#6-5-2-2-链接法" class="headerlink" title="6.5.2.2     链接法"></a>6.5.2.2     链接法</h4><h4 id="6-5-2-3-基本文件目录表（BFD）"><a href="#6-5-2-3-基本文件目录表（BFD）" class="headerlink" title="6.5.2.3    基本文件目录表（BFD）"></a>6.5.2.3    基本文件目录表（BFD）</h4><h3 id="6-5-3目录管理"><a href="#6-5-3目录管理" class="headerlink" title="6.5.3目录管理"></a>6.5.3目录管理</h3><p>文件目录管理应该存放在磁盘，其他的没理解todo</p><h2 id="6-6-文件存取控制"><a href="#6-6-文件存取控制" class="headerlink" title="6.6  文件存取控制"></a>6.6  文件存取控制</h2><p>用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。</p><h3 id="6-6-1存取控制矩阵"><a href="#6-6-1存取控制矩阵" class="headerlink" title="6.6.1存取控制矩阵"></a>6.6.1存取控制矩阵</h3><h3 id="6-6-2存取控制表"><a href="#6-6-2存取控制表" class="headerlink" title="6.6.2存取控制表"></a>6.6.2存取控制表</h3><h3 id="6-6-3口令方式"><a href="#6-6-3口令方式" class="headerlink" title="6.6.3口令方式"></a>6.6.3口令方式</h3><h3 id="6-6-4密码方式"><a href="#6-6-4密码方式" class="headerlink" title="6.6.4密码方式"></a>6.6.4密码方式</h3><p>密码方式是保密性最好的验证方式。</p><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7    设备管理"></a>7    设备管理</h1><h2 id="7-1-设备的分类"><a href="#7-1-设备的分类" class="headerlink" title="7.1  设备的分类"></a>7.1  设备的分类</h2><p>在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。</p><h2 id="7-2-数据传输控制方式"><a href="#7-2-数据传输控制方式" class="headerlink" title="7.2  数据传输控制方式"></a>7.2  数据传输控制方式</h2><p>设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。</p><h3 id="7-2-1程序直接控制方式"><a href="#7-2-1程序直接控制方式" class="headerlink" title="7.2.1程序直接控制方式"></a>7.2.1程序直接控制方式</h3><p>由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。</p><h3 id="7-2-2中断方式"><a href="#7-2-2中断方式" class="headerlink" title="7.2.2中断方式"></a>7.2.2中断方式</h3><p>I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。</p><h3 id="7-2-3DMA方式"><a href="#7-2-3DMA方式" class="headerlink" title="7.2.3DMA方式"></a>7.2.3DMA方式</h3><p>在外围设备和内存之间开辟直接的数据交换通道。</p><h3 id="7-2-4通道控制方式"><a href="#7-2-4通道控制方式" class="headerlink" title="7.2.4通道控制方式"></a>7.2.4通道控制方式</h3><p>以内存为中心，实现设备和内存直接交换数据的控制的方式。</p><h2 id="7-3-中断技术"><a href="#7-3-中断技术" class="headerlink" title="7.3  中断技术"></a>7.3  中断技术</h2><p><strong>原理：</strong>中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。</p><p><strong>过程：</strong>判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点</p><h3 id="7-3-1中断技术的分类"><a href="#7-3-1中断技术的分类" class="headerlink" title="7.3.1中断技术的分类"></a>7.3.1中断技术的分类</h3><p>中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。</p><h4 id="7-3-1-1-外中断"><a href="#7-3-1-1-外中断" class="headerlink" title="7.3.1.1    外中断"></a>7.3.1.1    外中断</h4><p>一般是来自处理机和内存外部的中断</p><h4 id="7-3-1-2-内中断（陷阱）"><a href="#7-3-1-2-内中断（陷阱）" class="headerlink" title="7.3.1.2    内中断（陷阱）"></a>7.3.1.2    内中断（陷阱）</h4><p>一般是来自处理机和内存内部的中断</p><h4 id="7-3-1-3-软中断"><a href="#7-3-1-3-软中断" class="headerlink" title="7.3.1.3    软中断"></a>7.3.1.3    软中断</h4><p>是通信进程之间模拟硬中断的一种信号通信方式</p><h2 id="7-4-缓冲技术"><a href="#7-4-缓冲技术" class="headerlink" title="7.4  缓冲技术"></a>7.4  缓冲技术</h2><p><strong>目的：</strong>缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。</p><p><strong>分类：</strong>缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。</p><h3 id="7-4-1缓冲池的结构"><a href="#7-4-1缓冲池的结构" class="headerlink" title="7.4.1缓冲池的结构"></a>7.4.1缓冲池的结构</h3><p>缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。</p><h3 id="7-4-2缓冲池管理"><a href="#7-4-2缓冲池管理" class="headerlink" title="7.4.2缓冲池管理"></a>7.4.2缓冲池管理</h3><p>Todo</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统绪论&quot;&gt;&lt;a href=&quot;#1-操作系统绪论&quot; class=&quot;headerlink&quot; title=&quot;1   操作系统绪论&quot;&gt;&lt;/a&gt;1   操作系统绪论&lt;/h1&gt;&lt;h2 id=&quot;1-1-操作系统概念&quot;&gt;&lt;a href=&quot;#1-1-操作系统概念&quot; cla</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机操作系统" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机操作系统" scheme="https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-FairyGUI</title>
    <link href="https://wwy.wwywy.com/posts/1542.html"/>
    <id>https://wwy.wwywy.com/posts/1542.html</id>
    <published>2021-12-12T13:00:00.000Z</published>
    <updated>2022-03-03T10:08:03.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FairyGUI概叙"><a href="#FairyGUI概叙" class="headerlink" title="FairyGUI概叙"></a>FairyGUI概叙</h1><h1 id="FairyGUI基础"><a href="#FairyGUI基础" class="headerlink" title="FairyGUI基础"></a>FairyGUI基础</h1><h1 id="FairyGUI基本元件"><a href="#FairyGUI基本元件" class="headerlink" title="FairyGUI基本元件"></a>FairyGUI基本元件</h1><h1 id="FairyGUI控件"><a href="#FairyGUI控件" class="headerlink" title="FairyGUI控件"></a>FairyGUI控件</h1><h2 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h2><h2 id="字体处理"><a href="#字体处理" class="headerlink" title="字体处理"></a>字体处理</h2><h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><h2 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h2><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h2 id="关联系统"><a href="#关联系统" class="headerlink" title="关联系统"></a>关联系统</h2><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="单选和多选框"><a href="#单选和多选框" class="headerlink" title="单选和多选框"></a>单选和多选框</h2><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><h2 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h2><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><h2 id="滚动容器"><a href="#滚动容器" class="headerlink" title="滚动容器"></a>滚动容器</h2><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h2><h1 id="Unity中的使用必备"><a href="#Unity中的使用必备" class="headerlink" title="Unity中的使用必备"></a>Unity中的使用必备</h1><h2 id="组件拓展类"><a href="#组件拓展类" class="headerlink" title="组件拓展类"></a>组件拓展类</h2><h2 id="分辨率自适应"><a href="#分辨率自适应" class="headerlink" title="分辨率自适应"></a>分辨率自适应</h2><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><h2 id="拖拽相关"><a href="#拖拽相关" class="headerlink" title="拖拽相关"></a>拖拽相关</h2><h2 id="插入其他对象"><a href="#插入其他对象" class="headerlink" title="插入其他对象"></a>插入其他对象</h2><h2 id="DrawCall优化"><a href="#DrawCall优化" class="headerlink" title="DrawCall优化"></a>DrawCall优化</h2><h1 id="FairyGUI进阶"><a href="#FairyGUI进阶" class="headerlink" title="FairyGUI进阶"></a>FairyGUI进阶</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="多国语言"><a href="#多国语言" class="headerlink" title="多国语言"></a>多国语言</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h2 id="弹出功能"><a href="#弹出功能" class="headerlink" title="弹出功能"></a>弹出功能</h2><h2 id="曲面UI"><a href="#曲面UI" class="headerlink" title="曲面UI"></a>曲面UI</h2><h2 id="动效"><a href="#动效" class="headerlink" title="动效"></a>动效</h2><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FairyGUI概叙&quot;&gt;&lt;a href=&quot;#FairyGUI概叙&quot; class=&quot;headerlink&quot; title=&quot;FairyGUI概叙&quot;&gt;&lt;/a&gt;FairyGUI概叙&lt;/h1&gt;&lt;h1 id=&quot;FairyGUI基础&quot;&gt;&lt;a href=&quot;#FairyGUI基础&quot;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="GUI解决方案" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="FairyGUI" scheme="https://wwy.wwywy.com/tags/FairyGUI/"/>
    
  </entry>
  
  <entry>
    <title>Lua语言</title>
    <link href="https://wwy.wwywy.com/posts/1344.html"/>
    <id>https://wwy.wwywy.com/posts/1344.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-03-09T02:19:36.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
    <category term="Lua" scheme="https://wwy.wwywy.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-基于Lua的热更新解决方案</title>
    <link href="https://wwy.wwywy.com/posts/1569.html"/>
    <id>https://wwy.wwywy.com/posts/1569.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-03-09T02:18:17.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="热更新" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Lua" scheme="https://wwy.wwywy.com/tags/Lua/"/>
    
    <category term="AssetBundle" scheme="https://wwy.wwywy.com/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>游戏同步方案</title>
    <link href="https://wwy.wwywy.com/posts/2177.html"/>
    <id>https://wwy.wwywy.com/posts/2177.html</id>
    <published>2021-10-12T13:00:00.000Z</published>
    <updated>2022-03-07T11:57:52.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="帧同步方案"><a href="#帧同步方案" class="headerlink" title="帧同步方案"></a>帧同步方案</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;帧同步方案&quot;&gt;&lt;a href=&quot;#帧同步方案&quot; class=&quot;headerlink&quot; title=&quot;帧同步方案&quot;&gt;&lt;/a&gt;帧同步方案&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="同步技术" scheme="https://wwy.wwywy.com/categories/Game-Play/%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="帧同步" scheme="https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法格式（.md后缀-使用typora）</title>
    <link href="https://wwy.wwywy.com/posts/1.html"/>
    <id>https://wwy.wwywy.com/posts/1.html</id>
    <published>2021-09-28T13:00:00.000Z</published>
    <updated>2022-01-24T06:26:54.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法格式"><a href="#Markdown语法格式" class="headerlink" title="Markdown语法格式"></a>Markdown语法格式</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#标题1 （大）</span><span class="token comment">##标题2</span><span class="token comment">###标题3</span><span class="token comment">####标题4 （小）</span>以此类推 最高标题6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">​```代码块名称<span class="token punctuation">(</span>可以输入各种语言java、c++、html等<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//加粗**加粗**//代码高亮显示<span class="token operator">==</span>高亮<span class="token operator">==</span>//删除线~~删除线~~//斜体  *斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//引用语法<span class="token operator">&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>作者：泽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//分割线---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="图片插入："><a href="#图片插入：" class="headerlink" title="图片插入："></a>图片插入：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//在线图片与本地图片<span class="token operator">!</span><span class="token punctuation">[</span>照片名子<span class="token punctuation">]</span>（/image/me.png）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//超链接语法<span class="token punctuation">[</span>超链接名字<span class="token punctuation">]</span>（https://gihub.com/yerenping）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//无需列表- 目录1  -后加空格- 目录2- 目录3//有序列表  <span class="token number">1</span>+. +名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右键》插入》表格用代码过于复杂不推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown语法格式&quot;&gt;&lt;a href=&quot;#Markdown语法格式&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法格式&quot;&gt;&lt;/a&gt;Markdown语法格式&lt;/h1&gt;&lt;h2 id=&quot;标题：&quot;&gt;&lt;a href=&quot;#标题：&quot; class</summary>
      
    
    
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Markdown" scheme="https://wwy.wwywy.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-Editor</title>
    <link href="https://wwy.wwywy.com/posts/1560.html"/>
    <id>https://wwy.wwywy.com/posts/1560.html</id>
    <published>2021-07-09T13:00:00.000Z</published>
    <updated>2022-03-03T10:04:32.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待写&quot;&gt;&lt;a href=&quot;#待写&quot; class=&quot;headerlink&quot; title=&quot;待写&quot;&gt;&lt;/a&gt;待写&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="UnityEditor" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="UnityEditor" scheme="https://wwy.wwywy.com/tags/UnityEditor/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法</title>
    <link href="https://wwy.wwywy.com/posts/545.html"/>
    <id>https://wwy.wwywy.com/posts/545.html</id>
    <published>2021-06-30T13:00:00.000Z</published>
    <updated>2022-03-06T01:20:16.945Z</updated>
    
    <content type="html"><![CDATA[<p>列举一些常用的排序算法</p><p>#冒泡排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void BubbleSort(int[] array, int count){    //设置标识符，如果为false意为当前数组为有序，不需要再排序了    bool shouldSorted = true;    for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++)    {        shouldSorted = false;        for (int j = count - 1; j &gt; i; j--)        {            if (array[j - 1] &gt; array[j])            {                shouldSorted = true;                Utilities.Swap(ref array[j - 1], ref array[j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#选择排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void SelectSort(int[] array, int count){    int min;    for (int i = 0; i &lt; count - 1; i++)    {        min = i;        for (int j = i + 1; j &lt; count; j++)        {            if (array[min] &gt; array[j])            {                min = j;            }        }        if (min != i)        {            Utilities.Swap(ref array[min], ref array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#插入排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void InserSort(int[] array, int count){    int guard; //哨兵，用于暂存需要交换的值    for (int i = 0; i &lt; count - 1; i++)    {        if (array[i] &gt; array[i + 1])        {            guard = array[i + 1];            int j;            for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--)            {                array[j + 1] = array[j]; //赋值操作（依次后移）            }            array[j + 1] = guard;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#希尔排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 希尔排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void ShellSort(int[] array, int count){    int i, j, guard;    int increment = count;    do    {        increment = increment / 3 + 1; //增量序列        for (i = increment + 1; i &lt; count; i++)        {            if (array[i] &lt; array[i - increment])            {                guard = array[i]; //暂存在哨兵处                for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment)                {                    array[j + increment] = array[j]; //记录后移，查找插入位置                }                array[j + increment] = guard; //插入            }        }    } while (increment &gt; 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#堆排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 堆排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void HeapSort(int[] array, int count){    for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆    {        HeapAdjust(array, i, count - 1);    }    for (int i = count - 1; i &gt; 0; i--)    {        Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换        HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆    }}/// &lt;summary&gt;/// 堆排序_构造大顶堆函数/// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义/// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="startIndex"&gt;起始位置&lt;/param&gt;/// &lt;param name="endIndex"&gt;结束位置&lt;/param&gt;public static void HeapAdjust(int[] array, int startIndex, int endIndex){    int temp;    temp = array[startIndex];    for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选    {        if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1])        {            ++i; //i为关键字中较大记录的下标        }        if (temp &gt; array[i])        {            break; //rc应插入在位置s上        }        array[startIndex] = array[i];        startIndex = i;    }    array[startIndex] = temp; //插入}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#归并排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 归并排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void MergeSort(int[] array, int count){    int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果    int k = 1;    while (k &lt; count)    {        MergePass(array, tempArray, k, count); //array归并到tempArray        k = 2 * k; //子序列长度加倍        MergePass(tempArray, array, k, count); //tempArray归并到array        k = 2 * k; //子序列长度加倍    }}/// &lt;summary&gt;/// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="srChildLength"&gt;SR中子序列长度&lt;/param&gt;/// &lt;param name="arrayLength"&gt;原数组长度&lt;/param&gt;public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength){    int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数    while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2,            hasMergeCount + 2 * srChildLength - 2); //两两归并        hasMergeCount += 2 * srChildLength;    }    if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1);    }    else //若最后只剩下单个子序列    {        for (int j = hasMergeCount - 1; j &lt; arrayLength; j++)        {            tr[j] = sr[j];        }    }}/// &lt;summary&gt;/// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="sr1StartIndex"&gt;SR数组子序列1起始位置&lt;/param&gt;/// &lt;param name="sr1EndIndex"&gt;SR数组子序列1结束位置&lt;/param&gt;/// &lt;param name="sr2EndIndex"&gt;SR数组子序列2结束位置&lt;/param&gt;private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex){    int sr2StartIndex, currentProcess; //currentProcess为当前进度    for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex;        sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex;        currentProcess++) //两个SR有一个被榨干后就要退出循环    {        if (sr[sr1StartIndex] &lt; sr[sr2StartIndex])        {            tr[currentProcess] = sr[sr1StartIndex++];        }        else        {            tr[currentProcess] = sr[sr2StartIndex++];        }    }    if (sr1StartIndex &lt;= sr1EndIndex)    {        for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++)        {            tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR        }    }    if (sr2StartIndex &lt;= sr2EndIndex)    {        for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++)        {            tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#快速排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 快速排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void QuickSort(int[] array, int count){    QSort(array, 0, count - 1);}/// &lt;summary&gt;/// 快速排序_递归调用/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;private static void QSort(int[] array, int low, int high){    int pivot;    while (low &lt; high)    {        pivot = Partition(array, low, high);        QSort(array, low, pivot - 1);        //尾递归，可以减少一次递归堆栈深度        low = pivot + 1;    }}/// &lt;summary&gt;/// 获取枢轴数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static int Partition(int[] array, int low, int high){    int pivotkey;    int m = low + (high - low) / 2;    //下面是三数取中优化    //交换左端与右端数据，保证左端较小    if (array[low] &gt; array[high])    {        Utilities.Swap(ref array[low],ref array[high]);    }    //交换中间与右端数据，保证中间较小    if (array[m] &gt; array[high])    {        Utilities.Swap(ref array[m],ref array[high]);    }    //交换中间与左端数据，保证左端较小    if (array[m] &gt; array[low])    {        Utilities.Swap(ref array[low],ref array[m]);    }    //默认选取当前数组的第一个值作为枢轴值    pivotkey = array[low];    //枢轴备份    int pivotkeyback = pivotkey;    while (low &lt; high)    {        while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey)        {            high--;        }        array[low] = array[high];        while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey)        {            low++;        }        array[high] = array[low];    }    //将枢轴数值替换回array[low]    array[low] = pivotkeyback;    //返回当前枢轴下标    return low;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#各种排序时空复杂度<br><img src="img/01002-0001.png" alt="排序复杂图"><br>n: 数据规模<br>k: “桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;列举一些常用的排序算法&lt;/p&gt;
&lt;p&gt;#冒泡排序&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c#&quot; data-language=&quot;c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 冒</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>游戏MVC系列框架</title>
    <link href="https://wwy.wwywy.com/posts/2051.html"/>
    <id>https://wwy.wwywy.com/posts/2051.html</id>
    <published>2020-12-15T13:00:00.000Z</published>
    <updated>2022-03-03T08:04:38.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑;</p><p>流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据;</p><p>总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架；</p><p>不使用MVC的逻辑：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevPanel : MonoBehaviour{      public Button btnLevUp;      public Button btnClose;            //展示UI面板      public static void ShowMe()    {    //todo    }        //隐藏UI面板    public static void HideMe()    {    //todo    }        void Start()    {        //2.监听事件        btnClose.onClick.AddListener(ClickClose);        btnLevUp.onClick.AddListener(ClickLevUp);    }        public void ClickClose()    {        Debug.Log("关闭");        HideMe();    }        public void ClickLevUp()    {        Debug.Log("升级");        //存储数据        //同步更新面板上的数据        UpdateInfo();        //更新主面板的内容        MainPanel.Panel.UpdateInfo();    }            //3.更新面板    public void UpdateInfo()    {    //更新数据    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发；</p><p>使用MVC：<br>Model层：负责增删查改获取界面上需要的数据</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevModel{    //定义数据    private int lev;    //外界只能获取字段    public int Lev    {        get        {            return lev;        }    }        //通知外部更新的事件    //通过它和外部建立联系 而不是直接获取外部的面板    private event UnityAction&lt;PlayerLevModel&gt; updateEvent;        //在外部第一次获取这个数据 如何获取    //通过单例模式 来达到数据的唯一性 和数据的获取    private static PlayerLevModel data = null;    public static PlayerLevModel Data    {        get        {            if( data == null )            {                data = new PlayerLevModel();                data.Init();            }            return data;        }    }        //数据相关的操作    // 初始化    public void Init()    {        lev = PlayerPrefs.GetInt("PlayerLev", 1);    }}    public void LevUp()    {        //升级 改变内容        lev += 1;        //改变过后保存        SaveData();    }            public void SaveData()    {        //把这些数据内容 存储到本地        PlayerPrefs.SetInt("PlayerLev", lev);        UpdateInfo();    }            public void AddEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent += function;    }    public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent -= function;    }    //通知外部更新外部数据的方法    private void UpdateInfo()    {        //找到对应的 使用数据的脚本 去更新数据        updateEvent?Invoke(this);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视图层：负责获取控件，更新控件信息</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevView : MonoBehaviour{      //1.找控件    public Button btnClose;    public Button btnLevUp;    //2.提供面板更新的相关方法给外部    public void UpdateInfo(PlayerModel data)    {        txtLev.text = "LV." + data.Lev;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevController : MonoBehaviour{    //视图实例，这里视图和控制在一个物体上    private PlayerLevView roleView;    private static PlayerLevController controller = null;    //控制层单例    public static PlayerLevController Controller    {        get        {            return controller;        }    }            public static void ShowMe()    {        if (controller == null)        {            //实例化面板对象            //设置它的父对象 为Canvas        }        //如果是隐藏的形式hide 在这要显示        controller.gameObject.SetActive(true);    }    public static void HideMe()    {        if (controller != null)        {            //方式一 直接删            //方式二 设置可见为隐藏        }    }            void Start()    {    //这里视图和控制在一个物体上        roleView = this.GetComponent&lt;RoleView&gt;();        //第一次更新面板        roleView.UpdateInfo(PlayerLevModel.Data);        roleView.btnClose.onClick.AddListener(ClickCloseBtn);        roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn);        //告知数据模块 当更新时 通知哪个函数做处理        PlayerModel.Data.AddEventListener(UpdateInfo);    }            private void ClickCloseBtn()    {        HideMe();    }    private void ClickLevUpBtn()    {        //通过数据模块 进行升级 达到数据改变        PlayerLevModel.Data.LevUp();    }    private void UpdateInfo( PlayerModel data )    {        if( roleView != null )        {            roleView.UpdateInfo(data);        }    }    private void OnDestroy()    {              PlayerLevModel.Data.RemoveEventListener(UpdateInfo);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好处：<br>1.各司其职，互不干涉 —— 编程思路更清晰<br>2.有利开发中的分工 —— 多人协同开发时，同步并行<br>3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率<br>缺点：<br>1.增加了程序文件的体量 —— 脚本由一变三<br>2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好<br>2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大）</p><h1 id="MV-的概念"><a href="#MV-的概念" class="headerlink" title="MV*的概念"></a>MV*的概念</h1><p>MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变；<br>  所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。</p><p><img src="https://s4.ax1x.com/2022/02/05/Hm6yN9.png" alt="相关的变种"></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>  切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部.</p><p>Model层:不变</p><p>View层:不能直接传入Model模型来更新</p><p>Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入；</p><h1 id="MVVM（MP）"><a href="#MVVM（MP）" class="headerlink" title="MVVM（MP）"></a>MVVM（MP）</h1><p>  MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细；</p><p>了解的话可以看看这些第三方MVVM框架：<br>loxodon-Framework:<a href="https://github.com/vovgou/loxodon-framework">vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)</a><br>uMVVM:<a href="https://github.com/MEyes/uMVVM">MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com)</a></p><p>所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心；</p><h1 id="MVE"><a href="#MVE" class="headerlink" title="MVE"></a>MVE</h1><p>  E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可；</p><h1 id="商业框架PureMVC"><a href="#商业框架PureMVC" class="headerlink" title="商业框架PureMVC"></a>商业框架PureMVC</h1><p>官网：<a href="http://puremvc.org/">PureMVC 框架</a><br>PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；<br>Model（数据模型）：关联Proxy(代理)对象，负责处理数据；<br>View（界面）：关联Mediator(中介)对象，负责处理界面；<br>Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；<br>Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；<br>Notification：通知，负责传递信息；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h1&gt;&lt;p&gt;基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
    <category term="MVC" scheme="https://wwy.wwywy.com/tags/MVC/"/>
    
  </entry>
  
</feed>
