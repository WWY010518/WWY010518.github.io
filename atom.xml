<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪夜</title>
  
  <subtitle>雪夜の博客</subtitle>
  <link href="http://wwy010518.github.io/atom.xml" rel="self"/>
  
  <link href="http://wwy010518.github.io/"/>
  <updated>2022-03-03T07:26:58.970Z</updated>
  <id>http://wwy010518.github.io/</id>
  
  <author>
    <name>雪夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人工智能导论</title>
    <link href="http://wwy010518.github.io/posts/515.html"/>
    <id>http://wwy010518.github.io/posts/515.html</id>
    <published>2022-03-02T13:00:00.000Z</published>
    <updated>2022-03-03T07:26:58.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="人工智能基本概念"><a href="#人工智能基本概念" class="headerlink" title="人工智能基本概念"></a>人工智能基本概念</h2><p>1.自然界四大奥秘：物质的本质、宇宙的起源、生命的本质、智能的发生；</p><p>2.智能的定义：智能是只是和智力的总和；</p><p>3.智能的特征：</p><ul><li>感知能力（游戏AI必须品）：主动信息的输入，实现视觉、听觉、触觉、嗅觉等感觉器官；</li><li>记忆力和思维能力：信息的存储和信息的模拟，记忆存储由感知器官感知到的外部信息以及由思维所产生的知识，思维能力对记忆的信息进行处理；<ul><li>逻辑思维（抽象思维）：例如理科生通过逻辑去肢解一道数学题；</li><li>形象思维（直感思维）：例如人的第五感；</li><li>顿悟思维（灵感思维）：例如牛顿如何发现了力学；</li></ul></li><li>学习能力：被动信息的输入，学习既可能是自觉的、有意识的，也可能是不自觉的、无意识的；既可以是有教师指导的，也可以是通过自己实践的；</li><li>行为能力（表达能力）：信息的输入，人工智能实现的目的；</li></ul><h2 id="人工智能发展简史"><a href="#人工智能发展简史" class="headerlink" title="人工智能发展简史"></a>人工智能发展简史</h2><p>人工智能发展史：了解就好了，知乎看看就好；<br><a href="https://zhuanlan.zhihu.com/p/43599960">人工智能发展史 - 知乎 (zhihu.com)</a></p><h2 id="人工智能研究的基本内容"><a href="#人工智能研究的基本内容" class="headerlink" title="人工智能研究的基本内容"></a>人工智能研究的基本内容</h2><p>1.知识表达：将人类知识形式化或者模型化，方法有符号表示法、连接机制表示法，简单点说就是建立一个能把人懂的东西弄成机器能懂的东西的东西；</p><p>2.机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主；</p><p>3.机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理；</p><p>4.机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识；</p><p>5.机器行为：计算机的表达能力，即“说”、“写”、“画”等能力；</p><h2 id="人工智能的主要研究领域"><a href="#人工智能的主要研究领域" class="headerlink" title="人工智能的主要研究领域"></a>人工智能的主要研究领域</h2><p>主要领域：自动定理证明、博弈、模式识别、机器视觉 、自然语言理解、机器翻译、智能信息检索 、数据挖掘与知识发现、专家系统、自动程序设计、机器人、组合优化问题、人工神经网络；</p><p>其他领域：分布式人工智能与多智能体、智能控制、智能仿真、智能CAD 、智能CAI  、智能管理与智能决策 、智能多媒体系统 、智能操作系统、智能计算机系统 、智能通信 、智能网络系统、人工生命 ；</p><h1 id="知识表示与知识图谱"><a href="#知识表示与知识图谱" class="headerlink" title="知识表示与知识图谱"></a>知识表示与知识图谱</h1><h2 id="知识和知识表示"><a href="#知识和知识表示" class="headerlink" title="知识和知识表示"></a>知识和知识表示</h2><h3 id="知识的概念"><a href="#知识的概念" class="headerlink" title="知识的概念"></a>知识的概念</h3><p>1.知识的定义：把有关信息关联在一起所形成的信息结构；</p><p>2.知识的作用：反映了客观世界中事物之间的关系；</p><p>3.知识的特性：</p><ul><li>相对正确性：知识在一定的条件及环境下产生的才是正确的；</li><li>不确定性：<ul><li>随机性引起的不确定性 ：清明一般都会下雨，但是也有不下雨的时候；</li><li>模糊性引起的不确定性 ：根据人的外貌去判断年龄；</li><li>经验引起的不确定性：经历丰富的人相对知识也更加丰富；</li><li>不完全性引起的不确定性：比如对人类对宇宙的了解并不完整；</li></ul></li><li>可表示性和可利用性：知识可以用适当形式表示和利用；</li></ul><h3 id="知识表示的概念"><a href="#知识表示的概念" class="headerlink" title="知识表示的概念"></a>知识表示的概念</h3><p>1.知识表示的定义：将人类的知识形式化或者模型化（人类划重点）；</p><p>2.知识表示的作用：计算机可以接受的描述知识的数据结构</p><p>3.知识选择方法的原则：有利于知识的充分表示和分利用、便于组织、维护、管理、理解和实现；</p><h2 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h2><h2 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h2><h2 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h2><h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;人工智能基本概念&quot;&gt;&lt;a href=&quot;#人工智能基本概念&quot; class=&quot;headerlink&quot; title=&quot;人工智能基本概念&quot;</summary>
      
    
    
    
    <category term="CS基础" scheme="http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="人工智能" scheme="http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="http://wwy010518.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>帧同步确定性物理库</title>
    <link href="http://wwy010518.github.io/posts/2053.html"/>
    <id>http://wwy010518.github.io/posts/2053.html</id>
    <published>2022-03-01T13:00:00.000Z</published>
    <updated>2022-03-01T07:15:05.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Game-Play" scheme="http://wwy010518.github.io/categories/Game-Play/"/>
    
    <category term="第三方库" scheme="http://wwy010518.github.io/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="帧同步" scheme="http://wwy010518.github.io/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
    <category term="第三方库" scheme="http://wwy010518.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="确定性物理库" scheme="http://wwy010518.github.io/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>定点数数学库</title>
    <link href="http://wwy010518.github.io/posts/2054.html"/>
    <id>http://wwy010518.github.io/posts/2054.html</id>
    <published>2022-03-01T13:00:00.000Z</published>
    <updated>2022-03-01T10:20:07.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定点数FInt"><a href="#定点数FInt" class="headerlink" title="定点数FInt"></a>定点数FInt</h1><p>基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化，使用位运算来直接操作二进制进行放大缩小，这里可以放大1024倍，也就是1&lt;&lt;10，使用完之后在缩小1024倍还原即可;<br>乘法还原正负不同问题：按照上面的流程，乘法运算后绝对值相同的正负数值经过还原后会出现不对等的问题，比如500乘FInt(0.3f)的RawInt值是是14，但是500乘FInt(-0.3f)的RawInt值却是-15，这是因为二进制中，正数由原码表示，负数由补码表示，补码是在原码的反码上再加一得来的，要简单的解决这一个问题可以对值进行取反运算再取反，让已经实现好的底层去解决；</p><h1 id="定点向量FVector3"><a href="#定点向量FVector3" class="headerlink" title="定点向量FVector3"></a>定点向量FVector3</h1><h1 id="常用运算FCalc"><a href="#常用运算FCalc" class="headerlink" title="常用运算FCalc"></a>常用运算FCalc</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定点数FInt&quot;&gt;&lt;a href=&quot;#定点数FInt&quot; class=&quot;headerlink&quot; title=&quot;定点数FInt&quot;&gt;&lt;/a&gt;定点数FInt&lt;/h1&gt;&lt;p&gt;基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化</summary>
      
    
    
    
    <category term="Game-Play" scheme="http://wwy010518.github.io/categories/Game-Play/"/>
    
    <category term="第三方库" scheme="http://wwy010518.github.io/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="帧同步" scheme="http://wwy010518.github.io/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
    <category term="第三方库" scheme="http://wwy010518.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="定点数数学库" scheme="http://wwy010518.github.io/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ET6.0框架Demo源码解析</title>
    <link href="http://wwy010518.github.io/posts/2052.html"/>
    <id>http://wwy010518.github.io/posts/2052.html</id>
    <published>2022-02-28T13:00:00.000Z</published>
    <updated>2022-03-01T00:55:47.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Game-Play" scheme="http://wwy010518.github.io/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="ET" scheme="http://wwy010518.github.io/tags/ET/"/>
    
    <category term="游戏框架" scheme="http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Unity角色换装</title>
    <link href="http://wwy010518.github.io/posts/1552.html"/>
    <id>http://wwy010518.github.io/posts/1552.html</id>
    <published>2022-02-18T13:00:00.000Z</published>
    <updated>2022-02-18T12:41:00.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待写&quot;&gt;&lt;a href=&quot;#待写&quot; class=&quot;headerlink&quot; title=&quot;待写&quot;&gt;&lt;/a&gt;待写&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="其他" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="换装" scheme="http://wwy010518.github.io/tags/%E6%8D%A2%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件 - Animancer插件使用</title>
    <link href="http://wwy010518.github.io/posts/1549.html"/>
    <id>http://wwy010518.github.io/posts/1549.html</id>
    <published>2022-01-29T13:00:00.000Z</published>
    <updated>2022-03-03T05:25:08.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Animancer介绍"><a href="#Animancer介绍" class="headerlink" title="Animancer介绍"></a>Animancer介绍</h1><h1 id="Animancer初步使用"><a href="#Animancer初步使用" class="headerlink" title="Animancer初步使用"></a>Animancer初步使用</h1><p>使用方法：添加Animator组件和AnimancerComponent相关组件，再编写脚本控制动画；</p><p>脚本案例：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public sealed class PlayAnimation : MonoBehaviour{    [SerializeField] private AnimancerComponent _Animancer;    [SerializeField] private AnimationClip _Clip;    private void OnEnable()    {        _Animancer.Play(_Clip);        var state = _Animancer.Play(_Clip);        state.Speed = ...                        state.Time = ...                     state.NormalizedTime = ...              state.Events.OnEnd = ...                   _Animancer.Play(_Clip).Time = 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer核心组件"><a href="#Animancer核心组件" class="headerlink" title="Animancer核心组件"></a>Animancer核心组件</h1><h2 id="AnimancerComponent"><a href="#AnimancerComponent" class="headerlink" title="AnimancerComponent"></a>AnimancerComponent</h2><p>说明：普通的动画师组件</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取Animator Controller组件animancer.Animator//2.获取Playableanimancer.Playable//3.获取该组件上的动画状态字典animancer.States//4.获取该组件上的动画层级animancer.Layers成员方法：//1.播放动画animancer.Play(AnimationClip, float, FadeMode)//2.使用键值播放动画。如果该键没有注册，返回nullanimancer.TryPlay(Object, float, FadeMode)//3.停止当前动画或者目标动画animancer.Stop(参数)//4.判断是否播放当前动画或者目标动画animancer.IsPlaying()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="NamedAnimancerComponent"><a href="#NamedAnimancerComponent" class="headerlink" title="NamedAnimancerComponent"></a>NamedAnimancerComponent</h2><p>说明：继承自AnimancerComponent并添加一个数组，并按名称注册动画，可以使用名字播放动画，这与 Unity 的旧版组件非常相似；</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">增加的成员变量：//1.获取动画源列表animancer.Animations//1.获取默认动画源animancer.DefaultAnimation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HybridAnimancerComponent"><a href="#HybridAnimancerComponent" class="headerlink" title="HybridAnimancerComponent"></a>HybridAnimancerComponent</h2><p>说明：继承自NamedAnimancerComponent，并且添加了控制器，可以融合Animator Controller组件和Animancer；</p><h1 id="Animancer动画状态"><a href="#Animancer动画状态" class="headerlink" title="Animancer动画状态"></a>Animancer动画状态</h1><p>动画状态说明：播放动画时，Animancer会创建一个状态来管理它并跟踪它的进度，如果以后再次播放相同的动画，它将重用相同的状态；</p><p>AnimancerState类API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取动画源文件state.Clip//2.动画事件集合state.Events//3.动画的长度state.Length//4.动画的速度state.Speed//5.状态的开始时间，该变量改变，动画事件也会变state.NormalizedTime//6.状态的结束时间，该变量改变，动画事件也会变state.NormalizedEndTime//7.状态的事件集合state.Events成员方法：//1.销毁动画state.Destroy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要访问和创建状态的方法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.此属性存储该方法最近返回的状态var state = animancer.States.Current;//2.此属性存储最近由 Layer 的方法返回的状态var state = animancer.Layers[x].CurrentState;//3.索引器获取var state = animancer.States[clip];//4.方法获取animancer.States.TryGet(clip, out var state);//5.如果已存在的状态，则此方法将返回该状态。否则它将创建并返回一个新的var state = animancer.States.GetOrCreate(clip);//6.创建新状态，即使该动画已存在一个状态。请注意，每个状态必须具有不同的密钥，否则将引发，注意key时object类型，所以会有装拆箱问题var state = animancer.States.Create(key, clip);//7.创建新状态，而不为其提供键。var state = new ClipState(clip);//8.如果存在的状态，则此方法将销毁该状态并返回，否则，它将返回falseanimancer.States.Destroy(clip);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer动画过渡"><a href="#Animancer动画过渡" class="headerlink" title="Animancer动画过渡"></a>Animancer动画过渡</h1><p>过渡说明：Animancer中除了使用Clip动画源文件来进行使用，也可以使用ClipTransition播放动画，并且这样效果更好；</p><p>过渡类类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//基本过渡：1.ClipTransition：实现ITransition接口，最基本的过渡类型，FadeDuration可以控制动画淡入淡出过渡的时长，Speed控制速度，StartTime和EndTime控制起始时间，同时动画支持添加帧事件；2.ClipTransitionSequence：继承自ClipTransition并简单地添加一个数组，这些数组将在第一个之后按顺序播放（使用他们的每个结束事件来播放下一个）；3.PlayableAssetTransition//混合过渡：1.ManualMixerTransition：简单的混合动画；2.LinearMixerTransition：1D混合动画，用一个参数控制，参数信息和Animator里的混合一致；3.MixerTransition2D：2D混合模式，用俩个参数控制，参数信息和Animator里的混合一致；//控制器过渡：1.ControllerTransition：使用控制器文件；//过渡资源1.过渡类+Asset：过渡资源在资源面板下可以创建该过渡资源文件，和上面不同的时，过渡文件整个项目全局共享，而不是每个对象都有自己单独的过渡。它们都遵循相同的命名约定；2.过渡类+Asset.UnShared:不共享分过渡资源，一般用不着；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer混合"><a href="#Animancer混合" class="headerlink" title="Animancer混合"></a>Animancer混合</h1><h2 id="动画淡入淡出"><a href="#动画淡入淡出" class="headerlink" title="动画淡入淡出"></a>动画淡入淡出</h2><p>淡入淡出说明：淡入淡出通常不用于动画，因为它们不能混合，但是对于骨架动画非常有用，因为它允许角色模型从一个动画的结束姿势平滑地过渡到另一个动画的起始姿势，而不需要两个姿势完全相同。这也意味着，如果动画在任何时候被中断，过渡仍然可以是平滑的；</p><p>常用淡入淡出类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.参数值按百分比计算下标0:FadeMode.FixedSpeed//2.参数根据事件计算下标1:FadeMode.FixedDuration//3.好像是不会创建的新的状态下标2:FadeMode.FromStart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画的层"><a href="#动画的层" class="headerlink" title="动画的层"></a>动画的层</h2><p>层说明：基本和Animator使用方法一致；</p><p>AnimancerLayer类API说明</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">重要成员变量：//1.层级下标layer.Index//2.层级叠加模式还是覆盖模式layer.IsAdditive//3.层权重layer.Weight重要成员方法：//1.设置骨骼蒙版layer.SetMask(AvatarMask)//2.设置层权重layer.SetWeight(float)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>混合树说明：基本和Animator使用方法一致；</p><p>混合树使用：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//混合类类型说明1.ManualMixerState：没有参数2.LinearMixerState：float参数，线性插值算法3.CartesianMixerState：Vector参数，梯度波段O(n2)插值算法4.DirectionalMixerState：Vector参数，极地梯度波段O(n2)插值算法//案例public sealed class LinearMixerExample : MonoBehaviour{    private AnimancerComponent _Animancer;    private AnimationClip _back;    private AnimationClip _forward;    private AnimationClip _left;    private AnimationClip _right;    private float _MovementSpeed;    public CartesianMixerState mixState;    private void Awake()    {        mixState = new CartesianMixerState();        //初始化混合动画        mixState.Initialize(_back, _forward，_left，_right);        //设置动画参数        mixState.SetThreshold(0, new Vector2(0, 0));        mixState.SetThreshold(1,new Vector2(0,-1));        mixState.SetThreshold(2, new Vector2(0, 1));        mixState.SetThreshold(3, new Vector2(-1, 0));        mixState.SetThreshold(4, new Vector2(1, 0));        //设置混合动画的同步，同步适用于移动，但对于空闲动画，通常应禁用同步        MixerState.AutoSynchronizeChildren = false;        mixer.DontSynchronizeChildren();        mixer.DontSynchronize(mixer.GetChild(0));        mixer.Synchronize(mixer.GetChild(1));        //播放        _Animancer.Play(mixState);    }    private void Update()    {            var input = new Vector2(    Input.GetAxisRaw("Horizontal"),    Input.GetAxisRaw("Vertical"));            mixState.Parameter = Vector2.MoveTowards(                mixState.Parameter,                input,                _MovementSpeed * Time.deltaTime);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer事件"><a href="#Animancer事件" class="headerlink" title="Animancer事件"></a>Animancer事件</h1><p>事件说明：基本和Animator使用方法一致，但是性能更好，且使用Clip文件使用时，每次都会创建垃圾，除非您缓存事件回调，而ClipTransition访问它将直接引用ClipTransition拥有的，因此当您再次播放时，您所做的任何修改都将保留。这意味着修改通常只应在启动时执行一次，而不是每次播放时都重复进行；</p><p>用法说明：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.添加事件state.Events.Add(0.4f, 事件);//2.结束事件，结束一定会调用  state.Events.OnEnd = 事件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer搭配推荐"><a href="#Animancer搭配推荐" class="headerlink" title="Animancer搭配推荐"></a>Animancer搭配推荐</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Animancer介绍&quot;&gt;&lt;a href=&quot;#Animancer介绍&quot; class=&quot;headerlink&quot; title=&quot;Animancer介绍&quot;&gt;&lt;/a&gt;Animancer介绍&lt;/h1&gt;&lt;h1 id=&quot;Animancer初步使用&quot;&gt;&lt;a href=&quot;#Anim</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="插件" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="Animancer" scheme="http://wwy010518.github.io/tags/Animancer/"/>
    
    <category term="Playable" scheme="http://wwy010518.github.io/tags/Playable/"/>
    
  </entry>
  
  <entry>
    <title>ET6.0框架笔记</title>
    <link href="http://wwy010518.github.io/posts/2049.html"/>
    <id>http://wwy010518.github.io/posts/2049.html</id>
    <published>2022-01-24T13:00:00.000Z</published>
    <updated>2022-02-26T15:01:07.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ET6-0框架介绍"><a href="#ET6-0框架介绍" class="headerlink" title="ET6.0框架介绍"></a>ET6.0框架介绍</h1><h1 id="项目的初步运行"><a href="#项目的初步运行" class="headerlink" title="项目的初步运行"></a>项目的初步运行</h1><p>1.运行Unity客户端项目，并且打开编程软件进行初步编译；<br>2.打开服务端项目，第一次打开编译Client下的Mono文件夹；<br>3.重新编译整个解决方案；<br>4.客户端F5生成代码；</p><h1 id="ET前后端通讯机制"><a href="#ET前后端通讯机制" class="headerlink" title="ET前后端通讯机制"></a>ET前后端通讯机制</h1><p>登录实例：<br>1.通过NetKcpComponent组件创建Session会话连接；<br>2.Session（由ET框架管理）会话的Id和TChannel进行绑定；<br>3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；<br>4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器；</p><h1 id="ET的多线程和分布式"><a href="#ET的多线程和分布式" class="headerlink" title="ET的多线程和分布式"></a>ET的多线程和分布式</h1><p>第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；<br>第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；<br>第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；<br>第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；<br>ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构</p><p>登录实例（接上）：<br>1.网关负载均衡服务器随机分配网关配置；<br>2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；<br>3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；<br>4.游戏客户端和游戏网关建立正式连接；<br>5.登录进Map服务器<br>注意：C就是客户端，R是网关负载均衡服务器，G是网关；<br><img src="https://s4.ax1x.com/2022/02/21/HveY4J.png" alt="ET分布式说明"></p><h1 id="ET的ECS组件编程"><a href="#ET的ECS组件编程" class="headerlink" title="ET的ECS组件编程"></a>ET的ECS组件编程</h1><p>ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）；</p><p>遵守的编程原则：<br>1.实体即组件、组件即实体；<br>2.编写一个实体或者组件，绝不继承除Entity外的任何父类；<br>3.不使用任何虚函数，使用逻辑分发替代；<br>4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；<br>5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；<br>6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；<br>7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误；</p><p>其他原则：<br>1.系统命名必须是实体名+System；<br>2.系统必须是静态类；<br>3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；<br>4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.实体或者组件    public class Computer: Entity,IAwake,IUpdate,IDestroy    public class MouseComponent : Entity, IAwake    //2.系统    public static class ComputerSystem    {       //需要使用拓展方法        public static void Start(this Computer self)        {            Log.Debug("计算机启动");//这里可以调用身上的组件            self.GetComponent&lt;PCCaseComponent&gt;().StartPower();            self.GetComponent&lt;MonitorsComponent&gt;().DisPlay();        }    }//3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上    Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;();computer.AddComponent&lt;PCCaseComponent&gt;();computer.AddComponent&lt;MonitorsComponent&gt;();computer.AddComponent&lt;KeyBoardComponent&gt;();computer.AddComponent&lt;MouseComponent&gt;();computer.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中ECS编程的生命周期"><a href="#ET中ECS编程的生命周期" class="headerlink" title="ET中ECS编程的生命周期"></a>ET中ECS编程的生命周期</h1><p>  ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.生命周期函数类    public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt;    public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt;    public class ComputerDestroySystem : DestroySystem&lt;Computer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET的逻辑分发"><a href="#ET的逻辑分发" class="headerlink" title="ET的逻辑分发"></a>ET的逻辑分发</h1><p>OOP面向对象的缺点：继承层次过深时，牵一发而动全身；</p><p>ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承；</p><h1 id="ET的Scene层级树"><a href="#ET的Scene层级树" class="headerlink" title="ET的Scene层级树"></a>ET的Scene层级树</h1><p>Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id；</p><p>客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）:<br><img src="https://s4.ax1x.com/2022/02/20/HO46xg.png" alt="ET框架客户端Scene的层级关系"></p><p>服务端Scene的层级关系:<br><img src="https://s4.ax1x.com/2022/02/20/HOIEX4.png" alt="ET框架服务端Scene的层级关系"></p><p>服务端机器人Scene的层级关系<br><img src="https://s4.ax1x.com/2022/02/20/HOT9zT.png" alt="ET框架服务端机器人Scene的层级关系"></p><h1 id="ET的Excel配置工具"><a href="#ET的Excel配置工具" class="headerlink" title="ET的Excel配置工具"></a>ET的Excel配置工具</h1><p>Excel配置工具注意事项：<br>1.配置文件从第三行第三列开始写，跟VBA宏有关；<br>2.第一个类型字段名必须是Id；<br>3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；<br>4.加#是注释，仅给策划使用，不会添加到游戏数据中；<br>5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\Assets\Bundles\Config下；可以查看文本形式在Bin\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；<br>6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；<br>7.行是可以空行的，可以用来分类注释，目测加#；<br>8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；<br>9.配置工具支持的导表类型可以在Tools\Apps\EXcelExporter文件下的Convert静态类中定义或查看；<br>10.数组类型默认在配置文件中加英文,配置;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型//获取单个UnitConfig config = UnitConfigCategory.Instance.Get(1001)//获取所有var configs = UnitConfigCategory.Instance.GetAll()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的事件系统"><a href="#ET中的事件系统" class="headerlink" title="ET中的事件系统"></a>ET中的事件系统</h1><p>1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；<br>2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；<br>3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.定义事件，添加事件,必须EventType命名空间下进行定义        public struct InstallComputer        {            //定义参数            public Computer computer;        }        //2.调用事件，触发事件//同步PublishGame.EventSystem.Publish(new EventType.InstallComputer() { computer = computer });//同步PublishAnycsawait Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer });//异步PublishAnycsGame.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine();//3.编写事件触发逻辑    public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt;    {        //必须添加async        protected async override ETTask Run(InstallComputer arg)        {            Computer computer = arg.computer;            computer.AddComponent&lt;PCCaseComponent&gt;();            computer.AddComponent&lt;MonitorsComponent&gt;();            computer.AddComponent&lt;KeyBoardComponent&gt;();            computer.AddComponent&lt;MouseComponent&gt;();            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的ETTask异步编程"><a href="#ET中的ETTask异步编程" class="headerlink" title="ET中的ETTask异步编程"></a>ET中的ETTask异步编程</h1><p>同步操作：先完成其全部工作在返回调用者；<br>异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；<br>ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.ETTask函数编写//无返回值,参数类型用来控制取消异步函数public async ETTask TestAsync(ETCancellationToken cancellationToken)        {//表明该函数可能是同步函数await ETTask.CompletedTask;//第二参数同上bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken);//根据返回值控制if (rt) Log.Debug("函数取消了");else Log.Debug("继续执行下面逻辑");}//有返回值        public async ETTask&lt;int&gt; TestResultAsync()        {            await TimerComponent.Instance.WaitAsync(1000);return 10;        }        2.ETTask函数的调用//定义取消异步函数实例ETCancellationToken cancellationToken=new ETCancellationToken();//等待无返回值函数调用完成await TestAsync(cancellationToken);//不等待无返回值函数完成，执行下面逻辑TestAsync(cancellationToken).Coroutine();//等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题int value = await TestResultAsync();//取消函数cancellationToken.Cancel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Protobuf通讯消息"><a href="#ET中的Protobuf通讯消息" class="headerlink" title="ET中的Protobuf通讯消息"></a>ET中的Protobuf通讯消息</h1><p>Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。<br>Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；<br>Protobuf的Github开源地址 :<a href="https://github.com/protocolbuffers/protobuf">GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式</a></p><p>ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\Apps\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版;</p><p>.proto描叙文件编写的的注意事项：<br>1.Proto数据结构描叙文件存放在Proto文件夹下；<br>2.OuterMessage是定义客户端和服务端通信的消息；<br>3.InnerMessage是服务端内部通信的消息；<br>4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；<br>5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；<br>6.消息定义体中的Id不能重复；<br>7.生成的转换类型列表可以在Tools\Apps\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\Generate\Message下；<br>8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；<br>9.字符之间必须要留空格；<br>10.proto文件中的注释意义重大；</p><p>网络Handler消息编写注意事项<br>1.类名定义务必以消息类名+Handler作为声明<br>2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；<br>3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用<br>4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与；</p><h1 id="ET普通网络消息编写"><a href="#ET普通网络消息编写" class="headerlink" title="ET普通网络消息编写"></a>ET普通网络消息编写</h1><p>普通消息.proto文件编写：</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">// ResponseType R2C_LoginTest（普通请求消息一定要注释返回类）message C2R_LoginTest  // IRequest（普通请求消息必须注释）{    int32 RpcId = 90;（普通请求消息必须声明该字段）string Account = 1;string Password = 2;}message R2C_LoginTest  // IResponse（普通响应消息必须注释）{    int32 RpcId = 90;（普通响应消息必须声明该字段）int32 Error = 91;string Message = 92;string GateAddress = 1;string Key = 2;}message C2R_SayHello // IMessage（一般消息必须注释）{string Hello = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通消息C#代码：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.客户端编写登录逻辑        public static async ETTask LoginTest(Scene zoneScene, string address)        {            try            {                Session session = null;                R2C_LoginTest r2C_LoginTest = null;                try                {                    session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address));                    {                        r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = "123", Password = "456" });                        Log.Debug(r2C_LoginTest.Key);                        session.Send(new C2R_SayHello() { Hello = "你好" });                    }                }                finally                {                    session?.Dispose();                }            }            catch(Exception e)            {                Log.Error(e.ToString());            }        }//2.普通请求消息逻辑    [MessageHandler]    public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt;    {        protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply)        {            response.Key = "110";            reply();            await ETTask.CompletedTask;        }    }    //3.一般消息（不用响应）    [MessageHandler]    public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt;    {        protected override async ETTask Run(Session session, C2R_SayHello message)        {            Log.Debug(message.Hello);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Actor通信模型"><a href="#ET中的Actor通信模型" class="headerlink" title="ET中的Actor通信模型"></a>ET中的Actor通信模型</h1><p>Actor模型：<img src="https://s4.ax1x.com/2022/02/21/Hvl1zQ.png" alt="Actor模型"></p><p>Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。</p><p>ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生<br>动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理；</p><p>ActorLocation消息Proto文件编写:</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">//ResponseType M2C_TestActorLocationResponsemessage C2M_TestActorLocationReqeust // IActorLocationRequest{int32 RpcId = 90;string Content = 1;}message M2C_TestActorLocationResponse // IActorLocationResponse{int32 RpcId = 90;int32 Error = 91;string Message = 92;string Content = 1;}message C2M_TestActorLocationMessage // IActorLocationMessage{int32 RpcId = 90;string Content = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ActorLocation消息C#代码编写:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.客户端场景切换逻辑            try            {                Session session = zoneScene.GetComponent&lt;Session&gt;();                var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = "111" });                Log.Debug(message.Content);                session.Send(new C2M_TestActorLocationMessage() { Content = "22222" });            }            catch (Exception e)            {                Log.Error(e);            }            2.ActorLocation请求消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt;    {        protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply)        {            Log.Debug(request.Content);            response.Content = "333333";            reply();            await ETTask.CompletedTask;        }    }3.ActorLocation一般消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt;    {        protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message)        {            Log.Debug(message.Content);            //MessageHelper.SendToClient(entity, 发送给客户端的消息);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET教程登录实例"><a href="#ET教程登录实例" class="headerlink" title="ET教程登录实例"></a>ET教程登录实例</h1><p>实例步骤：<br>1.编写账号登录请求和响应俩条协议Proto；<br>2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；<br>3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;<br>4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）;</p><p>事后心得：<br>1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；<br>2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；<br>3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；<br>4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；<br>5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；<br>6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ET6-0框架介绍&quot;&gt;&lt;a href=&quot;#ET6-0框架介绍&quot; class=&quot;headerlink&quot; title=&quot;ET6.0框架介绍&quot;&gt;&lt;/a&gt;ET6.0框架介绍&lt;/h1&gt;&lt;h1 id=&quot;项目的初步运行&quot;&gt;&lt;a href=&quot;#项目的初步运行&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Game-Play" scheme="http://wwy010518.github.io/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="ET" scheme="http://wwy010518.github.io/tags/ET/"/>
    
    <category term="游戏框架" scheme="http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统原理笔记</title>
    <link href="http://wwy010518.github.io/posts/513.html"/>
    <id>http://wwy010518.github.io/posts/513.html</id>
    <published>2022-01-08T13:00:00.000Z</published>
    <updated>2022-01-24T15:05:15.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统绪论"><a href="#1-操作系统绪论" class="headerlink" title="1   操作系统绪论"></a>1   操作系统绪论</h1><h2 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1  操作系统概念"></a>1.1  操作系统概念</h2><p>定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。</p><p><strong>特征：</strong>并发、共享、虚拟、异步。</p><h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2  操作系统发展历程"></a>1.2  操作系统发展历程</h2><p>手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。</p><h3 id="1-2-1单道批处理"><a href="#1-2-1单道批处理" class="headerlink" title="1.2.1单道批处理"></a>1.2.1单道批处理</h3><p><strong>原理：</strong>计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。</p><p><strong>特征：</strong>内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。</p><h3 id="1-2-2多道批处理"><a href="#1-2-2多道批处理" class="headerlink" title="1.2.2多道批处理"></a>1.2.2多道批处理</h3><p>原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。</p><p>特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。</p><h3 id="1-2-3分时系统"><a href="#1-2-3分时系统" class="headerlink" title="1.2.3分时系统"></a>1.2.3分时系统</h3><p>特征：多路性、独立性、及时性、交互性。</p><h3 id="1-2-4实时系统"><a href="#1-2-4实时系统" class="headerlink" title="1.2.4实时系统"></a>1.2.4实时系统</h3><p><strong>特征：</strong>多路性、独立性、及时性、交互性、可靠性。</p><h1 id="2-操作系统用户界面"><a href="#2-操作系统用户界面" class="headerlink" title="2   操作系统用户界面"></a>2   操作系统用户界面</h1><h2 id="2-1-作业"><a href="#2-1-作业" class="headerlink" title="2.1  作业"></a>2.1  作业</h2><p><strong>定义：</strong>分用户和系统角度去理解</p><p>a)     用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业；</p><p>b)     系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL)</p><h2 id="2-2-一般用户输入输出方式"><a href="#2-2-一般用户输入输出方式" class="headerlink" title="2.2  一般用户输入输出方式"></a>2.2  一般用户输入输出方式</h2><h3 id="2-2-1联机输入输出方式"><a href="#2-2-1联机输入输出方式" class="headerlink" title="2.2.1联机输入输出方式"></a>2.2.1联机输入输出方式</h3><h3 id="2-2-2脱机输入输出方式"><a href="#2-2-2脱机输入输出方式" class="headerlink" title="2.2.2脱机输入输出方式"></a>2.2.2脱机输入输出方式</h3><h3 id="2-2-3直接耦合方式"><a href="#2-2-3直接耦合方式" class="headerlink" title="2.2.3直接耦合方式"></a>2.2.3直接耦合方式</h3><h3 id="2-2-4Spooling系统"><a href="#2-2-4Spooling系统" class="headerlink" title="2.2.4Spooling系统"></a>2.2.4Spooling系统</h3><p><strong>原理：</strong>todo。</p><p><strong>特点：</strong>系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。</p><h3 id="2-2-5网络联机方式"><a href="#2-2-5网络联机方式" class="headerlink" title="2.2.5网络联机方式"></a>2.2.5网络联机方式</h3><h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3  系统调用"></a>2.3  系统调用</h2><p><strong>定义：</strong>系统调用是操作系统留给编程人员的唯一接口。</p><p><strong>原理：</strong>todo</p><h3 id="2-3-1系统调用指令"><a href="#2-3-1系统调用指令" class="headerlink" title="2.3.1系统调用指令"></a>2.3.1系统调用指令</h3><p>int和trap指令进行系统调用。</p><p>call和jmp指令进入普通过程调用(子调用)。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3   进程管理"></a>3   进程管理</h1><h2 id="3-1-进程的概念"><a href="#3-1-进程的概念" class="headerlink" title="3.1  进程的概念"></a>3.1  进程的概念</h2><p><strong>组成：</strong>进程=程序+数据+进程控制块(进程状态信息PCB)</p><p><strong>定义：</strong>进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p><strong>目的：</strong>对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性；</p><p><strong>优缺点：</strong>引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。</p><h2 id="3-2-进程和程序的区别"><a href="#3-2-进程和程序的区别" class="headerlink" title="3.2  进程和程序的区别"></a>3.2  进程和程序的区别</h2><p>a)     进程是动态的，程序是静态的；</p><p>b)     进程是暂时的，程序是永久的；</p><p>c)     组成不同，进程的组成包括程序；</p><p>d)    对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序；</p><p>e)    进程可以并行，具有独立性、异步性。</p><p>f)    进程是竞争计算机资源的基本单位。</p><h2 id="3-3-进程控制块-PCB"><a href="#3-3-进程控制块-PCB" class="headerlink" title="3.3  进程控制块(PCB)"></a>3.3  进程控制块(PCB)</h2><p>进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。</p><h3 id="3-3-1描述信息"><a href="#3-3-1描述信息" class="headerlink" title="3.3.1描述信息"></a>3.3.1描述信息</h3><h3 id="3-3-2控制信息"><a href="#3-3-2控制信息" class="headerlink" title="3.3.2控制信息"></a>3.3.2控制信息</h3><h3 id="3-3-3资源管理信息"><a href="#3-3-3资源管理信息" class="headerlink" title="3.3.3资源管理信息"></a>3.3.3资源管理信息</h3><h3 id="3-3-4CPU保护现场结构"><a href="#3-3-4CPU保护现场结构" class="headerlink" title="3.3.4CPU保护现场结构"></a>3.3.4CPU保护现场结构</h3><h2 id="3-4-进程上下文切换"><a href="#3-4-进程上下文切换" class="headerlink" title="3.4  进程上下文切换"></a>3.4  进程上下文切换</h2><p><strong>原因：</strong>进程中断、超时、进程调用。</p><p><strong>步骤：</strong></p><p>a)    保存被切换进程的正文部分到有关存储区。</p><p>b)    进程有关调度和资源分配程序执行，选取新的进程。</p><p>c)    新进程正文部分从存储区取出，激活选中进程执行。</p><h2 id="3-5-进程的状态和进程转换"><a href="#3-5-进程的状态和进程转换" class="headerlink" title="3.5  进程的状态和进程转换"></a>3.5  进程的状态和进程转换</h2><h3 id="3-5-1进程状态"><a href="#3-5-1进程状态" class="headerlink" title="3.5.1进程状态"></a>3.5.1进程状态</h3><p>初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止))</p><h3 id="3-5-2进程状态转换"><a href="#3-5-2进程状态转换" class="headerlink" title="3.5.2进程状态转换"></a>3.5.2进程状态转换</h3><h2 id="3-6-进程控制"><a href="#3-6-进程控制" class="headerlink" title="3.6  进程控制"></a>3.6  进程控制</h2><h3 id="3-6-1进程创建和撤销"><a href="#3-6-1进程创建和撤销" class="headerlink" title="3.6.1进程创建和撤销"></a>3.6.1进程创建和撤销</h3><h3 id="3-6-2进程阻塞和唤醒"><a href="#3-6-2进程阻塞和唤醒" class="headerlink" title="3.6.2进程阻塞和唤醒"></a>3.6.2进程阻塞和唤醒</h3><h3 id="3-6-3进程的挂起和激活"><a href="#3-6-3进程的挂起和激活" class="headerlink" title="3.6.3进程的挂起和激活"></a>3.6.3进程的挂起和激活</h3><h2 id="3-7-进程互斥和同步"><a href="#3-7-进程互斥和同步" class="headerlink" title="3.7  进程互斥和同步"></a>3.7  进程互斥和同步</h2><h3 id="3-7-1临界区和临界资源"><a href="#3-7-1临界区和临界资源" class="headerlink" title="3.7.1临界区和临界资源"></a>3.7.1临界区和临界资源</h3><p>临界资源是一次仅允许一个进程使用的共享资源。</p><p>临界区是每个进程访问临界资源的那段代码。</p><h3 id="3-7-2信号量和PV原语"><a href="#3-7-2信号量和PV原语" class="headerlink" title="3.7.2信号量和PV原语"></a>3.7.2信号量和PV原语</h3><p>信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。</p><p>信号量的数值仅能由P、V原语操作改变。</p><h3 id="3-7-3互斥的概念"><a href="#3-7-3互斥的概念" class="headerlink" title="3.7.3互斥的概念"></a>3.7.3互斥的概念</h3><p><strong>定义：</strong>不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。</p><h3 id="3-7-4同步的概念"><a href="#3-7-4同步的概念" class="headerlink" title="3.7.4同步的概念"></a>3.7.4同步的概念</h3><p><strong>定义：</strong>对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。</p><h2 id="3-8-进程通信"><a href="#3-8-进程通信" class="headerlink" title="3.8  进程通信"></a>3.8  进程通信</h2><p>Todo</p><h2 id="3-9-死锁问题"><a href="#3-9-死锁问题" class="headerlink" title="3.9  死锁问题"></a>3.9  死锁问题</h2><h3 id="3-9-1死锁的概念"><a href="#3-9-1死锁的概念" class="headerlink" title="3.9.1死锁的概念"></a>3.9.1死锁的概念</h3><p><strong>定义：</strong> 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。</p><p><strong>起因：</strong>并发进程的资源竞争</p><p><strong>条件：</strong>同时具备互斥条件、不剥夺条件、部分分配、环路条件。</p><h3 id="3-9-2死锁的解决方案"><a href="#3-9-2死锁的解决方案" class="headerlink" title="3.9.2死锁的解决方案"></a>3.9.2死锁的解决方案</h3><h4 id="3-9-2-1-死锁预防"><a href="#3-9-2-1-死锁预防" class="headerlink" title="3.9.2.1    死锁预防"></a>3.9.2.1    死锁预防</h4><h4 id="3-9-2-2-死锁避免"><a href="#3-9-2-2-死锁避免" class="headerlink" title="3.9.2.2    死锁避免"></a>3.9.2.2    死锁避免</h4><p>最具代表性的避免算法-银行家算法</p><h4 id="3-9-2-3-死锁的检测和恢复"><a href="#3-9-2-3-死锁的检测和恢复" class="headerlink" title="3.9.2.3    死锁的检测和恢复"></a>3.9.2.3    死锁的检测和恢复</h4><h2 id="3-10-线程"><a href="#3-10-线程" class="headerlink" title="3.10    线程"></a>3.10    线程</h2><h3 id="3-10-1-线程的基本概念"><a href="#3-10-1-线程的基本概念" class="headerlink" title="3.10.1 线程的基本概念"></a>3.10.1 线程的基本概念</h3><p>定义：引入线程后，线程是操作系统调度和分配的基本单位。</p><p>组成：线程=？+线程控制块(TCB)</p><h3 id="3-10-2-线程状态和线程控制块-TCB"><a href="#3-10-2-线程状态和线程控制块-TCB" class="headerlink" title="3.10.2 线程状态和线程控制块(TCB)"></a>3.10.2 线程状态和线程控制块(TCB)</h3><p>线程状态：执行状态、就绪状态、阻塞(等待)状态</p><p>线程控制块数据结构包括：</p><p>a)     线程标识符</p><p>b)     一组寄存器</p><p>c)     线程执行状态</p><p>d)     优先级</p><p>e)     线程专有存储区</p><p>f)     信号屏蔽</p><p>g)    堆栈指针</p><h3 id="3-10-3-线程和进程的区别"><a href="#3-10-3-线程和进程的区别" class="headerlink" title="3.10.3 线程和进程的区别"></a>3.10.3 线程和进程的区别</h3><p>从以下六点讨论</p><p>a)     调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。</p><p>b)     并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。</p><p>c)     拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。</p><p>d)     独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。</p><p>e)     系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。</p><p>f)     支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。</p><h1 id="4-处理机调度"><a href="#4-处理机调度" class="headerlink" title="4   处理机调度"></a>4   处理机调度</h1><h2 id="4-1-调度层级"><a href="#4-1-调度层级" class="headerlink" title="4.1  调度层级"></a>4.1  调度层级</h2><p>一个作业提交后，往往会经历三种层级（加线程四种）</p><h3 id="4-1-1作业调度"><a href="#4-1-1作业调度" class="headerlink" title="4.1.1作业调度"></a>4.1.1作业调度</h3><p>又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。</p><h4 id="4-1-1-1-周转时间相关"><a href="#4-1-1-1-周转时间相关" class="headerlink" title="4.1.1.1    周转时间相关"></a>4.1.1.1    周转时间相关</h4><p>周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间</p><p>平均周转时间=所有作业周转时间之和/总作业数</p><p>带权周转时间=作业周转时间/作业执行时间</p><p>平均带权周转时间=所有带权作业周转时间之和/总作业数</p><h4 id="4-1-1-2-响应时间，截止时间和系统吞吐量"><a href="#4-1-1-2-响应时间，截止时间和系统吞吐量" class="headerlink" title="4.1.1.2     响应时间，截止时间和系统吞吐量"></a>4.1.1.2     响应时间，截止时间和系统吞吐量</h4><p>响应时间是提交请求和返回该请求的响应之间使用的时间<br>截止时间是某任务必须开始执行或者必须完成的最迟时间<br>吞吐量是对单位时间内完成的工作量的量度</p><h3 id="4-1-2交换调度"><a href="#4-1-2交换调度" class="headerlink" title="4.1.2交换调度"></a>4.1.2交换调度</h3><p>又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存</p><h3 id="4-1-3进程调度"><a href="#4-1-3进程调度" class="headerlink" title="4.1.3进程调度"></a>4.1.3进程调度</h3><p>又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式</p><h4 id="4-1-3-1-非抢占方式"><a href="#4-1-3-1-非抢占方式" class="headerlink" title="4.1.3.1    非抢占方式"></a>4.1.3.1    非抢占方式</h4><p>一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。</p><h4 id="4-1-3-2-抢占方式"><a href="#4-1-3-2-抢占方式" class="headerlink" title="4.1.3.2     抢占方式"></a>4.1.3.2     抢占方式</h4><p>系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程</p><p>a)     优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU</p><p>b)     短作业优先原则：就绪的短进程有权抢占长进程的CPU</p><p>c)     时间片原则：一个时间片用完后，系统重新进行进程调度</p><h3 id="4-1-4线程调度"><a href="#4-1-4线程调度" class="headerlink" title="4.1.4线程调度"></a>4.1.4线程调度</h3><p>Todo</p><h2 id="4-2-作业和进程的关系"><a href="#4-2-作业和进程的关系" class="headerlink" title="4.2  作业和进程的关系"></a>4.2  作业和进程的关系</h2><p>系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。</p><h2 id="4-3-调度算法"><a href="#4-3-调度算法" class="headerlink" title="4.3  调度算法"></a>4.3  调度算法</h2><p>宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。</p><p>​    微观调度：轮转法、优先级法、多级反馈轮转法。</p><h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5   存储管理"></a>5   存储管理</h1><h2 id="5-1-存储器结构"><a href="#5-1-存储器结构" class="headerlink" title="5.1  存储器结构"></a>5.1  存储器结构</h2><p>由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。</p><h3 id="5-1-1寄存器"><a href="#5-1-1寄存器" class="headerlink" title="5.1.1寄存器"></a>5.1.1寄存器</h3><p>寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。</p><h3 id="5-1-2高速缓存"><a href="#5-1-2高速缓存" class="headerlink" title="5.1.2高速缓存"></a>5.1.2高速缓存</h3><p>它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。</p><h3 id="5-1-3主存输器"><a href="#5-1-3主存输器" class="headerlink" title="5.1.3主存输器"></a>5.1.3主存输器</h3><p>简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。</p><h3 id="5-1-4磁盘缓存"><a href="#5-1-4磁盘缓存" class="headerlink" title="5.1.4磁盘缓存"></a>5.1.4磁盘缓存</h3><p>目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。</p><h2 id="5-2-程序的处理阶段"><a href="#5-2-程序的处理阶段" class="headerlink" title="5.2  程序的处理阶段"></a>5.2  程序的处理阶段</h2><p>主要有编译，链接，装入，下面主要讲链接和装入。</p><h3 id="5-2-1程序的链接"><a href="#5-2-1程序的链接" class="headerlink" title="5.2.1程序的链接"></a>5.2.1程序的链接</h3><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。<br>链接又可分为静态链接，装入时动态链接，运行时动态链接。</p><h3 id="5-2-2程序的装入"><a href="#5-2-2程序的装入" class="headerlink" title="5.2.2程序的装入"></a>5.2.2程序的装入</h3><p>分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。</p><h2 id="5-3-地址变换"><a href="#5-3-地址变换" class="headerlink" title="5.3  地址变换"></a>5.3  地址变换</h2><h3 id="5-3-1静态地址重定向"><a href="#5-3-1静态地址重定向" class="headerlink" title="5.3.1静态地址重定向"></a>5.3.1静态地址重定向</h3><p><strong>原理：</strong>Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。</p><h3 id="5-3-2动态地址重定位"><a href="#5-3-2动态地址重定位" class="headerlink" title="5.3.2动态地址重定位"></a>5.3.2动态地址重定位</h3><p><strong>关系：</strong>MA(物理地址)=BR(基址地址)+VR(虚拟地址)。</p><p>原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。</p><h2 id="5-4-分区存储管理"><a href="#5-4-分区存储管理" class="headerlink" title="5.4  分区存储管理"></a>5.4  分区存储管理</h2><p>分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。</p><h3 id="5-4-1固态分区法"><a href="#5-4-1固态分区法" class="headerlink" title="5.4.1固态分区法"></a>5.4.1固态分区法</h3><p>原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。</p><p>优点:易于实现，开销小。</p><p>缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。</p><h3 id="5-4-2动态分区法"><a href="#5-4-2动态分区法" class="headerlink" title="5.4.2动态分区法"></a>5.4.2动态分区法</h3><p><strong>原理：</strong>动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。</p><p><strong>优点：</strong>没有内碎片；</p><p><strong>缺点：</strong>有外碎片；</p><p><strong>算法：</strong>根据情况有以下俩种，着重介绍三种</p><p>a)     基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法</p><p>b)     基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法</p><h4 id="5-4-2-2-最先适应法"><a href="#5-4-2-2-最先适应法" class="headerlink" title="5.4.2.2     最先适应法"></a>5.4.2.2     最先适应法</h4><h4 id="5-4-2-3-最佳适应法"><a href="#5-4-2-3-最佳适应法" class="headerlink" title="5.4.2.3     最佳适应法"></a>5.4.2.3     最佳适应法</h4><h4 id="5-4-2-4-最坏适应法"><a href="#5-4-2-4-最坏适应法" class="headerlink" title="5.4.2.4     最坏适应法"></a>5.4.2.4     最坏适应法</h4><h3 id="5-4-3页式管理（离散分配）"><a href="#5-4-3页式管理（离散分配）" class="headerlink" title="5.4.3页式管理（离散分配）"></a>5.4.3页式管理（离散分配）</h3><p>基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。</p><h4 id="5-4-3-1-静态页式管理"><a href="#5-4-3-1-静态页式管理" class="headerlink" title="5.4.3.1    静态页式管理"></a>5.4.3.1    静态页式管理</h4><p>原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。</p><h4 id="5-4-3-2-动态页式管理"><a href="#5-4-3-2-动态页式管理" class="headerlink" title="5.4.3.2    动态页式管理"></a>5.4.3.2    动态页式管理</h4><h3 id="5-4-4段式和段页式管理"><a href="#5-4-4段式和段页式管理" class="headerlink" title="5.4.4段式和段页式管理"></a>5.4.4段式和段页式管理</h3><p>基本思想：todo</p><h4 id="5-4-4-1-段式管理"><a href="#5-4-4-1-段式管理" class="headerlink" title="5.4.4.1     段式管理"></a>5.4.4.1     段式管理</h4><p>原理：todo</p><h4 id="5-4-4-2-段页式管理"><a href="#5-4-4-2-段页式管理" class="headerlink" title="5.4.4.2     段页式管理"></a>5.4.4.2     段页式管理</h4><p>原理：todo</p><h3 id="5-4-5覆盖和交换技术"><a href="#5-4-5覆盖和交换技术" class="headerlink" title="5.4.5覆盖和交换技术"></a>5.4.5覆盖和交换技术</h3><h2 id="5-5-虚拟存输器"><a href="#5-5-虚拟存输器" class="headerlink" title="5.5  虚拟存输器"></a>5.5  虚拟存输器</h2><h3 id="5-5-1虚拟存储的实现方式"><a href="#5-5-1虚拟存储的实现方式" class="headerlink" title="5.5.1虚拟存储的实现方式"></a>5.5.1虚拟存储的实现方式</h3><p>虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式：</p><h4 id="5-5-1-1-分页请求系统"><a href="#5-5-1-1-分页请求系统" class="headerlink" title="5.5.1.1     分页请求系统"></a>5.5.1.1     分页请求系统</h4><p>在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。<br>  硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上</p><h4 id="5-5-1-2-请求分段系统"><a href="#5-5-1-2-请求分段系统" class="headerlink" title="5.5.1.2     请求分段系统"></a>5.5.1.2     请求分段系统</h4><p>在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页”</p><h3 id="5-5-2页面置换算法"><a href="#5-5-2页面置换算法" class="headerlink" title="5.5.2页面置换算法"></a>5.5.2页面置换算法</h3><h4 id="5-5-2-1-随机淘汰算法"><a href="#5-5-2-1-随机淘汰算法" class="headerlink" title="5.5.2.1     随机淘汰算法"></a>5.5.2.1     随机淘汰算法</h4><p>随机地选择某个用户地页面并将其换出。</p><h4 id="5-5-2-2-最佳置换算法（理想型淘汰算法OPT）"><a href="#5-5-2-2-最佳置换算法（理想型淘汰算法OPT）" class="headerlink" title="5.5.2.2     最佳置换算法（理想型淘汰算法OPT）"></a>5.5.2.2     最佳置换算法（理想型淘汰算法OPT）</h4><p>其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。</p><h4 id="5-5-2-3-先进先出置换算法（FIFO）"><a href="#5-5-2-3-先进先出置换算法（FIFO）" class="headerlink" title="5.5.2.3     先进先出置换算法（FIFO）"></a>5.5.2.3     先进先出置换算法（FIFO）</h4><p>总是先淘汰最先进入内存的页面。</p><h4 id="5-5-2-4-最近最久未使用算法（LRU）"><a href="#5-5-2-4-最近最久未使用算法（LRU）" class="headerlink" title="5.5.2.4     最近最久未使用算法（LRU）"></a>5.5.2.4     最近最久未使用算法（LRU）</h4><p>选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。</p><h4 id="5-5-2-5-最少使用置换算法（LFU）"><a href="#5-5-2-5-最少使用置换算法（LFU）" class="headerlink" title="5.5.2.5     最少使用置换算法（LFU）"></a>5.5.2.5     最少使用置换算法（LFU）</h4><p>在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。</p><h4 id="5-5-2-6-Clock置换算法"><a href="#5-5-2-6-Clock置换算法" class="headerlink" title="5.5.2.6     Clock置换算法"></a>5.5.2.6     Clock置换算法</h4><p>是一种LRU算法<br>每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；<br>当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；<br>再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面；</p><h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6   文件系统"></a>6   文件系统</h1><h2 id="6-1-文件系统基本概念"><a href="#6-1-文件系统基本概念" class="headerlink" title="6.1  文件系统基本概念"></a>6.1  文件系统基本概念</h2><p><strong>目的：</strong>文件系统地出现是为了更好地管理软件资源</p><p><strong>文件系统的定义：</strong>操作系统中与管理文件有关的软件和数据称为文件系统</p><p><strong>文件的定义：</strong>文件时一段程序和数据的集合</p><p><strong>文件的分类：</strong>按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。</p><h2 id="6-2-文件的逻辑结构和存取方式"><a href="#6-2-文件的逻辑结构和存取方式" class="headerlink" title="6.2  文件的逻辑结构和存取方式"></a>6.2  文件的逻辑结构和存取方式</h2><h3 id="6-2-1逻辑结构"><a href="#6-2-1逻辑结构" class="headerlink" title="6.2.1逻辑结构"></a>6.2.1逻辑结构</h3><p><strong>字符流的无结构文件：</strong>管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。</p><p><strong>记录式的有结构文件：</strong>把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。</p><h4 id="6-2-1-1-连续结构"><a href="#6-2-1-1-连续结构" class="headerlink" title="6.2.1.1     连续结构"></a>6.2.1.1     连续结构</h4><h4 id="6-2-1-2-多重结构"><a href="#6-2-1-2-多重结构" class="headerlink" title="6.2.1.2     多重结构"></a>6.2.1.2     多重结构</h4><h4 id="6-2-1-3-转置结构"><a href="#6-2-1-3-转置结构" class="headerlink" title="6.2.1.3     转置结构"></a>6.2.1.3     转置结构</h4><h4 id="6-2-1-4-顺序结构"><a href="#6-2-1-4-顺序结构" class="headerlink" title="6.2.1.4     顺序结构"></a>6.2.1.4     顺序结构</h4><h3 id="6-2-2逻辑存储方法"><a href="#6-2-2逻辑存储方法" class="headerlink" title="6.2.2逻辑存储方法"></a>6.2.2逻辑存储方法</h3><h4 id="6-2-2-1-顺序存输方法"><a href="#6-2-2-1-顺序存输方法" class="headerlink" title="6.2.2.1     顺序存输方法"></a>6.2.2.1     顺序存输方法</h4><h4 id="6-2-2-2-随机存输方法"><a href="#6-2-2-2-随机存输方法" class="headerlink" title="6.2.2.2     随机存输方法"></a>6.2.2.2     随机存输方法</h4><h4 id="6-2-2-3-按关键字存输方法"><a href="#6-2-2-3-按关键字存输方法" class="headerlink" title="6.2.2.3    按关键字存输方法"></a>6.2.2.3    按关键字存输方法</h4><p>多用于复杂文件系统。</p><h3 id="6-2-3逻辑搜索方式"><a href="#6-2-3逻辑搜索方式" class="headerlink" title="6.2.3逻辑搜索方式"></a>6.2.3逻辑搜索方式</h3><p>文件的获取是要找到文件内容所在的逻辑地址</p><h4 id="6-2-3-1-线性搜索法"><a href="#6-2-3-1-线性搜索法" class="headerlink" title="6.2.3.1     线性搜索法"></a>6.2.3.1     线性搜索法</h4><h4 id="6-2-3-2-散列法"><a href="#6-2-3-2-散列法" class="headerlink" title="6.2.3.2     散列法"></a>6.2.3.2     散列法</h4><h4 id="6-2-3-3-二分搜索法"><a href="#6-2-3-3-二分搜索法" class="headerlink" title="6.2.3.3     二分搜索法"></a>6.2.3.3     二分搜索法</h4><h2 id="6-3-文件的物理结构和存储设备"><a href="#6-3-文件的物理结构和存储设备" class="headerlink" title="6.3  文件的物理结构和存储设备"></a>6.3  文件的物理结构和存储设备</h2><h3 id="6-3-1文件物理结构"><a href="#6-3-1文件物理结构" class="headerlink" title="6.3.1文件物理结构"></a>6.3.1文件物理结构</h3><h4 id="6-3-1-1-连续文件"><a href="#6-3-1-1-连续文件" class="headerlink" title="6.3.1.1    连续文件"></a>6.3.1.1    连续文件</h4><p>连续文件采用连续分配方式：</p><p><strong>特点：</strong>为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。<br><strong>优点：</strong>顺序访问容易; 顺序访问速度快;<br><strong>缺点：</strong>要求有连续的存储空间; 必须事先知道文件的长度;</p><h4 id="6-3-1-2-串联文件"><a href="#6-3-1-2-串联文件" class="headerlink" title="6.3.1.2    串联文件"></a>6.3.1.2    串联文件</h4><p>串联文件采用链接分配</p><p><strong>特点：</strong>文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；<br><strong>优点：</strong>没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间;</p><h4 id="6-3-1-3-索引文件"><a href="#6-3-1-3-索引文件" class="headerlink" title="6.3.1.3    索引文件"></a>6.3.1.3    索引文件</h4><p>索引文件采用索引分配</p><p><strong>特点：</strong>每个文件都有自己的索引块，这是一个磁盘块地址的数组。</p><h3 id="6-3-2文件存储设备"><a href="#6-3-2文件存储设备" class="headerlink" title="6.3.2文件存储设备"></a>6.3.2文件存储设备</h3><p>存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。</p><h4 id="6-3-2-1-顺序存取存储设备—磁带"><a href="#6-3-2-1-顺序存取存储设备—磁带" class="headerlink" title="6.3.2.1    顺序存取存储设备—磁带"></a>6.3.2.1    顺序存取存储设备—磁带</h4><p><strong>特点：</strong>只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。</p><p><strong>影响因素：</strong>信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。</p><h4 id="6-3-2-2-直接存取存储设备—磁盘"><a href="#6-3-2-2-直接存取存储设备—磁盘" class="headerlink" title="6.3.2.2     直接存取存储设备—磁盘"></a>6.3.2.2     直接存取存储设备—磁盘</h4><h2 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4  文件存储空间管理"></a>6.4  文件存储空间管理</h2><p>文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。</p><h3 id="6-4-1空闲目录管理"><a href="#6-4-1空闲目录管理" class="headerlink" title="6.4.1空闲目录管理"></a>6.4.1空闲目录管理</h3><h3 id="6-4-2空闲链块法"><a href="#6-4-2空闲链块法" class="headerlink" title="6.4.2空闲链块法"></a>6.4.2空闲链块法</h3><h3 id="6-4-3位示图"><a href="#6-4-3位示图" class="headerlink" title="6.4.3位示图"></a>6.4.3位示图</h3><h2 id="6-5-文件目录管理"><a href="#6-5-文件目录管理" class="headerlink" title="6.5  文件目录管理"></a>6.5  文件目录管理</h2><p>从文件管理角度看，一个文件包括文件说明和文件体。</p><h3 id="6-5-1文件目录的种类"><a href="#6-5-1文件目录的种类" class="headerlink" title="6.5.1文件目录的种类"></a>6.5.1文件目录的种类</h3><h4 id="6-5-1-1-单级文件目录"><a href="#6-5-1-1-单级文件目录" class="headerlink" title="6.5.1.1     单级文件目录"></a>6.5.1.1     单级文件目录</h4><p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。</p><h4 id="6-5-1-2-两级文件目录"><a href="#6-5-1-2-两级文件目录" class="headerlink" title="6.5.1.2     两级文件目录"></a>6.5.1.2     两级文件目录</h4><p>目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB；</p><h4 id="6-5-1-3-树形结构目录"><a href="#6-5-1-3-树形结构目录" class="headerlink" title="6.5.1.3     树形结构目录"></a>6.5.1.3     树形结构目录</h4><p>多级目录结构又称为树型目录结构；<br>主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点；</p><h3 id="6-5-2文件目录的共享"><a href="#6-5-2文件目录的共享" class="headerlink" title="6.5.2文件目录的共享"></a>6.5.2文件目录的共享</h3><p>从系统管理的方式来看，有三种方法可以实现文件共享</p><h4 id="6-5-2-1-绕道法"><a href="#6-5-2-1-绕道法" class="headerlink" title="6.5.2.1     绕道法"></a>6.5.2.1     绕道法</h4><h4 id="6-5-2-2-链接法"><a href="#6-5-2-2-链接法" class="headerlink" title="6.5.2.2     链接法"></a>6.5.2.2     链接法</h4><h4 id="6-5-2-3-基本文件目录表（BFD）"><a href="#6-5-2-3-基本文件目录表（BFD）" class="headerlink" title="6.5.2.3    基本文件目录表（BFD）"></a>6.5.2.3    基本文件目录表（BFD）</h4><h3 id="6-5-3目录管理"><a href="#6-5-3目录管理" class="headerlink" title="6.5.3目录管理"></a>6.5.3目录管理</h3><p>文件目录管理应该存放在磁盘，其他的没理解todo</p><h2 id="6-6-文件存取控制"><a href="#6-6-文件存取控制" class="headerlink" title="6.6  文件存取控制"></a>6.6  文件存取控制</h2><p>用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。</p><h3 id="6-6-1存取控制矩阵"><a href="#6-6-1存取控制矩阵" class="headerlink" title="6.6.1存取控制矩阵"></a>6.6.1存取控制矩阵</h3><h3 id="6-6-2存取控制表"><a href="#6-6-2存取控制表" class="headerlink" title="6.6.2存取控制表"></a>6.6.2存取控制表</h3><h3 id="6-6-3口令方式"><a href="#6-6-3口令方式" class="headerlink" title="6.6.3口令方式"></a>6.6.3口令方式</h3><h3 id="6-6-4密码方式"><a href="#6-6-4密码方式" class="headerlink" title="6.6.4密码方式"></a>6.6.4密码方式</h3><p>密码方式是保密性最好的验证方式。</p><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7    设备管理"></a>7    设备管理</h1><h2 id="7-1-设备的分类"><a href="#7-1-设备的分类" class="headerlink" title="7.1  设备的分类"></a>7.1  设备的分类</h2><p>在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。</p><h2 id="7-2-数据传输控制方式"><a href="#7-2-数据传输控制方式" class="headerlink" title="7.2  数据传输控制方式"></a>7.2  数据传输控制方式</h2><p>设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。</p><h3 id="7-2-1程序直接控制方式"><a href="#7-2-1程序直接控制方式" class="headerlink" title="7.2.1程序直接控制方式"></a>7.2.1程序直接控制方式</h3><p>由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。</p><h3 id="7-2-2中断方式"><a href="#7-2-2中断方式" class="headerlink" title="7.2.2中断方式"></a>7.2.2中断方式</h3><p>I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。</p><h3 id="7-2-3DMA方式"><a href="#7-2-3DMA方式" class="headerlink" title="7.2.3DMA方式"></a>7.2.3DMA方式</h3><p>在外围设备和内存之间开辟直接的数据交换通道。</p><h3 id="7-2-4通道控制方式"><a href="#7-2-4通道控制方式" class="headerlink" title="7.2.4通道控制方式"></a>7.2.4通道控制方式</h3><p>以内存为中心，实现设备和内存直接交换数据的控制的方式。</p><h2 id="7-3-中断技术"><a href="#7-3-中断技术" class="headerlink" title="7.3  中断技术"></a>7.3  中断技术</h2><p><strong>原理：</strong>中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。</p><p><strong>过程：</strong>判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点</p><h3 id="7-3-1中断技术的分类"><a href="#7-3-1中断技术的分类" class="headerlink" title="7.3.1中断技术的分类"></a>7.3.1中断技术的分类</h3><p>中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。</p><h4 id="7-3-1-1-外中断"><a href="#7-3-1-1-外中断" class="headerlink" title="7.3.1.1    外中断"></a>7.3.1.1    外中断</h4><p>一般是来自处理机和内存外部的中断</p><h4 id="7-3-1-2-内中断（陷阱）"><a href="#7-3-1-2-内中断（陷阱）" class="headerlink" title="7.3.1.2    内中断（陷阱）"></a>7.3.1.2    内中断（陷阱）</h4><p>一般是来自处理机和内存内部的中断</p><h4 id="7-3-1-3-软中断"><a href="#7-3-1-3-软中断" class="headerlink" title="7.3.1.3    软中断"></a>7.3.1.3    软中断</h4><p>是通信进程之间模拟硬中断的一种信号通信方式</p><h2 id="7-4-缓冲技术"><a href="#7-4-缓冲技术" class="headerlink" title="7.4  缓冲技术"></a>7.4  缓冲技术</h2><p><strong>目的：</strong>缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。</p><p><strong>分类：</strong>缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。</p><h3 id="7-4-1缓冲池的结构"><a href="#7-4-1缓冲池的结构" class="headerlink" title="7.4.1缓冲池的结构"></a>7.4.1缓冲池的结构</h3><p>缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。</p><h3 id="7-4-2缓冲池管理"><a href="#7-4-2缓冲池管理" class="headerlink" title="7.4.2缓冲池管理"></a>7.4.2缓冲池管理</h3><p>Todo</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统绪论&quot;&gt;&lt;a href=&quot;#1-操作系统绪论&quot; class=&quot;headerlink&quot; title=&quot;1   操作系统绪论&quot;&gt;&lt;/a&gt;1   操作系统绪论&lt;/h1&gt;&lt;h2 id=&quot;1-1-操作系统概念&quot;&gt;&lt;a href=&quot;#1-1-操作系统概念&quot; cla</summary>
      
    
    
    
    <category term="CS基础" scheme="http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机操作系统" scheme="http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关_FairyGUI</title>
    <link href="http://wwy010518.github.io/posts/1542.html"/>
    <id>http://wwy010518.github.io/posts/1542.html</id>
    <published>2021-12-12T13:00:00.000Z</published>
    <updated>2022-02-11T13:38:53.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FairyGUI概叙"><a href="#FairyGUI概叙" class="headerlink" title="FairyGUI概叙"></a>FairyGUI概叙</h1><h1 id="FairyGUI基础"><a href="#FairyGUI基础" class="headerlink" title="FairyGUI基础"></a>FairyGUI基础</h1><h1 id="FairyGUI基本元件"><a href="#FairyGUI基本元件" class="headerlink" title="FairyGUI基本元件"></a>FairyGUI基本元件</h1><h1 id="FairyGUI控件"><a href="#FairyGUI控件" class="headerlink" title="FairyGUI控件"></a>FairyGUI控件</h1><h2 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h2><h2 id="字体处理"><a href="#字体处理" class="headerlink" title="字体处理"></a>字体处理</h2><h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><h2 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h2><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h2 id="关联系统"><a href="#关联系统" class="headerlink" title="关联系统"></a>关联系统</h2><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="单选和多选框"><a href="#单选和多选框" class="headerlink" title="单选和多选框"></a>单选和多选框</h2><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><h2 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h2><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><h2 id="滚动容器"><a href="#滚动容器" class="headerlink" title="滚动容器"></a>滚动容器</h2><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h2><h1 id="Unity中的使用必备"><a href="#Unity中的使用必备" class="headerlink" title="Unity中的使用必备"></a>Unity中的使用必备</h1><h2 id="组件拓展类"><a href="#组件拓展类" class="headerlink" title="组件拓展类"></a>组件拓展类</h2><h2 id="分辨率自适应"><a href="#分辨率自适应" class="headerlink" title="分辨率自适应"></a>分辨率自适应</h2><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><h2 id="拖拽相关"><a href="#拖拽相关" class="headerlink" title="拖拽相关"></a>拖拽相关</h2><h2 id="插入其他对象"><a href="#插入其他对象" class="headerlink" title="插入其他对象"></a>插入其他对象</h2><h2 id="DrawCall优化"><a href="#DrawCall优化" class="headerlink" title="DrawCall优化"></a>DrawCall优化</h2><h1 id="FairyGUI进阶"><a href="#FairyGUI进阶" class="headerlink" title="FairyGUI进阶"></a>FairyGUI进阶</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="多国语言"><a href="#多国语言" class="headerlink" title="多国语言"></a>多国语言</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h2 id="弹出功能"><a href="#弹出功能" class="headerlink" title="弹出功能"></a>弹出功能</h2><h2 id="曲面UI"><a href="#曲面UI" class="headerlink" title="曲面UI"></a>曲面UI</h2><h2 id="动效"><a href="#动效" class="headerlink" title="动效"></a>动效</h2><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FairyGUI概叙&quot;&gt;&lt;a href=&quot;#FairyGUI概叙&quot; class=&quot;headerlink&quot; title=&quot;FairyGUI概叙&quot;&gt;&lt;/a&gt;FairyGUI概叙&lt;/h1&gt;&lt;h1 id=&quot;FairyGUI基础&quot;&gt;&lt;a href=&quot;#FairyGUI基础&quot;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="GUI解决方案" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="GUI解决方案" scheme="http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关_基于Lua的热更新解决方案</title>
    <link href="http://wwy010518.github.io/posts/03008.html"/>
    <id>http://wwy010518.github.io/posts/03008.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-01-29T04:14:48.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="热更新" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="Lua" scheme="http://wwy010518.github.io/tags/Lua/"/>
    
    <category term="AssetBundle" scheme="http://wwy010518.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法格式（.md后缀-使用typora）</title>
    <link href="http://wwy010518.github.io/posts/1.html"/>
    <id>http://wwy010518.github.io/posts/1.html</id>
    <published>2021-09-28T13:00:00.000Z</published>
    <updated>2022-01-24T06:26:54.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法格式"><a href="#Markdown语法格式" class="headerlink" title="Markdown语法格式"></a>Markdown语法格式</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#标题1 （大）</span><span class="token comment">##标题2</span><span class="token comment">###标题3</span><span class="token comment">####标题4 （小）</span>以此类推 最高标题6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">​```代码块名称<span class="token punctuation">(</span>可以输入各种语言java、c++、html等<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//加粗**加粗**//代码高亮显示<span class="token operator">==</span>高亮<span class="token operator">==</span>//删除线~~删除线~~//斜体  *斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//引用语法<span class="token operator">&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>作者：泽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//分割线---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="图片插入："><a href="#图片插入：" class="headerlink" title="图片插入："></a>图片插入：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//在线图片与本地图片<span class="token operator">!</span><span class="token punctuation">[</span>照片名子<span class="token punctuation">]</span>（/image/me.png）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//超链接语法<span class="token punctuation">[</span>超链接名字<span class="token punctuation">]</span>（https://gihub.com/yerenping）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//无需列表- 目录1  -后加空格- 目录2- 目录3//有序列表  <span class="token number">1</span>+. +名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右键》插入》表格用代码过于复杂不推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown语法格式&quot;&gt;&lt;a href=&quot;#Markdown语法格式&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法格式&quot;&gt;&lt;/a&gt;Markdown语法格式&lt;/h1&gt;&lt;h2 id=&quot;标题：&quot;&gt;&lt;a href=&quot;#标题：&quot; class</summary>
      
    
    
    
    <category term="其他" scheme="http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Markdown" scheme="http://wwy010518.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>UnityEditor</title>
    <link href="http://wwy010518.github.io/posts/1550.html"/>
    <id>http://wwy010518.github.io/posts/1550.html</id>
    <published>2021-07-09T13:00:00.000Z</published>
    <updated>2022-02-18T11:13:50.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待写&quot;&gt;&lt;a href=&quot;#待写&quot; class=&quot;headerlink&quot; title=&quot;待写&quot;&gt;&lt;/a&gt;待写&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="UnityEditor" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="UnityEditor" scheme="http://wwy010518.github.io/tags/UnityEditor/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法</title>
    <link href="http://wwy010518.github.io/posts/514.html"/>
    <id>http://wwy010518.github.io/posts/514.html</id>
    <published>2021-06-30T13:00:00.000Z</published>
    <updated>2022-01-24T15:05:02.801Z</updated>
    
    <content type="html"><![CDATA[<p>列举一些常用的排序算法</p><p>#冒泡排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void BubbleSort(int[] array, int count){    //设置标识符，如果为false意为当前数组为有序，不需要再排序了    bool shouldSorted = true;    for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++)    {        shouldSorted = false;        for (int j = count - 1; j &gt; i; j--)        {            if (array[j - 1] &gt; array[j])            {                shouldSorted = true;                Utilities.Swap(ref array[j - 1], ref array[j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#选择排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void SelectSort(int[] array, int count){    int min;    for (int i = 0; i &lt; count - 1; i++)    {        min = i;        for (int j = i + 1; j &lt; count; j++)        {            if (array[min] &gt; array[j])            {                min = j;            }        }        if (min != i)        {            Utilities.Swap(ref array[min], ref array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#插入排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void InserSort(int[] array, int count){    int guard; //哨兵，用于暂存需要交换的值    for (int i = 0; i &lt; count - 1; i++)    {        if (array[i] &gt; array[i + 1])        {            guard = array[i + 1];            int j;            for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--)            {                array[j + 1] = array[j]; //赋值操作（依次后移）            }            array[j + 1] = guard;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#希尔排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 希尔排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void ShellSort(int[] array, int count){    int i, j, guard;    int increment = count;    do    {        increment = increment / 3 + 1; //增量序列        for (i = increment + 1; i &lt; count; i++)        {            if (array[i] &lt; array[i - increment])            {                guard = array[i]; //暂存在哨兵处                for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment)                {                    array[j + increment] = array[j]; //记录后移，查找插入位置                }                array[j + increment] = guard; //插入            }        }    } while (increment &gt; 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#堆排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 堆排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void HeapSort(int[] array, int count){    for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆    {        HeapAdjust(array, i, count - 1);    }    for (int i = count - 1; i &gt; 0; i--)    {        Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换        HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆    }}/// &lt;summary&gt;/// 堆排序_构造大顶堆函数/// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义/// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="startIndex"&gt;起始位置&lt;/param&gt;/// &lt;param name="endIndex"&gt;结束位置&lt;/param&gt;public static void HeapAdjust(int[] array, int startIndex, int endIndex){    int temp;    temp = array[startIndex];    for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选    {        if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1])        {            ++i; //i为关键字中较大记录的下标        }        if (temp &gt; array[i])        {            break; //rc应插入在位置s上        }        array[startIndex] = array[i];        startIndex = i;    }    array[startIndex] = temp; //插入}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#归并排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 归并排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void MergeSort(int[] array, int count){    int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果    int k = 1;    while (k &lt; count)    {        MergePass(array, tempArray, k, count); //array归并到tempArray        k = 2 * k; //子序列长度加倍        MergePass(tempArray, array, k, count); //tempArray归并到array        k = 2 * k; //子序列长度加倍    }}/// &lt;summary&gt;/// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="srChildLength"&gt;SR中子序列长度&lt;/param&gt;/// &lt;param name="arrayLength"&gt;原数组长度&lt;/param&gt;public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength){    int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数    while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2,            hasMergeCount + 2 * srChildLength - 2); //两两归并        hasMergeCount += 2 * srChildLength;    }    if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1);    }    else //若最后只剩下单个子序列    {        for (int j = hasMergeCount - 1; j &lt; arrayLength; j++)        {            tr[j] = sr[j];        }    }}/// &lt;summary&gt;/// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="sr1StartIndex"&gt;SR数组子序列1起始位置&lt;/param&gt;/// &lt;param name="sr1EndIndex"&gt;SR数组子序列1结束位置&lt;/param&gt;/// &lt;param name="sr2EndIndex"&gt;SR数组子序列2结束位置&lt;/param&gt;private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex){    int sr2StartIndex, currentProcess; //currentProcess为当前进度    for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex;        sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex;        currentProcess++) //两个SR有一个被榨干后就要退出循环    {        if (sr[sr1StartIndex] &lt; sr[sr2StartIndex])        {            tr[currentProcess] = sr[sr1StartIndex++];        }        else        {            tr[currentProcess] = sr[sr2StartIndex++];        }    }    if (sr1StartIndex &lt;= sr1EndIndex)    {        for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++)        {            tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR        }    }    if (sr2StartIndex &lt;= sr2EndIndex)    {        for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++)        {            tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#快速排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 快速排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void QuickSort(int[] array, int count){    QSort(array, 0, count - 1);}/// &lt;summary&gt;/// 快速排序_递归调用/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;private static void QSort(int[] array, int low, int high){    int pivot;    while (low &lt; high)    {        pivot = Partition(array, low, high);        QSort(array, low, pivot - 1);        //尾递归，可以减少一次递归堆栈深度        low = pivot + 1;    }}/// &lt;summary&gt;/// 获取枢轴数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static int Partition(int[] array, int low, int high){    int pivotkey;    int m = low + (high - low) / 2;    //下面是三数取中优化    //交换左端与右端数据，保证左端较小    if (array[low] &gt; array[high])    {        Utilities.Swap(ref array[low],ref array[high]);    }    //交换中间与右端数据，保证中间较小    if (array[m] &gt; array[high])    {        Utilities.Swap(ref array[m],ref array[high]);    }    //交换中间与左端数据，保证左端较小    if (array[m] &gt; array[low])    {        Utilities.Swap(ref array[low],ref array[m]);    }    //默认选取当前数组的第一个值作为枢轴值    pivotkey = array[low];    //枢轴备份    int pivotkeyback = pivotkey;    while (low &lt; high)    {        while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey)        {            high--;        }        array[low] = array[high];        while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey)        {            low++;        }        array[high] = array[low];    }    //将枢轴数值替换回array[low]    array[low] = pivotkeyback;    //返回当前枢轴下标    return low;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#各种排序时空复杂度<br><img src="img/01002-0001.png" alt="排序复杂图"><br>n: 数据规模<br>k: “桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;列举一些常用的排序算法&lt;/p&gt;
&lt;p&gt;#冒泡排序&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c#&quot; data-language=&quot;c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 冒</summary>
      
    
    
    
    <category term="CS基础" scheme="http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构和算法" scheme="http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构和算法" scheme="http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>游戏MVC系列框架</title>
    <link href="http://wwy010518.github.io/posts/2051.html"/>
    <id>http://wwy010518.github.io/posts/2051.html</id>
    <published>2020-12-15T13:00:00.000Z</published>
    <updated>2022-02-19T14:13:49.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑;</p><p>流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据;</p><p>总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架；</p><p>不使用MVC的逻辑：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevPanel : MonoBehaviour{      public Button btnLevUp;      public Button btnClose;            //展示UI面板      public static void ShowMe()    {    //todo    }        //隐藏UI面板    public static void HideMe()    {    //todo    }        void Start()    {        //2.监听事件        btnClose.onClick.AddListener(ClickClose);        btnLevUp.onClick.AddListener(ClickLevUp);    }        public void ClickClose()    {        Debug.Log("关闭");        HideMe();    }        public void ClickLevUp()    {        Debug.Log("升级");        //存储数据        //同步更新面板上的数据        UpdateInfo();        //更新主面板的内容        MainPanel.Panel.UpdateInfo();    }            //3.更新面板    public void UpdateInfo()    {    //更新数据    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发；</p><p>使用MVC：<br>Model层：负责增删查改获取界面上需要的数据</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevModel{    //定义数据    private int lev;    //外界只能获取字段    public int Lev    {        get        {            return lev;        }    }        //通知外部更新的事件    //通过它和外部建立联系 而不是直接获取外部的面板    private event UnityAction&lt;PlayerLevModel&gt; updateEvent;        //在外部第一次获取这个数据 如何获取    //通过单例模式 来达到数据的唯一性 和数据的获取    private static PlayerLevModel data = null;    public static PlayerLevModel Data    {        get        {            if( data == null )            {                data = new PlayerLevModel();                data.Init();            }            return data;        }    }        //数据相关的操作    // 初始化    public void Init()    {        lev = PlayerPrefs.GetInt("PlayerLev", 1);    }}    public void LevUp()    {        //升级 改变内容        lev += 1;        //改变过后保存        SaveData();    }            public void SaveData()    {        //把这些数据内容 存储到本地        PlayerPrefs.SetInt("PlayerLev", lev);        UpdateInfo();    }            public void AddEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent += function;    }    public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent -= function;    }    //通知外部更新外部数据的方法    private void UpdateInfo()    {        //找到对应的 使用数据的脚本 去更新数据        updateEvent?Invoke(this);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视图层：负责获取控件，更新控件信息</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevView : MonoBehaviour{      //1.找控件    public Button btnClose;    public Button btnLevUp;    //2.提供面板更新的相关方法给外部    public void UpdateInfo(PlayerModel data)    {        txtLev.text = "LV." + data.Lev;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevController : MonoBehaviour{    //视图实例，这里视图和控制在一个物体上    private PlayerLevView roleView;    private static PlayerLevController controller = null;    //控制层单例    public static PlayerLevController Controller    {        get        {            return controller;        }    }            public static void ShowMe()    {        if (controller == null)        {            //实例化面板对象            //设置它的父对象 为Canvas        }        //如果是隐藏的形式hide 在这要显示        controller.gameObject.SetActive(true);    }    public static void HideMe()    {        if (controller != null)        {            //方式一 直接删            //方式二 设置可见为隐藏        }    }            void Start()    {    //这里视图和控制在一个物体上        roleView = this.GetComponent&lt;RoleView&gt;();        //第一次更新面板        roleView.UpdateInfo(PlayerLevModel.Data);        roleView.btnClose.onClick.AddListener(ClickCloseBtn);        roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn);        //告知数据模块 当更新时 通知哪个函数做处理        PlayerModel.Data.AddEventListener(UpdateInfo);    }            private void ClickCloseBtn()    {        HideMe();    }    private void ClickLevUpBtn()    {        //通过数据模块 进行升级 达到数据改变        PlayerLevModel.Data.LevUp();    }    private void UpdateInfo( PlayerModel data )    {        if( roleView != null )        {            roleView.UpdateInfo(data);        }    }    private void OnDestroy()    {              PlayerLevModel.Data.RemoveEventListener(UpdateInfo);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好处：<br>1.各司其职，互不干涉 —— 编程思路更清晰<br>2.有利开发中的分工 —— 多人协同开发时，同步并行<br>3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率<br>缺点：<br>1.增加了程序文件的体量 —— 脚本由一变三<br>2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好<br>2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大）</p><h1 id="MV-的概念"><a href="#MV-的概念" class="headerlink" title="MV*的概念"></a>MV*的概念</h1><p>MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变；<br>  所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。</p><p><img src="https://s4.ax1x.com/2022/02/05/Hm6yN9.png" alt="相关的变种"></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>  切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部.</p><p>Model层:不变</p><p>View层:不能直接传入Model模型来更新</p><p>Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入；</p><h1 id="MVVM（MP）"><a href="#MVVM（MP）" class="headerlink" title="MVVM（MP）"></a>MVVM（MP）</h1><p>  MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细；</p><p>了解的话可以看看这些第三方MVVM框架：<br>loxodon-Framework:<a href="https://github.com/vovgou/loxodon-framework">vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)</a><br>uMVVM:<a href="https://github.com/MEyes/uMVVM">MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com)</a></p><p>所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心；</p><h1 id="MVE"><a href="#MVE" class="headerlink" title="MVE"></a>MVE</h1><p>  E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可；</p><h1 id="商业框架PureMVC"><a href="#商业框架PureMVC" class="headerlink" title="商业框架PureMVC"></a>商业框架PureMVC</h1><p>官网：<a href="http://puremvc.org/">PureMVC 框架</a><br>PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；<br>Model（数据模型）：关联Proxy(代理)对象，负责处理数据；<br>View（界面）：关联Mediator(中介)对象，负责处理界面；<br>Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；<br>Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；<br>Notification：通知，负责传递信息；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h1&gt;&lt;p&gt;基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller</summary>
      
    
    
    
    <category term="Game-Play" scheme="http://wwy010518.github.io/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="游戏框架" scheme="http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
    <category term="MVC" scheme="http://wwy010518.github.io/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>游戏程序基础框架</title>
    <link href="http://wwy010518.github.io/posts/2050.html"/>
    <id>http://wwy010518.github.io/posts/2050.html</id>
    <published>2020-11-20T13:00:00.000Z</published>
    <updated>2022-02-19T13:48:55.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例管理者基类"><a href="#单例管理者基类" class="headerlink" title="单例管理者基类"></a>单例管理者基类</h1><h2 id="不继承自Mono"><a href="#不继承自Mono" class="headerlink" title="不继承自Mono"></a>不继承自Mono</h2><p>1.利用单例模式和泛形去实现模块管理者基类；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">public class SingletonBase&lt;T&gt; where T:new(){    private static T instance;    public static T GetInstance()    {        if (instance == null) instance = new T();        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承自Mono"><a href="#继承自Mono" class="headerlink" title="继承自Mono"></a>继承自Mono</h2><p>1.直接实例化通过生成游戏对象并且附加脚本；<br>2.Awake实例化的话要保证单例的唯一性；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour{    private static T instance;    public static T GetInstance()    {        if (instance == null)        {            GameObject go = new GameObject            {                name = typeof(T).Name,            };            instance = go.AddComponent&lt;T&gt;();            DontDestroyOnLoad(go);        }        return instance;    }    protected virtual void Awake()    {        if (instance == null)        {            instance = this as T;            DontDestroyOnLoad(gameObject);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事件管理者"><a href="#事件管理者" class="headerlink" title="事件管理者"></a>事件管理者</h1><p>1.观察者模式，利用了泛形和委托（事件）<br>2.这里的事件字典只能对付小游戏，大型游戏仍是不够</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public interface IEventInfo { } public class EventInfo : IEventInfo{    public event UnityAction actions;    public EventInfo(UnityAction action)    {        actions += action;    }    public void EventTrigger()    {        actions?.Invoke();    }}public class EventInfo&lt;T&gt; : IEventInfo{    public event UnityAction&lt;T&gt; actions;    public EventInfo(UnityAction&lt;T&gt; action)    {        actions += action;    }    public void EventTrigger(T Info)    {        actions?.Invoke(Info);    }}public class EventMgr : SingletonBase&lt;EventMgr&gt;{    //暂时只定义一个字典进行储存，小游戏够用了    private Dictionary&lt;string, IEventInfo&gt; eventDic = new Dictionary&lt;string, IEventInfo&gt;();     public void AddListenter(string name,UnityAction action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions += action;        else eventDic.Add(name,new EventInfo(action));    }    public void AddListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions += action;        else eventDic.Add(name, new EventInfo&lt;T&gt;(action));    }    public void RemoveListenter(string name, UnityAction action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions -= action;    }    public void RemoveListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions -= action;    }    public void EventTrigger(string name)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).EventTrigger();    }    public void EventTrigger&lt;T&gt;(string name,T info)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).EventTrigger(info);    }    public void Clear()    {        eventDic.Clear();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Mono根节点"><a href="#Mono根节点" class="headerlink" title="Mono根节点"></a>Mono根节点</h1><p>1.可以创建一个全局唯一的Mono节点使用<br>2.实现游戏入口继承自该节点即可，但是实现Awake单例</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class MonoRoot : SingletonMono&lt;MonoRoot&gt;{    private event UnityAction updateActions;    protected override void Awake()    {        base.Awake();    }    protected virtual void Update()    {        updateActions?.Invoke();    }    public void AddUpdateListenter(UnityAction updateAction)    {        updateActions += updateAction;    }    public void RemoveUpdateListenter(UnityAction updateAction)    {        updateActions -= updateAction;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="资源加载管理者"><a href="#资源加载管理者" class="headerlink" title="资源加载管理者"></a>资源加载管理者</h1><p>1.资源加载有同步加载和异步加载，异步加载用协程实现<br>2.资源加载管理者包括场景切换，以及配置文件加载</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class ResMgr : SingletonBase&lt;ResMgr&gt;{    #region 资源加载    private Dictionary&lt;string,Object&gt; ObjCacheDic=new Dictionary&lt;string, Object&gt;();    public T LoadObj&lt;T&gt;(string path , bool isIns=true , bool isCache= true ) where T : Object    {        T obj;        if (ObjCacheDic.TryGetValue(path, out Object cacheObj)) obj = cacheObj as T;        else         {            obj = Resources.Load&lt;T&gt;(path);            if (isCache) ObjCacheDic.Add(path, obj);        };        if (obj is GameObject &amp;&amp; isIns) return GameObject.Instantiate(obj);        else return obj;    }    public void LoadObjAsyn&lt;T&gt;(string path,UnityAction&lt;T&gt; callback, bool isIns = true, bool isCache = true) where T : Object    {        if (ObjCacheDic.TryGetValue(path, out Object obj))        {            if (obj is GameObject &amp;&amp; isIns)                callback(GameObject.Instantiate(obj) as T);            else                callback(obj as T);        }        else MonoRoot.GetInstance().StartCoroutine(ReallyLoadObjAsyn(path, callback, isIns, isCache));    }    public IEnumerator ReallyLoadObjAsyn&lt;T&gt;(string path, UnityAction&lt;T&gt; callback, bool isIns, bool isCache) where T : Object    {        ResourceRequest r = Resources.LoadAsync&lt;T&gt;(path);        yield return r;        if(isCache) ObjCacheDic.Add(path, r.asset);        if (r.asset is GameObject &amp;&amp; isIns)            callback(GameObject.Instantiate(r.asset) as T);        else            callback(r.asset as T);    }    #endregion        #region 场景切换    public void LoadScene(string name, UnityAction fun)    {        //场景同步加载        SceneManager.LoadScene(name);        //加载完成过后 才会去执行fun        fun();    }    public void LoadSceneAsyn(string name, UnityAction fun)    {        MonoRoot.GetInstance().StartCoroutine(ReallyLoadSceneAsyn(name, fun));    }    public IEnumerator ReallyLoadSceneAsyn(string name, UnityAction fun)    {        AsyncOperation op = SceneManager.LoadSceneAsync(name);        while (!op.isDone)        {            //这里可以去做一些事情，例如更新进度条            //EventMgr.GetInstance().EventTrigger("更新进度条", op.progress);            yield return op.progress;        }        //加载完成过后 才会去执行fun        fun();    }     #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="缓存池管理者"><a href="#缓存池管理者" class="headerlink" title="缓存池管理者"></a>缓存池管理者</h1><p>1.用一个类类型去包装缓存队列，这个类里面应该封装了获取和设置缓存对象的方法<br>2.缓存池目前只支持预制物的缓存</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PoolMgr :SingletonBase&lt;PoolMgr&gt; {    private Dictionary&lt;string, PoolData&gt; poolDic=new Dictionary&lt;string, PoolData&gt;();    private GameObject poolRoot;    public void GetObj(string name, UnityAction&lt;GameObject&gt; callBack)    {        if(poolDic.TryGetValue(name, out PoolData poolData) &amp;&amp; poolData.Count &gt; 0)        {            callBack(poolData.GetObj());        }        else        {            //创建资源应使用资源路径            ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(name, (go) =&gt;{                go.name = name;                callBack(go);            });        }    }    public void PushObj(string name,GameObject obj)    {        if(poolRoot=null)poolRoot=new GameObject("PoolRoot");        if(poolDic.TryGetValue(name,out PoolData poolData)) poolData.PushObj(obj);        else poolDic.Add(name, new PoolData(obj,poolRoot));    }    public void  Clear()    {        poolDic.Clear();        poolRoot = null;    }}public class PoolData{    private GameObject parentRoot;    private Queue&lt;GameObject&gt; objQue;    public PoolData(GameObject obj,GameObject poolObj)    {        parentRoot = new GameObject($"{obj.name}Root");        parentRoot.transform.parent = poolObj.transform;        objQue = new Queue&lt;GameObject&gt;();    }    public int Count    {        get { return objQue.Count; }    }    public void PushObj(GameObject obj)    {        //存起来        objQue.Enqueue(obj);        //失活 让其隐藏        obj.SetActive(false);        //设置父对象        obj.transform.parent = parentRoot.transform;    }    public GameObject GetObj()    {        //取出第一个        GameObject obj = objQue.Dequeue();        //激活 让其显示        obj.SetActive(true);        //断开了父子关系        obj.transform.parent = null;        return obj;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="输入管理者"><a href="#输入管理者" class="headerlink" title="输入管理者"></a>输入管理者</h1><p>1.输入管理者耦合事件监听和Mono根节点</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class InputMgr : SingletonBase&lt;InputMgr&gt;{    private bool isStart = false;    public InputMgr()    {        MonoMgr.GetInstance().AddUpdateListener(UpdateIpt);    }    public void StartOrEndCheck(bool isOpen)    {        isStart = isOpen;    }    private void CheckKeyCode(KeyCode key)    {        //事件中心模块 分发按下抬起事件        if (Input.GetKeyDown(key))            EventCenter.GetInstance().EventTrigger("某键按下", key);        //事件中心模块 分发按下抬起事件        if (Input.GetKeyUp(key))            EventCenter.GetInstance().EventTrigger("某键抬起", key);    }    private void UpdateIpt()    {        //没有开启输入检测 就不去检测 直接return        if (!isStart)            return;        CheckKeyCode(KeyCode.W);        CheckKeyCode(KeyCode.S);        CheckKeyCode(KeyCode.A);        CheckKeyCode(KeyCode.D);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="音效管理者"><a href="#音效管理者" class="headerlink" title="音效管理者"></a>音效管理者</h1><p>1.一般音效资源应该做缓存池处理</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class MusicMgr : MonoBehaviour{    private bool isMute = false;    //背景音乐源    private AudioSource bkSource;    //背景音乐大小    private float bkValue = 1;    //一般音乐列表    private List&lt;AudioSource&gt; sourceLst = new List&lt;AudioSource&gt;();    //背景音乐大小    private float soundValue = 1;    //音乐源节点    private GameObject musicRoot;    public MusicMgr()    {        MonoMgr.GetInstance().AddUpdateListener(UpdateMsc);    }    //音乐播放完就回收    private void UpdateMsc()    {        for (int i = sourceLst.Count - 1; i &gt;= 0; --i)        {            if (!sourceLst[i].isPlaying)            {                GameObject.Destroy(sourceLst[i]);                sourceLst.RemoveAt(i);            }        }    }    public void PlayBkMusic(string name)    {        if(!musicRoot) musicRoot=new GameObject("MusicRoot");        if (bkSource) bkSource = musicRoot.AddComponent&lt;AudioSource&gt;();        //异步加载背景音乐 加载完成后 播放        ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;("Music/BK/" + name, (clip) =&gt;        {            bkSource.clip = clip;            bkSource.loop = true;            bkSource.volume = bkValue;            bkSource.Play();        });    }    public void PauseBKMusic()    {        bkSource?.Pause();    }    public void StopBKMusic()    {        bkSource?.Stop();    }    public void ChangeBKValue(float v)    {        bkValue = v;        if (bkSource == null) bkSource.volume = bkValue;    }    public void PlaySound(string name, bool isLoop=false, GameObject parent=null, UnityAction&lt;AudioSource&gt; callBack = null)    {        if (!musicRoot) musicRoot = new GameObject("MusicRoot");        //当音效资源异步加载结束后 再添加一个音效        ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;("Music/Sound/" + name, (clip) =&gt;        {            AudioSource source;            if (parent) source=parent.AddComponent&lt;AudioSource&gt;();            else source = musicRoot.AddComponent&lt;AudioSource&gt;();            source.clip = clip;            source.loop = isLoop;            source.volume = soundValue;            source.Play();            sourceLst.Add(source);            if (callBack != null)                callBack(source);        });    }    public void ChangeSoundValue(float value)    {        soundValue = value;        for (int i = 0; i &lt; sourceLst.Count; ++i)            sourceLst[i].volume = value;    }    public void StopSound(AudioSource source)    {        if (sourceLst.Contains(source))        {            sourceLst.Remove(source);            source.Stop();            GameObject.Destroy(source);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="UI管理者和UI面板基类"><a href="#UI管理者和UI面板基类" class="headerlink" title="UI管理者和UI面板基类"></a>UI管理者和UI面板基类</h1><h2 id="面板基类"><a href="#面板基类" class="headerlink" title="面板基类"></a>面板基类</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class BasePanel : MonoBehaviour{    //通过里式转换原则 来存储所有的控件    private Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt; controlDic = new Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt;();    protected virtual void Awake()    {        FindChildrenControl&lt;Button&gt;();        FindChildrenControl&lt;Image&gt;();        FindChildrenControl&lt;Text&gt;();        FindChildrenControl&lt;Toggle&gt;();        FindChildrenControl&lt;Slider&gt;();        FindChildrenControl&lt;ScrollRect&gt;();        FindChildrenControl&lt;InputField&gt;();    }    public virtual void ShowMe()    {    }    public virtual void HideMe()    {    }    protected virtual void OnClick(string btnName)    {    }    protected virtual void OnValueChanged(string toggleName, bool value)    {    }    protected T GetControl&lt;T&gt;(string controlName) where T : UIBehaviour    {        if (controlDic.ContainsKey(controlName))        {            for (int i = 0; i &lt; controlDic[controlName].Count; ++i)            {                if (controlDic[controlName][i] is T)                    return controlDic[controlName][i] as T;            }        }        return null;    }    private void FindChildrenControl&lt;T&gt;() where T : UIBehaviour    {        T[] controls = this.GetComponentsInChildren&lt;T&gt;();        for (int i = 0; i &lt; controls.Length; ++i)        {            string objName = controls[i].gameObject.name;            if (controlDic.ContainsKey(objName))                controlDic[objName].Add(controls[i]);            else                controlDic.Add(objName, new List&lt;UIBehaviour&gt;() { controls[i] });            //如果是按钮控件            if (controls[i] is Button)            {                (controls[i] as Button).onClick.AddListener(() =&gt;                {                    OnClick(objName);                });            }            //如果是单选框或者多选框            else if (controls[i] is Toggle)            {                (controls[i] as Toggle).onValueChanged.AddListener((value) =&gt;                {                    OnValueChanged(objName, value);                });            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="UI管理者"><a href="#UI管理者" class="headerlink" title="UI管理者"></a>UI管理者</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class UIMgr : SingletonBase&lt;UIMgr&gt;{    public Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;();    private Transform bot;    private Transform mid;    private Transform top;    private Transform system;    //记录我们UI的Canvas父对象 方便以后外部可能会使用它    public RectTransform canvas;    public UIMgr()    {        //创建Canvas 让其过场景的时候 不被移除        GameObject obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;("UI/Canvas");        canvas = obj.transform as RectTransform;        GameObject.DontDestroyOnLoad(obj);        //找到各层        bot = canvas.Find("Bot");        mid = canvas.Find("Mid");        top = canvas.Find("Top");        system = canvas.Find("System");        //创建EventSystem 让其过场景的时候 不被移除        obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;("UI/EventSystem");        GameObject.DontDestroyOnLoad(obj);    }    /// &lt;summary&gt;    /// 通过层级枚举 得到对应层级的父对象    /// &lt;/summary&gt;    /// &lt;param name="layer"&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public Transform GetLayerFather(EUIayer layer)    {        switch (layer)        {            case EUIayer.Bot:                return this.bot;            case EUIayer.Mid:                return this.mid;            case EUIayer.Top:                return this.top;            case EUIayer.System:                return this.system;        }        return null;    }    /// &lt;summary&gt;    /// 显示面板    /// &lt;/summary&gt;    /// &lt;typeparam name="T"&gt;面板脚本类型&lt;/typeparam&gt;    /// &lt;param name="panelName"&gt;面板名&lt;/param&gt;    /// &lt;param name="layer"&gt;显示在哪一层&lt;/param&gt;    /// &lt;param name="callBack"&gt;当面板预设体创建成功后 你想做的事&lt;/param&gt;    public void ShowPanel&lt;T&gt;(string panelName, EUIayer layer = EUIayer.Mid, UnityAction&lt;T&gt; callBack = null) where T : BasePanel    {        if (panelDic.ContainsKey(panelName))        {            panelDic[panelName].ShowMe();            // 处理面板创建完成后的逻辑            if (callBack != null)                callBack(panelDic[panelName] as T);            //避免面板重复加载 如果存在该面板 即直接显示 调用回调函数后  直接return 不再处理后面的异步加载逻辑            return;        }        ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;("UI/" + panelName, (obj) =&gt;        {            //把他作为 Canvas的子对象            //并且 要设置它的相对位置            //找到父对象 你到底显示在哪一层            Transform father = bot;            switch (layer)            {                case EUIayer.Mid:                    father = mid;                    break;                case EUIayer.Top:                    father = top;                    break;                case EUIayer.System:                    father = system;                    break;            }            //设置父对象  设置相对位置和大小            obj.transform.SetParent(father);            obj.transform.localPosition = Vector3.zero;            obj.transform.localScale = Vector3.one;            (obj.transform as RectTransform).offsetMax = Vector2.zero;            (obj.transform as RectTransform).offsetMin = Vector2.zero;            //得到预设体身上的面板脚本            T panel = obj.GetComponent&lt;T&gt;();            // 处理面板创建完成后的逻辑            if (callBack != null)                callBack(panel);            panel.ShowMe();            //把面板存起来            panelDic.Add(panelName, panel);        });    }    /// &lt;summary&gt;    /// 隐藏面板    /// &lt;/summary&gt;    /// &lt;param name="panelName"&gt;&lt;/param&gt;    public void HidePanel(string panelName)    {        if (panelDic.ContainsKey(panelName))        {            panelDic[panelName].HideMe();            GameObject.Destroy(panelDic[panelName].gameObject);            panelDic.Remove(panelName);        }    }    /// &lt;summary&gt;    /// 得到某一个已经显示的面板 方便外部使用    /// &lt;/summary&gt;    public T GetPanel&lt;T&gt;(string name) where T : BasePanel    {        if (panelDic.ContainsKey(name))            return panelDic[name] as T;        return null;    }    /// &lt;summary&gt;    /// 给控件添加自定义事件监听    /// &lt;/summary&gt;    /// &lt;param name="control"&gt;控件对象&lt;/param&gt;    /// &lt;param name="type"&gt;事件类型&lt;/param&gt;    /// &lt;param name="callBack"&gt;事件的响应函数&lt;/param&gt;    public static void AddCustomEventListener(UIBehaviour control, EventTriggerType type, UnityAction&lt;BaseEventData&gt; callBack)    {        EventTrigger trigger = control.GetComponent&lt;EventTrigger&gt;();        if (trigger == null)            trigger = control.gameObject.AddComponent&lt;EventTrigger&gt;();        EventTrigger.Entry entry = new EventTrigger.Entry();        entry.eventID = type;        entry.callback.AddListener(callBack);        trigger.triggers.Add(entry);    }}/// &lt;summary&gt;/// UI层级/// &lt;/summary&gt;public enum EUIayer{    Bot,    Mid,    Top,    System,}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例管理者基类&quot;&gt;&lt;a href=&quot;#单例管理者基类&quot; class=&quot;headerlink&quot; title=&quot;单例管理者基类&quot;&gt;&lt;/a&gt;单例管理者基类&lt;/h1&gt;&lt;h2 id=&quot;不继承自Mono&quot;&gt;&lt;a href=&quot;#不继承自Mono&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Game-Play" scheme="http://wwy010518.github.io/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="游戏框架" scheme="http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关_数据持久化</title>
    <link href="http://wwy010518.github.io/posts/1543.html"/>
    <id>http://wwy010518.github.io/posts/1543.html</id>
    <published>2020-05-24T13:00:00.000Z</published>
    <updated>2022-02-11T13:39:15.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="数据持久化" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="数据持久化" scheme="http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关_UGUI</title>
    <link href="http://wwy010518.github.io/posts/1541.html"/>
    <id>http://wwy010518.github.io/posts/1541.html</id>
    <published>2020-01-24T13:00:00.000Z</published>
    <updated>2022-02-15T10:06:49.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六大基础组件"><a href="#六大基础组件" class="headerlink" title="六大基础组件"></a>六大基础组件</h1><p>1.Canvas对象上依附的：<br>Canvas：画布组件，主要用于渲染UI控件<br>Canvas Scaler：画布分辨率自适应组件，主要用于分辨率自适应<br>Graphic Raycaster：射线事件交互组件，主要用于控制射线响应相关<br>RectTransform：UI对象位置锚点控制组件，主要用于控制位置和对其方式</p><p>2.EventSystem对象上依附的：<br>EventSystem和Standalone Input Module：<br>玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作</p><h2 id="Canvas画布组件"><a href="#Canvas画布组件" class="headerlink" title="Canvas画布组件"></a>Canvas画布组件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Screen Space - Overlay：屏幕空间，覆盖模式，UI始终在前；    Pixel Perfect：是否开启无锯齿精确渲染（性能换效果）    SortOrder：排序层编号（用于控制多个Canvas时的渲染先后顺序）    TargetDisplay：目标设备（在哪个显示设备上显示）    Additional Shader Channels：其他着色器通道，决定着色器可以读取哪些数据<span class="token number">2</span>.Screen Space - Camera<span class="token punctuation">(</span>不推荐设置成主摄像机<span class="token punctuation">)</span>：屏幕空间，摄像机模式，3D物体可以显示在UI之前；    RenderCamera：用于渲染UI的摄像机（如果不设置将类似于覆盖模式）    Plane Distance：UI平面在摄像机前方的距离，类似整体Z轴的感觉    Sorting Layer：所在排序层    Order <span class="token keyword">in</span> Layer：排序层的序号    <span class="token number">3</span>.World Space：世界空间，3D模式；    Event Camera：用于处理UI事件的摄像机（如果不设置，不能正常注册UI事件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Canvas.html">画布 - Unity 手册 (unity3d.com)</a></p><h2 id="CanvasScaler画布缩放控制器组件"><a href="#CanvasScaler画布缩放控制器组件" class="headerlink" title="CanvasScaler画布缩放控制器组件"></a>CanvasScaler画布缩放控制器组件</h2><p>  CanvasScaler意思是画布缩放控制器，它是用于分辨率自适应的组件，它主要负责在不同分辨率下UI控件大小自适应，它并不负责位置，位置由之后的RectTransform组件负责；</p><p>1.屏幕分辨率（UI画布宽高*缩放系数 = 屏幕分辨率）：当前设备的分辨率，编辑器下Game窗口中可以查看到；<br>2.参考分辨率：在其中一种适配模式中出现的关键参数，参与分辨率自适应的计算；<br>3.画布宽高和缩放系数：分辨率自适应会改变的参数，通过屏幕分辨率和参考分辨率计算而来；<br>4.分辨率大小自适应：通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数，该结果会影响所有UI控件的缩放大小；</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-CanvasScaler.html">画布缩放器 (Canvas Scaler) - Unity 手册 (unity3d.com)</a></p><h3 id="缩放模式"><a href="#缩放模式" class="headerlink" title="缩放模式"></a>缩放模式</h3><p>  根据屏幕尺寸进行缩放，随着屏幕尺寸变化来放大缩小（游戏开发中常用）；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Reference Resolution：参考分辨率（美术同学出图的标准分辨率）；缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算；<span class="token number">2</span>.Screen Match Mode：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式；    Expand：水平或垂直拓展画布区域，会根据宽高比的变化来放大缩小画布，可能有黑边<span class="token punctuation">(</span>缩放系数 <span class="token operator">=</span> Mathf.Min<span class="token punctuation">(</span>屏幕宽/参考分辨率宽，屏幕高/参考分辨率高<span class="token punctuation">))</span><span class="token punctuation">;</span>    Shrink：水平或垂直裁剪画布区域，会根据宽高比的变化来放大缩小画布，可能会裁剪<span class="token punctuation">(</span>缩放系数 <span class="token operator">=</span> Mathf.Max<span class="token punctuation">(</span>屏幕宽/参考分辨率宽，屏幕高/参考分辨率高<span class="token punctuation">))</span><span class="token punctuation">;</span>    Match Width Or Height：以宽高或者二者的平均值作为参考来缩放画布区<span class="token punctuation">(</span>在取平均值之前，我们先取相对宽度和高度的对数,float logWidth <span class="token operator">=</span> Mathf.Log<span class="token punctuation">(</span>屏幕宽 / 参考分辨率宽, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>float logHeight <span class="token operator">=</span> Mathf.Log<span class="token punctuation">(</span>屏幕高 / 参考分辨率高, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>,在对数空间中变换是为了获得更好的性能以及更准确的结果,float logWeightedAverage <span class="token operator">=</span> Mathf.Lerp<span class="token punctuation">(</span>logWidth, logHeight, m_MatchWidthOrHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>scaleFactor <span class="token operator">=</span> Mathf.Pow<span class="token punctuation">(</span><span class="token number">2</span>, logWeightedAverage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恒定像素模式"><a href="#恒定像素模式" class="headerlink" title="恒定像素模式"></a>恒定像素模式</h3><p>  无论屏幕大小如何，UI始终保持相同像素大小。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Scale Factor：缩放系数，按此系数缩放画布中的所有UI元素；<span class="token number">2</span>.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素），图片设置中的Pixels Per Unit设置，会和该参数一起参与计算；计算公式：UI原始尺寸 <span class="token operator">=</span> 图片大小（像素）/ <span class="token punctuation">(</span>Pixels Per Unit / Reference Pixels Per Unit）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恒定物理模式"><a href="#恒定物理模式" class="headerlink" title="恒定物理模式"></a>恒定物理模式</h3><p>  无论屏幕大小和分辨率如何，UI元素始终保持相同物理大小（DPI：（Dots Per Inch，每英寸点数）图像每英寸长度内的像素点数）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Physical Unit：物理单位，使用的物理单位种类<span class="token number">2</span>.Fallback Screen DPI：备用DPI，当找不到设备DPI时，使用此值<span class="token number">3</span>.Default Sprite DPI：默认图片DP单位种类 与1英寸的关系：Centimeters（厘米cm） <span class="token number">2.54</span>Millimeters（毫米mm） <span class="token number">25.4</span>Inches（英寸） <span class="token number">1</span>Points（点） <span class="token number">72</span>Picas（皮卡） 计算公式：根据DPI算出新的Reference Pixels Per Unit （单位参考像素）新单位参考像素 <span class="token operator">=</span>单位参考像素 * Physical Unit / Default Sprite DPI再使用模式一：恒定像素模式的公式进行计算原始尺寸 <span class="token operator">=</span>图片大小（像素）/ <span class="token punctuation">(</span>Pixels Per Unit / 新单位参考像素<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##3D模式<br>  当Canvas的渲染模式设置为，世界空间3D渲染模式时，这时Canvas Scaler 的缩放模式会强制变为，World 3D世界模式；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Dynamic Pixels Per Unit：UI中动态创建的位图（例如文本）中，单位像素数（类似密度）<span class="token number">2</span>.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Graphic-Raycaster图像射线投射器"><a href="#Graphic-Raycaster图像射线投射器" class="headerlink" title="Graphic Raycaster图像射线投射器"></a>Graphic Raycaster图像射线投射器</h2><p>  Graphic Raycaster意思是图形射线投射器,它是用于检测UI输入事件的射线发射器,它主要负责通过射线检测玩家和UI元素的交互,判断是否点击到了UI元素;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Ignore Reversed Graphics：是否忽略反转图形<span class="token number">2</span>.Blocking Objects：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效）<span class="token number">3</span>.Blocking Mask：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-GraphicRaycaster.html">图形射线投射器 - Unity 手册 (unity3d.com)</a></p><h2 id="RectTransform"><a href="#RectTransform" class="headerlink" title="RectTransform"></a>RectTransform</h2><p>  RectTransform意思是矩形变换，它继承于Transform，是专门用于处理UI元素位置大小相关的组件，Transform组件只处理位置、角度、缩放，RectTransform在此基础上加入了矩形相关，将UI元素当做一个矩形来处理，加入了中心点、锚点、长宽等属性，其目的是更加方便的控制其大小以及分辨率自适应中的位置适应；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Pivot：轴心<span class="token punctuation">(</span>中心<span class="token punctuation">)</span>点，取值范围0~1<span class="token number">2</span>.Anchors<span class="token punctuation">(</span>相对父矩形锚点<span class="token punctuation">)</span>：<span class="token number">3</span>.Min是矩形锚点范围X和Y的最小值<span class="token number">4</span>.Max是矩形锚点范围X和Y的最大值取值范围都是0~1<span class="token number">5</span>.Pos<span class="token punctuation">(</span>X,Y,Z<span class="token punctuation">)</span>：轴心点<span class="token punctuation">(</span>中心点<span class="token punctuation">)</span>相对锚点的位置<span class="token number">6</span>.Width/Height：矩形的宽高<span class="token number">7</span>.Left/Top/Right/Bottom：矩形边缘相对于锚点的位置；当锚点分离时会出现这些内容<span class="token number">8</span>.Rotation：围绕轴心点旋转的角度<span class="token number">9</span>.Scale：缩放大小<span class="token number">10</span>.Blueprint Mode（蓝图模式）:启用后，编辑旋转和缩放不会影响矩形，只会影响显示内容<span class="token number">11</span>.Raw Edit Mode（原始编辑模式）:启用后，改变轴心和锚点值不会改变矩形位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-RectTransform.html">矩形变换 - Unity 手册 (unity3d.com)</a></p><h2 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h2><p>  Event System意思是事件系统，它是用于管理玩家的输入事件并分发给各UI控件，它是事件逻辑处理模块，所有的UI事件都通过EventSystem组件中轮询检测并做相应的执行，它类似一个中转站，和许多模块一起共同协作，如果没有它，所有点击、拖曳等等行为都不会被响应；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.First Selected：首先选择的游戏对象，可以设置游戏一开始的默认选择<span class="token number">2</span>.Send Navigation Events：是否允许导航事件（移动/按下/取消）<span class="token number">3</span>.Drag Threshold：拖拽操作的阈值（移动多少像素算拖拽）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-EventSystem.html">事件系统管理器 - Unity 手册 (unity3d.com)</a></p><h2 id="Standalone-Input-Module"><a href="#Standalone-Input-Module" class="headerlink" title="Standalone Input Module"></a>Standalone Input Module</h2><p>  Standalone Input Module意思是独立输入模块，它主要针对处理鼠标/键盘/控制器/触屏（新版Unity）的输入，输入的事件通过EventSystem进行分发，它依赖于EventSystem组件，他们两缺一不可；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Horizontal Axis：水平轴按钮对应的热键名（该名字对应Input管理器）<span class="token number">2</span>.Vertical Axis：垂直轴按钮对应的热键名（该名字对应Input管理器）<span class="token number">3</span>.Submit Button：提交（确定）按钮对应的热建名（该名字对应Input管理器）<span class="token number">4</span>.Cancel Button：取消按钮对应的热建名（该名字对应Input管理器）<span class="token number">5</span>.Input Actions Per Second：每秒允许键盘/控制器输入的数量<span class="token number">6</span>.Repeat Delay：每秒输入操作重复率生效前的延迟时间<span class="token number">7</span>.ForceModule Active：是否强制模块处于激活状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-StandaloneInputModule.html">独立输入模块 - Unity 手册 (unity3d.com)</a></p><h1 id="三大基础控件"><a href="#三大基础控件" class="headerlink" title="三大基础控件"></a>三大基础控件</h1><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>  是UGUI中用于显示文本的关键组件，可以加OutLine组件和Shadow组件配合。</p><p>Text参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Text：文本显示内容Font：字体FontStyle：字体样式Normal：普通Bold：加粗Italic：斜体Bold And Italic：加粗 + 斜体Font Size：字体大小Line Spacing：行之间的垂直间距Rich Text：是否开启富文本Alignment：对其方式Align By Geometry：使用字形集合形状范围进行水平对其，而不是字形指标Horizontal Overflow：处理文本太宽无法放入矩形范围内时的处理方式Wrap：包裹模式-字体始终在矩形范围内，会自动换行Overflow：溢出模式-字体可以溢出矩形框Vertical Overflow：处理文本太高无法放入矩形范围内时的处理方式Truncate：截断模式-字体始终在矩形范围内，超出部分裁剪Overflow：溢出模式-字体可以溢出矩形框Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整字体大小MinSize：最小多小MaxSize：最大多大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>富文本:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">加粗<span class="token operator">&lt;</span>b<span class="token operator">&gt;</span>文本内容<span class="token operator">&lt;</span>/b<span class="token operator">&gt;</span>斜体<span class="token operator">&lt;</span>i<span class="token operator">&gt;</span>文本内容<span class="token operator">&lt;</span>/i<span class="token operator">&gt;</span>大小<span class="token operator">&lt;</span>size<span class="token operator">=</span><span class="token number">5</span><span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>文本内容<span class="token operator">&lt;</span>/size<span class="token operator">&gt;</span>颜色:<span class="token operator">&lt;</span>color<span class="token operator">=</span><span class="token comment">#ff0000ff&gt;文本内容&lt;/size&gt;</span><span class="token operator">&lt;</span>color<span class="token operator">=</span>red<span class="token operator">&gt;</span>文本内容<span class="token operator">&lt;</span>/size<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Text.html">文本 (Text) - Unity 手册 (unity3d.com)</a></p><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>  是UGUI中用于显示精灵图片的关键组件，除了背景图等大图，一般都使用Image来显示UI中的图片元素。<br>Image参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Source Image：图片来源（图片类型必须是”精灵“类型）Color：图像的颜色Material：图像的材质（一般不修改，会使用UI的默认材质）Raycast Target：是否作为射线检测的目标（如果不勾选将不会响应射线检测）Maskable：是否能被遮罩（之后结合遮罩相关知识点进行讲解）Image Type：图片类型Simple-普通模式，均匀缩放整个图片Sliced-切片模式，9宫格拉伸，只拉伸中央十字区域Pixels Per UnitMultiplier：每单位像素乘数Fill Center：中心填充Tiled-平铺模式，重复平铺中央部分Filled-填充模式Fill Method：填充方式Fill Origin：填充原点Fill Amount：填充量Clockwise：顺时针方向Use Sprite Mesh：使用精灵网格，勾选的话Unity会帮我们生成图片网格Preserve Aspect：确保图像保持其现有尺寸Set Native Size：设置为图片资源的原始大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Image.html">图像 (Image) - Unity 手册 (unity3d.com)</a></p><h2 id="RawImage"><a href="#RawImage" class="headerlink" title="RawImage"></a>RawImage</h2><p>  它和Image的区别是 一般RawImage用于显示大图(背景图，不需要打入图集的图片，网络下载的图等等)。</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-RawImage.html">原始图像 (Raw Image) - Unity 手册 (unity3d.com)</a></p><h1 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h1><h2 id="Button按钮控件"><a href="#Button按钮控件" class="headerlink" title="Button按钮控件"></a>Button按钮控件</h2><p>  是UGUI中用于处理玩家按钮相关交互的关键组件。<br>参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果None：没有状态变化效果ColorTint：用颜色表示不同状态的变化TargetGraphic：控制的目标图形Normal Color：正常状态颜色Highlighted Color：鼠标进入时显示高亮颜色Pressed Color：按下颜色Selected Color：选中的颜色Disabled Color：禁用时的颜色Color Multiplier：颜色倍增器，过渡颜色乘以该值FadeDuration：衰减持续时间，从一个状态进入另一个状态时需要的时间Sprite Swap：用图片表示不同状态的变化Highlighted Sprite：鼠标进入时图片Pressed Sprite：按下时图片Selected Color：选中时的颜色Disabled Sprite：禁用时显示的图片Animation：用动画表示不同状态的变化Normal Trigger：正常动画触发器Highlighted Trigger：鼠标进入状态时触发器Pressed Trigger：按下时触发器Selected Trigger：选中时触发器Disabled Trigger：禁用时触发器Navigation：导航模式，可以设置UI元素如何在播放模式中控制导航None：无键盘导航Horizontal：水平导航Verticval：垂直导航Automatic：自动导航Explicit：指定周边控件进行导航Visualize:可以在场景窗口看到导航连线OnClick：单击（按下再抬起）执行的函数列表<span class="token punctuation">(</span>btn.onClick.AddListenter<span class="token punctuation">(</span>事件<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Button.html">按钮 (Button) - Unity 手册 (unity3d.com)</a></p><h2 id="Toggle开关控件"><a href="#Toggle开关控件" class="headerlink" title="Toggle开关控件"></a>Toggle开关控件</h2><p>  是UGUI中用于处理玩家单选框多选框相关交互的关键组件，可以通过配合ToggleGroup组件制作为单选框，默认创建的Toggle由4个对象组成，父对象——Toggle组件依附，子对象——背景图（必备）、选中图（必备）、说明文字（可选）。</p><p>Toggle参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>IsOn：当前是否处于打开状态Toggle Transition：在开关值变化时的过渡方式None：无任何过渡，直接显示隐藏Fade：淡入淡出Graphic：用于表示选中状态的图片Group：单选框分组<span class="token punctuation">(</span>需要挂载Toggle Group组件<span class="token punctuation">)</span>Allow Switch Off：是否允许不选中任何一个单选框（注意：单选框分组组件可以挂载在任何对象上，只需要将其和一组的单选框关联即可）OnValueChanged：开关状态变化时执行的函数列表（ tog.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span><span class="token punctuation">;</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Toggle.html">开关 (Toggle) - Unity 手册 (unity3d.com)</a></p><h2 id="InputField文本输入控件"><a href="#InputField文本输入控件" class="headerlink" title="InputField文本输入控件"></a>InputField文本输入控件</h2><p>  是UGUI中用于处理玩家文本输入相关交互的关键组件，默认创建的InputField由3个对象组成，父对象——InputField组件依附对象 以及 同时在其上挂载了一个Image作为背景图，子对象——文本显示组件（必备）、默认显示文本组件（必备）。<br> InputField参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>TextComponent：用于关联显示输入内容的文本组件Text：输入框的起始默认值Character Limit：可以输入字符长度的最大值（0默认无限）Content Type：输入的字符类型限制Standard：标准模式；可以输入任何字符Autocorrected：自动更正模式；跟踪未知单词，向用户建议合适的替换候选词Integer Number：整数模式；用户只能输入整数Decimal Number：十进制数模式；用于只能输入数字包括小数Alphanumeric：字母数字模式；只能输入字母和数字Name：名字模式；自动将每个单子首字母大写Email Address：邮箱地址模式；允许最多输入一个@符号组成的字符和数字字符串Password：密码模式；用星号隐藏输入的字符，允许使用字符Pin：别针模式；用星号隐藏输入的字符，只允许输入整数Custom：自定义模式；允许自定义行类型，输入类型，键盘类型和字符验证Line Type：行类型，定义文本格式Single Line：只允许单行显示Multi Line Submit：允许使用多行。仅在需要时使用新的一行Multi Line NewLine：允许使用多行。用户可以按回车键空行Placeholder：关联用于显示初始内容文本控件Caret Blink Rate：光标闪烁速率Caret Width：光标宽Custom Caret Color：自定义光标颜色Selection Color：批量选中的背景颜色Hide Mobile Input：隐藏移动设备屏幕上键盘，仅适用于IOSRead Only：只读，不能改OnValueChanged：滑动条值改变时执行的函数列表input.onValueChanged.AddListener<span class="token punctuation">(</span>事件）input.onEndEdit.AddListener<span class="token punctuation">(</span>事件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-InputField.html">输入字段 (Input Field) - Unity 手册 (unity3d.com)</a></p><h2 id="Slider滑动条控件"><a href="#Slider滑动条控件" class="headerlink" title="Slider滑动条控件"></a>Slider滑动条控件</h2><p>  Slider是滑动条组件，默认创建的Slider由4组对象组成，父对象——Slider组件依附的对象，子对象——背景图、进度图、滑动块三组对象。</p><p>Slider参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>FillRect：用于填充的进度条图形Handle Rect：用于滑动的滑动块图形Direction：滑动条值增加的方向Left To Right：从左到右Right To Left：从右到左Bottom To Top：从下到上Top To Bottom：从上到下Min Value 和 Max Value：最小值和最大值，滑动滚动条时值从最小到最大之间变化（左右、上下极值）Whole Numbers：是否约束为整数值变化Value：当前滑动条代表的数值OnValueChanged：滑动条值改变时执行的函数列表（ s.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Slider.html">滑动条 (Slider) - Unity 手册 (unity3d.com)</a></p><h2 id="ScrollBar滚动条控件"><a href="#ScrollBar滚动条控件" class="headerlink" title="ScrollBar滚动条控件"></a>ScrollBar滚动条控件</h2><p>  是UGUI中用于处理滚动条相关交互的关键组件，默认创建的Scrollbar由2组对象组成，父对象——Scrollbar组件依附的对象，子对象——滚动块对象，一般情况下我们不会单独使用滚动条 ，都是配合ScrollView滚动视图来使用。</p><p>ScrollBar参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Handle Rect：关联滚动块图形对象Direction：滑动条值增加的方向Left To Right：从左到右Right To Left：从右到左Bottom To Top：从下到上Top To Bottom：从上到下Value：滚动条初始位置值（0~1）Value：滚动块在条中的比例大小（0~1）Number Of Steps：允许可以滚动多少次（不同滚动位置的数量）OnValueChanged：滚动条值改变时执行的函数列表（   sb.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Scrollbar.html">滚动条 (Scrollbar) - Unity 手册 (unity3d.com)</a></p><h2 id="ScrollView滚动视图控件"><a href="#ScrollView滚动视图控件" class="headerlink" title="ScrollView滚动视图控件"></a>ScrollView滚动视图控件</h2><p>  是UGUI中用于处理滚动视图相关交互的关键组件，默认创建的ScrollRect由4组对象组成，父对象——ScrollRect组件依附的对象 还有一个Image组件 最为背景图，子对象——Viewport控制滚动视图可视范围和内容显示、Scrollbar Horizontal 水平滚动条、Scrollbar Vertical 垂直滚动条。</p><p>ScrollRect参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Content：控制滚动视图显示内容的父对象，它的尺寸有多大<span class="token punctuation">(</span>滚动视图就能拖多远<span class="token punctuation">)</span>Horizontal：启用水平滚动Vertical：启用垂直滚动Movement Type：滚动视图元素的运动类型。主要控制拖动时的反馈效果Unrestricted（一般不使用）：不受限制，随便拖动Elastic（常用）：回弹效果，当滚出边缘后，会弹回边界Elasticity：回弹系数，控制回弹效果。值越大回弹越慢Clamped：夹紧效果，始终限制在范围内，没有回弹效果Inertia：移动惯性，如果开启，松开鼠标后会有一定的移动惯性Deceleration Rate：减速率（0~1），0没有惯性，1不会停止Scroll Sensitivity：滚轮（鼠标中间）和触摸板（笔记本）的滚动事件敏感性Viewport：关联滚动视图内容视口对象Horizontal Scrollbar：关联水平滚动条Visibility：是否在不需要时自动隐藏等模式Permanent：一直显示滚动条Auto Hide：自动隐藏滚动条Auto Hide And Expand Viewport：自动隐藏滚动条并且自动拓展内容视口Spacing：滚动条和视口之间的间隔空间OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dropdow下拉列表控件"><a href="#Dropdow下拉列表控件" class="headerlink" title="Dropdow下拉列表控件"></a>Dropdow下拉列表控件</h2><p>  是UGUI中用于处理下拉列表相关交互的关键组件，默认创建的DropDown由4组对象组成，父对象——DropDown组件依附的对象 还有一个Image组件 作为背景图，子对象——Label是当前选项描Arrow右侧小箭头、Template下拉列表选单。</p><p>Dropdow参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Template：关联下拉列表对象Caption Text：关联显示当前选择内容的文本组件Caption Image：关联显示当前选择内容的图片组件Item Text：关联下拉列表选项用的文本控件Item Image：关联下拉列表选项用的图片控件Value：当前所选选项的索引值Alpha Fada Speed：下拉列表窗口淡入淡出的速度Options：存在的选项列表OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Dropdown.html">下拉选单 (Dropdown) - Unity 手册 (unity3d.com)</a></p><h1 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h1><h2 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h2><p>  打图集注意的是在游戏场景插入同图集的图会打断批处理，即使在同一个图集也不行，所以要额外注意UI元素的排列顺序。</p><h2 id="事件监听接口"><a href="#事件监听接口" class="headerlink" title="事件监听接口"></a>事件监听接口</h2><h2 id="EventTrigger事件触发器"><a href="#EventTrigger事件触发器" class="headerlink" title="EventTrigger事件触发器"></a>EventTrigger事件触发器</h2><h2 id="屏幕坐标转UI相对坐标"><a href="#屏幕坐标转UI相对坐标" class="headerlink" title="屏幕坐标转UI相对坐标"></a>屏幕坐标转UI相对坐标</h2><h2 id="遮罩Mask"><a href="#遮罩Mask" class="headerlink" title="遮罩Mask"></a>遮罩Mask</h2><h2 id="模型和粒子显示在UI之前"><a href="#模型和粒子显示在UI之前" class="headerlink" title="模型和粒子显示在UI之前"></a>模型和粒子显示在UI之前</h2><h2 id="异形按钮"><a href="#异形按钮" class="headerlink" title="异形按钮"></a>异形按钮</h2><h2 id="自动布局组件"><a href="#自动布局组件" class="headerlink" title="自动布局组件"></a>自动布局组件</h2><h2 id="画布组Canvas-Group"><a href="#画布组Canvas-Group" class="headerlink" title="画布组Canvas Group"></a>画布组Canvas Group</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;六大基础组件&quot;&gt;&lt;a href=&quot;#六大基础组件&quot; class=&quot;headerlink&quot; title=&quot;六大基础组件&quot;&gt;&lt;/a&gt;六大基础组件&lt;/h1&gt;&lt;p&gt;1.Canvas对象上依附的：&lt;br&gt;Canvas：画布组件，主要用于渲染UI控件&lt;br&gt;Canvas Sc</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="GUI解决方案" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="GUI解决方案" scheme="http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关_GUI</title>
    <link href="http://wwy010518.github.io/posts/1540.html"/>
    <id>http://wwy010518.github.io/posts/1540.html</id>
    <published>2020-01-10T13:00:00.000Z</published>
    <updated>2022-02-11T13:33:05.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GUI概叙"><a href="#GUI概叙" class="headerlink" title="GUI概叙"></a>GUI概叙</h1><h1 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h1><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h2><h2 id="多选框"><a href="#多选框" class="headerlink" title="多选框"></a>多选框</h2><h2 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h2><h2 id="拖动条"><a href="#拖动条" class="headerlink" title="拖动条"></a>拖动条</h2><h2 id="图像绘制和框"><a href="#图像绘制和框" class="headerlink" title="图像绘制和框"></a>图像绘制和框</h2><h1 id="复合控件"><a href="#复合控件" class="headerlink" title="复合控件"></a>复合控件</h1><h2 id="工具栏和选择网格"><a href="#工具栏和选择网格" class="headerlink" title="工具栏和选择网格"></a>工具栏和选择网格</h2><h2 id="滚动视图和分组"><a href="#滚动视图和分组" class="headerlink" title="滚动视图和分组"></a>滚动视图和分组</h2><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h1 id="自定义整体样式"><a href="#自定义整体样式" class="headerlink" title="自定义整体样式"></a>自定义整体样式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GUI概叙&quot;&gt;&lt;a href=&quot;#GUI概叙&quot; class=&quot;headerlink&quot; title=&quot;GUI概叙&quot;&gt;&lt;/a&gt;GUI概叙&lt;/h1&gt;&lt;h1 id=&quot;基础控件&quot;&gt;&lt;a href=&quot;#基础控件&quot; class=&quot;headerlink&quot; title=&quot;基础控件&quot;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="GUI解决方案" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="GUI解决方案" scheme="http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-AnimationPlayable</title>
    <link href="http://wwy010518.github.io/posts/03009.html"/>
    <id>http://wwy010518.github.io/posts/03009.html</id>
    <published>2019-11-13T13:00:00.000Z</published>
    <updated>2022-03-02T12:46:09.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
    <category term="Playable" scheme="http://wwy010518.github.io/tags/Playable/"/>
    
  </entry>
  
  <entry>
    <title>Unity核心</title>
    <link href="http://wwy010518.github.io/posts/1539.html"/>
    <id>http://wwy010518.github.io/posts/1539.html</id>
    <published>2019-10-05T13:00:00.000Z</published>
    <updated>2022-02-11T13:18:55.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2D相关"><a href="#2D相关" class="headerlink" title="2D相关"></a>2D相关</h1><h2 id="图片导入设置"><a href="#图片导入设置" class="headerlink" title="图片导入设置"></a>图片导入设置</h2><h3 id="Unity支持的图片格式"><a href="#Unity支持的图片格式" class="headerlink" title="Unity支持的图片格式"></a>Unity支持的图片格式</h3><p>BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大;</p><p>TIF:基本不损失图片信息的图片格式，缺点是体积大;</p><p>JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道;</p><p>PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道;</p><p>TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道;</p><p>PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面;</p><p>其它:还支持,EXR、GIF、HDR、IFF、PICT等等,其中Unity最常用的图片格式是JPG、PNG、TGA三种格式;</p><h3 id="纹理类型设置（Texture-Type）"><a href="#纹理类型设置（Texture-Type）" class="headerlink" title="纹理类型设置（Texture Type）"></a>纹理类型设置（Texture Type）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Default-默认纹理，大部分导入的模型贴图都是该类型sRGB<span class="token punctuation">(</span>Color Texture<span class="token punctuation">)</span>：启用可以将纹理存储在伽马空间<span class="token punctuation">(</span>见下图一<span class="token punctuation">)</span>中（对每一个像素做一次幂函数运算）Alpha Source：指定如何生成纹理的Alpha通道None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道Input Texture Alpha：输入纹理中的AlphaFrom Gray Scale：从输入纹理RGB值的平均值生成AlphaAlpha Is Transparency：启用可以避免边缘上的过滤瑕疵<span class="token number">2</span>.Normal map-法线贴图格式：法线贴图说明：就是在原物体的凹凸表面的每个点上均作法线法线就是垂直于某个点的切线的方向向量Create From Grayscale：启用此属性可以从灰度高度贴图创建法线贴图Bumpiness：控制凹凸程度，值越大凹凸感越强Filtering：如何计算凹凸值Smooth：使用标准算法生成法线贴图Sharp：生成比标准模式更锐利的法线贴图<span class="token number">3</span>.Editor GUI and Legacy GUI：一般在编辑器中或者GUI上使用的纹理<span class="token number">4</span>.Sprite（2D and UI）：2D游戏或者UGUI中使用的格式Sprite Mode：图像中提取精灵图形的方式Single：按原样使用精灵图像Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片Polygon：网格精灵模式Pixels Per Unit：世界空间中的一个距离单位对应多少像素MeshType：网格类型；只有Single和Multiple模式才支持Full Rect：创建四边形，将精灵显示在四边形上Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状；任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是；Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小Pivot：精灵图片的轴心点，Single模式才有此选项，对应九宫格布局的九个点，还可以自定义Generate Physics Shape：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状，只有Single 和Multiple模式才可使用Sprite Editor：编辑Sprite，需要安装2D Sprite包，之后单独讲解<span class="token number">5</span>.Cursor：自定义光标<span class="token number">6</span>.Cookie：光源剪影格式Light Type：应用的光源类型，一般点光源的剪影需要设置为立方体纹理，方向光和聚光灯的剪影设置为2D纹理；Spotlight：聚光灯类型，需要边缘纯黑色纹理Directional：方向光，平铺纹理Point：点光源，需要设置为立方体形状<span class="token number">7</span>.Lightmap：光照贴图格式<span class="token number">8</span>.Single Channel：纹理只需要单通道的格式Channel：希望将纹理处理为Alpha还是Red通道Alpha：使用Alpha通道，不允许进行压缩Red：使用红色通道<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图一：线性和伽马颜色空间说明<br><img src="https://s4.ax1x.com/2022/01/28/7x84ij.png" alt="线性和伽马颜色空间说明"></p><h3 id="纹理形状（Texture-Shape）"><a href="#纹理形状（Texture-Shape）" class="headerlink" title="纹理形状（Texture Shape）"></a>纹理形状（Texture Shape）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.2D：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上<span class="token punctuation">;</span><span class="token number">2</span>.Cube：立方体贴图，主要用于天空盒和反射探针Mapping：如何将纹理投影到游戏对象上Auto：根据纹理信息创建布局<span class="token number">6</span> Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像Latitude-Longitude Layout：将纹理映射到2D维度/经度Mirrored Ball：将纹理映射到类似球体的立方体贴图上Convolution Type：纹理的过滤类型None：无过滤Specular：将立方体作为反射探针Diffuse：将纹理进行过滤表示辐照度，可作为光照探针Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理高级设置"><a href="#纹理高级设置" class="headerlink" title="纹理高级设置"></a>纹理高级设置</h3><p>  高级设置主要是纹理的一些尺寸规则、读写规则、以及MipMap相关设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Non-Power of <span class="token number">2</span>：如果纹理尺寸非2的幂如何处理<span class="token punctuation">(</span>为什么纹理要设置为2的N次方：因为图形学规则，纹理必须是2的幂尺寸<span class="token punctuation">)</span>None：纹理尺寸大小保持不变To nearest：将纹理缩放到最接近2的幂的大小（注意：PVRTC格式要求纹理为正方形）To larger：将纹理缩放到最大尺寸大小值的2的幂的大小To smaller：将纹理缩放到最小尺寸大小值的2的幂的大小<span class="token number">2</span>.Read/Write Enabled：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启）<span class="token number">3</span>.Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap<span class="token number">4</span>.Generate Mip Maps：允许生成MipMap<span class="token punctuation">(</span>开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片,在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率<span class="token punctuation">)</span><span class="token punctuation">;</span>Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘Mip Map Filtering：优化图像质量的过滤方法Box：随着尺寸减小，级别更加平滑Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率Alpha Cutoff Value：覆盖率参考值Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理平铺拉伸设置"><a href="#纹理平铺拉伸设置" class="headerlink" title="纹理平铺拉伸设置"></a>纹理平铺拉伸设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Wrap Mode：平铺纹理时的方式Repeat：在区块中重复纹理Clamp：拉伸纹理的边缘Mirror：在每个整数边界上镜像纹理以创建重复图案Mirror Once：镜像纹理一次，然后将拉伸边缘纹理Per-axis：单独控制如何在U轴和V轴上包裹纹理Filter Mode：纹理在通过3D变化拉伸时如何进行过度Point：纹理在靠近时变为块状Bilinear：纹理在靠近时变得模糊Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理平台打包设置（非常重要）"><a href="#纹理平台打包设置（非常重要）" class="headerlink" title="纹理平台打包设置（非常重要）"></a>纹理平台打包设置（非常重要）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Max Size：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内<span class="token number">2</span>.Resize Algorithm：当纹理尺寸大于指定的Max Size时，使用的缩小算法Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多Format：纹理格式（各平台支持的格式有所不同，如果选择Automatic，会根据平台使用默认设置）都支持的格式:下图一移动端和网页端特有格式：下图二不同平台单独进行设置：IOS：选择默认的纹理压缩设置 <span class="token punctuation">(</span>PVRTC<span class="token punctuation">)</span> 可获得更大的兼容性。如果您的应用程序不包含 OpenGL ES <span class="token number">2</span> 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。Andorid：推荐如下图三由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包；构建一个以 OpenGL ES <span class="token number">3</span> 为目标的 APK，访问 Android 的 Player Settings，菜单：Edit <span class="token operator">&gt;</span> Project Settings <span class="token operator">&gt;</span>Player Settings，然后选择 Android 类别），向下滚动到 Graphics APIs 部分，确保 OpenGL ES <span class="token number">2</span> 不在列表中，构建 APK，（菜单：File <span class="token operator">&gt;</span> Build Settings，然后单击 Build）；构建一个以 OpenGL ES <span class="token number">2</span> 为目标的单独 APK，访问 Android Player Settings，向下滚动到 Graphics APIs 部分，在列表中添加 OpenGL ES <span class="token number">2</span>，并删除 OpenGL ES <span class="token number">3</span> 和 Vulkan，构建 APK。<span class="token number">3</span>.Compression：选择纹理的压缩类型，帮助Unity正确选择压缩格式，会根据平台和压缩格式的可用性进行压缩；None：不压缩纹理Low Quality：以低质量格式压缩纹理Normal Quality：以标准格式压缩纹理High Quality：以高质量格式压缩纹理<span class="token number">4</span>.Use Crunch Compression：启用后，使用Crunch压缩，Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快；Compressor Quality:压缩质量条，质量越高意味着纹理越大，压缩事件越长。<span class="token number">5</span>.Split Alpha Channel：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。<span class="token number">6</span>.Override ETC2 fallback：不支持ETC2压缩的设备上，使用的格式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图一：都支持的格式<br><img src="https://s4.ax1x.com/2022/01/28/7xag9e.png" alt="都支持的格式"><br>图二：移动端和网页端特有格式<br><img src="https://s4.ax1x.com/2022/01/28/7xaoAf.png" alt="移动端和网页端特有格式"><br>图三：移动端和网页端特有格式<br><img src="https://s4.ax1x.com/2022/01/28/7xdi34.png" alt="移动端和网页端特有格式"></p><h2 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h2><h3 id="Sprite-Editor"><a href="#Sprite-Editor" class="headerlink" title="Sprite Editor"></a>Sprite Editor</h3><p>1.Single图片编辑：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右下角设置窗口：Name：名字Position：在图片中的偏移位置和宽高Border：边框，用于设置九宫格的4条边Pivot：轴心（中心）点位置Pivot Unit Mode：轴心点单位模式Normalized：标准化模式，0~1Pixels：像素模式Custom Pivot：自定义轴心点（OutLine）自定义边缘线和<span class="token punctuation">(</span>Physics<span class="token punctuation">)</span>自定义物理形状：Snap：将控制点贴近在最近的像素Outline Tolerance：轮廓点的复杂性和准确性，0~1值越大轮廓点越多，越准确Generate：生成网格轮廓        //1.Sprite Editor        //  基础图片设置（右下角窗口）        //  主要用于设置单张图片的基础属性        //2.Custom Outline（决定渲染区域）        //  自定义边缘线设置，可以自定义精灵网格的轮廓形状        //  默认情况下不修改都是在矩形网格上渲染,边缘外部透明区域会被渲染，浪费性能        //  使用自定义轮廓，可以调小透明区域，提高性能        //3.Custom Physics Shape（决定碰撞判断区域）        //  自定义精灵图片的物理形状，主要用于设置需要物理碰撞判断的2D图形        //  它决定了之后产生碰撞检测的区域        //4.Secondary Textures<span class="token punctuation">(</span>为图片添加特殊效果<span class="token punctuation">)</span>        //  次要纹理设置，可以将其它纹理和该精灵图片关联        //  着色器可以得到这些辅助纹理然后用于做一些效果处理        //  让精灵应用其它效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.Multiple图集元素分割：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">自动分割<span class="token punctuation">(</span>Automatic<span class="token punctuation">)</span>：Pivot：单张图片轴心点位置Custom Pivot：自定义轴心点Method：如何处理现有对象Delete Existing：替换掉已经选择的任何矩形Smart：尝试创建新矩形同时保留或调整现有矩形Safe：添加新矩形而不更改任何已经存在的矩形按单元格大小分割<span class="token punctuation">(</span>Grid By Cell Size<span class="token punctuation">)</span>：Pixel Size：单元格宽高Offset：偏移位置Padding：和边缘的偏移位置Keep Empty Rects：是否保留空矩形按单元格大小分割<span class="token punctuation">(</span>Grid By Cell Count<span class="token punctuation">)</span>增加参数Column <span class="token operator">&amp;</span> Row：行列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.Polygon多边形编辑：</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/SpriteEditor.html">Sprite Editor - Unity 手册 (unity3d.com)</a></p><h3 id="Sprite-Renderer"><a href="#Sprite-Renderer" class="headerlink" title="Sprite Renderer"></a>Sprite Renderer</h3><p>  所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的。</p><p>参数讲解:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Sprite：渲染的精灵图片<span class="token number">2</span>.Color：定义着色，一般没有特殊需求不会修改<span class="token number">3</span>.Filp：水平或竖直翻转精灵图片<span class="token number">4</span>.Draw Mode：绘制模式，当尺寸变化时的缩放方式Simple：简单模式，缩放时整个图像一起缩放Sliced：切片模式，9宫格切片模式，十字区域缩放，4个角不变化,一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect）Tiled：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect）Continuous：当尺寸变化时，中间部分将均匀平铺Adaptive：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺<span class="token number">5</span>.Mask Interaction：与精灵遮罩交互时的方式None：不与场景中任何精灵遮罩交互Visible inside Mask：精灵遮罩覆盖的地方可见，而遮罩外部不可见Visible Outside Mask：精灵遮罩外部的地方可见，而遮罩覆盖处不可见<span class="token number">6</span>.Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改<span class="token number">7</span>.Material：材质，可以使用一些自定义材质来显示一些特殊效果,一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse<span class="token number">8</span>.Additional Settings：高级设置Sorting Layer：排序层选择Order <span class="token keyword">in</span> Layer：层级序列号，数值越大约会显示在前面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteRenderer.html">Sprite Renderer - Unity 手册 (unity3d.com)</a></p><p>API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 代码设置        GameObject obj = new GameObject();        SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;();        //动态的改变图片        sr.sprite = Resources.Load&lt;Sprite&gt;("dead1");        //动态的加载 图集中的图        Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;("RobotBoyIdleSprite");        sr.sprite = sprs[10];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/SpriteRenderer.html">UnityEngine.SpriteRenderer - Unity 脚本 API (unity3d.com)</a></p><h3 id="Sprite-Creator"><a href="#Sprite-Creator" class="headerlink" title="Sprite Creator"></a>Sprite Creator</h3><p>  我们可以利用Sprite Editor的多边形工具创造出各种多边形,Unity也为我们提供了现成的一些多边形,它的主要作用是2D游戏的替代资源,在等待美术出资源时我们可以用他们作为替代品,有点类似Unity提供的自带几何体(在Project窗口右键创建各种形状的Sprite精灵图片).</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/SpriteCreator.html">Sprite Creator - Unity 手册 (unity3d.com)</a></p><h3 id="Sprite-Mask"><a href="#Sprite-Mask" class="headerlink" title="Sprite Mask"></a>Sprite Mask</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Sprite：遮罩图片<span class="token punctuation">;</span><span class="token number">2</span>.Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）<span class="token punctuation">;</span><span class="token number">3</span>.Custom Range：自定义遮罩范围,开启后可以设置遮罩的范围，按照排序层来划分<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/SpriteMask.html">UnityEngine.SpriteMask - Unity 脚本 API (unity3d.com)</a></p><h3 id="Sorting-Group"><a href="#Sorting-Group" class="headerlink" title="Sorting Group"></a>Sorting Group</h3><p>  顾名思义，SortingGroup是排序分组的意思,它的主要作用就是对多个精灵图片进行分组排序,Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样,主要作用是对于需要分层的2D游戏用于整体排序。</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SortingGroup.html">排序组 - Unity 手册 (unity3d.com)</a></p><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Rendering.SortingGroup.html">Rendering.SortingGroup - Unity 脚本 API (unity3d.com)</a></p><h3 id="Sprite-Atlas精灵图集制作"><a href="#Sprite-Atlas精灵图集制作" class="headerlink" title="Sprite Atlas精灵图集制作"></a>Sprite Atlas精灵图集制作</h3><p>  在工程设置面板中打开功能:Edit——&gt;Project Setting——&gt;Editor（Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)）；<br>Disabled：默认设置，不会打包图集；<br>Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包；<br>Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集；</p><p>1.打图集面板参数相关</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Type：图集类型Master：主图集Include <span class="token keyword">in</span> Build：选中可以在当前构建中包含图集Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度Padding：图集中各图片的间隔像素Variant：变体类型的图集Master Atlas：关联的主图集（图集类型必须是Master）Include <span class="token keyword">in</span> Build：选中可以在当前构建中包含图集Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果<span class="token punctuation">(</span>变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include <span class="token keyword">in</span> build选项，而主图集禁用此选项即可<span class="token punctuation">)</span><span class="token number">2</span>.Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它<span class="token number">3</span>.Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启<span class="token number">4</span>.SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。<span class="token number">5</span>.Filter Mode：纹理在3D变化拉伸时如何进行过滤Point：纹理靠近时变为块状Bilinear：纹理靠近时变得模糊Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊<span class="token number">6</span>.Objects <span class="token keyword">for</span> Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片<span class="token number">7</span>.Default:Max Texture Size：纹理的最大尺寸，像素为单位Format：指定纹理的内部表示，在不同平台上会有不同的参数Compression：纹理压缩类型<span class="token punctuation">(</span>质量越高占用内存越多，不压缩质量最好<span class="token punctuation">)</span>不压缩、低质量、普通质量、高质量；Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快Compressor Quality：压缩质量，质量越高纹理越大，耗时越长<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteAtlas.html">精灵图集 - Unity 手册 (unity3d.com)</a></p><p>2.API使用</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 代码控制        GameObject obj = new GameObject();        SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;();        //加载图集资源        SpriteAtlas spriteAtlas = Resources.Load&lt;SpriteAtlas&gt;("MyAtlas");        //加载图集资源中的某一张小图        sr.sprite = spriteAtlas.GetSprite("dead1");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/U2D.SpriteAtlas.html">U2D.SpriteAtlas - Unity 脚本 API (unity3d.com)</a></p><h2 id="2D物理系统"><a href="#2D物理系统" class="headerlink" title="2D物理系统"></a>2D物理系统</h2><h3 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h3><p>1.刚体类型参数说明:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Dynamic：动态类型（受重力和力的影响移动和旋转）Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质，如果不设置，将使用在Physics 2D窗口中设置的默认材质物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项；Use Auto Mass：是否使用自动质量Mass：质量Linear Dray：影响位置移动的阻力系数Angular Drag：影响旋转移动的阻力系数Gravity Scale：受重力影响的程度Collision Detection：碰撞检测算法Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况Sleeping Mode：对象处于静止状态时进入睡眠模式Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大Start Awake：最初处于唤醒状态Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒Interpolate：物理更新间隔之间的插值运算None：不应用移动平滑Interpolate：根据前一帧进行平滑处理Extrapolate：根据后一帧位置进行平滑处理Constraints：约束限制，可以让某一个轴不受力影响位移或者旋转<span class="token number">2</span>.Kinematic：运动学类型，不受力的影响，只能通过代码让其动起来，能和Dynamic 2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数，因此它没有了质量莫摩擦系数等属性，因此它的性能能消耗较低，主要会通过代码来处理其移动旋转；Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞，如果Use FullKinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞；Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它，如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞<span class="token number">3</span>.Static：静态类型完全不动的需要检测碰撞的对象，相当于是无限质量不可移动的对象，它的性能消耗最小，它只能和Dynamic 2D刚体碰撞（和只加碰撞体的区别），和它类似的有只加碰撞器而不加刚体的物体，它们会和刚体物体产生碰撞，但是自己不会动；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Rigidbody2D.html">2D 刚体 - Unity 手册 (unity3d.com)</a></p><p>2.刚体API说明:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 刚体API(参考刚体3D)        //加力        Rigidbody2D rigid = this.GetComponent&lt;Rigidbody2D&gt;();        rigid.AddForce(new Vector2(0, 100));        //速度        rigid.velocity = new Vector2(1, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Rigidbody2D.html">UnityEngine.Rigidbody2D - Unity 脚本 API (unity3d.com)</a></p><h3 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h3><p>1.碰撞体参数相关:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.圆形碰撞器（Circle）:Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性Is Trigger：是否是触发器Used By Effector：是否被附加的2D效应器使用Offset：圆心偏移位置Radius：圆形的半径<span class="token number">2</span>.盒状碰撞器<span class="token punctuation">(</span>Box<span class="token punctuation">)</span>:`Used by Composite：如果勾选，则该碰撞器将附加到2D复合碰撞器使用（勾选后一些属性只能在复合碰撞器中配置）Auto Tiling：如果渲染器组件的Draw Mode设置为Tiled模式，勾选该选项，当改变精灵大小时将自动更新碰撞器尺寸；Size：矩形的宽高Edge Radius：使四个顶点为圆角<span class="token number">3</span>.多边形碰撞器<span class="token punctuation">(</span>Polygon<span class="token punctuation">)</span>Points：多边形顶点虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了，都通过Edit Collider编辑，或者让Unity自动识别创建<span class="token number">4</span>.边界碰撞器<span class="token punctuation">(</span>Edge地形<span class="token punctuation">)</span>：边界碰撞器的编辑主要还是通过Edit Collider一般不会手动去通过数值加点<span class="token number">5</span>.<span class="token number">5</span>.胶囊碰撞器<span class="token punctuation">(</span>Capsule<span class="token punctuation">)</span>Size：胶囊的宽高Direction：是竖直胶囊还是水平胶囊<span class="token number">6</span>.复合碰撞器<span class="token punctuation">(</span>Composite必须配合刚体使用<span class="token punctuation">)</span>Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型Outlines：空心轮廓，类似边界碰撞器Polygons：实心多边形，类似多边形碰撞器Generation Type：生成类型，复合碰撞器在何时生成新几何体Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/Collider2D.html">2D 碰撞体 - Unity 手册 (unity3d.com)</a></p><p>2.碰撞器API：碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 碰撞检测函数    private void OnCollisionEnter2D(Collision2D collision)    private void OnCollisionExit2D(Collision2D collision)    private void OnCollisionStay2D(Collision2D collision)    private void OnTriggerEnter2D(Collider2D collision)    private void OnTriggerExit2D(Collider2D collision)    private void OnTriggerStay2D(Collider2D collision)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h3><p>物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质<br>物理材质参数相关：<br>    Friction：摩擦系数，为0表示没有摩擦力<br>    Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹）</p><h3 id="恒定力（了解即可）"><a href="#恒定力（了解即可）" class="headerlink" title="恒定力（了解即可）"></a>恒定力（了解即可）</h3><p>恒定力（Constant Force）参数说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Force：物理更新时施加于2D刚体上的线性力Relative Force：物理更新时施加的线性力（相对刚体对象坐标系）Torque：物理更新时施加于2D刚体的扭矩力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="效应器-Effector"><a href="#效应器-Effector" class="headerlink" title="效应器(Effector)"></a>效应器(Effector)</h3><p>效应器参数相关:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.区域效应器（Area）：在一个区域内让游戏对象受到力和扭矩力的作用<span class="token punctuation">(</span>作浮力和电梯传送带<span class="token punctuation">)</span>Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度Force Angle：施加力的角度Force Magnitude：施加力的大小Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化ForceTarget：效应器在目标对象上施加力的作用点Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转）Rigidbody：以刚体的当前质心（不会产生扭矩力）Drag：阻力Angular Drag：扭矩阻力<span class="token number">2</span>.浮力效应器（Buoyancy）：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮，密度和流体相同的碰撞体会浮在流体中Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移Linear Drag：影响对象在水中移动的阻力系数Angular Drag：影响对象在水中旋转的阻力系数Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小Flow Variation：随机改变流体力的值<span class="token number">3</span>.点效应器：模拟磁铁 吸引或者排斥的效果Force Magnitude：施加力的大小Force Variation：施加力的大小变化Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放Force Source：力源来自哪个位置，从该点计算距离。Collider：碰撞器的位置Rigidbody：刚体的位置Force Target：作用力目标位置，用改点计算位置Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力Rigidbody：刚体的位置，不会产生扭矩力Force Mode：计算力的模式Constant：忽略源和目标之间相隔的距离Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力<span class="token number">4</span>.平台效应器（Platform）：2D游戏当中的平台或可往上跳跃的墙壁Rotational Offset：旋转偏移量，控制平台角度偏移Use One Way：是否使用单向碰撞行为Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞Use Side Friction：是否应该在平台两侧使用摩擦Use Side Bounce：是否应该在平台两侧使用弹性Side Arc：用于定义左右两侧平台的响应弧度<span class="token number">5</span>.表面效应器（Surface）：模拟传送带Speed：表面保持的速度Speed Variation：速度的随机增加值Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转Use Friction：是否使用摩擦力Use Bounce：是否使用弹力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/Effectors2D.html">2D 效应器 - Unity 手册 (unity3d.com)</a></p><h2 id="SpriteShape"><a href="#SpriteShape" class="headerlink" title="SpriteShape"></a>SpriteShape</h2><p>  SpriteShape是精灵形状的意思（在Package Manager中导入相关工具），它主要是方便我们以节约美术资源为前提，制作2D游戏场景地形或者背景的。<br>类型：开放不封闭的图形、封闭的图形；</p><h3 id="Sprite-Shape-Profile精灵形状概述文件"><a href="#Sprite-Shape-Profile精灵形状概述文件" class="headerlink" title="Sprite Shape Profile精灵形状概述文件"></a>Sprite Shape Profile精灵形状概述文件</h3><p>Sprite Shape Profile精灵形状概述文件配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式）Offset：纹理偏移量Angle Ranges：角度范围（这里的设置主要用于封闭图形在不同角度范围内使用的图片不同，可以达到一个封闭效果）Start：起始角度End：结束角度Order：Sprite相交时的优先级，优先级高的显示在前面Sprites：指定角度范围内的精灵列表，在该角度范围内，可以选择使用的图片资源Corners：指定角显示的精灵图片，主要用于封闭图形，外部四个角用的图片，内部四个角用的图片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sprite-Shape-Renderer和Sprite-Shape-Controller精灵形状渲染器和控制器"><a href="#Sprite-Shape-Renderer和Sprite-Shape-Controller精灵形状渲染器和控制器" class="headerlink" title="Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器"></a>Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器</h3><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteShapeRenderer.html">Sprite Shape Renderer - Unity 手册 (unity3d.com)</a></p><p>参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Sprite Shape Renderer精灵形状渲染器：该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息Color：颜色Mask Interaction：遮罩相互作用规则设置Fill Material和Edge Material：填充材质和边缘材质Sorting Layer和Order <span class="token keyword">in</span> Layer：排序相关<span class="token number">2</span>.Sprite Shape Controller精灵形状控制器：Profile：使用的精灵形状概述文件Detail：精灵形状的质量（高中低三种质量）Is Open Ended：是否是开放的，不封闭的Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸，开启后只有宽度够才会平铺，如果宽度不够会拉伸，不开启始终平铺，但是可能会出现裁剪效果，一般根据你的实际效果进行选择；Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量Enable Tangents：是否启用切线计算功能（如果你的着色器中需要切线信息参与计算，则勾选）Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小Worldspace UV：根据世界控件的UV填充纹理启用编辑状态后：Tangent Mode ：切线模式（从左至右依次是）顶点模式-点两侧不构成曲线切线模式-点两侧构成曲线，并且可以控制切线弧度左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度Position：选中点的局部坐标位置Height：控制点左右两侧精灵图片的高度Corner：是否使用角度图片Disabled：不使用角度图片Automatic：自动Sprite Variant：选择使用的精灵图片Snapping：是否开启捕捉设置控制点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Tilemap-过后再来学"><a href="#Tilemap-过后再来学" class="headerlink" title="Tilemap(过后再来学)"></a>Tilemap(过后再来学)</h2><h1 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a>动画基础</h1><h2 id="Animation动画窗口"><a href="#Animation动画窗口" class="headerlink" title="Animation动画窗口"></a>Animation动画窗口</h2><p>面板左侧（说明）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">顶部从左至右：<span class="token number">1</span>.预览模式（开关）<span class="token number">2</span>.录制模式（开关）打开后预览模式默认开启<span class="token number">3</span>.回到动画开头<span class="token number">4</span>.上一关键帧（快捷键：键盘逗号）<span class="token number">5</span>.播放动画（快捷键：键盘Alt+逗号）<span class="token number">6</span>.下一关键帧（快捷键：键盘句号）<span class="token number">7</span>.回到动画结尾（快捷键：键盘Alt+句号）<span class="token number">8</span>.当前处于第几帧底部Dopesheet：关键帧模式底部Curves：曲线模式中部从左至右：按选择筛选添加关键帧添加事件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>面板左侧（操作）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">多出一个可以选择当前动画的下拉列表：可以在这里创建新动画和切换动画多出一个可以添加变化属性的按钮：在这里你可以任意添加你想要在动画中变化的脚本变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>面板右侧（说明）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">动画时间轴面板：当编辑动画时，会在该面板上编辑关键帧等信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>右侧面板（操控）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">时间轴可以拖动（注意）：时间轴上的单位为n秒n帧，一格代表一帧（并不是秒）选择关键帧右键：Add Key：添加关键帧Delete Key：删除关键帧Clamped Auto：切线模式，自动设置切线Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画Free Smooth：自由设置切线Flat：切线设置为水平Broken：单独控制左右曲线切线Free：自由设置Linear：直线Constant：常量切换Weighted：权重切换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/animeditor-UsingAnimationEditor.html">使用 Animation 视图 - Unity 手册 (unity3d.com)</a></p><h2 id="Animation老动画组件"><a href="#Animation老动画组件" class="headerlink" title="Animation老动画组件"></a>Animation老动画组件</h2><p>  在创建动画之前为对象添加Animation组件之后再制作动画，这时制作出的动画和之前的动画格式是有区别的。<br>Animation组件参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Animation组件：默认播放的动画Animations：该动画组件可以控制的所有动画Play AutoMatically：是否一开始就自动播放默认动画Animate Physics：动画是否与物理交互Culling Type：决定什么时候不播放动画Always Animate：始终播放Based On Renderers：基于默认动画姿势剔除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老动画Animation文件参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Default：读取设置得更高的默认重复模式Once：播放一次就停止Loop：从头到尾不停循环播放PingPong：从头到尾从尾到头不停播放ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老Animation组件API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 代码控制播放        //1.播放动画        animation.Play("1");        //2.淡入播放,自动产生过渡效果        //当你要播放的动画的开始状态 和当前的状态 不一样时         //就会产生过渡效果        animation.CrossFade("3");        //3.前一个播完再播放下一个        animation.PlayQueued("2");        animation.CrossFadeQueued("2");                //4.停止播放所有动画        animation.Stop();        //5.是否在播放某个动画        if( animation.IsPlaying("1") )        //6.播放模式设置        animation.wrapMode = WrapMode.Loop;        //7.其它（了解即可，新动画系统中会详细讲解）        //层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果）        //设置层级        animation["1"].layer = 1;        //设置权重        animation["1"].weight = 1;        //混合模式 叠加还是混合        animation["1"].blendMode = AnimationBlendMode.Additive;        //设置混组相关骨骼信息        animation[""].AddMixingTransform();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Animation.html">UnityEngine.Animation - Unity 脚本 API (unity3d.com)</a></p><h2 id="Animator动画控制器面板"><a href="#Animator动画控制器面板" class="headerlink" title="Animator动画控制器面板"></a>Animator动画控制器面板</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.左侧面板Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的Parameters：参数页签，为动画状态机添加控制状态切换的参数眼睛图标：显隐左侧面板<span class="token number">2</span>.右侧面板：网格化布局区域（主要用于编辑状态之前的切换关系）；1.窗口中的每一个矩形表示一个状态；2.窗口中的每一个箭头表示一个切换条件；矩形说明：默认三大矩形：绿色Entry矩形：进入状态机流程红色Exit矩形：退出状态机流程Any State：任意状态，代表状态机中的任意状态人为添加矩形：橙色矩形：一开始的默认状态动画，和Entry相连，表示一开始播放的动画灰色矩形：自己添加的某一种动作状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AnimatorController.html">Animator Controller - Unity 手册 (unity3d.com)</a></p><h2 id="Animator新动画组件"><a href="#Animator新动画组件" class="headerlink" title="Animator新动画组件"></a>Animator新动画组件</h2><p>Animator组件参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Controller：对应的动画控制器（状态机）Avatar：对应的替身配置信息（之后讲解3D模型时详细讲解）Apply Root Motion：是否启用动画位移更新UpdateMode：更新模式（一般不修改它）:Normal：正常更新Animate Physics：物理更新Unscaled Time：不受时间缩放影响；Culling Mode：裁剪剔除模式：Always Animate：始终播放动画，即使在屏幕外也不剔除；Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入；Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新动画文件(.ani)界面参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Loop Time：是否是循环动画（在动画结尾时重新开始）Loop Pose：无缝循环运动Cycle Offset：循环动画在其他时间开始时的周期偏移<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Animator组件API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 Animator中的API        //我们用代码控制状态机切换主要使用的就是Animator提供给我们的API        //我们知道一共有四种切换条件 int float bool trigger        //所以对应的API也是和这四种类型有关系的        animator = this.GetComponent&lt;Animator&gt;();        //1.通过状态机条件切换动画        animator.SetFloat("条件名", 1.2f);        animator.SetInteger("条件名", 5);        animator.SetBool("条件名", true);        animator.SetTrigger("条件名");        animator.GetFloat("条件名");        animator.GetInteger("条件名");        animator.GetBool("条件名");        //2.直接切换动画 除非特殊情况 不然一般不使用        animator.Play("状态名");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Animator.html">UnityEngine.Animator - Unity 脚本 API (unity3d.com)</a></p><h1 id="2D动画"><a href="#2D动画" class="headerlink" title="2D动画"></a>2D动画</h1><h2 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h2><h2 id="骨骼动画-2DAnimation"><a href="#骨骼动画-2DAnimation" class="headerlink" title="骨骼动画-2DAnimation"></a>骨骼动画-2DAnimation</h2><h2 id="骨骼动画-Spine"><a href="#骨骼动画-Spine" class="headerlink" title="骨骼动画-Spine"></a>骨骼动画-Spine</h2><h1 id="3D模型导入相关"><a href="#3D模型导入相关" class="headerlink" title="3D模型导入相关"></a>3D模型导入相关</h1><p>模型导出：<a href="https://docs.unity.cn/cn/2019.4/Manual/CreatingDCCAssets.html">在 Unity 外部创建资源（模型导出） - Unity 手册</a></p><h2 id="Model模型页签"><a href="#Model模型页签" class="headerlink" title="Model模型页签"></a>Model模型页签</h2><p>Model模型页签说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Scene场景相关设置：*Scale Factor：当模型中的比例不符合项目中的预期比例时，可以修改此值来改变该模型的全局比例Unity的物理系统希望游戏世界中的1米在导入模型文件中为1个单位；*Convert Units：启用可将模型文件中定义的模型比例转换为Unity的比例，不同的格式的比例如下，.fbx .max .jas <span class="token operator">=</span> <span class="token number">0.01</span>，.3ds <span class="token operator">=</span> <span class="token number">0.1</span>，.mb .ma .lxo .dxf .blend .dae <span class="token operator">=</span> <span class="token number">1</span>；Import BlendShapes：是否允许Unity随网格一起导入混合形状，当导入包含混合形状的网格时，将使用Skinned MeshRenderer组件（注意：1.导入混合形状发现需要在FBX文件中具有平滑组；2.如果想要导入具有法线的混合形状；把下方的Blend Shape Normals属性设置为Import，将使用FBX文件的发现，或者把下方的Blend Shape Normals属性设置为Calculate，Unity使用相同的逻辑来计算网格和混合形状上的法线）；Import Visibility：是否导入可见性，开启后可以从FBX文件中读取可见性属性。，比如模型动作里 有些动作是要隐藏模型形象的，开启后才会生效，一些3D建模软件对可见性属性不支持或者有限制，比如Maya和Blender就对可见性有限制，所以一般这个选项要根据你使用的建模软件决定（一般可以不勾选）；Import Cameras：是否导入摄像机；*Preserve Hierarchy：始终创建一个显示预制体根，通常在导入的时候，FBX会将模型中的空根节点进行优化去掉它，但是如果多个FBX文件中包含同一层级的空跟对象，可以勾选它来保留他们；主要作用是：比如有两个fbx文件，1包含骨骼和网格，2只包含骨骼动画。如果不启用它导入2，那么Unity将剥离根节点，会让层级不匹配让动画不能正常播放；Sort Hierarchy By Name：在层级窗口中根据名字排序子物体，如果不启用，会保留FBX文件中定义的层级顺序；<span class="token number">2</span>.Meshes网格相关设置：*Mesh Compression-网格压缩，设置压缩比级减小网格的文件大小，提高压缩比会降低网格的精度，调整该参数可以优化游戏包的大小：Off：不使用压缩Low：低压缩比Medium：中等压缩比High：高压缩比*Read/Write Enabled：是否开启读写网格信息，如果开启，Unity将网格数据传给GPU后，在CPU中还会保留可寻址内存，意味着我们可以通过代码访问网格数据进行处理，如果不开启，Unity将网格数据传个GPU后，会将CPU中的可寻址内存中网格数据删除，我们无法再得到网格数据，开启时，会增加内存占用，关闭时，可以节约运行时内存使用量（何时开启？；1.需要在代码中读取或写入网格数据；2.需要运行时合并网格；3.需要使用网格碰撞器时；4.需要运行时使用NavMesh构建组件来烘焙NavMesh时）；Optimize Mesh-确定三角形在网格中列出的顺序以提高GPU性能：Nothing：无优化Everything：对顶点以及多边形顶点索引进行重新排序Polygon Order：仅对多边形重新排序Vertex Order：仅对顶点重新排序*Generate Colliders：生成碰撞器，启用后会自动附加网格碰撞器的情况下导入你的网格，建议不移动的环境几何体可以开启它，但是需要移动的几何体建议不要开启它；<span class="token number">3</span>.Geometry几何体相关设置：*Keep Quads：保留四边形，启用后，Unity不会将4个顶点的多边形转为三角形，当使用曲面细分着色器时可能需要启用此选项，因为四边形的曲面周色漆比多边形的效率更高；*Weld Vertices：合并在空间中共享相同位置的顶点，前提是这些顶点总体上共享相同的属性（UV，法线，切线等等）（开启后相当于会通过减少网格的总数量来优化网格的顶点计数）；一般都开启，除非你想有意保留这些重复顶点，之后想通过代码去获取他们来进行处理；Index Format：网格索引缓冲区的大小（一般都选择16bits，Auto可以会默认选择16bits，只有在必要时使用32bit，16bits即通用又节约内存）；Legacy Blend Shape Normals：启用后会基于Smoothing Angle值来计算法线；Normals-定义如何计算法线：Import：从文件中导入法线，如果文件中不包含发现信息，将使用Calculate模式计算法线Calculate：根据Normals Mode、Smoothness Source和Smoothing Angle属性来计算发现None：不计算法线Blend Shape Normal：定义如何为混合形状计算法线，只有当Legacy Blend Shape Normals禁用时出现Normals Mode：计算法线的模式，只有当上方的Normals设置为Import和Calculate才会出现Unweighted Legacy：2017.1版本之前计算法线的方式，如果是在该版本之前导入的所有FBX模型，默认设置为该模式Unweighted：法线不加权重Area Weighted：法线按照图面面积加权重Angle Weighted：法线按照每个图面上的顶角加权重Area And Angle Weighted：法线按照每个图面上的图面面积和顶角加权重，这是默认选项Smoothness Source-如何确定平滑，哪些边应该平滑，哪些应该粗糙，只有当Legacy Blend Shape Normals 禁用时出现：Prefer Smoothing Groups：尽可能使用模型文件中的平滑组From Smoothing Groups：仅使用模型文件中的平滑组From Angle：使用Smoothing Angle值来确定哪些边应该是平滑的None：不拆分硬边的任何顶点Smoothing Angle：控制是否为硬边拆分顶点，通常，值越大，产生的顶点越少，仅当Normals设置为Calculate时才可用（注意：此设置仅用于非常光滑的或者非常复杂的模型，否则，最好在3D建模软件中手动平滑然后导入，始终建议建模的时候就做好，更加准确）；Tangents-定义如何导入或计算顶点切线，仅当Normals设置为Calculate或Import时，此属性才可用：Import：如果Normals设置为Import，则从FBX文件中导入顶点切线，如果网格没有切线，那么将无法使用法线贴图着色器Calculate Legacy：使用旧版算法计算切线Calculate Legacy With Split Tangents：使用旧版算法计算切线，并在UV图表上进行拆分。如果网格上的接缝碰坏了法线贴图光照，请使用此属性Calculate Mikktspace：使用米克特空间计算切线None：不导入顶点切线，网格没有切线，则无法使用法线贴图着色器Swap UVs：在网格中交换UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项Generate Lightmap UVs：为光照贴图创建第二个UV通道<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/FBXImporter-Model.html">Model 选项卡 - Unity 手册 (unity3d.com)</a></p><h2 id="Rig操纵骨骼页签"><a href="#Rig操纵骨骼页签" class="headerlink" title="Rig操纵骨骼页签"></a>Rig操纵骨骼页签</h2><p>Animation Type-动画类型说明:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.None-不存在动画:主要用于一些环境静态模型<span class="token number">2</span>.Humanoid-人形模型,一般情况下，有头和四肢（一个头两条腿两只手）为人形,人形模型需要使用Avatar化身系统,绑定人主要关节的映射关系:Avatar Definition：选择获取Avatar定义的位置No Avatar：没有化身系统信息Create From This Model：根据此模型创建Avatar化身信息Copy from Other Avatar：指向另一个模型上设置的Avatar化身信息Source：复制另一个具有相同骨架的Avatar化身信息以导入其动画剪辑,使用Copy From Other Avatar时才有Configure<span class="token punctuation">..</span>.：打开Avatar化身配置,使用Create From This Model时才有Skin Weights：设置影响单个顶点的最大骨骼数量Standard（4 Bones）：使用最多4个骨骼来产生影响。默认值，处于对性能考虑，建议使用此设Custom：设置自定义的最大骨骼数，选择后会出现下方的两个选项Max Bones/Vertex：定义每个顶点的最大估个数，值越大性能消耗越大Max Bone Weight：设置考虑骨骼权重的最低阈值，权重计算时将忽略小于此值的内容Optimize Game Objects：在Avatar化身系统和Animator动画组件中删除和存储所导入角色的游戏对象骨骼层级信息。如果启用会出现下方的Extra Transforms to Expose选项。角色将使用Unity动画系统的内部骨架，可以提高动画角色的性能Extra Transforms to Expose：要公开的骨骼层级，在下方打钩将公开该骨骼层级信息放大镜：通过名称搜索对应骨骼信息Toggle All：全选或者反选Collapse All：全部折叠Expand All：全部展开<span class="token number">3</span>.Generic-通用模型，非人形模型,不是标准的人形模型，可以是任意形状，可能有8只腿两个头等等,这种模型主要需要设置骨骼根节点:Root Node：选择用于此Avatar的根节点的骨骼（仅当选择Create From This Model才会出现）<span class="token number">4</span>.Legacy-旧版动画类型与Unity3.x及更早版本导入和使用动画一般不使用:Generation：动画导入方法Don't Import：不导入动画第2~4个选项：已禁用，勿使用Store <span class="token keyword">in</span> Root（New）：导入动画将其存储在模型的根节点中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Avatar设置说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Mapping设置-我们需要在这个页签对模型关节进行映射设置，因为人物动画无非就是改变这些关节的角度：部位设置：身体，头部，左右手，关节映射信息设置Mapping选项：Clear：清空映射AutoMap：自动映射Load：从文件中读取Save：保存映射信息Pose选项：Reset：重置姿势Sample Bind-Pose：绑定姿势示例Enforce T-Pose：强制T姿势<span class="token number">2</span>.Muscles<span class="token operator">&amp;</span>Settings设置：Muscle Group Preview-肌肉群预览：可以在这里预览在不同姿势的旋转变化，用来观察之前的关联映射关系是否合理，主要起到预览作用；Per-Muscle Settings-肌肉设置：，用于设置各骨骼在旋转时的范围限制，因为如果不设置限制，在一些极限角度时会非常奇怪，我们可以在这里单独设置限制范围；Additional Settings-高级设置：可以设置手脚的扭转和伸展值，一般不会修改他们，其中Translation DoF比较重要，如果启用，将启用人形角色的移动动画，如果禁用，Unity仅使用旋转对骨骼进行动画化，但是启用后，会提升性能消耗，因为动画需要执行额外步骤来重定向人形动画，除非动画包含角色某些骨骼的动画式移动才会启用，一般情况下禁用即可；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/FBXImporter-Rig.html">Rig 选项卡 - Unity 手册 (unity3d.com)</a></p><h2 id="Animation动画页签"><a href="#Animation动画页签" class="headerlink" title="Animation动画页签"></a>Animation动画页签</h2><p>1.如何导入外部创建的模型资源：<a href="https://docs.unity.cn/cn/2019.4/Manual/CreatingDCCAssets.html">在 Unity 外部创建资源 - Unity 手册</a></p><p>2.使用多个模型文件来导入动画：<a href="https://docs.unity.cn/cn/2019.4/Manual/Splittinganimations.html">提取动画剪辑 - Unity 手册</a></p><h3 id="动画基础信息设置"><a href="#动画基础信息设置" class="headerlink" title="动画基础信息设置"></a>动画基础信息设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Import Constraints-从此资源导入约束：启用后，Unity会自动添加相应的约束组件将其关联到正确的游戏对象Import Animation-从此资源导入动画：如果禁用，下面的都没有，并且不会导入任何动画；Bake Animations：通过反向动力学（IK）或模拟创建的动画以便推进运动关键帧，仅用于Maya、3Dmax和Cinema4D文件Anim.Compression：导入动画时使用的压缩类型Off：禁用动画压缩，在导入时Unity不会减少关键帧数量，效果最好性能较低，文件较大，运行时内存占用也大。通常不建议使用Keyframe Reduction：减少冗余关键帧，仅适用于Generic通用动画类型Keyframe Reduction and Compression：减少关键帧并在文件中存储动画时压缩关键帧，会影响文件大小，但是内存大小和Keyframe Reduction相同，仅适用于Legacy旧版动画类型Optimal：让Unity决定如何压缩，仅适用Generic通用和Humanoid人形动画类型Rotation Error：设置旋转曲线压缩容错度（百分比），原始旋转值和减小值之间的最小角度Position Error：设置位置曲线压缩容错度（百分比）Scale Error：设置缩放曲线压缩容错度（百分比）（如果原始值和消减值之间的差小于原始值乘以容错百分比，会删除关键帧）这些内容仅在Keyframe Reduction或Optimal压缩时可用；Animated Custom Properties：导入你指定为自定义用户属性的任何FBX属性动画剪辑选择列表：在这里我们可以看到所有的动画剪辑可以通过+或-来新增剪辑或者删除所选的剪辑，在这里选择一个动画剪辑后，我们可以在下方编辑具体的相关属性信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动画剪辑属性基本设置"><a href="#动画剪辑属性基本设置" class="headerlink" title="动画剪辑属性基本设置"></a>动画剪辑属性基本设置</h3><p>动画剪辑属性:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.动画剪辑名称:可编辑修改<span class="token number">2</span>.时间轴:Start动画剪辑的开始帧,End动画剪辑的结束帧,我们可以在时间轴中定义每个动画剪辑的帧范围<span class="token punctuation">;</span><span class="token number">3</span>.动画重要信心设置:Loop Time：播放动画剪辑时是否循环播放，到结尾时重新开始Loop Pose：无缝循环运动Loop Match：循环匹配Cycle Offset：循环动画在其他时间开始时的周期偏移Root Transform Rotation：根位置的角度相关Bake Into Pose：将根旋转烘焙到骨骼移动，禁用此选项将存储为根运动Based Upon：根旋转的基础Original：保持源文件中的原始旋转Root Node Rotation：使用根节点的旋转（仅适用Generic通用动画类型）Body Orientation：保持上半身朝前（仅适用于Humanoid人形动画类型）Offset：根旋转偏移（单位：度）Root Transform Position（Y）：根垂直位置（Y轴方向）Bake Into Pose：将垂直根运动烘焙到骨骼移动。禁用此选项将会存储为根运动Based Upon（at Start）：垂直方向根位置的基础Original：保持源文件中的垂直位置Root Node Position：使用垂直根位置（仅适用Generic通用动画类型）Center Of Mass：保持质心与根位置对其（仅适用Humanoid人形动画类型）Feet（推荐）：保持双脚与根变换位置对齐（仅适用Humanoid人形动画类型）Offset：垂直根位置偏移Root Transform Position（XZ）：根水平位置（XZ平面）Bake Into Pose：将水平根运动烘焙到骨骼移动。禁用此选项将会存储为根运动Based Upon：水平根位置的基础Original：保持源文件中的水平位置Root Node Position：使用水平根位置（仅适用Generic通用动画类型）Center Of Mass：保持与根位置对其（仅适用Humanoid人形动画类型）Mirror：在此剪辑中进行左右镜像（仅Humanoid人形动画类型才显示）Additive Reference Pose：启用后可以设置附加动画层基础参考姿势的帧。在时间轴中可以看到蓝色标记，附加动画层：在动画控制器（状态机）中可以添加新的动画层：Pose Frame：当启用参考姿势帧时，该项就是选择的具体是哪一帧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动画剪辑属性其它设置"><a href="#动画剪辑属性其它设置" class="headerlink" title="动画剪辑属性其它设置"></a>动画剪辑属性其它设置</h3><p>其它设置说明:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Curves:曲线可以配合Animator作为参数，通过加入曲线值可以利用他标记重要的点,可以修改曲线的名字，名字就类似参数名,可以通过加减来添加或删除曲线信息<span class="token punctuation">;</span><span class="token punctuation">(</span>曲线中的值X轴代表标准化时（0~1）代表动画的开始和结尾<span class="token punctuation">;</span>Y轴的值可以根据需求自己设置也可以使用下方提供的预设曲线<span class="token punctuation">)</span><span class="token number">2</span>.Events动画事件<span class="token punctuation">(</span>不推荐延迟严重<span class="token punctuation">)</span>:类似之前我们学习的Animation窗口中的动画事件可以在这里为动画剪辑添加一个事件，当动画播放到事件处时会自动找对象脚本中的同名函数,当我们希望在动画某一时刻进行逻辑处理时非常常用,比如某一时刻进行伤害判断<span class="token number">3</span>.Mask动画遮罩:主要作用是当播放该动画时，可以指定哪一部分或者哪些骨骼排除在外不受动作影响,Humanoid（人形动画的快捷设置）,我们分别可以控制,头、左右臂、左右手、左右腿、根等,点击他们让他们变成红色，就代表做该动作时不影响该部位,Transform（明确指定哪些骨骼关节点不受影响）<span class="token number">4</span>.Motion:当导入的动画剪辑包含根运动时,我们可以在这里手动设置特定骨骼关节点作为我们的根运动节点,展开后看到的都是骨骼关节节点<span class="token number">5</span>.Inport Messages:当我们导入动画出现问题，看到黄色的警告符号时,你可以将 Generate Retargeting Quality Report 选中,Unity会帮我们生成更多的有关重定向问题的具体信息,我们便可以看到具体的一些问题<span class="token punctuation">(</span>只有看到警告动画不正确时才启用，可以帮助我们排查问题<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AnimationClip.html">Animation 选项卡 - Unity 手册 (unity3d.com)</a></p><h2 id="Materials材质纹理页签"><a href="#Materials材质纹理页签" class="headerlink" title="Materials材质纹理页签"></a>Materials材质纹理页签</h2><p>材质纹理页签说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Material Creation Mode-定义希望Unity如何为模型生成或导入材质：None：不使用此模型中嵌入的任何材质，改用Unity的默认漫反射材质Standard：导入时，Unity使用默认规则来生成材质Import via MaterialDescription（Experimental）：导入时，Unity使用FBX文件中嵌入的材质描述来生成材质；（与Standard相比，该方法结果更准确，并且支持更广泛的材质类型。）sRGB Albedo Colors：是否在伽马空间中使用反射率颜色，对于使用线性颜色控件的项目，禁用此选项；Location：定义如何访问材质和纹理Use Embedded Materials：将导入的材质保持在导入的资源中Use External Materials（Legacy）：将导入的材质提取为外部资源。旧版材质处理方式，适用于2017.1或更早的Unity版本创建的项目Extract Textures/Materials：当选择Use Embedded Materials后会出现的内容。这两个按钮可以提取导入的资源中嵌入的所有材质和纹理。Naming：定义材质的命名规则By Base Texture Name：使用导入材质的漫反射纹理名称来命名材质。如果未将漫反射纹理分配给材质，Unity将使用导入材质的名称From Model<span class="token string">'s Material：使用导入材质的名称来命名材质Model Name + Model'</span>s Material：使用模型文件的名称与导入材质的名称相结合来命名材质Search：定义在使用Naming选项定义的名称时查找现有材质的位置规则Local Materials Folder：在本地Materials材质子文件夹（模型文件所在的同一文件夹）中查找现有材质Recursive-Up：在所有父文件夹（一直向上追溯到Assets文件夹）中所有Materials子文件夹中查找现有材质Project-Wide：在所有Unity项目文件夹中查找现有材质重新映射的材质:如果找到了，Unity会自动关联,如果没有找到，我们可以手动进行关联<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/FBXImporter-Materials.html">Materials 选项卡 - Unity 手册 (unity3d.com)</a></p><h1 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h1><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AnimatorController.html">Animator Controller - Unity 手册 (unity3d.com)</a></p><h2 id="3D动画使用"><a href="#3D动画使用" class="headerlink" title="3D动画使用"></a>3D动画使用</h2><h3 id="状态参数"><a href="#状态参数" class="headerlink" title="状态参数"></a>状态参数</h3><p>状态参数说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Motion：分配给此状态的动画剪辑Speed：动画的默认速度Multiplier：控制速度的乘数，如果要使用需要勾选的Parameter选中配合的参数float类型Motion Time：运动的时间，如果要使用需要勾选的Parameter选中配合的参数float类型Mirror：是否为状态生成镜像，仅适用于人形动画，如果要配合参数使用选中旁边的Parameter关联参数，参数是bool类型Cycle Offset：循环偏移时间，如果要配合参数使用选中旁边的Parameter关联参数，参数是float类型Foot IK：是否遵循Foot IK，适用于人形人形动画Write Defaults：AnimatorStates 是否为其运动执行未动画化的属性写回默认值。Solo：仅播放该过渡Mute：禁用过渡Solo和Mute如果一起选择，Mute优先执行Add Behaviour：添加状态机行为脚本，之后会专门讲解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连线参数"><a href="#连线参数" class="headerlink" title="连线参数"></a>连线参数</h3><p>连线参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">改名框：可以在这里为动画过渡改名，如果不改，对应的名字就是，<span class="token string">"某一状态名"</span>-<span class="token operator">&gt;</span><span class="token string">"某一状态名"</span>；Has Exit Time：是否有退出时间，如果勾选，当切换动画时，动画一定是播放到下方的Exit Time（百分比）的时间时才过渡到下一个动画Exit Time：退出时间，当选择上方的Has Exit Time时，该值决定了过渡生效的确切时间。该值可以大于1，如果小于1，比如0.85，表示当动画播放到了85%的动画时，就会过渡。如果大于1，比如4.5，那么动画将循环4.5次后过渡到下一个动画Fixed Duration：选中后，下方的Trnaition Duration过渡持续时间将以秒为单位解读过渡时间，如果不选中，则以百分比解读过渡时间Transition Duration<span class="token punctuation">(</span>s/%<span class="token punctuation">)</span>：过渡持续时间，相当于从该状态切换到下一状态的过渡动画持续的时间，对应下方两个蓝色箭头包裹区域Transition Offset：过渡到目标状态的起始播放的时间偏移。如果是0则从目标状态开头开始播放，如果是0.5则从目标状态的一半开始播放，你可以理解为切入下一个状态的切入点；Interruption Source：该过渡中断的情况None：不在添加任何过渡Current State：将当前状态过渡排队Next State：使下一个状态的过渡进行排队Current State Then Next State：将当前状态的过渡和下一个状态的过渡都依次排队Next State Thne Current State：将下一状态的过渡和当前状态的过渡依次排队Ordered Interruption：当前过渡是否可在不考虑顺序的情况下被其它过渡中断选中时，找到有效过渡或当前过渡时，会中断不选中时，找到有效过渡，会中断Conditions：过渡条件（如果没有过渡条件，只会考虑Exit Time）AnyState和动作之间连线Can Transition To self：是否可以过渡到自己Preview <span class="token builtin class-name">source</span> state：预览各种过渡状态，可以查看从任意状态切换到当前状态的过渡效果；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画分层和遮罩"><a href="#动画分层和遮罩" class="headerlink" title="动画分层和遮罩"></a>动画分层和遮罩</h2><p>动画分层设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Weight：权重，当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例Mask：动画遮罩，该层动画全部都会受该遮罩的影响Blending：混合方式Override：覆盖方式，播放该层动画时忽略其他层信息Additive：叠加方式，会和其它层动画叠加播放Sync：是否同步其它层，主要用于直接从另一个层复制状态过来，在该层中进行修改，适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑（选择后会多一个Source Layer表示你要复制哪一层的状态）Timing：当选中Sync同步其它层时，该参数激活，选中，会采用折中方案调整同步层上的动画时长（基于权重计算），不选中，动画时长将使用原始层做为母版IK Pass：反向动力学，之后讲解IK的时候再讲解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画混合"><a href="#动画混合" class="headerlink" title="动画混合"></a>动画混合</h2><p>1.2D Simple Directional     2D简单定向模式  运动表示不同方向时使用 比如向前、后、左、右走；<br>2.2D Freeform Directional   2D自由形式定向模式   同上 运动表示不同方向时使用 但是可以在同一方向上有多个运动 比如向前跑和走；<br>3.2D Freeform Cartesian     2D自由形式笛卡尔坐标模式  运动不表示不同方向时使用 比如向前走不拐弯 向前跑不拐弯 向前走右转 向前跑右转；<br>4.Direct直接模式   自由控制每个节点权重，一般做表情动作等；<br>5.1D混合是用一个参数控制动画的混合，之所以叫1D是因为一个参数可以看做是1维线性的；</p><h2 id="动画IK控制"><a href="#动画IK控制" class="headerlink" title="动画IK控制"></a>动画IK控制</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 什么是IK？        //在骨骼动画中，构建骨骼的方法被称为正向动力学        //它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变        //用我们人体举例子        //当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子        //而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思        //它和正向动力学恰恰相反        //它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转        //用我们人体举例子        //当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动        //用父子骨骼理解的话就是子带动了父知识点二 如何进行IK控制        //1.在状态机的层级设置中 开启 IK 通道        //2.继承MonoBehavior的类中        //  Unity定义了一个IK回调函数:OnAnimatorIK        //  我们可以在该函数中调用Unity提供的IK相关API来控制IK        //3.Animator中的IK相关API        //头部IK相关        //weight:LookAt全局权重0~1        //bodyWeight:LookAt时身体的权重0~1        //headWeight:LookAt时头部的权重0~1        //eyesWeight:LookAt时眼镜的权重0~1        //clampWeight:0表示角色运动时不受限制，1表示角色完全固定无法执行LookAt，0.5表示只能够移动范围的一半        SetLookAtWeight     设置头部IK权重        SetLookAtPosition   设置头部IK看向位置        SetIKPositionWeight 设置IK位置权重        SetIKRotationWeight 设置IK旋转权重        SetIKPosition       设置IK对应的位置        SetIKRotation       设置IK对应的角度        AvatarIKGoal枚举    四肢末端IK枚举知识点三 关于OnAnimatorIK和OnAnimatorMove两个函数的理解        //我们可以简单理解这两个函数是两个和动画相关的特殊生命周期函数        //他们在Update之后LateUpdate之前调用        //他们会在每帧的状态机和动画处理完后调用        OnAnimatorIK在OnAnimatorMove之前调用        OnAnimatorIK中主要处理 IK运动相关逻辑        OnAnimatorMove主要处理 动画移动以修改根运动的回调逻辑        //他们存在的目的只是多了一个调用时机，当每帧的动画和状态机逻辑处理完后再调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画目标匹配"><a href="#动画目标匹配" class="headerlink" title="动画目标匹配"></a>动画目标匹配</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 什么是动画目标匹配        //动画目标匹配主要指的是        //当游戏中角色要以某种动作移动，该动作播放完毕后，人物的手或者脚必须落在某一个地方        //比如：角色需要跳过踏脚石或者跳跃并抓住房梁        //那么这时我们就需要动作目标匹配来达到想要的效果       知识点二 如何实现动画目标匹配        //Unity中的Animator提供了对应的函数来完成该功能        //使用步骤是        //1.找到动作关键点位置信息（比如起跳点，落地点，简单理解就是真正可能产生位移的动画表现部分）        //2.将关键信息传入MatchTargetAPI中//参数一：目标位置        //参数二：目标角度        //参数三：匹配的骨骼位置        //参数四：位置角度权重        //参数五：开始位移动作的百分比        //参数六：结束位移动作的百分比        animator.MatchTarget(targetPos.position, targetPos.rotation, AvatarTarget.RightFoot, new MatchTargetWeightMask(Vector3.one, 1), 0.4f, 0.64f);知识点三 注意        //调用匹配动画的时机有一些限制        //1.必须保证动画已经切换到了目标动画上        //2.必须保证调用时动画并不是处于过度阶段而真正在播放目标动画        //如果发现匹配不正确，往往都是这两个原因造成的        //3.需要开启Apply Root Motion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="状态机行为脚本"><a href="#状态机行为脚本" class="headerlink" title="状态机行为脚本"></a>状态机行为脚本</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">识点一 状态机行为脚本是什么？        //状态机行为脚本时一类特殊的脚本,继承指定的基类        //它主要用于关联到状态机中的状态矩形上        //我们可以按照一定规则编写脚本        //当进入、退出、保持在某一个特定状态时我们可以进行一些逻辑处理        //简单解释就是为Animator Controller状态机窗口中的某一个状态添加一个脚本        //利用这个脚本我们可以做一些特殊功能        //比如        //1.进入或退出某一状态时播放声音        //2.仅在某些状态下检测一些逻辑，比如是否接触地面等等        //3.激活和控制某些状态相关的特效知识点二 如何使用状态机脚本        //1.新建一个脚本继承StateMachineBehaviour基类        //2.实现其中的特定方法进行状态行为监听        //  OnStateEnter    进入状态时，第一个Update中调用        //  OnStateExit     退出状态时，最后一个Update中调用        //  OnStateIK       OnAnimatorIK后调用        //  OnStateMove     OnAnimatorMove后调用        //  OnStateUpdate   除第一帧和最后一帧，每个Update上调用        //  OnStateMachineEnter     子状态机进入时调用，第一个Update中调用        //  OnStateMachineExit      子状态机退出时调用，最后一个Update中调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="角色控制器"><a href="#角色控制器" class="headerlink" title="角色控制器"></a>角色控制器</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一· 角色控制器的使用        //关键参数        //是否接触了地面        if ( cc.isGrounded )        //关键方法        //受重力作用的移动        cc.SimpleMove(Vector3.forward * 10 * Time.deltaTime);        //不受重力作用的移动        cc.Move(Vector3.forward * 10 * Time.deltaTime);    //当角色控制器想要判断和别的碰撞器产生碰撞时 使用该函数    private void OnControllerColliderHit(ControllerColliderHit hit)    {        print(hit.collider.gameObject.name);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/CharacterController.html">UnityEngine.CharacterController - Unity 脚本 API (unity3d.com)</a></p><h1 id="导航寻路"><a href="#导航寻路" class="headerlink" title="导航寻路"></a>导航寻路</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2D相关&quot;&gt;&lt;a href=&quot;#2D相关&quot; class=&quot;headerlink&quot; title=&quot;2D相关&quot;&gt;&lt;/a&gt;2D相关&lt;/h1&gt;&lt;h2 id=&quot;图片导入设置&quot;&gt;&lt;a href=&quot;#图片导入设置&quot; class=&quot;headerlink&quot; title=&quot;图片导入设</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="http://wwy010518.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
