<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪夜の自我救赎</title>
  
  <subtitle>雪夜の博客</subtitle>
  <link href="https://wwy.wwywy.com/atom.xml" rel="self"/>
  
  <link href="https://wwy.wwywy.com/"/>
  <updated>2022-07-09T15:44:55.116Z</updated>
  <id>https://wwy.wwywy.com/</id>
  
  <author>
    <name>雪夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ILRuntiome热更新技术</title>
    <link href="https://wwy.wwywy.com/posts/1570.html"/>
    <id>https://wwy.wwywy.com/posts/1570.html</id>
    <published>2022-07-09T13:00:00.000Z</published>
    <updated>2022-07-09T15:44:55.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ILRuntime介绍"><a href="#ILRuntime介绍" class="headerlink" title="ILRuntime介绍"></a>ILRuntime介绍</h1><p>  ILRuntime项目为基于C#的平台（例如Unity）提供了一个纯C#实现，快速、方便且可靠的IL运行时，使得能够在不支持JIT的硬件环境（如iOS）能够实现代码的热更新。</p><h2 id="ILRuntime的优势"><a href="#ILRuntime的优势" class="headerlink" title="ILRuntime的优势"></a>ILRuntime的优势</h2><p>  同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p><ul><li>无缝访问C#工程的现成代码，无需额外抽象脚本API</li><li>直接使用VS2015进行开发，ILRuntime的解译引擎支持.Net 4.6编译的DLL</li><li>执行效率是L#的10-20倍</li><li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右（从脚本调用GameObject之类的接口）</li><li>支持跨域继承</li><li>完整的泛型支持</li><li>拥有Visual Studio的调试插件，可以实现真机源码级调试。支持Visual Studio 2015 Update3 以及Visual Studio 2017和Visual Studio 2019</li><li>最新的2.0版引入的寄存器模式将数学运算性能进行了大幅优化</li></ul><h2 id="C-vs-Lua"><a href="#C-vs-Lua" class="headerlink" title="C# vs Lua"></a>C# vs Lua</h2><p>  目前市面上主流的热更方案，主要分为Lua的实现和用C#的实现，两种实现方式各有各的优缺点；</p><ul><li>Lua：Lua是一个已经非常成熟的解决方案，但是对于Unity项目而言，也有非常明显的缺点。就是如果使用Lua来进行逻辑开发，就势必要求团队当中的人员需要同时对Lua和C#都特别熟悉，或者将团队中的人员分成C#小组和Lua小组。不管哪一种方案，对于中小型团队都是非常痛苦的一件事情；</li><li>用C#来作为热更语言最大的优势就是项目可以用同一个语言来进行开发，对Unity项目而言，这种方式肯定是开发效率最高的，最新2.0版本的ILRuntime，加入了<a href="https://ourpalm.github.io/ILRuntime/public/v1/guide/register-vm.html">寄存器模式</a>，在10多项测试用例当中的性能，均已超过lua53版xlua；</li></ul><h2 id="性能对比注意事项"><a href="#性能对比注意事项" class="headerlink" title="性能对比注意事项"></a>性能对比注意事项</h2><p>  如果需要测试ILRuntime对比Lua的性能Benchmark，需要确认以下几点，ILRuntime设计上为了在开发时提供更多的调试支持。在Unity Editor中运行会有很多额外的性能开销，因此在Unity Editor中直接测试并不能代表ILRuntime的实际运行性能。</p><ul><li>ILRuntime加载的dll文件是<code>Release</code>模式编译的</li><li>dll中对外部API的调用都进行了<code>CLR绑定</code></li><li>确保<code>没有勾选Development Build</code>的情况下发布成正式真机运行包，而<code>不是在Editor中直接运行</code></li><li>可以直接使用Demo工程中提供的性能测试进行对比</li></ul><h2 id="调试插件"><a href="#调试插件" class="headerlink" title="调试插件"></a>调试插件</h2><p>  ILRuntime提供了一个支持Visual Studio 2015、Visual Studio 2017和Visual Studio 2019的调试插件，用来源码级调试你的热更脚本，你可以在<a href="https://github.com/Ourpalm/ILRuntime/releases">这里</a>下载到最新的Visual Studio调试插件。</p><p><strong>使用方法如下：</strong></p><ul><li>安装ILRuntime调试插件，并重新启动VS2015或VS2017、VS2019</li><li>确保dll和pdb都加载完毕。</li><li>运行Unity工程，并保证执行过appdomain.DebugService.StartDebugService（56000）;来启动调试服务器</li><li>用VisualStudio打开热更DLL项目</li><li>点击菜单中的Debug-&gt;Attach to ILRuntime按钮。注意，不是“附加Unity调试程序”</li><li>在弹出来的窗口中填入被调试的主机的IP地址以及调试服务器的端口</li><li>点击Attach按钮后，即可像UnityVS一样下断点调试</li></ul><h1 id="ILRuntime环境搭建"><a href="#ILRuntime环境搭建" class="headerlink" title="ILRuntime环境搭建"></a>ILRuntime环境搭建</h1><h2 id="导入ILRuntime"><a href="#导入ILRuntime" class="headerlink" title="导入ILRuntime"></a>导入ILRuntime</h2><p>  ILRuntime1.6版新增了Package Manager发布，使用Unity2018以上版本可以直接通过Package Manager安装，如果你使用的是Unity，或者无法在PackageManager中找到ILRuntime，则需要按照以下步骤设置项目；</p><ul><li>首先需要在项目的Packages/manifest.json中，添加ILRuntime的源信息，在这个文件的dependencies节点前增加以下代码<pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">"scopedRegistries": [  {    "name": "ILRuntime",    "url": "https://registry.npmjs.org",    "scopes": [      "com.ourpalm"    ]  }],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li> 然后通过Unity的菜单，打开Package Manager，将上部标签页选项选择为All Packages，Advanced里勾上Show Preview Packages，等待Unity加载完包信息，应该就能在左侧列表中找到ILRuntime，点击安装即可Window-&gt;Package Manager；</li><li> 部分Unity版本可以无法直接在列表中刷出ILRuntime，如果左边列表找不着，那就在项目的manifest.json中的dependencies段的开头，增加如下代码手动将ILRuntime添加进项目；<pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">"com.ourpalm.ilruntime": "1.6.0",<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>示例导入工程后有可能因为没开启unsafe导致编译报错，可以在PlayerSettings中勾选Allow unsafe code解决编译问题；</li></ul><h2 id="创建HotFix项目"><a href="#创建HotFix项目" class="headerlink" title="创建HotFix项目"></a>创建HotFix项目</h2><ul><li><p>首先创建一个C#类库工程，接下来，我们将开始配置这个热更工程，以便我们在里面可以编写业务代码；</p></li><li><p>在Unity项目创建一个DLL文件夹，将UnityEngine和UnityEngine.CoreModule放进去，使用文本编辑器打开HotFix.csproj这个文件，配置如下内容，注意路径可能本人不一致，或者你也可以直接在VS中添加依赖项；</p></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">&lt;ItemGroup&gt;  &lt;Reference Include="Assembly-CSharp"&gt; //Unity项目编译后的程序集，路径如下    &lt;HintPath&gt;..\..\..\..\Library\ScriptAssemblies\Assembly-CSharp.dll&lt;/HintPath&gt;    &lt;Private&gt;false&lt;/Private&gt;  &lt;/Reference&gt;  &lt;Reference Include="UnityEngine"&gt;    &lt;HintPath&gt;..\..\..\..\DLL\UnityEngine.dll&lt;/HintPath&gt;    &lt;Private&gt;false&lt;/Private&gt;  &lt;/Reference&gt;  &lt;Reference Include="UnityEngine.CoreModule"&gt;    &lt;HintPath&gt;..\..\..\..\DLL\UnityEngine.CoreModule.dll&lt;/HintPath&gt;    &lt;Private&gt;false&lt;/Private&gt;  &lt;/Reference&gt;&lt;/ItemGroup&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接下来我们就可以在热更工程编写代码了，我们在HotFix工程中新增一个c#文件，名字叫AppMain.cs 如图所示，解释一下，就是把路径Assets\GAssets\CSProject~\HotFix\bin\Debug\netstandard2.1\下生成的HotFix.dll和HotFix.pdb拷贝到Assets\StreamingAssets\路径下，并且给文件加上.txt后缀名 ；</li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using UnityEngine;namespace HotFix{    public class AppMain    {        public static void Start()        {            Debug.Log("AppMain::Start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接下来我们要配置一下这个热更工程的dll输入路径，右键项目属性，在生成事件后填入如下内容；</li></ul><pre class="line-numbers language-Bat" data-language="Bat"><code class="language-Bat">Copy "$(TargetDir)HotFix.dll" "$(TargetDir)..\..\..\..\..\..\StreamingAssets\HotFix.dll.txt"Copy "$(TargetDir)HotFix.pdb" "$(TargetDir)..\..\..\..\..\..\StreamingAssets\HotFix.pdb.txt"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Unity中调用"><a href="#Unity中调用" class="headerlink" title="Unity中调用"></a>Unity中调用</h2><p>热更部分已经配置好了，接下来，我们要在主工程启动ILRuntime的运行时环境，并且加载热更代码，运行起来，具体步骤如下，新建一个c#文件Startup.cs 里面的内容如下，然后运行即可，就可以看到控制台输出了AppMain::Start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class Startup : MonoBehaviour{    private ILRuntime.Runtime.Enviorment.AppDomain appdomain;    void Start()    {        StartCoroutine(LoadILRuntime());    }    IEnumerator LoadILRuntime()    {        appdomain = new ILRuntime.Runtime.Enviorment.AppDomain();        UnityWebRequest webRequest = UnityWebRequest.Get(StreamingAssetsPath("HotFix.dll.txt"));        yield return webRequest.SendWebRequest();        if (webRequest.result != UnityWebRequest.Result.Success)        {            yield break;        }        byte[] dll = webRequest.downloadHandler.data;        webRequest.Dispose();        webRequest = UnityWebRequest.Get(StreamingAssetsPath("HotFix.pdb.txt"));        yield return webRequest.SendWebRequest();        if (webRequest.result != UnityWebRequest.Result.Success)        {            yield break;        }        byte[] pdb = webRequest.downloadHandler.data;        webRequest.Dispose();        appdomain.LoadAssembly(new MemoryStream(dll), new MemoryStream(pdb), new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());        OnILRuntimeInitialized();    }    void OnILRuntimeInitialized()    {        appdomain.Invoke("HotFix.AppMain", "Start", null, null);    }    public string StreamingAssetsPath(string fileName)    {        string path = Application.streamingAssetsPath + "/" + fileName;        return path;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="热更代码中编写Mono脚本"><a href="#热更代码中编写Mono脚本" class="headerlink" title="热更代码中编写Mono脚本"></a>热更代码中编写Mono脚本</h1><p>  我们在常规的unity代码编写流程，是实现一个monobehaviour脚本，挂载在一个GameObject对象上，通过实现Awake，Start，Update，OnDestroy 这样一些函数驱动游戏逻辑的执行，在ILRuntime中，我们在热更工程中编写的代码本质上是脚本，也就是文本字符串，在Unity主工程看来，并没有什么monobehaviour脚本被创建出来，但我们依然希望在热更工程中像常规的Unity项目一样，使用monobehaviour脚本的模式编写代码，那怎么实现呢？</p><p>实现方法步骤：</p><ul><li><p>在主工程中，实现一个真正的monobehaviour脚本命名为MonoProxy，作为代理，以后无论热更工程的任何GameObject想要挂载脚本，都挂载这个固定的MonoProxy类；</p></li><li><p>热更工程将一个自定义的热更脚本和这个MonoProxy类绑定，这样Unity在运行时通过驱动MonoProxy类，然后这个MonoProxy类将驱动行为转移到这个热更脚本上，从而驱动这个热更脚本的运行；</p></li><li><p>为了规范热更热更脚本的编写严谨性，在热更工程中，定义一个热更脚本的基类MonoBase，所有需要挂载在GameObject上的热更脚本(当然这个并不是真正的挂载，真正挂载的是代理类MonoProxy)都必须继承这个MonoBase类；</p></li><li><p>具体代码如下</p><p>在主工程中实现的MonoProxy代理类</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using ILRuntime.CLR.TypeSystem;using System.Collections;using System.Collections.Generic;using System.Reflection;using UnityEngine;/// &lt;summary&gt;/// 在GameObject上挂载的真正的脚本对象MonoProxy/// 运行时，会把逻辑执行转交给绑定的对应热更脚本对象ScriptObject/// &lt;/summary&gt;public class MonoProxy : MonoBehaviour{    /// &lt;summary&gt;    /// 当前这个MonoProxy对象映射的热更脚本的类型字符串    /// &lt;/summary&gt;    public string ScriptName;    /// &lt;summary&gt;    /// 映射的热更脚本的类型的对象    /// &lt;/summary&gt;    public object ScriptObject;    /// &lt;summary&gt;    /// 将本MonoProxy对象和一个热更脚本绑定在一起    /// &lt;/summary&gt;    /// &lt;param name="scriptName"&gt;&lt;/param&gt;    public void Bind(string scriptName)    {        ScriptName = "HotFix." + scriptName;        ScriptObject = Startup.appdomain.Instantiate(ScriptName);        IType scriptIType = Startup.appdomain.LoadedTypes[ScriptName];        FieldInfo goField = scriptIType.ReflectionType.GetField("gameObject");        goField.SetValue(ScriptObject, gameObject);//为什么不实现Awke函数，而在这里申明，因为该函数是在AddComponent后就立马调用的，Mono脚本可能在HotFix中添加，而这时参数并未传递进来，会出问题        Startup.appdomain.Invoke(ScriptName, "Awake", ScriptObject, null);    }        void Start()    {        Startup.appdomain.Invoke(ScriptName, "Start", ScriptObject, null);    }    void Update()    {        Startup.appdomain.Invoke(ScriptName, "Update", ScriptObject, null);    }    private void OnDestroy()    {        Startup.appdomain.Invoke(ScriptName, "OnDestroy", ScriptObject, null);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>  热更工程中的MonoBase类（即所有需要挂载的热更脚本的基类）</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using System.Collections.Generic;using System.Text;using UnityEngine;namespace HotFix{    public class MonoBase    {        public GameObject gameObject;        public virtual void Awake() { }        public virtual void Start() { }        public virtual void Update() { }        public virtual void OnDestroy() { }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  创建一个HelloComponent脚本集成自MonoBase进行实验：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using System.Collections.Generic;using System.Text;using UnityEngine;namespace HotFix{    public class HelloComponent : MonoBase    {        public override void Awake()        {            Debug.Log(gameObject.name + " HelloComponent::Awake");                  }        public override void Start()        {            Debug.Log(gameObject.name + " HelloComponent::Start");        }        public override void Update()        {            Debug.Log(gameObject.name + " HelloComponent::Update " + Time.deltaTime);        }        public override void OnDestroy()        {            Debug.Log(gameObject.name + " HelloComponent::OnDestroy ");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  演示下使用，在热更工程中创建一个GameObject，命名为Hello，并且挂载一个脚本HelloComponent，编译运行后就能看到效果了：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using UnityEngine;namespace HotFix{    public class AppMain    {        public static void Start()        {            GameObject go = new GameObject("HelloGo");            MonoProxy monoProxy = go.AddComponent&lt;MonoProxy&gt;();            monoProxy.Bind("HelloComponent");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ILRuntime（适配器）"><a href="#ILRuntime（适配器）" class="headerlink" title="ILRuntime（适配器）"></a>ILRuntime（适配器）</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">//调用协程来举例子gameObject.GetComponent&lt;MonoProxy&gt;().StartCoroutine(Coroutine());//定义的协程函数public System.Collections.IEnumerator Coroutine(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  对于这行代码，StartCoroutine确实需要一个真正的协程对象，而这里Coroutine()返回的却是一个ILTypeInstance对象，因为在热更代码中，我们这些创建的类型对象大多数在Unity主工程看来都是ILTypeInstance对象，并没有什么真正意义的协程对象被创建出来！！</p><p>  所以ILRuntime运行到这行代码时，发现需要的类型（协程对象）和传入的实际类型（ILTypeInstance对象）不一致时，ILRuntime运行时会试图查找是否有相应的CrossBindingAdaptor类型可以把传入的当前类型对象转换成需要的类型对象，如果有，就用当前类型对象作为输入创建一个需要的类型对象，并且调用这个新的类新对象！！</p><p>  以上就是ILRuntime所谓的跨域继承，其实并没有什么继承，本来就是两个类型，用户需要自己实现这个转换过程，实现方法就是自定义一个CrossBindingAdaptor的派生类，并且注册到ILRuntime运行时中去，以下是适配器的基本写法；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using ILRuntime.CLR.Method;using ILRuntime.Runtime.Enviorment;using ILRuntime.Runtime.Intepreter;using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class CoroutineAdapter : CrossBindingAdaptor{    public override Type BaseCLRType    {        get        {            return null;        }    }    public override Type[] BaseCLRTypes    {        get        {            //跨域继承只能有1个Adapter，因此应该尽量避免一个类同时实现多个外部接口，对于coroutine来说是IEnumerator&lt;object&gt;,IEnumerator和IDisposable，            //ILRuntime虽然支持，但是一定要小心这种用法，使用不当很容易造成不可预期的问题            //日常开发如果需要实现多个DLL外部接口，请在Unity这边先做一个基类实现那些个接口，然后继承那个基类            return new Type[] { typeof(IEnumerator&lt;object&gt;), typeof(IEnumerator), typeof(IDisposable) };        }    }    public override Type AdaptorType    {        get        {            return typeof(Adaptor);        }    }    public override object CreateCLRInstance(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance)    {        return new Adaptor(appdomain, instance);    }    /// &lt;summary&gt;    /// Coroutine生成的类实现了IEnumerator&lt;System.Object&gt;, IEnumerator, IDisposable 所以都要实现    /// 这个可以通过reflector之类的IL反编译软件得知    /// &lt;/summary&gt;    internal class Adaptor : IEnumerator&lt;System.Object&gt;, IEnumerator, IDisposable, CrossBindingAdaptorType    {        ILTypeInstance instance;        ILRuntime.Runtime.Enviorment.AppDomain appdomain;        public Adaptor()        {        }        public Adaptor(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance)        {            this.appdomain = appdomain;            this.instance = instance;        }        public ILTypeInstance ILInstance { get { return instance; } }        IMethod mCurrentMethod;        bool mCurrentMethodGot;        public object Current        {            get            {                if (!mCurrentMethodGot)                {                    mCurrentMethod = instance.Type.GetMethod("get_Current", 0);                    if (mCurrentMethod == null)                    {                        //这里写System.Collections.IEnumerator.get_Current而不是直接get_Current是因为coroutine生成的类是显式实现这个接口的，通过Reflector等反编译软件可得知                        //为了兼容其他只实现了单一Current属性的，所以上面先直接取了get_Current                        mCurrentMethod = instance.Type.GetMethod("System.Collections.IEnumerator.get_Current", 0);                    }                    mCurrentMethodGot = true;                }                if (mCurrentMethod != null)                {                    object res = appdomain.Invoke(mCurrentMethod, instance, null);                    return res;                }                else                {                    return null;                }            }        }        IMethod mDisposeMethod;        bool mDisposeMethodGot;        public void Dispose()        {            if (!mDisposeMethodGot)            {                mDisposeMethod = instance.Type.GetMethod("Dispose", 0);                if (mDisposeMethod == null)                {                    mDisposeMethod = instance.Type.GetMethod("System.IDisposable.Dispose", 0);                }                mDisposeMethodGot = true;            }            if (mDisposeMethod != null)            {                appdomain.Invoke(mDisposeMethod, instance, null);            }        }        IMethod mMoveNextMethod;        bool mMoveNextMethodGot;        public bool MoveNext()        {            if (!mMoveNextMethodGot)            {                mMoveNextMethod = instance.Type.GetMethod("MoveNext", 0);                mMoveNextMethodGot = true;            }            if (mMoveNextMethod != null)            {                return (bool)appdomain.Invoke(mMoveNextMethod, instance, null);            }            else            {                return false;            }        }        IMethod mResetMethod;        bool mResetMethodGot;        public void Reset()        {            if (!mResetMethodGot)            {                mResetMethod = instance.Type.GetMethod("Reset", 0);                mResetMethodGot = true;            }            if (mResetMethod != null)            {                appdomain.Invoke(mResetMethod, instance, null);            }        }        public override string ToString()        {            IMethod m = appdomain.ObjectType.GetMethod("ToString", 0);            m = instance.Type.GetVirtualMethod(m);            if (m == null || m is ILMethod)            {                return instance.ToString();            }            else                return instance.Type.FullName;        }    }}//同时需要注册适配器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ILRuntime介绍&quot;&gt;&lt;a href=&quot;#ILRuntime介绍&quot; class=&quot;headerlink&quot; title=&quot;ILRuntime介绍&quot;&gt;&lt;/a&gt;ILRuntime介绍&lt;/h1&gt;&lt;p&gt;  ILRuntime项目为基于C#的平台（例如Unity）提供了一</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="热更新" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="AssetBundle" scheme="https://wwy.wwywy.com/tags/AssetBundle/"/>
    
    <category term="ILRuntimes" scheme="https://wwy.wwywy.com/tags/ILRuntimes/"/>
    
  </entry>
  
  <entry>
    <title>情商的修炼之道</title>
    <link href="https://wwy.wwywy.com/posts/321.html"/>
    <id>https://wwy.wwywy.com/posts/321.html</id>
    <published>2022-05-22T13:00:00.000Z</published>
    <updated>2022-05-27T08:51:20.204Z</updated>
    
    <content type="html"><![CDATA[<p>（这是我博客中最珍贵最重要的心得，人生往往是经历无数后悔才能实现的自我救赎，而高情商可以让你少走很多弯路）</p><h1 id="何为情商"><a href="#何为情商" class="headerlink" title="何为情商"></a>何为情商</h1><h2 id="情商的本质"><a href="#情商的本质" class="headerlink" title="情商的本质"></a>情商的本质</h2><p>  情商的本质就是情绪，体现在以下几点；</p><ul><li>论点一：情商高的表现之一就是让别人开心，跟你在一起很舒适，有情感上的共鸣；</li><li>论点二：同时，高情商在让别人开心的同时，也让自己开心，而那种靠牺牲自己，为难自己去让去别人感到舒适的，这并不是高情商；</li><li>结论：总之，真正的高情商是在自己和别人的情绪之间找到一个和谐点，彼此都特别愉快的实现共赢；</li></ul><h2 id="情商的层级"><a href="#情商的层级" class="headerlink" title="情商的层级"></a>情商的层级</h2><p>  情商也是有层次的，请慢慢尝试从这几步去提升自己的情商</p><ul><li>认识自己的情绪；</li><li>管理自己的情绪；</li><li>认知他人的情绪；</li><li>影响他人的情绪；</li></ul><h1 id="认识自己的情绪"><a href="#认识自己的情绪" class="headerlink" title="认识自己的情绪"></a>认识自己的情绪</h1><h2 id="接受自己的情绪："><a href="#接受自己的情绪：" class="headerlink" title="接受自己的情绪："></a>接受自己的情绪：</h2><ul><li>原因：一味的压抑自己的情绪并不是高情商的表现，当你被别人骂了，自己不开心时，却总安慰自己说没事，去学习、工作的时候就是很开心，隐藏自己的笑容却内心苦苦的，那只是憋屈和强忍；</li><li>结论：所以，我们得先学会人有这种情绪，才是解决这个情绪的开始，而接受、了解自己的情绪的情绪就得先从下面三点入手；</li></ul><h2 id="给情绪上标签"><a href="#给情绪上标签" class="headerlink" title="给情绪上标签"></a>给情绪上标签</h2><ul><li><p>原因：情绪并没有我们眼里的那么简单，也许大部分人仍然认为情绪就是喜悦、愤怒和悲伤，但是这只是表面上直观的情绪；我们实际感受到的情绪，往往是通过别人的”外在表现”或者自己想要表达的”感受”而体现出的情绪，这些情绪其实是有着很明显的特征的，是有标签的；</p></li><li><p>例如：生活中就有一些这样的情绪在悄无声息的影响着我们的行为和判断力，你肯定遇到过这样的场景，”啊！！！我不明白我为什么当时会那样子，我好后悔，我明明不是这样想的，但我却说出那样的话”，这种情况就是你不理解的情绪悄无声息的影响了你的判断能力，让你的大脑过热；</p></li><li><p>结论：所以，认识自己情绪的第一步，就是给情绪贴上标签，要明确情绪之间的界限感，对情绪进行区分，而不是永远都只是感觉很糟糕，我们要能感知更多的情绪；</p></li></ul><p><img src="https://s1.ax1x.com/2022/05/22/OzOs9s.png" alt="情绪的分类"><br><a href="https://imgtu.com/i/OzOs9s"><img src="https://s1.ax1x.com/2022/05/22/OzOs9s.png" alt="OzOs9s.png"></a></p><h2 id="情绪分级"><a href="#情绪分级" class="headerlink" title="情绪分级"></a>情绪分级</h2><ul><li>结论：除了要对情绪进行分类，了解自己处于哪一种情绪外，还要对情绪进行分级；</li><li>例如：比如把愤怒分为1~5级，明白自己当前情绪是哪一种程度级别；</li></ul><h2 id="自我反省"><a href="#自我反省" class="headerlink" title="自我反省"></a>自我反省</h2><ul><li>例如：每天晚上躺在床上反思自己的所作所为，为什么要那样做，是因为生气了吗，没有生气那么为什么要这么做，生气了那么生气程度是否太过火了，</li><li>结论：不断的反思自己，这样才会更加”熟悉”自己的情绪，特别注意的是，这是一个长远的、需要坚持的过程；</li></ul><h1 id="管理自己的情绪"><a href="#管理自己的情绪" class="headerlink" title="管理自己的情绪"></a>管理自己的情绪</h1><h2 id="慢-静下来"><a href="#慢-静下来" class="headerlink" title="慢/静下来"></a>慢/静下来</h2><ul><li>原因：人本来就是动物，天生的生理习惯就是有情绪就立刻表达出来，但是这种表达方式往往都是野蛮和不理智的，遇到不如意的事情就会动手打人、辱骂，这些都是马上表达的结果；</li><li>结论：有激烈情绪时，慢下来或者干脆什么都不做，给大脑一个处理时间；</li></ul><h2 id="与自己对话"><a href="#与自己对话" class="headerlink" title="与自己对话"></a>与自己对话</h2><ul><li>结论：情绪激烈时注意提醒自己，我现在的情绪如何，我正在做什么，我现在的情绪如何，养成习惯，你就会慢慢的越来越理智；</li></ul><h2 id="学习更好的情绪"><a href="#学习更好的情绪" class="headerlink" title="学习更好的情绪"></a>学习更好的情绪</h2><ul><li>例如：看书、刷剧、与人交流；</li><li>结论：学习更好的情绪表达方式，做生活的观察者、学习者；</li></ul><h1 id="认知他人的情绪"><a href="#认知他人的情绪" class="headerlink" title="认知他人的情绪"></a>认知他人的情绪</h1><h2 id="理解对方的表达"><a href="#理解对方的表达" class="headerlink" title="理解对方的表达"></a>理解对方的表达</h2><ul><li>前提：能听得懂别人说的什么话、表达的什么意思，对语文水平还是有一定要求的；</li><li>例如：你去邀约别人，而别人说我比较忙，过几天去，但是你过了几天竟然还去邀约别人，其实这只是一种委婉的拒绝方式；</li><li>结论：能了解别人表达的情绪；</li></ul><h2 id="提升共情能力"><a href="#提升共情能力" class="headerlink" title="提升共情能力"></a>提升共情能力</h2><ul><li>反例：你的朋友考试得了大鸭蛋，他难受极了，找你来倾诉，但是你却哈哈哈乐了；</li><li>正例：多去和亲近的人分享自己的生活和感受，慢慢的就在数据交换之中逐渐熟悉非我的思维模式，也就是说多去了解别人是咋想的，多进行换位思考，慢慢的就会让别人喜欢上你；</li><li>结论：核心是换位思考，能体会到别人的感受，有情感上的共鸣；</li></ul><h2 id="学会观察语言外的语言"><a href="#学会观察语言外的语言" class="headerlink" title="学会观察语言外的语言"></a>学会观察语言外的语言</h2><ul><li>结论：刻意或者不经意表露出来的行为或动作，比如身体语言；</li><li>例如：<ul><li>俩手交叉：他可能对这事情并不是很关心；</li><li>眼神飘忽不定不集中：可能心里装着别的事情；</li><li>交谈后匆匆离开：说明这次交流对他并不是很重要；</li><li>下意识撅嘴：表示对你所说并不满意；</li></ul></li></ul><h1 id="影响别人的情绪"><a href="#影响别人的情绪" class="headerlink" title="影响别人的情绪"></a>影响别人的情绪</h1><p>（不要做一些伤天害理的事情^_^）</p><h2 id="让自己能接近别人"><a href="#让自己能接近别人" class="headerlink" title="让自己能接近别人"></a>让自己能接近别人</h2><ul><li>例如：你身边那些人缘好活跃的人，往往之后会给你深刻的印象，它们就会影响到你的情绪，可能很多话你现在还历历在目，而内心封闭的人往往不能影响别人的情绪，他们很大的原因就是缺乏鼓励，缺乏正反馈，时间长了就不敢主动和陌生人对话，所以要做一个擅长社交的人，容易被别人接纳的人；</li><li>结论：接近别人，做个积极交际的人，不要自我封闭；</li></ul><h2 id="更加完美的表达自己的想法"><a href="#更加完美的表达自己的想法" class="headerlink" title="更加完美的表达自己的想法"></a>更加完美的表达自己的想法</h2><ul><li>例如：内容复杂时先说结论、在一个观点后分条理陈列理由、把最重要的情况说在前面、描述抽象事物时恰当的运用比喻；</li><li>方法：经常写作，记录想法，不断完善、修改；</li><li>结论：把自己的想法完美的表达出来；</li></ul><h2 id="操控别人情绪（请用于正道）"><a href="#操控别人情绪（请用于正道）" class="headerlink" title="操控别人情绪（请用于正道）"></a>操控别人情绪（请用于正道）</h2><ul><li>前提：做到前面内容，并熟练运用；</li><li>结论：抓住别人的心理诉求，然后……；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（这是我博客中最珍贵最重要的心得，人生往往是经历无数后悔才能实现的自我救赎，而高情商可以让你少走很多弯路）&lt;/p&gt;
&lt;h1 id=&quot;何为情商&quot;&gt;&lt;a href=&quot;#何为情商&quot; class=&quot;headerlink&quot; title=&quot;何为情商&quot;&gt;&lt;/a&gt;何为情商&lt;/h1&gt;&lt;h2 </summary>
      
    
    
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="为人处世" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/%E4%B8%BA%E4%BA%BA%E5%A4%84%E4%B8%96/"/>
    
    
    <category term="情商" scheme="https://wwy.wwywy.com/tags/%E6%83%85%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="https://wwy.wwywy.com/posts/520.html"/>
    <id>https://wwy.wwywy.com/posts/520.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-06-25T23:32:06.704Z</updated>
    
    <content type="html"><![CDATA[<p>重要信息：老师电话13574404624</p><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="什么是编译原理"><a href="#什么是编译原理" class="headerlink" title="什么是编译原理"></a>什么是编译原理</h2><p>1.计算机编译语言的层次：</p><ul><li>机器语言：可以直接被计算机直接理解；</li><li>汇编语言：引入助记符，但是还是难以被直接理解，由汇编语言到机器语言是通过汇编的形式；</li><li>高级语言：能直接理解的，由高级语言到汇编语言或者机器语言是通过编译的形式；</li></ul><h2 id="编译程序补充说明"><a href="#编译程序补充说明" class="headerlink" title="编译程序补充说明"></a>编译程序补充说明</h2><p>1.编译程序的功能：是把高级语言翻译成等价的目标程序，编译程序把”源语言”翻译成二进制文件的”目标语言”的过程，目标程序可以独立源程序运行（注意编译和运行是分俩个阶段的）；</p><p>2.编译器的系统位置以及语言处理流程：源程序=&gt;经过预处理源程序=&gt;汇编语言程序=&gt;可重定位机器码=&gt;目标机器代码；</p><ul><li>预处理器：把存储在不同文件中的源程序聚合在一起，把被成为宏的缩写语句转换为原始语句；</li><li>编译器：如上；</li><li>汇编器：进行可重定位，可重定位指的是在内存中存放的起始位置L不是固定的，而起始位置+相对地址=绝对地址；</li><li>链接器/加载器：其中加载器修改可重定位地址，将修改后的指令和数据放到内存中适当位置，而链接器将多个可重定位的机器代码文件连接到一起以及解决外部内存地址问题；</li></ul><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><p>1.编译过程的划分：分俩批次</p><ul><li>第一批次：分析/前端部分，与源语言相关；<ul><li>词法分析：分析各个短语的词性；</li><li>语法分析：划分句子，也就是句子的中的短语；</li><li>语义分析：就是分析源语言的语义，分析各个短语在句子中占什么成分，语义分析的结果一般直接用中间代码表示，所以这俩个可以一起实现，同时语法分析时分许句子时同时结合语义分析，所以该三个阶段可以一起实现，这个技术被称为语法制导翻译；</li><li>第二批次：综合/后端部分，与目标语言相关，中间代码生成其实也属于前端部分；</li></ul></li></ul><ul><li>中间代码生成；</li><li>代码优化：代码优化一般中间代码和目标机器代码都需要优化；</li><li>目标代码生成；</li></ul><h2 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h2><p>1.解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析上基本同编译过程一致，但是运行用户程序时，它是直接执行源程序或者说源程序的内部形式（中间代码），解释程序不会生成目标代码；</p><h2 id="编译程序和解释程序的区别"><a href="#编译程序和解释程序的区别" class="headerlink" title="编译程序和解释程序的区别"></a>编译程序和解释程序的区别</h2><p>1.区别：</p><ul><li><p>相同点：</p><ul><li>都有相同的词法、语法、语义分析过程；</li></ul></li><li><p>不同点：</p><ul><li>编译程序运行速度会更快，编译程序是生成目标代码后再运行的，而解释程序是一边翻译一边执行；</li><li>编译程序安全性更高，因为编译程序生成的目标代码是二进制形式的；</li><li>编译程序不参与用户程序运行控制，而解释程序参与；</li><li>解释程序不需要同机器码打交道，实现起来比较简单，且便于在不同平台上移植；</li></ul></li></ul><h2 id="前端部分简单介绍"><a href="#前端部分简单介绍" class="headerlink" title="前端部分简单介绍"></a>前端部分简单介绍</h2><p>1.词法分析主要任务：从左到由逐行扫描程序的字符，识别出各个单词，确定单词的类型，将识别出的单词转换成统一的机内表示——语法单元(token)形式，token&lt;种别码，属性值&gt;，第一分量表示种别码，第二个表示值；</p><table><thead><tr><th>单词类型</th><th>种别</th><th>种别码</th></tr></thead><tbody><tr><td>关键字/保留字</td><td>if,else,then</td><td>一词一码</td></tr><tr><td>标识符</td><td>变量名、数组名、记录名</td><td>多词一码</td></tr><tr><td>常量</td><td>整形、浮点型、字符型、布尔型</td><td>一型一码</td></tr><tr><td>运算符</td><td>算数、关系、逻辑·</td><td>一词移码或者一型一码</td></tr><tr><td>界限符</td><td>; () = {} …</td><td>一词一码</td></tr></tbody></table><p>2.语法分析简单介绍：语法分析器从词法分析器输出的token序列种识别出各类短语，并构造语法分析树；</p><p>3.语义分析的主要任务：</p><ul><li>第一个任务：收集标识符的如下主要属性信息，存储在符号表中：<ul><li>种属（Kind）</li><li>类型（Type）</li><li>存储位置和长度</li><li>值和作用域</li><li>参数和返回值信息</li></ul></li><li>第二个任务：语义检查；<ul><li>变量或者过程未经申明就使用；</li><li>变量或者过程名重复声明；</li><li>运算分量类型不匹配； </li><li>操作符和操作数之间的类型不匹配； </li></ul></li></ul><h2 id="中间代码生成及编译器后端"><a href="#中间代码生成及编译器后端" class="headerlink" title="中间代码生成及编译器后端"></a>中间代码生成及编译器后端</h2><h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><h2 id="文法的概述"><a href="#文法的概述" class="headerlink" title="文法的概述"></a>文法的概述</h2><p>1.文法的定义：文法是语言的抽象规则（例如我们的语言都是遵守主谓宾这个文法）；</p><p>2.文法的描述：</p><ul><li>语法规则构成说明：通过建立一组规则，来描述句子的语法结构，例如：<ul><li>&lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt;</li><li>&lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt;</li><li>&lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt;……..</li></ul></li><li>规则推导：有了一组规则，可以按照一定的方式来推导产生句子（方法从一个要识别的符号开始推导，即用相应规则的右部去替代规则的左部）<ul><li>&lt;句子&gt; =&gt; &lt;主语&gt;&lt;谓语&gt;</li><li>&lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt;</li></ul></li></ul><h2 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h2><p>1.字母表：字母表是元素的非空有穷集合，字母表中的元素被称为符号，字母表的运算有乘积、n次幂、正闭包、克林闭包；</p><p>2.符号串：由字母表中符号组成的任意又穷序列称为符号串（例如011101是字母表{0,1}上的字符串）；</p><ul><li>空串：是长度为0的串，用ε表示；</li><li>连接运算：将俩个串进行相连；</li><li>幂运算：串的0次幂等于ε，否则S^n = S^n-1*S；</li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>1.文法G=（Vn,Vt,P,Z）</p><ul><li>Vn：非终结符，是用来表示句子成分的符号，有时也称为“语法变量”；</li><li>Vt：终结符，是文法所定义的语言的基本符号，有时也称为token；</li><li>P：产生式或规则的集合，描述了将终结符和非终结符组成串的方法，产生式的一般形式：α→β，α称为产生出式的头或者左部，β称为产生式的体或者右部；</li><li>Z：开始符合 （Z∈Vn），表示文法中的最大语法成分；</li></ul><p>例如：文法G=（Vn,Vt,P,S）,Vn={S}，Vt={0,1}，P={S=&gt;0S1,S=&gt;01}，S为开始符号；</p><p>2.符号约定：</p><ul><li>终结符：a、b、c；</li><li>非终结符：A、B、C；</li><li>文法符号：X、Y、Z；</li><li>终结符号串：u、v……z；</li><li>文法符号串：α、β；</li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><p>1.推导：用产生式的右部替换产生式的左部，是一个自顶向下的过程；</p><p>2.规约：用产生式的左部替换产生式的右部，是一个自底向上的过程，规约是推导的逆过程；</p><p>3.句子和句型：句子是推导出后只包含终结符得就是句子，否则是句型；</p><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><p>1..最左推导和最右推导：没搞懂；</p><p>3.文法的等价：若L(G1)=L(G2)，则称文法G1和G2是等价的，既然说文法是等价的，所以文法可以是多重的，不同的文法实现同样的功能；</p><p>1.文法的类型：低级文法包含高级文法，高级文法一定是低级文法</p><ul><li>0型文法（短语文法）：对于产生式α→β的结构中，α至少含有一个非终结符；</li><li>1型文法（上下文有关）：对于产生式式α→β，都有|β|&gt;=|α|，仅仅S→ε除外；</li><li>2型文法（上下文无关）：对于产生式α→β，α只能是非终结符，产生式型的形式可变形为A→β；</li><li>3型文法（正规文法）：<ul><li>左线性文法：A→wβ | A→w</li><li>右线性文法： A→βw | A→w</li></ul></li></ul><h2 id="CFG的分析树"><a href="#CFG的分析树" class="headerlink" title="CFG的分析树"></a>CFG的分析树</h2><p>1.二义性文法：</p><ul><li>定义：如果一个文法可以为某个句子生成多颗分析树，则称这个文法时二义性的；</li><li>判定：大多数时候我们都希望文法不是歧义性的，可以给出一组充分条件，满足这组充分条件的文法是无二义性的；</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>1.运算类型：</p><ul><li>*：克林闭包；</li><li>连接；</li><li>|：或运算；</li></ul><h2 id="递归文法"><a href="#递归文法" class="headerlink" title="递归文法"></a>递归文法</h2><p>例如（定义变量）：变量名 x,y,z;,可以推理得：S=&gt;aAb，而A=&gt;B|BcA;</p><p>例如（加减乘除）：E=&gt;E+T|T;T=&gt;T*F|F;F=&gt;(E)|a；</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="有穷自动机的分类（FA）"><a href="#有穷自动机的分类（FA）" class="headerlink" title="有穷自动机的分类（FA）"></a>有穷自动机的分类（FA）</h2><p>1.有穷自动机（FA）：是一个五元组 M：</p><ul><li>有穷状态集；</li><li>输入字母表；</li><li>转换函数；</li><li>开始状态；</li><li>接受状态|终止状态；</li></ul><p>2.区别：不确定的有穷自动机（NFA）和确定的有穷自动机（DFA）区别在于转换函数可以有多个能到达的状态集合；</p><h2 id="从正则表达式到有穷自动机"><a href="#从正则表达式到有穷自动机" class="headerlink" title="从正则表达式到有穷自动机"></a>从正则表达式到有穷自动机</h2><p>[![正则表达式到又穷自动机]<br>(<a href="https://s1.ax1x.com/2022/06/09/XyQ3Of.md.png)]">https://s1.ax1x.com/2022/06/09/XyQ3Of.md.png)]</a><br>(<a href="https://imgtu.com/i/XyQ3Of">https://imgtu.com/i/XyQ3Of</a>)</p><h2 id="由NFA到DFA的转换"><a href="#由NFA到DFA的转换" class="headerlink" title="由NFA到DFA的转换"></a>由NFA到DFA的转换</h2><p>1.将NFA的状态组成一个新的状态，如以下r=aa*bb*cc的表示<br>[![由NFA到DFA]<br>(<a href="https://s1.ax1x.com/2022/06/09/XyQsmT.md.png)]">https://s1.ax1x.com/2022/06/09/XyQsmT.md.png)]</a><br>(<a href="https://imgtu.com/i/XyQsmT">https://imgtu.com/i/XyQsmT</a>)</p><p>2.子集构造法实例：<br>[![带有ε的NFA到DFA]<br>(<a href="https://s1.ax1x.com/2022/06/09/XyQbAe.md.png)]">https://s1.ax1x.com/2022/06/09/XyQbAe.md.png)]</a><br>(<a href="https://imgtu.com/i/XyQbAe">https://imgtu.com/i/XyQbAe</a>)</p><h1 id="自顶向下语法分析方法（重点）"><a href="#自顶向下语法分析方法（重点）" class="headerlink" title="自顶向下语法分析方法（重点）"></a>自顶向下语法分析方法（重点）</h1><h2 id="自顶向下分析概述"><a href="#自顶向下分析概述" class="headerlink" title="自顶向下分析概述"></a>自顶向下分析概述</h2><p>1.</p><h1 id="自顶向上优先分析"><a href="#自顶向上优先分析" class="headerlink" title="自顶向上优先分析"></a>自顶向上优先分析</h1><h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><h1 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h1><h1 id="静态语义分析和中间代码生成"><a href="#静态语义分析和中间代码生成" class="headerlink" title="静态语义分析和中间代码生成"></a>静态语义分析和中间代码生成</h1><h1 id="运行时存储组织"><a href="#运行时存储组织" class="headerlink" title="运行时存储组织"></a>运行时存储组织</h1><h1 id="代码优化和目标代码生成"><a href="#代码优化和目标代码生成" class="headerlink" title="代码优化和目标代码生成"></a>代码优化和目标代码生成</h1><p>1.代码优化：</p><ul><li>常数合并：编译时将常数运算进行合并；</li><li>常数传播：</li><li>代数化简：消掉没有必要的代数，例如x+0 = x；</li><li>削弱运算强度：将高复杂度度运算替换为低复杂度运算；</li></ul><h1 id="补录"><a href="#补录" class="headerlink" title="补录"></a>补录</h1><p>tracert -d 查看网络路节点</p><p>1.编译器的定义<br>2.考PL/0语言<br>3.考LL(1)<br>4.几天的课：运行时存储器组织、优化和目标代码生成，拍照的东西<br>5.上次课：抽象语法树和利波兰式<br>6.今天的课：运行时存储器组织、优化和目标代码生成，拍照的东西<br>7.分析设计题，老师最后讲</p><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><h2 id="文法和语言-1"><a href="#文法和语言-1" class="headerlink" title="文法和语言"></a>文法和语言</h2><p>1.文法：</p><ul><li>文法是语言的形式化的描述工具；</li><li>文法是一个四元组；</li><li>文法是等价的，可以进行改造，文法分类成0、1、2、3型文法；</li><li>推导完成的叫句子，中间的过程叫句型，逆推导的过程叫归约；</li><li>同一个文法在推导过程中语法树是否具有二义性，是否进行改造；</li></ul><p>2.</p><h1 id="A卷考试重点"><a href="#A卷考试重点" class="headerlink" title="A卷考试重点"></a>A卷考试重点</h1><p>  写无聊语言的杀，啥也不写的杀，下个学期的补考也杀，带*号的题目不全；</p><h2 id="选择题-（40）"><a href="#选择题-（40）" class="headerlink" title="选择题-（40）"></a>选择题-（40）</h2><p>1.期中考试题（GCC）<br>2.以及目标代码生成、代码优化</p><h2 id="解答题（30）"><a href="#解答题（30）" class="headerlink" title="解答题（30）"></a>解答题（30）</h2><p>1.何为编译器，编译器的组成部分，编译器的各组成部分作用；</p><p>a、编译器是将高级语言翻译成等价的目标语言的程序；</p><p>b、编译器由词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成组成：</p><p>c、如下：</p><ul><li>词法分析：主要将字符从左至右读入源程序，对构成源程序的字符进行扫描和分解；</li><li>语法分析：在词法分析的基础上将单词序列分解为各类语法短语，这中语法短语也称为语法单位，可表示为语法树；</li><li>语义分析：审查源程序有无语义错误，为代码生成阶段收集类型信息；</li><li>中间代码生成：在进行语法分析和语义分析后，有的编译程序变成一种内部表现形式，这种表现形似就是中间代码；</li><li>代码优化：对中间代码进行变化或者改造，目的是使生成的目标代码更高效； </li><li>目标代码生成：将中间代码变换为特定机器上的绝对指令或者重定位的指令代码或者某种汇编指令代码；</li></ul><p>2.何为PL/0语言，试用PL/0语言描述xx算法；</p><p>a、如下：</p><ul><li>PL/0语言是Pascal的一个子集；</li><li>PL/0语言编译系统由PL/0编译程序和P-code解释程序组成；</li></ul><p>3.如何判断一个文法是LL(1)的，若有文法xx，试将其改造成LL(1)文法；</p><p>a、如下：</p><ul><li>文法不含左递归；</li><li>产生式的候选首符集俩俩不相交；</li></ul><p>4.请结合C语言说明函数参数传递的方式和不同；</p><p>a、如下：</p><ul><li><p>按值传递：将实参的值拷贝给形参、有内存分配和释放、不改变外部的值；</p></li><li><p>地址传递：将形参是指针变量，指针的值拷贝形参指针的值，有内存分配和释放、改变外部值；</p></li><li><p>引用传递：形参是实参的引用，无内存分配，改变外部值；</p></li></ul><p>5.给出表达式的抽象语法树和利波兰式；</p><p>6.请简述代码生成时的指令调度；代码生成，寄存器</p><h2 id="分析设计题（30）"><a href="#分析设计题（30）" class="headerlink" title="分析设计题（30）"></a>分析设计题（30）</h2><p>给出文法：S→A，A→BA，A→c，B→aB，B→b<br>1.构造活前缀DFA<br>2.构造LR(0)分析表，Action表和Goto表；<br>3.给出输入串，写出分析过程（状态栈）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">例题：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="B卷考试重点"><a href="#B卷考试重点" class="headerlink" title="B卷考试重点"></a>B卷考试重点</h1><h2 id="解答题（70）"><a href="#解答题（70）" class="headerlink" title="解答题（70）"></a>解答题（70）</h2><p>1.何为编译器，解释编译器的组成，解释各个编译器的作用；<br>2.linux系统在C语言的编译过程；<br>3.何为FA、NFA、DFA，以及将DFA转换成DFA；<br>4.何为文法，举例说明文法的分类；<br>5.LR(0)的分析表<br>6.请把利波兰式复原成为算数表达式，并且将抽象语法树画出来；<br>7.请生成下列语句的目标代码(x=x+1)；</p><h2 id="分析设计题（30）-1"><a href="#分析设计题（30）-1" class="headerlink" title="分析设计题（30）"></a>分析设计题（30）</h2><p>1.请参考c语言的变量定义语句，根据要求写出文法<br>2.计算非终结符<br>3.根据文法写出语法分析程序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重要信息：老师电话13574404624&lt;/p&gt;
&lt;h1 id=&quot;引论&quot;&gt;&lt;a href=&quot;#引论&quot; class=&quot;headerlink&quot; title=&quot;引论&quot;&gt;&lt;/a&gt;引论&lt;/h1&gt;&lt;h2 id=&quot;什么是编译原理&quot;&gt;&lt;a href=&quot;#什么是编译原理&quot; class=&quot;he</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编译原理" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="https://wwy.wwywy.com/posts/544.html"/>
    <id>https://wwy.wwywy.com/posts/544.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-23T08:22:15.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据结构概论"><a href="#数据结构概论" class="headerlink" title="数据结构概论"></a>数据结构概论</h2><h3 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h3><p>1.数据：描述客观事物的数和字符的集合；</p><p>2.数据项：数据最小单位；</p><p>3.数据对象：性质相同的数据元素集合；</p><p>4.数据结构：数据元素之间的关系；</p><ul><li>数据逻辑结构：由数据元素之间的逻辑关系组成；</li><li>数据的存储结构：数据元素以及其关系的物理结构；</li><li>数据的运算：施加在该数据上的操作；</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>1.定义：数据之间的抽象逻辑关系；</p><p>2.表示方法：图表表示、二元组表示；</p><p>3.逻辑结构类型：</p><ul><li>集合：同属集合，无关系；</li><li>线性结构：一对一；</li><li>树形结构：一对多；</li><li>图：多对多；</li></ul><h3 id="存储结构（物理结构）"><a href="#存储结构（物理结构）" class="headerlink" title="存储结构（物理结构）"></a>存储结构（物理结构）</h3><p>1.定义：指数据的实际存储，逻辑结构在计算机存储实现；</p><p>2.物理存输类型：</p><ul><li>顺序存储结构：连续存储</li><li>链式存储结构：非连续存储</li><li>索引存储结构：键值对</li><li>哈希（散列）存储：计算关键字哈希值仅存数据<h3 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h3></li></ul><p>1.定义：对数据实施的操作；</p><p>运算定义和运算实现分离：基于逻辑结构定义运算，基于存储结构实现运算</p><p>2.常用数据运算类型：增删改查以及排序；</p><h3 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h3><p>1.数据类型：值类型，引用类型等；</p><p>2.抽象数据类型：从求解问题抽象出来的数据逻辑结构和抽象运算，与具体实现无关（重要特征是数据抽象和数据封装），算法就是抽象运算的实现；</p><p>3.抽象数据结构定义：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ADT:数据结构名（例如List）；Data:数据结构的描述（例如线性表元素一一对应）；Operation:数据结构定义了哪些操作（例如对线性表的清空、插入、添加、删除、初始化等等）；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="算法概论"><a href="#算法概论" class="headerlink" title="算法概论"></a>算法概论</h2><p>1.算法的定义：对特定问题的一种描叙，是指令的有限序列，应具有以下特征；</p><ul><li>有穷性：是可以终止结束的算法；</li><li>确定性：相同输入相同输出；</li><li>可行性：算法每一步都必须是可行的，每一步都能执行有限次数完成；</li><li>有输入输出：输入加工对象，加功得到结果；</li></ul><p>2.算法的设计目标：如下几点</p><ul><li>正确性：对于非法的数据能够得到满足规格的结果；</li><li>可读可使用性：便于阅读、交流和使用；</li><li>健壮性：数据不合法时，也能做出相应处理；</li><li>时间高效率和低存储：满足时间高效率和低存储；</li></ul><p>3.算法的描述：采用计算机语言描叙算法；</p><h2 id="算法分析概论"><a href="#算法分析概论" class="headerlink" title="算法分析概论"></a>算法分析概论</h2><p>1.算法分析的定义：分析算法占用的计算机CPU时间和内存空间的多少；</p><h3 id="算法时间性能分析（重点理解）"><a href="#算法时间性能分析（重点理解）" class="headerlink" title="算法时间性能分析（重点理解）"></a>算法时间性能分析（重点理解）</h3><p>1.时间算法类型：</p><ul><li>事后统计法：统计执行时间，必须执行程序且很多因素掩盖了算法本质，如计算机速度、语言、问题规模等；</li><li>事前估计法：抛开问题，仅考虑算法本身的效率；</li></ul><p>2.算法时间复杂度定义：平均情况下的问题规模n的函数的最高阶表示，推导如下</p><ul><li>执行次数T(n) ==&gt; 问题规模n的函数；</li><li>总算法执行时间 ==&gt; 原操作+ T(n)(执行次数或算法频率)；</li><li>简化算法执行时间 ==&gt;  仅考虑执行次数T(n)  ；</li><li>上界f(n) ==&gt; 由T(n)对于n的阶级函数的拆解，是问题规模n的某个函数；</li><li>问题阶级增率比较 ==&gt; 1(仅原操作)&lt;${log}<em>{2}$n&lt;n&lt;n${log}</em>{2}$n&lt;$n^2$&lt;$n^3$&lt;$2^n$&lt;n!&lt;$n^n$；</li><li>渐进时间复杂度（函数渐进增长问题） ==&gt; O(f(n))（O是找出T(n)最高阶或者说最紧凑的上界）；</li><li>平均时间复杂度 ==&gt;最好时间复杂度（算法运气好的时间）与最坏时间复杂度（算法运气坏的时候）的折中考虑；</li></ul><p>3.推导大O阶的方法：</p><ul><li>用常数1取代运行时间中所有加法常数；</li><li>修改后的运行次数函数，只保留最高阶数；</li><li>去除最高阶的相乘系数，得到的就是大O阶；</li></ul><p>4.算法复杂度求和求积：</p><ul><li>T1(n)+T2(n)=O(Max(fn,g(n)))  例如并列循环</li><li>T1(n) * T2(n) = O(f(n)*g(n)) 例如多层嵌套循环</li></ul><p>5.递归算法时间复杂度：自己调用自己，不能采用前面的分析方法；</p><h3 id="算法空间性能分析"><a href="#算法空间性能分析" class="headerlink" title="算法空间性能分析"></a>算法空间性能分析</h3><p>1.算法空间复杂度：记作S(n) = O(g(n))，n为问题的规模，f(n)为语句所占用的存储空间函数，解释如下；</p><ul><li>局部空间：初始只分配一次空间，参与原操作完继续使用，如果算法只有该形式空间分配，即问题规模n为常数，则该算法为原地工作或就地工作算法，空间复杂度为O(1)；</li><li>临时空间：原操作时才分配空间，原操作完即可释放，基本是其算法执行次数的考虑，空间复杂度和时间复杂度相关；</li></ul><p>2.递归算法空间复杂度：待记；</p><h2 id="程序概论"><a href="#程序概论" class="headerlink" title="程序概论"></a>程序概论</h2><p>1.程序=数据结构+算法；</p><p>2.数据结构和算法的联系：数据存储结构会影响算法的好坏，不能只单单考虑一种，存储强、信息多的存储结构，算法会比较好设计，反而相对简单的存储结构可能要设计一套复杂的算法；</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>1.线性表定义：具有相同特征的数据元素的一个有限序列；</p><p>2.线性表的抽象数据类型：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ADT：线性表（List）Data：一个有n个数据元素的数据集合，且元素类型相同，除了第一个和最后一个元素，每一个元素只有一个前驱元素和后继元素，且它之间的关系是一一对应的；Operation：其中i是下标，e是表元素Init<span class="token punctuation">(</span><span class="token punctuation">)</span>:初始化操作IsEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span>:判断是否为空Clear<span class="token punctuation">(</span><span class="token punctuation">)</span>:清空操作GetElem<span class="token punctuation">(</span>i<span class="token punctuation">)</span>:根据下标获取元素Locate<span class="token punctuation">(</span>e<span class="token punctuation">)</span>:根据元素获取下标，为-1则表示返回失败；Insert<span class="token punctuation">(</span>e,i<span class="token punctuation">)</span>:在下标位置插入元素Delete<span class="token punctuation">(</span>i<span class="token punctuation">)</span>:删除下标元素，并且返回其值Lengtn<span class="token punctuation">(</span><span class="token punctuation">)</span>:获取个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>1.顺序存储结构定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素，逻辑上相邻的俩个元素在对应得顺序表中它们得存储位置也相邻；</p><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>2.链式存储结构定义：</p><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h1 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h1><h1 id="数和二叉树"><a href="#数和二叉树" class="headerlink" title="数和二叉树"></a>数和二叉树</h1><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h1 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h1><h1 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;数据结构概论&quot;&gt;&lt;a href=&quot;#数据结构概论&quot; class=&quot;headerlink&quot; title=&quot;数据结构概论&quot;&gt;&lt;/a&gt;数</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络技术</title>
    <link href="https://wwy.wwywy.com/posts/536.html"/>
    <id>https://wwy.wwywy.com/posts/536.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-17T13:20:30.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概叙"><a href="#计算机网络概叙" class="headerlink" title="计算机网络概叙"></a>计算机网络概叙</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.定义：一些互连的、独立自治的计算机集合；</p><p>2.目的：资源共享、数据通信、负载均衡和分布式计算、数据信息集中处理；</p><p>3.一般分类：</p><ul><li>按通信媒体：有线网络、无线网络；</li><li>按使用对象：公众网络、专用网络、接入网；</li><li>网络传输技术：广播式网络、点到点网络；</li><li>按地理覆盖（常用）：<ul><li>局域网：几十米到几千米之间；</li><li>城域网：几千米到几十千米；</li><li>广域网 ：几十千米到几千千米，例如Internet；</li></ul></li></ul><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><p>1.常见的拓扑结构：</p><ul><li>总线型拓扑结构：结构简单、易于阔充、属于广播网络；</li><li>星型拓扑结构：结构简单、易于实现和管理、但是耗费电缆、中心出问题会带动其他地方；</li><li>树形拓扑结构：易于分级管理和控制；</li><li>环形拓扑结构：结构简单、易于实现、传输时延确定和路径选择简单；</li><li>网状拓扑结构：充分利用网络资源，但是成本高；</li></ul><h2 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h2><p>1.比特的概念：比特(bit)意思是一个二进制数字（0或1）。 B为字节(Byte)，b为比特(bit)，一字节为8比特，即1B = 8b。 网络技术中的数率指的是数据的传送速率，当数据率较高时，常常在bit/s前面加上字母，比如k = $10^3$,M = $10^6$,G = $10^9$,T = $10^{12}$等。 （注意区分网络传输和文件系统中的数据后缀字母，文件系统一般是字节。比如一个100MB的文件，这里的M就是$2^{20}$，传输率为100Mbit/s，这里的M为$10^6$）</p><p>2.数据传输率：又叫比特率，指连接在网络上的主机在数字信道上传送数据的速率。 速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等；</p><p>3.信道容量：信道容量即是指最大的数据传输速率，通常说数字通信系统所说的带宽与数据传输速率相等，注意这个数据传输速率是实际的传输速率，实际与最大的数据传输速率二者之间满足香农公式，具体如下俩种情况</p><ul><li>在有噪声的情况下即信道不是理想信道，信道容量是信道能够达到的最大数据速率，此时数字信道的带宽W与信道容量C满足香农公式C=W${Log}_{2}$（1+S/N） ;</li><li>理想信道时，根据奈奎斯特定理，C=最大的数据传输速率=2W；</li></ul><p>4.带宽：分以下俩种情况</p><ul><li>对于模拟通信或传输介质，带宽指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）；</li><li>而数字通信系统中“带宽”，理论上是指传输信道的信道容量，也即信道中传递信息的最大值，单位为“比特/秒”。由于数字系统中的信道多指逻辑信道，而信道容量又是理论上的最大值(不可能达到)，所以平时我们使用的“带宽”一词，是指信道中数据的实际传输速率；</li></ul><p>5.误码率：误码指信号传输过程中受干扰的和衰减的数据传输错误，是衡量传输可靠性的主要观测点，误码率${P}_{e}$=接受的错位数  除以   传输总数；</p><p>6.时延：</p><ul><li>发送时延：发送数据时，数据帧从结点进入到传输媒体所需要的时间。 $\mathrm{发送时延};=;\frac{\mathrm{数据帧长度}(b)}{\mathrm{发送速率}(b/s)}$</li><li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间。 $\mathrm{传播时延};=;\frac{\mathrm{信道长度}(米)}{\mathrm{信号在信道上的传输速率}(b/s)}$</li><li>处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间；</li><li>排队时延：结点缓存队列中分组排队所经历的时延.</li><li>总时延：总时延 = 发送时延+传播时延+处理时延+处理时延</li></ul><p>7.利用率：信道利用率指出某信道有百分之几的时间是被利用的。 网络利用率则是全网络的信道利用率的加权平均值. $D;=;\frac{D_0}{1;-;U}$ $D_0$为网络空闲时的时延，$D$为当前时延，U为利用率。</p><h1 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h1><h2 id="ISO-OSI七层模型"><a href="#ISO-OSI七层模型" class="headerlink" title="ISO/OSI七层模型"></a>ISO/OSI七层模型</h2><p>1.专业术语</p><ul><li>实体和对等实体：每一层中，用于实现该层功能的活动元素被称为实体，不同机器同一层、完成相同功能的实体称为对等实体；</li><li>协议：对等实体之间交换数据的约定；</li><li>服务和接口：下层为上层提供的功能叫服务，通过上下层之间的接口实现；</li></ul><p>2.OSI理想模型层级（由上到下）：</p><ul><li>应用层（APDU）：负责为用户程序提供网络服务；</li><li>表示层（PPDU）：表示层以下关心可靠的数据传输，而表示层关心传输数据的语法和语义；</li><li>会话层（SPDU）：在俩个节点之间建立、维护和释放用户连接；</li><li>传输层（分段）：该层负责两台主机中进程之间的通信，而传输层上三层主要面向用户提供服务，下三层面向网络通信；</li><li>网络层（分组）：端到端的主机通信；</li><li>数据链路层（帧）：解决相邻节点的数据传输等问题；</li><li>物理层（比特流）：直接面向原始比特流的传输；</li></ul><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>1.TCP\IP模型层级（从上到下）：应用层、传输层、网络层、网络访问层；</p><p>2.OSI模型和TCP/IP模型比较：</p><ul><li>相同点：<ul><li>均采用层次结构，并具有可比的运输层和网络层；</li><li>都基于协议数据单元的包交换网络，且分别作为概念模型和事实标准；</li></ul></li><li>不同点：<ul><li>OSI七层，TCP四层，TCP应用层中包含了OSI上三层的功能，网络访问层包含了下俩层的功能；</li><li>OSI对分层很好的说明服务、协议、接口的概念，是最重要的计算机网络概念模型，但是每层都存在寻址、流量控制、差错控制等机制，所以比较复杂，缺乏实现上的操作性；</li><li>TCP/IP层次较少，显得更加简洁，容易实现，但是服务、协议、接口区分并不是很清晰。</li></ul></li></ul><p><img src="https://s1.ax1x.com/2022/03/08/bgleBj.jpg" alt="OSI模型和TCP/IP模型比较"></p><h2 id="五层结构（OSI和TCP-IP折中方案）"><a href="#五层结构（OSI和TCP-IP折中方案）" class="headerlink" title="五层结构（OSI和TCP/IP折中方案）"></a>五层结构（OSI和TCP/IP折中方案）</h2><p>1.五层结构（从上到下）：</p><ul><li>应用层：是体系中的最高层，任务是通过应用进程间的交互来完成特定网络应用，把应用层交互的数据单元称为报文。</li><li>运输层：负责两台主机中进程之间的通信提供通用的数据传输服务。主要用到以下两种协议;<ul><li>TCP：传输控制协议（Transmission Control Protocol），提供面向连接，可靠地数据传输服务，其数据传输的单位是报文段。</li><li>UDP：用户数据报协议（User Datagram Protocol）,提供无连接的，尽最大努力的数据传输服务，是不可靠的。其数据传输的单位是用户数据报。</li></ul></li><li>网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。在TCP/IP体系中使用IP协议，因此分组也叫做IP数据报。</li><li>数据链路层：两台主机之间的数据传输，总是在一段一段的链路上进行传送的，需要使用专门的链路层协议，在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点之间的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样数据链路层在接收到一个帧后，就可以从中提取出数据部分，上交给网络层。</li><li>物理层：物理层上所传数据的单位是比特。传递信息所用的载体（比如双绞线，光缆等）不属于物理层，是物理层下面一层。</li></ul><h2 id="分组交换技术☆"><a href="#分组交换技术☆" class="headerlink" title="分组交换技术☆"></a>分组交换技术☆</h2><p>1.介绍：提高信道利用率，提高抗毁性 端到端数据流被划分为若干数据块，添加首部形成若干分组，分组首部中携带地址、长度等控制信息 主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。 路由器的用途则是用来转发分组的，即进行分组交换的，分组交换也称包交换，它是将用户传送的数据划分成一定的长度，每个部分叫做一个分组。在每个分组的前面加上一个分组头，用以指明该分组发往何地址，然后由交换机根据每个分组的地址标志，将他们转发至目的地，这一过程称为分组交换。进行分组交换的通信网称为分组交换网。从交换技术的发展历史看，数据交换经历了电路交换、报文交换、分组交换和综合业务数字交换的发展过程。分组交换实质上是在“存储—转发”基础上发展起来的。它兼有电路交换和报文交换的优点。分组交换在线路上采用动态复用技术传送按一定长度分割为许多小段的数据—分组。每个分组标识后，在一条物理线路上采用动态复用的技术，同时传送多个数据分组。把来自用户发端的数据暂存在交换机的存储器内，接着在网内转发。到达接收端，再去掉分组头将各数据字段按顺序重新装配成完整的报文。分组交换比电路交换的电路利用率高，比报文交换的传输时延小，交互性好，如下图所示；</p><p><img src="https://s1.ax1x.com/2022/03/06/bDzxmt.png" alt="分组交换技术"></p><p>2.存储转发：路由器在输入链路上接收整个分组 存储接收的分组 然后选择输出链路，并以最大传输速率向输出链路转发；</p><p>3.优点：</p><ul><li>高效：动态分配传输带宽，对通信链路是逐段占用；</li><li>灵活：以分组为传送单位和查找路由；</li><li>迅速：不必先建立连接就能向其他主机发送分组；</li><li>可靠：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性；</li></ul><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h2><p>1.说明：物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p><p>2.物理层主要问题：</p><ul><li>信号和信道类型选择</li><li>传输媒体选择</li><li>提高传输媒体的利用率</li><li>关于衰减和噪音影响的处理</li><li>通信方式的选择</li><li>物理互通的实现</li></ul><p>3.物理层传输质量的评估：通过数据传输速率和误码率作为评估主要标准；</p><h2 id="基带传输和数字数据编码"><a href="#基带传输和数字数据编码" class="headerlink" title="基带传输和数字数据编码"></a>基带传输和数字数据编码</h2><p>1.基本概念：二进制数字数据利用脉冲信号（数字信号和信道）来进行传输和编码，数字信号是离散的电压或电流脉冲序列，常用方法是使用脉冲信号来表示二进制数字字符“0”和“1”；</p><p>2.数字信号编码方式：如下</p><ul><li>不归零制：正电平代表1，负电平代表0；</li><li>归零制：正脉冲代表1，负脉冲代表0；</li><li>曼彻斯特编码：位周期中心的向上跳代表0，位周期中心的向下跳代表1，也可以反过来定义；</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1；<br>  <img src="https://s1.ax1x.com/2022/03/08/bgBGHP.png" alt="数字信号编码方式"></li></ul><h2 id="频带传输和调制解调"><a href="#频带传输和调制解调" class="headerlink" title="频带传输和调制解调"></a>频带传输和调制解调</h2><p>1.频带传输基本概念：基带传输受到距离限制，所以远距离一般采用模拟通信；</p><p>2.调制解调方法：如下三种</p><ul><li>幅度调制</li><li>频率调制</li><li>相位调制</li></ul><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>1.分类：如下几种</p><ul><li>有线传输媒体：<ul><li>双绞线：最古老又最常用、价格便宜，但是对电磁干扰敏感，主要用于室内；</li><li>同轴电缆：新标准已经不再推荐；</li><li>光纤：传输带宽大，传输损耗小，中继距离长，抗干扰能力强（雷电和电磁干扰），保密性好（不易被窃听）体积小，重量轻。精确对接困难。</li></ul></li><li>无线传输媒体：<ul><li>无线电波：通过空间电磁传播、无需安装物理线路，频率范围再30kHz到30000MHz之间，波长10km~0.1mm；</li><li>微波（卫星）： 带宽高，容量大，不受环境影响，且不需实现铺好电缆，但是需要相关部门许可；</li><li>红外线：通过空间电磁传播、不受电磁干扰和射频干扰，但是必须再直线视距之间，且数据传输速率相对较低；</li><li>激光通信：短距离传输，但是受天气影响大；</li></ul></li></ul><p><img src="https://s1.ax1x.com/2022/03/08/bgsM3F.png" alt="无线传输媒体"></p><p>2.传输媒体的比较和选用：如下图<br><img src="https://s1.ax1x.com/2022/03/08/bgyP56.png" alt="传输媒体的比较"></p><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><p>1.基本概念：指在一条物理线路上建立多条通信信道；</p><p>2.分类：</p><ul><li> 频分复用（FDM）：将线路带宽划分成若干较小带宽来达到多路复用目的，用户在分配在一定频宽后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。</li><li> 时分复用（TDM）：将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占领固定序号的时隙，时分复用的所有用户是在不同的时间占用同样的频带宽度，时分复用分为同步（STDM）和异步（ATDM）技术。</li><li> 波分复用（WDM）：采用光波波长的分隔的多路复用方法；</li><li> 码分复用（CDM）：是一种移动通信系统的复用技术，基于码型分割信道，每个用户可以在同样时间使用同样频带进行通信，具有很强的抗干扰性。</li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>1.串行通信和并行通信：</p><ul><li>串行通信：指发送端所发送和的数据，按照数据位的先后顺序，依次通过信源和信宿之间的单条信道到达接收端；</li><li>并行通信：发送端和接受端之间多条并行信道实现一个节拍下多个数据位的并行传送；</li></ul><p>2.全双工通信和半双工通信</p><ul><li>单工通信：能有一个方向的通信而没有反方向的交互（广播和电视节目）；</li><li>半双工通信：通信的双方都可以发送信息，但不能双方同时发送和同时接收（对讲机）；</li><li>全双工通信：通信的双方可以同时发送和接收信息（手机）；</li></ul><h2 id="常见物理层组件和设备"><a href="#常见物理层组件和设备" class="headerlink" title="常见物理层组件和设备"></a>常见物理层组件和设备</h2><p>1.常见的物理组件设备：指物理层提供的无源器件，如下所示</p><ul><li>端接器件：为网络线缆连接提供良好的端接，不同线缆对应的连接头不能通用；</li><li>转换器：用于不同接口或媒体之间进行信号转换；</li></ul><p>2.常见的物理组件：用于增强网络覆盖和传输距离的网络互联网设施</p><ul><li>中继器：对物理信号进行放大再生，单进单出，网络规模增加时，需要多个中继器；</li><li>集线器：拥有多个接端口，但是只能提供一路的信号放大、整形和转发，否则会出问题；</li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据链路层概念"><a href="#数据链路层概念" class="headerlink" title="数据链路层概念"></a>数据链路层概念</h2><p>1.基本概念：</p><ul><li>使用一对一的点对点通信方式；</li><li>数据链路=物理链路+数据链路协议；</li><li>数据链路层是为了克服物理层的不足而建立的，旨在实现网络俩个相邻节点之间的无差错传输和信息的定界；</li></ul><p>2.待解决的问题：</p><ul><li>物理寻址：</li><li>数据链路的建立、维持和释放；</li><li>数据流的定界；</li><li>差错控制；</li><li>流量控制；</li><li>帧的构造、同步和区分；</li></ul><h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><h3 id="帧与成帧"><a href="#帧与成帧" class="headerlink" title="帧与成帧"></a>帧与成帧</h3><p>1.帧的概念：帧是数据链路层的协议数据单元，有了帧，数据就有了意义，不再是物理层的原始比特流；</p><p>2.帧的构成：在数据的前后添加上帧首和帧尾构成一个帧；</p><p>3.帧的定界：就是区分帧开始和帧结束的方法，主要如下三种</p><ul><li>字符计数法：使用一个字符计数字段来标明帧内字符数；</li><li>带字符填充的首尾界符法：帧头帧尾前面加上一个ASCII的字符标志，此法会有大量的冗余DLE标记字符；</li><li>带位填充的首位标志法：与上类似，但是采用特殊的二进制位数来进行标志；</li></ul><p>4.零比特填充：在发送端，只要发现有5个连续1，则立即填入一个0；而接受端对帧中比特流进行扫描时，每当发现5个连续1，就把这5个连续1后的一个0删除；</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>1.差错原因：在传输过程中可能出现误差，1可能变成0，而0可能变成1；</p><p>2.误码率：传输错误的比特占所传输比特总数的比率称为误码率（BER）；误码率和信噪比有很大关系；</p><p>3.差错控制机制：计算机网络传输数据时，必须采用如校验码的技术，校验码根据校验能力不同分为纠错码和检错码，如下所说</p><ul><li>纠错码：纠错码不仅可以发现所悟，还能进行自动纠正错误，例如汉明码这种典型的纠错码（在计算机组成中有说明）</li><li>检错码：而检错码只能发现传输中的错误，常见的如奇偶校验码（在计算机组成中有说明）和循环冗余校验码，目前，数据链路层广泛采用循环冗余检验码；</li></ul><p>4.CRC循环冗余检验：以下运算皆使用二进制的模2运算 CRC冗余码的生成：先进行$2^n$乘M(待发送的数码)，相当于在M后面加n个零，M(k位)是原本的数码，然后除以除数P(n+1位)(一般用多项式表示，比如P为1101,用多项式表示就是P(x) = $x^3+x^2+1$，就是对应位)，得到的余数(n位)就是冗余码，把它拼接到尾部即可。 CRC冗余码的检验：将收到的数码(k+n位)除以事先商定好的除数P(n+1位)，得出的余数为R(n位)，如果R为0说明没有差错。</p><p>5.反馈重发机制：由于检错码本身不提供自动错误纠错的能力，所以需要一种错误纠正的机制：</p><ul><li>停止-等待方式：发出一帧后停下来判断对方是否正确收到，否则，就重发该帧，该模式性能较差；</li><li>连续自动请求重发方式：发送帧后，不进行等待，而是连续发送，出现传输差错采取以下措施：<ul><li>拉回方式：某帧出现问题后，接收方丢弃该帧后所有帧，发送端重发该帧后所有帧；</li><li>选择性重传方式：接收方只丢弃该帧，缓存该帧后所有帧，发送端只重发该帧，该方式需要足够的存储缓冲；<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3></li></ul></li></ul><p>1.流量控制的作用：发送端和接受端接收数据速率不匹配造成的弱端丢帧问题；</p><p>2.滑动窗口协议：一种采用滑动窗口机制进行流量控制的方式，通过限制已经发送但还未得到确认的帧数量，滑动窗口协议可以调整发送端的发送速率，由帧序列号、发送窗口和接受窗口组成；</p><h3 id="数据链路成协议"><a href="#数据链路成协议" class="headerlink" title="数据链路成协议"></a>数据链路成协议</h3><p>1.点对点协议PPP：全世界采用最多的数据链路层协议是点对点协议PPP（Point-to-Point Protocol），用户使用拨号电话接入因特网时，一般采用的就是PPP协议；</p><h3 id="数据链路层的设备和组件"><a href="#数据链路层的设备和组件" class="headerlink" title="数据链路层的设备和组件"></a>数据链路层的设备和组件</h3><p>1.网卡：全称网络适配器，主要实现数据的发送和接受、帧的封装和拆封、编码和解码、数据缓存和媒体访问控制；每一个网卡在出厂时都被分配一个全球唯一的地址标识（MAC地址）；</p><p>2.网桥：实际中已经不再使用，了解即可；</p><p>3.交换机：由网桥发展而来，是一种多功能网桥；</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的概述"><a href="#网络层的概述" class="headerlink" title="网络层的概述"></a>网络层的概述</h2><p>1.网络层说明：数据链路层只解决了相邻之间节点的数据传输问题，而大多数源节点和目标节点并不是相邻节点，网络层由此而生，以下是主要的问题；</p><ul><li>节点之间的最佳路径选择问题（又被称为路由）；</li><li>路径选择时的超负载和空闲协调；</li><li>异构网络的互联问题（异构指网络技术、通信协议、计算机体系和操作系统存在差异）；</li><li>跨越互联网的主机寻址问题；</li></ul><p>2.网络层提供的服务：网络层向上提供简单灵活、无连接的、尽最大努力的数据报服务；</p><p>3.IP协议说明：IP协议是TCP/IP网络层的核心协议，也是整个TCP/IP模型中最重要的核心协议之一，规定该层的协议数据单元的类型和格式（分组packet）</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>1.IPv4地址结构和分类：</p><ul><li>结构：IP地址目前住主要分为IPv4和IPv6，同时移动端也有特殊的“mobile”的协议；IPv4采用32位长度的二进制地址，但为了书写和记忆，又采用了点分十进制来进行记忆，</li><li>分类：被分为A、B、C、D和E五类，其中ABC是普通的主机地址，而D是网路组播服务或者网路测试使用的，E类地址保留给实验和未来扩充使用；</li></ul><p>IPv4地址的分类:<br><img src="https://s1.ax1x.com/2022/03/17/q9wAk4.png" alt="分类的IPv4地址"></p><p>IPv4的指派范围:<br><img src="https://s1.ax1x.com/2022/03/17/q9wn6x.png" alt="IPv4的指派范围"></p><p>一般不使用的特殊IP:<br><img src="https://s1.ax1x.com/2022/03/17/q9wt1I.png" alt="一般不使用的特殊IP"></p><p>2.IP地址逻辑地址和物理地址：物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址(因为IP地址是用软件实现的)。 在发送数据时，数据从高层下到低层，然后才能到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在了MAC帧首部。 IP地址放在IP数据报首部，硬件地址规则放在MAC帧的首部，在网络层以上使用的都是IP地址，在数据链路层及以下使用的都是硬件地址，以MAC地址是不变的，而IP地址可能会随着网络的迁移而变化；</p><p>3.地址解析协议ARP：不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。通过地址解析协议ARP即可知道IP地址对应的MAC值。</p><p><img src="https://s1.ax1x.com/2022/03/17/q909Cd.png" alt="地址解析协议ARP"></p><p>4.</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="知名端口"><a href="#知名端口" class="headerlink" title="知名端口"></a>知名端口</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络概叙&quot;&gt;&lt;a href=&quot;#计算机网络概叙&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概叙&quot;&gt;&lt;/a&gt;计算机网络概叙&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机网络技术" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="计算机网络技术" scheme="https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://wwy.wwywy.com/posts/528.html"/>
    <id>https://wwy.wwywy.com/posts/528.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-03-15T10:57:11.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="计算机软硬件概念"><a href="#计算机软硬件概念" class="headerlink" title="计算机软硬件概念"></a>计算机软硬件概念</h2><p>1.软硬件概念：计算机系统由软件和硬件俩大部分组成，如下；</p><ul><li>硬件：是计算机的实体部分；</li><li>软件：由各类特殊功能的程序组成，通常存放在计算机的主存或者辅存中，通常分为系统软件和应用软件；</li></ul><h2 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h2><p>1.冯·诺依曼计算机：1945年提出“存储程序”概念设计的计算机，是对图灵机（<a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E6%9C%BA/2112989">图灵机</a>）概念模型的实现和升级，冯·诺依曼计算机是以运算器为中心的，现代的计算机已经转化为以存储器为中心，如下图；</p><p><img src="https://s1.ax1x.com/2022/03/06/bBXj7F.png" alt="冯·诺依曼计算机"></p><p>2.计算机组成：以下五部分组成</p><ul><li>输入设备：将程序和数据以机器所能识别和接受的信息形式输入到计算机内（键盘、鼠标、扫描仪、语音输入设备、手写笔、触摸屏、数码摄像设备等）；</li><li>输出设备：将计算机处理的结果以人们所能接受的信息形式或其它系统所要求的信息形式输出（显示器、打印机、绘图仪 、音箱）；</li><li>存储器：用于存放程序和数据。存储器是计算机存储信息的核心，一般分为如下主存和外存。<ul><li>主存储器(主存，内存)：CPU能直接访问，主存分为若干个存储单元，每个单元都有唯一的地址编码，通常是按字节或字节的整数倍编码。存储器总是按地址访问的；</li><li>辅助存储器(外存，辅存)：CPU不能直接访问，辅存中的信息必须调入主存后，才能为CPU所使用，辅存速度较慢，但容量大，用于存放CPU暂时不用的程序和数据（软盘、硬盘、光盘、磁带机）；</li></ul></li><li>运算器：用于完成算术和逻辑运算，核心是算术逻辑部件(ALU)，是CPU的核心部件，还有若干寄存器，用于存放操作数、中间结果或最终结果；</li><li>控制器：控制器是整个计算机的指挥中心，通过实现编好的程序用于控制整个计算机系统中的各部件有条不紊地进行工作，其控制部件（CU）是CPU的核心部件，运作如下。<ul><li>程序计数器PC（Program Counter）：存放将要执行的指令的地址（指向存储单元），具有自增功能；</li><li>指令寄存器IR（ Instruction Register）： 存放当前正在执行的指令；</li><li>指令译码器ID（Instruction Decoder）：分析指令；</li><li>时序部件（Sequencer）：分析指令时序；</li><li>控制信号发生器：运作；<br><img src="https://s1.ax1x.com/2022/03/06/bBXrYd.png" alt="计算机五大组成部件"></li></ul></li></ul><p>3.计算机硬件技术指标：</p><ul><li>机器字长：数据的位数，一般和CPU寄存器有关；</li><li>存储容量：存储器的容量；</li><li>运算速度：计算机运行速度；</li></ul><h1 id="计算计信息和运算"><a href="#计算计信息和运算" class="headerlink" title="计算计信息和运算"></a>计算计信息和运算</h1><h2 id="机器数的表示"><a href="#机器数的表示" class="headerlink" title="机器数的表示"></a>机器数的表示</h2><h3 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h3><p>1.机器数：如下分类</p><ul><li>定义：计算机中的数据通常存放在寄存器中，通常称寄存器的位数为机器字长，而存储的数据叫机器数；</li><li>格式：符号和数值均二进制化，小数点隐含在某一固定位置上，不占存储空间，位数受机器字长的限制。超过机器字长的数值位要舍去；</li><li>分类：俩种情况<ul><li>无符号数：机器字长的所有二进制均表示数值部分；</li><li>带符号数：第1个二进制位为符号位，其余为数值部分 ；</li></ul></li></ul><p>2.真值：机器数所表示的实际数值，例：8位机器数为11011011分以下情况</p><ul><li>若为无符号整数，其真值为 219；</li><li>若为带符号整数，且采用原码表示，则最高位为符号， 1 1011011 表示二进制整数 -1011011，其真值为 -91；</li></ul><h3 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h3><p>1.原码的定义：符号位0表示正数，1表示负数，数值位即真值的绝对值，约定符号位用逗号隔开，小数位用小数点隔开，如下整数和小数的定义式；</p><ul><li>整数原码定义式：其中x为真值，n为整数位位数，<ul><li>$ {[x]}_{原} $ = 0,x   当$ 2^n $&gt;x&gt;=0时 （就是等于真值，正数前面加上符号0）</li><li>$ {[x]}_{原} $ = $2^n$-x  当0&gt;=x&gt;$-2^n$时（就是等于真值，负数前面加上符号1）</li></ul></li><li>小数原码定义式：其中x为真值<ul><li> $ {[x]}_{原} $ = x   当1&gt;x&gt;=0时（就是等于真值，正数前面加上符号0）</li><li> $ {[x]}_{原} ​$ = 1-x   当0&gt;=x&gt;-1时（就是等于真值，负数前面加上符号1）</li></ul></li><li>0的表示：<ul><li>纯小数 ：[+0]原=0.00…0，[-0]原=1.00…0</li><li>纯整数：[+0]原=00…0，[-0]原=10…0</li></ul></li></ul><p>2.原码的优缺点：</p><ul><li>优点：<ul><li>表示简单；</li><li>和真值转换容易；</li></ul></li><li>缺点：<ul><li>0有俩种表示，给使用带来不便；</li><li>原码表示加减法运算很复杂；</li></ul></li></ul><h3 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h3><p>1.补数的说明：能找到一个模，让一个数对于模的补数就是正数本身（例如mod10中 -4=6），如下结论</p><ul><li>让它的负数可用它的正补数来代替，这个正补数可以用模加上负数本身求得；</li><li>一个正数和一个负数互为补数时，它们的绝对相加即为模数；</li><li>正数的补数即为正数本身；</li></ul><p>2.补码的定义：如下整数和小数的定义式</p><ul><li>整数补码定义式：其中x为真值，n为整数位位数<ul><li>$ {[x]}_{补} $ = 0,x   当$ 2^n $&gt;x&gt;=0时 （正数就是等于原码）</li><li>$ {[x]}_{补} $ = $2^n+1$+x   当0&gt;=x&gt;$-2^n$时 （根据x的原码，每位取反，末位加一）<br> 小数补码定义式：其中x为真值</li><li>$ {[x]}_{补} $ = x   当1&gt;x&gt;=0时 （正数就是等于原码）</li><li>$ {[x]}_{补} $ = 2+x   当0&gt;=x&gt;-1时 （根据x的原码，每位取反，末位加一）</li></ul></li><li>0的表示：<ul><li>纯小数 ：[+0]补=[-0]补=0.00…0</li><li>纯整数：[+0]补=[-0]补=0,00…0</li></ul></li></ul><p>3.补码的优缺点：</p><ul><li>优点：<ul><li>可以只设加法器，将减法转成加法的形式；</li><li>只表示一个0 ;</li></ul></li><li>缺点：<ul><li>比原码多表示一个-1; </li></ul></li></ul><h3 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h3><p>1.反码说明：反码通常用来作为原码和反码互转的中间过渡；</p><p>2.反码定义：如下整数和小数的定义式</p><ul><li>整数补码定义式：其中x为真值，n为整数位位数<ul><li>$ {[x]}_{反} $ = 0,x   当$ 2^n $&gt;x&gt;=0时 （正数就是等于原码）</li><li>$ {[x]}_{反} $ = ($2^n+1$-1)+x   当0&gt;=x&gt;$ -2^n $时 （根据x的原码，每位取反）</li></ul></li><li>小数补码定义式：其中x为真值<ul><li>$ {[x]}_{反} $ = x   当1&gt;x&gt;=0时 （正数就是等于原码）</li><li>$ {[x]}_{反} $ = (2-$2^-n$)+x   当0&gt;=x&gt;-1时 （根据x的原码，每位取反）</li></ul></li><li>0的表示：<ul><li>纯小数 ：[+0]反=0.00…0，[-0]反=1.00…0</li><li>纯整数：[+0]反=00…0，[-0]反=10…0</li></ul></li></ul><h3 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h3><p>1.移码定义：移码表示把真值x在数轴上正向平移1(纯小数)或2n(纯整数)，所以移码也称为增码、余码，如下定义式，其中x为真值，n为整数位位数</p><ul><li>移码定义式：${[x]}_{移}$ = $ 2^n $+x   当$2^n$&gt;x&gt;=$-2^n$时 （和[x]补互转，符号位取反，数值位不变）；</li></ul><h3 id="四种机器数总结"><a href="#四种机器数总结" class="headerlink" title="四种机器数总结"></a>四种机器数总结</h3><p>1.最高位都表示符号位。原码、反码和补码的符号位均是0表示+，1表示-，移码相反。<br>2.移码、补码和反码的符号位可和数值位一起参加运算；原码的符号位必须分开进行处理。<br>3.对于正数，除移码外，其他码值都等于真值本身，而对于负数各有不同的表示。<br>4.对于真值0，原码和反码各有两种不同的表示形式，而补码和移码只有唯一的一种表示形式。<br>5.原码、反码表示的范围是一样的；补码、移码表示的范围是一样的，且比前二者能多表示一个最负的数：$-2^n$（纯整数）或-1（纯小数）。</p><h2 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h2><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p>1.前置知识-科学计数法说明：任何一个数都可以表示为$ {(N)}_R=M\times R^e $，详细如下</p><ul><li>M：尾数。代表数N的有效数字。计算机中一般表示为纯小数；</li><li>R：尾数基值。计算机中常用的R可取2、8、16等；</li><li>e：阶码。代表数N的小数点的实际位置。一般表示为纯整数；</li><li>根据小数点的位置是否固定，计算机中的数据格式又分为两种：定点表示和浮点表示。</li></ul><h3 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h3><p>1.定点表示说明：约定计算机中所有数据的小数点位置是固定不变的，即阶码e的取值固定不变；</p><p>2.定点数说明：采用定点表示的数据，机器数确定后，e也就确定了，不能更改，整数和小数不能共存，当运算结果超出机器数所能表示的数据范围时，会出现溢出；</p><ul><li>定点整数：小数点位于数值位后面，表示范围-(1-$2^-n$)~(1-$2^-n$)；</li><li>定点小数：小数点位于数符和第一数值位之间，表示范围-($2^n$-1)~($2^n$-1)；</li></ul><p>3.定点数缺点：</p><ul><li>比例因子难以选择，容易溢出或影响精度</li><li>表示的数值范围比较小</li><li>存储单元利用率低，当存储特别大或者特别小的数时，可能大部分尾数都是0被浪费掉了；</li></ul><h3 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h3><p>1.浮点表示说明：指小数点位置可变的数据表示形式，即e值是可变的；</p><p>2.浮点数说明：典型的浮点数格式由阶码e和尾数M组成，一般被表示成$ {(N)}_R=M\times R^e $；</p><ul><li>基数R：用隐含方法表示，数学中一般由数位权决定，二进制通常取R＝2；</li><li>阶码e：阶码的二进制数值位决定了表示数的小数点实际位置，也就是数的大小，可用补码或移码表示；</li><li>尾数M：表示数的有效数字，符号代表浮点数的正负，其位数反映了浮点数的精度，可用补码或原码表示；</li></ul><p>3.浮点数的规格化：尾数最高位为1的数为规格化数，为了提高浮点数的精度，其尾数必须是规格化数；</p><ul><li>左规：尾数每左移一位，阶码减一；</li><li>右规：同上相反；</li></ul><p>4.浮点数的表示范围：阶码用移码，尾数用补码<br><img src="https://s1.ax1x.com/2022/03/13/bqVKIS.png" alt="浮点数的表示范围"></p><p>5.IEEE754浮点数标准：每个浮点数由三部分组成数符S，指数E，尾数M，有以下四种格式</p><ul><li>单精度格式（32位）：E=8位，M=23位；</li><li>扩展单精度格式：E&gt;=11位，M=31位；</li><li>双精度格式（64位）：E=11位，M=52位；</li><li>扩展双精度格式：E&gt;=15位，M&gt;=63位；</li></ul><h3 id="定点数和浮点数的比较"><a href="#定点数和浮点数的比较" class="headerlink" title="定点数和浮点数的比较"></a>定点数和浮点数的比较</h3><p>1.定点数和浮点数的比较：如下几点</p><ul><li>当浮点机和定点机中数的数位相同时，浮点数表示的范围比定点数大得多；</li><li>浮点数为规格化数时，其相对精度远比定点数高；</li><li>浮点数运算分阶码和尾数部分，而且运算结果都要求规格化，故浮点运算比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算复杂；</li><li>在溢出判断上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断；</li></ul><h2 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>1.移位运算的说明：计算机中小数点的位置是事先约定的，二进制表示数在相对于小数点作n位左移或者右移时，其本质就是乘以或者除以2^n，这种移位操作可以配合加法相结合，就可以简单的实现乘除运算；</p><p>2.算数移位规则：考虑正数负数俩种情况</p><ul><li>正数：原码，反码，补码等于真值，故移位后的空位均添加0；</li><li>负数：负数时，三种机器数表现形式均不同，所以分开考虑<ul><li>原码 ：添加代码0；</li><li>补码：左移添加0，右移添加1；</li><li>反码：添加1；</li></ul></li></ul><p>3.算数移位和逻辑移位的区别：</p><ul><li>算数移位：有符号的移位是算数移位，算数位移左右移时，符号位会位移保留，避免移丢；</li><li>逻辑位移：无符号的是逻辑移位，逻辑位移左右移时，移往的位置会移丢，反过来添0；</li></ul><h3 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h3><p>1.原码加减法运算规则：符号位不能和数据一起参与运算，符号位和加减法指令共同作为运算的依据，加法采用同号求和，异号求差，减法采用异号求和，同号求差，如下解释：</p><ul><li>求和：俩操作数的数值位相加得到和的数值位，数值最高位产生进位，则结果溢出，和的符号位采用第一操作数的（被加数/被减数）的符号；</li><li>求差：第一操作数的数值位加上第二操作数（加数/减数）的数值位的补码，分俩种情况考虑；<ul><li>最高数值位有进位，表明加法结果为正，所得数值位正确，结果的符号位采用第一操作数的符号；</li><li>最高数值位无进位，表明加法结果为负（补码形式），应对于求其补，还原为绝对值形式的数值位，结果的符号位位第一操作数的符号变反；</li></ul></li></ul><p>2.补码加减法运算规则：</p><ul><li>参与运算的各个操作数均以补码表示，运算结果仍以补码表示；</li><li>符号位和数值一起参与运算；</li><li>若求和，则将俩补码直接相加，得到俩数之和的补码；</li><li>若求差，则将减数变补，然后和被减数相加，得到俩数之差的补码。</li><li>补码总是对确定的模而言的，当运算结果超过模，则模自动丢掉；</li></ul><h3 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h3><p>1.一位符号位判断溢出：如下说明</p><ul><li>对于加法，只有正正相加或者负负相加才会溢出；</li><li>对于减法，只有正减负，或者负减正才会溢出；</li><li>减法运算在机器一般都采用加法器实现，故只要实际操作的数符号相同，但又和原操作结果数符号不同，即为溢出；</li></ul><p>2.俩位符号位判断溢出（没懂）：</p><ul><li>俩位符号位的补码是以4为模的，即变形补码；</li><li>变形补码判断的原则是俩位符号位不同时，表示溢出，否则不溢出</li><li>不论是否发生溢出，第一位符号位永远代表真正符号；</li></ul><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><p>1.补码一位乘法运算规则（没懂）：如下五步</p><ul><li>a：参与运算的数均以补码表示，结果仍以补码表示；</li><li>b：增设yn+1，且初始化为0，部分积初始化为0；</li><li>c：部分积与被乘数采用双符号位，且符号位参加运算；</li><li>d：判别ynyn+1，并采取相应的操作。其中，右移指将部分积连同乘数（ 包括yn+1 ）一起算术右移；</li><li>e：重复d，共做n+1次操作，最后一次不移位；<br>  <img src="https://s1.ax1x.com/2022/03/14/bO6tv8.png" alt="机器数乘法运算"></li></ul><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><p>1.存储器分类：以下三种分类</p><ul><li>按存储介质分类：<ul><li>半导体存储器：体积小、功耗低、存取时间短、近年来信息易失的弊端也慢慢被克服，是目前主流的存储器；</li><li>磁表面存储器：主要是非易失性，现在计算机已经很少采用了；</li><li>磁芯存储器：体积过大，目前已经逐渐被半导体存储器所取代了；</li><li>光盘存储器记录密度高、耐用性好、可靠性高，越来越被用于计算机系统；</li></ul></li><li>按存取方式：<ul><li>随机存储器（RAM）：存储器任何一个存储单元的内容都可以随机读取或者写入，且存取时间和存储单元物理位置无关，主要用于组成主存；</li><li>只读存储器（ROM）：只能随机读出而不能随机写入和修改，可作为主存的一部分，通常用来存放固定不变的程序，而且还能作为其他固定存储器，如存放微程序的控制存储器、存放字符点阵图案的字符发生器等；</li><li>顺序存取存储器（SAM）：存储器所存的信息是按顺序进行的，没有唯一的对于地址，并且存取时间与存储器的物理位置有关，常用的如磁带存储器；</li><li>直接存取储存器（DAM）：介于SAM和RAM之间，也称为半顺序存储器，当进行信息存取时，先进行寻道，属于随机方式，然后在磁道中寻找扇区，属于顺序方式；</li></ul></li><li>按计算机中的作用分类：<ul><li>主存储器：CPU能直接访问的存储器；</li><li>辅助存储器：CPU不能直接访问的存储器；</li><li>高速缓冲存储器：  是一种介于主存和CPU之间用于解决CPU和主存速度匹配问题的高速小容量的存储器，Cache用于存放CPU立即要运行或刚使用过的程序和数据；</li></ul></li></ul><p>2.存储器层次结构关系：寄存器&gt;缓存&gt;主存&gt;磁盘&gt;磁带，从右到左，速度越快，价位越高，容量越小（反映了时间空间的矛盾关系）；</p><h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="主存的组成和操作"><a href="#主存的组成和操作" class="headerlink" title="主存的组成和操作"></a>主存的组成和操作</h3><p>1.主存储器组成：以下由小到大：</p><ul><li>存储元：能存储一位二进制信息的物理器件，存储元是存储器中最小的存储单位，以下是存储元的必要条件：<ul><li>由俩个稳定状态，对应二进制的0和1；</li><li>在外界的刺激下，能写入0和1；</li><li>能够识别器件当前的状态，即可读出所存的0和1； </li></ul></li><li>存储单元：由一组存储元件组成，可以同时进行读写；</li><li>存储体：把大量存储单元电路按一定形式排列起来，即构成存储体，存储体一般排列成阵列形式，所以又叫存储阵列；</li></ul><p>2.存储器的地址：存储体中每个存储单元被赋予一个唯一的编号，该编号就是存储单元的地址，当访问某存储单元时，必须给出存储单元的地址；</p><p>3.存储单元的编址：</p><ul><li>按字节编址：相邻的俩个单元就是俩个字节；</li><li>按字编制：相邻的俩个单元就是俩个字；</li></ul><p>4.主存读写过程：</p><ul><li>CPU通过地址总线把地址送到主存地址寄存器MAR；</li><li>CPU通过数据总线向主存数据寄存器MDR发送和写入数据或从主存的MDR接收读出数据；</li><li>CPU通过控制总线把地址吗向主存发送读写控制信号；</li></ul><h3 id="存储器的主要性能指标"><a href="#存储器的主要性能指标" class="headerlink" title="存储器的主要性能指标"></a>存储器的主要性能指标</h3><p>1.主要性能指标：</p><ul><li>存储容量：存储容量是指主存能存放的二进制代码的总位数，存储容量=存储单元个数*存储字节； <ul><li>在以字节为编址单位的机器中，常用字节表示存储容量，例如4MB表示主存可容纳4兆个字节信息；</li><li>对于存储器芯片，用存储单元数×每个单元的位数表示，例如512k×16位，表示主存有512k个单元，每个单元为16位；</li></ul></li><li>存储速度：存储速度是由存取时间和存取周期来表示的；</li></ul><p>2.存储容量的主要计量单位和存储器地址线关系:</p><ul><li>1K=2^10=1024：需要10根地址线；</li><li>1M=2^20=1048576：需要20根地址线；</li><li>1G=2^30=1073741824：需要30根地址线；</li></ul><h3 id="半导体随机存取存储器"><a href="#半导体随机存取存储器" class="headerlink" title="半导体随机存取存储器"></a>半导体随机存取存储器</h3><p>1.SRAM（静态随机存取存储器）：</p><ul><li>集成度较低（6管）、单片容量较小；</li><li>不需要刷新；</li><li>速度快，曾在Pentium主板上用作二级高速缓存；</li><li>通常是字选方式；</li></ul><p>2.DRAM（动态随机存取存储器）：</p><ul><li>集成度高（单管），单片容量较大；</li><li>需要定时刷新；</li><li>速度较慢，多用作主存储器；</li><li>通常是位选方式</li></ul><h3 id="半导体只读存储器"><a href="#半导体只读存储器" class="headerlink" title="半导体只读存储器"></a>半导体只读存储器</h3><p>1.只读存储器类型：对于半导体ROM而言，基本器件为俩种，MOS型和TTL型</p><ul><li>掩模ROM；</li><li>PROM；</li><li>EPROM；</li></ul><h3 id="存储器提升和优化"><a href="#存储器提升和优化" class="headerlink" title="存储器提升和优化"></a>存储器提升和优化</h3><p>1.存储器扩充：单片存储芯片的容量总是有限的，一个存储器由一定数量的存储芯片构成，芯片总片数=（存储器总单元数×位数）/（每片芯片单元数×位数），但是很难满足实际需求，所以将若干存储芯片连接在一起才能组成足够容量的存储器，称为存储容量的扩展，如下几种方式</p><ul><li>位扩展：指存储字节的扩展；</li><li>字扩展：指增加存储器字的数量；</li><li>字、位扩展：以上俩种；</li></ul><p>2.存储器和CPU连接：存储芯片和CPU芯片相连时，特别要注意片和片之间的地址线、数据线和控制线的连接；</p><ul><li>地址线的连接：存储芯片的容量不同，其地址线数也不同，CPU的地址线往往比存储芯片的地址线多很多，通常是将CPU地址线的地位和存储芯片的地址线相连，而CPU的高位或在存储芯片扩充时用，或做其他途径，如片选信号；</li><li>数据线的连接：CPu数据线数与存储芯片的数据线数也不一定相等，也需要对存储芯片扩位，使其数据位数相等；</li><li>读写命令线的连接：CPU读写命令线一般可直接与存储芯片读写控制端相连，通常高点平为读，低电平为写；</li><li>片选线的连接：存储器的哪一片存储芯片被选中完全取决于该存储芯片的片选控制端CS是否能接受到来自CPU的片选有效信号；</li><li>合理选择存储芯片：通常使用ROM存放系统程序、标准子程序和各类常数等，而RAM则是为用户编程而设置的；</li></ul><p>3.存储器校验：采用汉明码进行纠正错误；</p><p>4.提高访存速度的措施：</p><ul><li>单体多字系统：同一个存储周期，从同一个地址取出4条指令，然后再逐条送至CPU执行，即每隔1/4存取周期，主存向CPU发送一条指令，显然增大了单体存储器的带宽；</li><li>多体并行系统：采用多体模块组成的存储器，每个模块有相同的容量和存取速度，即同时访问N个模块，同时启动，同时读写，完全并行工作，而主存和哪个部件交换信息由存储器控制部件承担，如下是它的的组成体；<ul><li>排队器：访问是随机的，为了防止发生俩个以上的请求源同时占用一个存储体，必须设立一个排队器来确定请求的优先级；</li><li>存控标记触发器C_M：用来接受排队器的输出的排队信号；</li><li>节拍发生器：用来产生固定节拍，与机器主脉冲同步，使控制线路按一定时序发出信号；</li><li>控制线路：向存储器的部件发出请求和响应回复；</li></ul></li><li>高性能存储芯片：DRAM如今发展速度很快，几乎每隔三年存储芯片的容量就翻俩番，同时还出现了许多基于DRAM的增强功能，例如SDRAM、RDRAM、CDRAM；</li></ul><h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>1.高速缓冲存储器说明（Cache）：Cache的提出有以下俩个主要原因；</p><ul><li>避免CPU空等现象：在多体并行存储系统中，由于I/O设备向主存请求的级别高于CPU，所以会出现等待I/O设备访存的现象，使CPU空等一段时间；</li><li>CPU和主存（DRAM）的速度差异：CPU速度平均每年改进百分之60，而组成主存的动态RAM速度每年只改进百分之7，主存的速度始终跟不上CPU的发展；</li></ul><h3 id="Cache性能指标"><a href="#Cache性能指标" class="headerlink" title="Cache性能指标"></a>Cache性能指标</h3><p>1.命中率：设$N_c$为访问Cache的总命中次数，$N_m$为访问主存的总次数，则 Cache 命中率为 $h;=;\frac{N_c}{N_c+N_m}$</p><p>2.平均访问时间：设 $t_c$ 为命中时的Cache访问时间，$t_m$ 为未命中时的主存访问时间，则Cache – 主存系统的 平均访问时间为$t_a=ht_c+(1-h)t_m$（平均访问时间 ta 与 命中率 有关）；</p><p>3.访问效率：访问效率 e 与 命中率 有关，$e=\frac{\mathrm{访问}Cache\mathrm{的时间}}{\mathrm{平均访问时间}}\times100%$，设 Cache 命中率 为 h，访问 Cache 的时间为 $t_c$ ，访问 主存 的时间为 $t_m$，$e=\frac{t_c}{h\times t_c+(1-h)\times t_m}\times100%$；</p><h3 id="Cache命中问题"><a href="#Cache命中问题" class="headerlink" title="Cache命中问题"></a>Cache命中问题</h3><p>1.缓存命中说明：</p><ul><li>Cache命中：CPU欲访问的数据已经在Cache中；</li><li>Cache不命中：CPU欲访问的数据不在Cache内；</li><li>命中率：CPU欲访问的信息在Cache中的比率；</li></ul><h3 id="Cache基本结构"><a href="#Cache基本结构" class="headerlink" title="Cache基本结构"></a>Cache基本结构</h3><p>1.Cache基本组成：</p><ul><li>Cache存储体：存储体以快为单元和主存交换信息，且主存大多采用多体结构，且Cache访存的优先级最高；</li><li>地址映射机构：是将CPU送来的主存地址转换为Cache地址，有如下几种替换策略<ul><li>直接映射：固定的映射关系，容易实现，但是不够灵活，降低缓存命中率；</li><li>全相联映射：灵活的映射关系，命中率高，但是逻辑电路甚多，成本较高；</li><li>组相联映射：上面方案的折中实现； </li></ul></li><li>替换机构：当Cache的内容已满时，无法接受来自主存块的信息时，就有Cache内的替换机构按照一定的替换算法来进行替换，替换的算法如下：<ul><li>先进先出算法（FIFO）：选择最早进入Cache的字块进行替换，不需要记录各字块的使用情况，比较容易实现，但是没有根据访存的局部性原理，故不能提高Cache的命中率；</li><li>近期最少使用算法（LRU）：利用访存的局部性原理，替换出近期用得最少的字块，平均命中率比FIFO高，但是需要记录各字块的使用情况，一般作简化，只记录每个块最近一次使用的时间；</li><li>随机法： 随机进行替换，比较简单；</li></ul></li></ul><p>###Cache读写操作<br>1.读操作：如图<br><img src="https://s1.ax1x.com/2022/03/15/bjqz7j.png" alt="Cache读操作流程图"></p><p>2.写操作：</p><ul><li>如果Cache命中，那么就需要保持Cache和主存内容一致的问题，如下俩种解决方案：<ul><li>写直达法：同时写入主存和高速存储器，容易实现，但是增加访问次数；</li><li>写回法：只写入高速存储器，但是标记该组被修改过；</li></ul></li><li>如果Cache不命中 ：<ul><li>按写分配法：写入主存，同时装入该块到Cache；</li><li>不按写分配法：直接写入主存，不进行装入； </li></ul></li></ul><h3 id="Cache改进（多级缓存）"><a href="#Cache改进（多级缓存）" class="headerlink" title="Cache改进（多级缓存）"></a>Cache改进（多级缓存）</h3><p>1.Cache改进方式：主要有俩种改进方式</p><ul><li>单一缓存和两级缓存：单一缓存指CPU和主存之间只设一个缓存，且随着集成电路的开发，这个缓存直接和CPU制作在同一个芯片上，故称片内缓存（一级缓存），片内缓存速度很快，但是容量往往比较小，所以在主存和片内缓存之间又加了一级缓存，称片外缓存（二级缓存）；</li><li>统一缓存和分立缓存：统一缓存指指令和数据都存放在同一个缓存内的Cache中；而分立缓存指指令和数据分别存放在俩个缓存中，一个称为指令缓存，一个称为数据缓存；</li></ul><h2 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h2><p>1.辅助存储器说明：辅存属于外部存储器，相对于主存而言具有容量大、速度慢、价格低且非易失性的存储器，目前主要使用的辅盘有硬磁盘、软磁盘、磁带和光盘，前三者都属于磁表面存储器；</p><p>2.磁表面存储器主要计数指标</p><ul><li>记录密度；</li><li>存储容量；</li><li>平均寻址时间；</li><li>数据传输率；</li><li>误码率；</li></ul><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令的概念"><a href="#指令的概念" class="headerlink" title="指令的概念"></a>指令的概念</h2><p>1.指令（机器指令）：控制计算机执行某种操作的命令；</p><p>2.指令字（指令码）：表示一条指令的二进制代码；</p><p>3.机器语言：用机器指令设计的编程语言，是计算机硬件实体直接表示控制信息的语言；</p><p>4.机器语言程序，用机器语言编制的程序，任何用其他语言编制的程序，都必须经过”翻译“，翻译为机器语言程序，才能在机器中正确的运行；</p><p><a href="http://c.biancheng.net/view/4136.html">编译型语言和解释型语言的区别</a></p><p>5.指令系统（指令集）：一台计算机所能执行的全部指令的集合；</p><h2 id="指令的特征和格式"><a href="#指令的特征和格式" class="headerlink" title="指令的特征和格式"></a>指令的特征和格式</h2><p>1.指令特征：</p><ul><li>完备性：指令功能齐全、足够使用；</li><li>高效性：所编写的程序占存储空间小、执行速度快；</li><li>规整性：所有的寄存器和存储单元都可同等对待，所有指令都可使用各种寻址方式；</li><li>匀齐性：可以支持各种数据类型，指令的格式和数据格式的一致性；</li><li>兼容性：系列机各种机型具有相同的基本结构和共同的基本指令集；</li></ul><p>2.指令的格式：操作码+地址码</p><ul><li>操作码：指定指令所要完成的操作；</li><li>地址码：操作数的来源，结果去向，下一条指令的地址；</li></ul><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><h1 id="控制器和中央处理器"><a href="#控制器和中央处理器" class="headerlink" title="控制器和中央处理器"></a>控制器和中央处理器</h1><h2 id="控制器和中央处理器的概念"><a href="#控制器和中央处理器的概念" class="headerlink" title="控制器和中央处理器的概念"></a>控制器和中央处理器的概念</h2><p>1.概念说明：控制器是计算机的指挥和控制中心，其主要功能就是根据事先编好并存放在存储器中的解题程序，按所执行指令的具体要求，适时地产生并发出各种控制命令，控制计算机各部件自动、连续、协调地进行工作，直到完成程序的全部功能为止。所以控制器的基本功能就是运行程序；</p><h2 id="控制器的工作过程"><a href="#控制器的工作过程" class="headerlink" title="控制器的工作过程"></a>控制器的工作过程</h2><p>1.工作过程说明：</p><ul><li>取指令：根据PC（程序计数器）提供的指令地址，从存储器中取出所要执行的指令放入IR（指令寄存器）；</li><li>分析指令：对取出的指令进行译码分析，确定指令应完成的操作，产生相应操作的控制电位，去参与形成该指令功能所需要的全部控制命令（微操作控制信号）；根据寻址方式，形成操作数的有效地址，并按此地址取出操作数据（运算型指令）或形成转移地址（转移类指令），以实现程序转移；</li><li>执行指令：根据指令所规定的操作，并根据需要，保存操作结果，一条指令执行结束，若没有异常情况和特殊请求，则按程序顺序，再去取出并执行下一条指令；</li></ul><h1 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h1><h2 id="输入输出系统概念"><a href="#输入输出系统概念" class="headerlink" title="输入输出系统概念"></a>输入输出系统概念</h2><p>1.概念：</p><ul><li>输入设备：将外部可读数据转换称计算机内部的数字编码设备；</li><li>输出设别：将计算机内部的数字编码转换成外部可读的字符，图形或声音的设备；</li></ul><h1 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h1><h2 id="系统总线概念"><a href="#系统总线概念" class="headerlink" title="系统总线概念"></a>系统总线概念</h2><p>1.基本概念：一组可为多个功能部件共享的公共信息传送线路；</p><p>2.总线上系统传输的特点：某一时刻只允许一个部件向总线发送信息，而多个部件和同时从总线接收信息；</p><h1 id="补充附录"><a href="#补充附录" class="headerlink" title="补充附录"></a>补充附录</h1><h2 id="数据效验码"><a href="#数据效验码" class="headerlink" title="数据效验码"></a>数据效验码</h2><h3 id="奇偶效验码"><a href="#奇偶效验码" class="headerlink" title="奇偶效验码"></a>奇偶效验码</h3><p>1.奇偶校验码定义：在n位的有效信息位AnAn-1…A1中，加一位校验位P，构成n+1位的奇偶校验码AnAn-1…A1P或者PAnAn-1…A1，若P使n+1位的校验码中“1”的个数为奇数或者偶数。则称为奇校验码或者偶校验码，校验位P又记作Peven（Podd）；</p><h3 id="海明效验码"><a href="#海明效验码" class="headerlink" title="海明效验码"></a>海明效验码</h3><h2 id="常用进位计数制"><a href="#常用进位计数制" class="headerlink" title="常用进位计数制"></a>常用进位计数制</h2><p>1.定义：用进位的原则进行计数称为进位计数制，简称进制；</p><p>2.有关的概念：</p><ul><li>数码：一组用来表示某种数制的符号，eg：二进制的0和1；</li><li>基数：数制所使用的数码个数，常用R表示，称为R进制；</li><li>位权：数码在不同位置的权值 eg：十进制的位权就是10的几次方；</li></ul><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>1.定义：</p><ul><li>数码：1，2，3，4，5，6，7，8，9；</li><li>基数：10；</li><li>位权：10为底的幂；</li><li>写法规则：2022 D （D是DEC，可以省略）；</li></ul><p>2.转二进制：转换规则：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来，如下图： 180（十进制）转换二进制为：10110100<br><img src="https://s1.ax1x.com/2022/03/06/bDda79.png" alt="十进制转二进制"></p><p>3.转八进制：按照8除十进制整数取余，直到商为0为止；<br><img src="https://s1.ax1x.com/2022/03/06/bD0yee.png" alt="十进制转八进制"></p><p>4.转十六进制：转换规则：用16整除十进制整数，可以得到一个商和余数；再用16去除商，又会得到一个商和余数，如此进行；<br><img src="https://s1.ax1x.com/2022/03/06/bD0Hoj.png" alt="十进制转十六进制"></p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>1.定义：</p><ul><li>数码：0，1；</li><li>基数： R= 2；</li><li>位权：2为底的幂；</li><li>写法规则：0B 10010101 B （0B是c#中s使用二进制的前缀，D是BIN，可以省略）；</li></ul><p>2.转十进制：把二进制按权展开，相加即得十进制数<br><img src="https://s1.ax1x.com/2022/03/06/bDaTeJ.png" alt="二进制转十进制"></p><p>3.转八进制：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。<br><img src="https://s1.ax1x.com/2022/03/06/bDd9wd.png" alt="二进制转八进制"></p><p>4.转十六进制：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。<br><img src="https://s1.ax1x.com/2022/03/06/bDwG4I.png" alt="二进制转十六进制"></p><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>1.定义：</p><ul><li>数码：0,1,2,3,4,5,6,7；</li><li>基数：8；</li><li>位权：8为底的幂；</li><li>写法规则：0 720 O （0是c#中使用八进制的前缀，O是OCT，可以省略）；</li></ul><p>2.转十进制：把八进制数按权展开、相加即得十进制数。<br><img src="https://s1.ax1x.com/2022/03/06/bDBFYR.png" alt="八进制转十进制"></p><p>3.转二进制：八进制通过除二取余，得到二进制数，对每个八进制为3个二进制，不足在最左边补零；<br><img src="https://s1.ax1x.com/2022/03/06/bDdkfP.png" alt="八进制转二进制"></p><p>4.转十六进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换；</p><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>1.定义：</p><ul><li>数码：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F;</li><li>基数：16;</li><li>位权：16为底的幂；</li><li>写法规则：0X 1AF H （0X是c#中使用十六进制的前缀，D是HEX，可以省略）；</li></ul><p>2.转十进制：把十六进制数按权展开、相加即得十进制数。<br><img src="https://s1.ax1x.com/2022/03/06/bDBu0e.png" alt="十六进制转十进制"></p><p>3.转二进制：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。<br><img src="https://s1.ax1x.com/2022/03/06/bDw0bQ.png" alt="十六进制转二进制"></p><p>4.转八进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换</p><h2 id="CPU类型"><a href="#CPU类型" class="headerlink" title="CPU类型"></a>CPU类型</h2><p>复杂指令：X86（CISC）<br>精简指令：ARM（RISC）</p><h2 id="ASCII码（美国信息交换标准代码）"><a href="#ASCII码（美国信息交换标准代码）" class="headerlink" title="ASCII码（美国信息交换标准代码）"></a>ASCII码（美国信息交换标准代码）</h2><p>1.ASCII 码说明：ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。其中：</p><ul><li>0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 。</li><li>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。</li><li>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</li><li>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1 [1]  。</li><li>后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1]  。</li></ul><p>2.ASCII码表具体如下所示 :</p><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>缩写/字符</th><th>解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>00</td><td>0</td><td>0x00</td><td>NUL(null)</td><td>空字符</td></tr><tr><td>0000 0001</td><td>01</td><td>1</td><td>0x01</td><td>SOH(start of headline)</td><td>标题开始</td></tr><tr><td>0000 0010</td><td>02</td><td>2</td><td>0x02</td><td>STX (start of text)</td><td>正文开始</td></tr><tr><td>0000 0011</td><td>03</td><td>3</td><td>0x03</td><td>ETX (end of text)</td><td>正文结束</td></tr><tr><td>0000 0100</td><td>04</td><td>4</td><td>0x04</td><td>EOT (end of transmission)</td><td>传输结束</td></tr><tr><td>0000 0101</td><td>05</td><td>5</td><td>0x05</td><td>ENQ (enquiry)</td><td>请求</td></tr><tr><td>0000 0110</td><td>06</td><td>6</td><td>0x06</td><td>ACK (acknowledge)</td><td>收到通知</td></tr><tr><td>0000 0111</td><td>07</td><td>7</td><td>0x07</td><td>BEL (bell)</td><td>响铃</td></tr><tr><td>0000 1000</td><td>010</td><td>8</td><td>0x08</td><td>BS (backspace)</td><td>退格</td></tr><tr><td>0000 1001</td><td>011</td><td>9</td><td>0x09</td><td>HT (horizontal tab)</td><td>水平制表符</td></tr><tr><td>0000 1010</td><td>012</td><td>10</td><td>0x0A</td><td>LF (NL line feed, new line)</td><td>换行键</td></tr><tr><td>0000 1011</td><td>013</td><td>11</td><td>0x0B</td><td>VT (vertical tab)</td><td>垂直制表符</td></tr><tr><td>0000 1100</td><td>014</td><td>12</td><td>0x0C</td><td>FF (NP form feed, new page)</td><td>换页键</td></tr><tr><td>0000 1101</td><td>015</td><td>13</td><td>0x0D</td><td>CR (carriage return)</td><td>回车键</td></tr><tr><td>0000 1110</td><td>016</td><td>14</td><td>0x0E</td><td>SO (shift out)</td><td>不用切换</td></tr><tr><td>0000 1111</td><td>017</td><td>15</td><td>0x0F</td><td>SI (shift in)</td><td>启用切换</td></tr><tr><td>0001 0000</td><td>020</td><td>16</td><td>0x10</td><td>DLE (data link escape)</td><td>数据链路转义</td></tr><tr><td>0001 0001</td><td>021</td><td>17</td><td>0x11</td><td>DC1 (device control 1)</td><td>设备控制1</td></tr><tr><td>0001 0010</td><td>022</td><td>18</td><td>0x12</td><td>DC2 (device control 2)</td><td>设备控制2</td></tr><tr><td>0001 0011</td><td>023</td><td>19</td><td>0x13</td><td>DC3 (device control 3)</td><td>设备控制3</td></tr><tr><td>0001 0100</td><td>024</td><td>20</td><td>0x14</td><td>DC4 (device control 4)</td><td>设备控制4</td></tr><tr><td>0001 0101</td><td>025</td><td>21</td><td>0x15</td><td>NAK (negative acknowledge)</td><td>拒绝接收</td></tr><tr><td>0001 0110</td><td>026</td><td>22</td><td>0x16</td><td>SYN (synchronous idle)</td><td>同步空闲</td></tr><tr><td>0001 0111</td><td>027</td><td>23</td><td>0x17</td><td>ETB (end of trans. block)</td><td>结束传输块</td></tr><tr><td>0001 1000</td><td>030</td><td>24</td><td>0x18</td><td>CAN (cancel)</td><td>取消</td></tr><tr><td>0001 1001</td><td>031</td><td>25</td><td>0x19</td><td>EM (end of medium)</td><td>媒介结束</td></tr><tr><td>0001 1010</td><td>032</td><td>26</td><td>0x1A</td><td>SUB (substitute)</td><td>代替</td></tr><tr><td>0001 1011</td><td>033</td><td>27</td><td>0x1B</td><td>ESC (escape)</td><td>换码(溢出)</td></tr><tr><td>0001 1100</td><td>034</td><td>28</td><td>0x1C</td><td>FS (file separator)</td><td>文件分隔符</td></tr><tr><td>0001 1101</td><td>035</td><td>29</td><td>0x1D</td><td>GS (group separator)</td><td>分组符</td></tr><tr><td>0001 1110</td><td>036</td><td>30</td><td>0x1E</td><td>RS (record separator)</td><td>记录分隔符</td></tr><tr><td>0001 1111</td><td>037</td><td>31</td><td>0x1F</td><td>US (unit separator)</td><td>单元分隔符</td></tr><tr><td>0010 0000</td><td>040</td><td>32</td><td>0x20</td><td>(space)</td><td>空格</td></tr><tr><td>0010 0001</td><td>041</td><td>33</td><td>0x21</td><td>!</td><td>叹号</td></tr><tr><td>0010 0010</td><td>042</td><td>34</td><td>0x22</td><td>“</td><td>双引号</td></tr><tr><td>0010 0011</td><td>043</td><td>35</td><td>0x23</td><td>#</td><td>井号</td></tr><tr><td>0010 0100</td><td>044</td><td>36</td><td>0x24</td><td>$</td><td>美元符</td></tr><tr><td>0010 0101</td><td>045</td><td>37</td><td>0x25</td><td>%</td><td>百分号</td></tr><tr><td>0010 0110</td><td>046</td><td>38</td><td>0x26</td><td>&amp;</td><td>和号</td></tr><tr><td>0010 0111</td><td>047</td><td>39</td><td>0x27</td><td>‘</td><td>闭单引号</td></tr><tr><td>0010 1000</td><td>050</td><td>40</td><td>0x28</td><td>(</td><td>开括号</td></tr><tr><td>0010 1001</td><td>051</td><td>41</td><td>0x29</td><td>)</td><td>闭括号</td></tr><tr><td>0010 1010</td><td>052</td><td>42</td><td>0x2A</td><td>*</td><td>星号</td></tr><tr><td>0010 1011</td><td>053</td><td>43</td><td>0x2B</td><td>+</td><td>加号</td></tr><tr><td>0010 1100</td><td>054</td><td>44</td><td>0x2C</td><td>,</td><td>逗号</td></tr><tr><td>0010 1101</td><td>055</td><td>45</td><td>0x2D</td><td>-</td><td>减号/破折号</td></tr><tr><td>0010 1110</td><td>056</td><td>46</td><td>0x2E</td><td>.</td><td>句号</td></tr><tr><td>0010 1111</td><td>057</td><td>47</td><td>0x2F</td><td>/</td><td>斜杠</td></tr><tr><td>0011 0000</td><td>060</td><td>48</td><td>0x30</td><td>0</td><td>字符0</td></tr><tr><td>0011 0001</td><td>061</td><td>49</td><td>0x31</td><td>1</td><td>字符1</td></tr><tr><td>0011 0010</td><td>062</td><td>50</td><td>0x32</td><td>2</td><td>字符2</td></tr><tr><td>0011 0011</td><td>063</td><td>51</td><td>0x33</td><td>3</td><td>字符3</td></tr><tr><td>0011 0100</td><td>064</td><td>52</td><td>0x34</td><td>4</td><td>字符4</td></tr><tr><td>0011 0101</td><td>065</td><td>53</td><td>0x35</td><td>5</td><td>字符5</td></tr><tr><td>0011 0110</td><td>066</td><td>54</td><td>0x36</td><td>6</td><td>字符6</td></tr><tr><td>0011 0111</td><td>067</td><td>55</td><td>0x37</td><td>7</td><td>字符7</td></tr><tr><td>0011 1000</td><td>070</td><td>56</td><td>0x38</td><td>8</td><td>字符8</td></tr><tr><td>0011 1001</td><td>071</td><td>57</td><td>0x39</td><td>9</td><td>字符9</td></tr><tr><td>0011 1010</td><td>072</td><td>58</td><td>0x3A</td><td>:</td><td>冒号</td></tr><tr><td>0011 1011</td><td>073</td><td>59</td><td>0x3B</td><td>;</td><td>分号</td></tr><tr><td>0011 1100</td><td>074</td><td>60</td><td>0x3C</td><td>&lt;</td><td>小于</td></tr><tr><td>0011 1101</td><td>075</td><td>61</td><td>0x3D</td><td>=</td><td>等号</td></tr><tr><td>0011 1110</td><td>076</td><td>62</td><td>0x3E</td><td>&gt;</td><td>大于</td></tr><tr><td>0011 1111</td><td>077</td><td>63</td><td>0x3F</td><td>?</td><td>问号</td></tr><tr><td>0100 0000</td><td>0100</td><td>64</td><td>0x40</td><td>@</td><td>电子邮件符号</td></tr><tr><td>0100 0001</td><td>0101</td><td>65</td><td>0x41</td><td>A</td><td>大写字母A</td></tr><tr><td>0100 0010</td><td>0102</td><td>66</td><td>0x42</td><td>B</td><td>大写字母B</td></tr><tr><td>0100 0011</td><td>0103</td><td>67</td><td>0x43</td><td>C</td><td>大写字母C</td></tr><tr><td>0100 0100</td><td>0104</td><td>68</td><td>0x44</td><td>D</td><td>大写字母D</td></tr><tr><td>0100 0101</td><td>0105</td><td>69</td><td>0x45</td><td>E</td><td>大写字母E</td></tr><tr><td>0100 0110</td><td>0106</td><td>70</td><td>0x46</td><td>F</td><td>大写字母F</td></tr><tr><td>0100 0111</td><td>0107</td><td>71</td><td>0x47</td><td>G</td><td>大写字母G</td></tr><tr><td>0100 1000</td><td>0110</td><td>72</td><td>0x48</td><td>H</td><td>大写字母H</td></tr><tr><td>0100 1001</td><td>0111</td><td>73</td><td>0x49</td><td>I</td><td>大写字母I</td></tr><tr><td>01001010</td><td>0112</td><td>74</td><td>0x4A</td><td>J</td><td>大写字母J</td></tr><tr><td>0100 1011</td><td>0113</td><td>75</td><td>0x4B</td><td>K</td><td>大写字母K</td></tr><tr><td>0100 1100</td><td>0114</td><td>76</td><td>0x4C</td><td>L</td><td>大写字母L</td></tr><tr><td>0100 1101</td><td>0115</td><td>77</td><td>0x4D</td><td>M</td><td>大写字母M</td></tr><tr><td>0100 1110</td><td>0116</td><td>78</td><td>0x4E</td><td>N</td><td>大写字母N</td></tr><tr><td>0100 1111</td><td>0117</td><td>79</td><td>0x4F</td><td>O</td><td>大写字母O</td></tr><tr><td>0101 0000</td><td>0120</td><td>80</td><td>0x50</td><td>P</td><td>大写字母P</td></tr><tr><td>0101 0001</td><td>0121</td><td>81</td><td>0x51</td><td>Q</td><td>大写字母Q</td></tr><tr><td>0101 0010</td><td>0122</td><td>82</td><td>0x52</td><td>R</td><td>大写字母R</td></tr><tr><td>0101 0011</td><td>0123</td><td>83</td><td>0x53</td><td>S</td><td>大写字母S</td></tr><tr><td>0101 0100</td><td>0124</td><td>84</td><td>0x54</td><td>T</td><td>大写字母T</td></tr><tr><td>0101 0101</td><td>0125</td><td>85</td><td>0x55</td><td>U</td><td>大写字母U</td></tr><tr><td>0101 0110</td><td>0126</td><td>86</td><td>0x56</td><td>V</td><td>大写字母V</td></tr><tr><td>0101 0111</td><td>0127</td><td>87</td><td>0x57</td><td>W</td><td>大写字母W</td></tr><tr><td>0101 1000</td><td>0130</td><td>88</td><td>0x58</td><td>X</td><td>大写字母X</td></tr><tr><td>0101 1001</td><td>0131</td><td>89</td><td>0x59</td><td>Y</td><td>大写字母Y</td></tr><tr><td>0101 1010</td><td>0132</td><td>90</td><td>0x5A</td><td>Z</td><td>大写字母Z</td></tr><tr><td>0101 1011</td><td>0133</td><td>91</td><td>0x5B</td><td>[</td><td>开方括号</td></tr><tr><td>0101 1100</td><td>0134</td><td>92</td><td>0x5C</td><td>\</td><td>反斜杠</td></tr><tr><td>0101 1101</td><td>0135</td><td>93</td><td>0x5D</td><td>]</td><td>闭方括号</td></tr><tr><td>0101 1110</td><td>0136</td><td>94</td><td>0x5E</td><td>^</td><td>脱字符</td></tr><tr><td>0101 1111</td><td>0137</td><td>95</td><td>0x5F</td><td>_</td><td>下划线</td></tr><tr><td>0110 0000</td><td>0140</td><td>96</td><td>0x60</td><td>`</td><td>开单引号</td></tr><tr><td>0110 0001</td><td>0141</td><td>97</td><td>0x61</td><td>a</td><td>小写字母a</td></tr><tr><td>0110 0010</td><td>0142</td><td>98</td><td>0x62</td><td>b</td><td>小写字母b</td></tr><tr><td>0110 0011</td><td>0143</td><td>99</td><td>0x63</td><td>c</td><td>小写字母c</td></tr><tr><td>0110 0100</td><td>0144</td><td>100</td><td>0x64</td><td>d</td><td>小写字母d</td></tr><tr><td>0110 0101</td><td>0145</td><td>101</td><td>0x65</td><td>e</td><td>小写字母e</td></tr><tr><td>0110 0110</td><td>0146</td><td>102</td><td>0x66</td><td>f</td><td>小写字母f</td></tr><tr><td>0110 0111</td><td>0147</td><td>103</td><td>0x67</td><td>g</td><td>小写字母g</td></tr><tr><td>0110 1000</td><td>0150</td><td>104</td><td>0x68</td><td>h</td><td>小写字母h</td></tr><tr><td>0110 1001</td><td>0151</td><td>105</td><td>0x69</td><td>i</td><td>小写字母i</td></tr><tr><td>0110 1010</td><td>0152</td><td>106</td><td>0x6A</td><td>j</td><td>小写字母j</td></tr><tr><td>0110 1011</td><td>0153</td><td>107</td><td>0x6B</td><td>k</td><td>小写字母k</td></tr><tr><td>0110 1100</td><td>0154</td><td>108</td><td>0x6C</td><td>l</td><td>小写字母l</td></tr><tr><td>0110 1101</td><td>0155</td><td>109</td><td>0x6D</td><td>m</td><td>小写字母m</td></tr><tr><td>0110 1110</td><td>0156</td><td>110</td><td>0x6E</td><td>n</td><td>小写字母n</td></tr><tr><td>0110 1111</td><td>0157</td><td>111</td><td>0x6F</td><td>o</td><td>小写字母o</td></tr><tr><td>0111 0000</td><td>0160</td><td>112</td><td>0x70</td><td>p</td><td>小写字母p</td></tr><tr><td>0111 0001</td><td>0161</td><td>113</td><td>0x71</td><td>q</td><td>小写字母q</td></tr><tr><td>0111 0010</td><td>0162</td><td>114</td><td>0x72</td><td>r</td><td>小写字母r</td></tr><tr><td>0111 0011</td><td>0163</td><td>115</td><td>0x73</td><td>s</td><td>小写字母s</td></tr><tr><td>0111 0100</td><td>0164</td><td>116</td><td>0x74</td><td>t</td><td>小写字母t</td></tr><tr><td>0111 0101</td><td>0165</td><td>117</td><td>0x75</td><td>u</td><td>小写字母u</td></tr><tr><td>0111 0110</td><td>0166</td><td>118</td><td>0x76</td><td>v</td><td>小写字母v</td></tr><tr><td>0111 0111</td><td>0167</td><td>119</td><td>0x77</td><td>w</td><td>小写字母w</td></tr><tr><td>0111 1000</td><td>0170</td><td>120</td><td>0x78</td><td>x</td><td>小写字母x</td></tr><tr><td>0111 1001</td><td>0171</td><td>121</td><td>0x79</td><td>y</td><td>小写字母y</td></tr><tr><td>0111 1010</td><td>0172</td><td>122</td><td>0x7A</td><td>z</td><td>小写字母z</td></tr><tr><td>0111 1011</td><td>0173</td><td>123</td><td>0x7B</td><td>{</td><td>开花括号</td></tr><tr><td>0111 1100</td><td>0174</td><td>124</td><td>0x7C</td><td>|</td><td>垂线</td></tr><tr><td>0111 1101</td><td>0175</td><td>125</td><td>0x7D</td><td>}</td><td>闭花括号</td></tr><tr><td>0111 1110</td><td>0176</td><td>126</td><td>0x7E</td><td>~</td><td>波浪号</td></tr><tr><td>0111 1111</td><td>0177</td><td>127</td><td>0x7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机概论&quot;&gt;&lt;a href=&quot;#计算机概论&quot; class=&quot;headerlink&quot; title=&quot;计算机概论&quot;&gt;&lt;/a&gt;计算机概论&lt;/h1&gt;&lt;h2 id=&quot;计算机软硬件概念&quot;&gt;&lt;a href=&quot;#计算机软硬件概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机组成原理" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论</title>
    <link href="https://wwy.wwywy.com/posts/517.html"/>
    <id>https://wwy.wwywy.com/posts/517.html</id>
    <published>2022-03-02T13:00:00.000Z</published>
    <updated>2022-03-17T09:55:54.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="人工智能基本概念"><a href="#人工智能基本概念" class="headerlink" title="人工智能基本概念"></a>人工智能基本概念</h2><p>1.自然界四大奥秘：物质的本质、宇宙的起源、生命的本质、智能的发生；</p><p>2.智能的定义：智能是只是和智力的总和；</p><p>3.智能的特征：</p><ul><li>感知能力（游戏AI必须品）：主动信息的输入，实现视觉、听觉、触觉、嗅觉等感觉器官；</li><li>记忆力和思维能力：信息的存储和信息的模拟，记忆存储由感知器官感知到的外部信息以及由思维所产生的知识，思维能力对记忆的信息进行处理；<ul><li>逻辑思维（抽象思维）：例如理科生通过逻辑去肢解一道数学题；</li><li>形象思维（直感思维）：例如人的第五感；</li><li>顿悟思维（灵感思维）：例如牛顿如何发现了力学；</li></ul></li><li>学习能力：被动信息的输入，学习既可能是自觉的、有意识的，也可能是不自觉的、无意识的；既可以是有教师指导的，也可以是通过自己实践的；</li><li>行为能力（表达能力）：信息的输入，人工智能实现的目的；</li></ul><h2 id="人工智能发展简史"><a href="#人工智能发展简史" class="headerlink" title="人工智能发展简史"></a>人工智能发展简史</h2><p>人工智能发展史：了解就好了，知乎看看就好；<br><a href="https://zhuanlan.zhihu.com/p/43599960">人工智能发展史 - 知乎 (zhihu.com)</a></p><h2 id="人工智能研究的基本内容"><a href="#人工智能研究的基本内容" class="headerlink" title="人工智能研究的基本内容"></a>人工智能研究的基本内容</h2><p>1.知识表达：将人类知识形式化或者模型化，方法有符号表示法、连接机制表示法，简单点说就是建立一个能把人懂的东西弄成机器能懂的东西的东西；</p><p>2.机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主；</p><p>3.机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理；</p><p>4.机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识；</p><p>5.机器行为：计算机的表达能力，即“说”、“写”、“画”等能力；</p><h2 id="人工智能的主要研究领域"><a href="#人工智能的主要研究领域" class="headerlink" title="人工智能的主要研究领域"></a>人工智能的主要研究领域</h2><p>主要领域：自动定理证明、博弈、模式识别、机器视觉 、自然语言理解、机器翻译、智能信息检索 、数据挖掘与知识发现、专家系统、自动程序设计、机器人、组合优化问题、人工神经网络；</p><p>其他领域：分布式人工智能与多智能体、智能控制、智能仿真、智能CAD 、智能CAI  、智能管理与智能决策 、智能多媒体系统 、智能操作系统、智能计算机系统 、智能通信 、智能网络系统、人工生命 ；</p><h1 id="知识表示与知识图谱"><a href="#知识表示与知识图谱" class="headerlink" title="知识表示与知识图谱"></a>知识表示与知识图谱</h1><h2 id="知识和知识表示"><a href="#知识和知识表示" class="headerlink" title="知识和知识表示"></a>知识和知识表示</h2><h3 id="知识的概念"><a href="#知识的概念" class="headerlink" title="知识的概念"></a>知识的概念</h3><p>1.知识的定义：把有关信息关联在一起所形成的信息结构；</p><p>2.知识的作用：反映了客观世界中事物之间的关系；</p><p>3.知识的特性：</p><ul><li>相对正确性：知识在一定的条件及环境下产生的才是正确的；</li><li>不确定性：<ul><li>随机性引起的不确定性 ：清明一般都会下雨，但是也有不下雨的时候；</li><li>模糊性引起的不确定性 ：根据人的外貌去判断年龄；</li><li>经验引起的不确定性：经历丰富的人相对知识也更加丰富；</li><li>不完全性引起的不确定性：比如对人类对宇宙的了解并不完整；</li></ul></li><li>可表示性和可利用性：知识可以用适当形式表示和利用；</li></ul><h3 id="知识表示的概念"><a href="#知识表示的概念" class="headerlink" title="知识表示的概念"></a>知识表示的概念</h3><p>1.知识表示的定义：将人类的知识形式化或者模型化（人类划重点）；</p><p>2.知识表示的作用：计算机可以接受的描述知识的数据结构</p><p>3.知识选择方法的原则：有利于知识的充分表示和分利用、便于组织、维护、管理、理解和实现；</p><h2 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/thsrobot/article/details/85211896"> 人工智能一阶谓词逻辑表示法</a></p><h2 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h2><p>非专业作了解：<br><a href="http://www.360doc.com/content/11/0502/21/2097544_113822638.shtml">产生式表示法</a></p><h2 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h2><p>非专业作了解：<br><a href="https://www.cnblogs.com/cy0628/p/13905601.html">知识表示之框架表示法</a></p><h2 id="知识图谱（推荐学习）"><a href="#知识图谱（推荐学习）" class="headerlink" title="知识图谱（推荐学习）"></a>知识图谱（推荐学习）</h2><p>定义：是一种揭示实体之间关系的语义网络；<br>目的：知识图谱的目的是为了提高搜索引擎的能力，改善用户的搜索质量以及搜索体验；</p><p>1.知识图谱的逻辑结构：</p><ul><li>数据层：主要是由一系列的事实组成，而知识以事实为单位进行存储。</li><li>模式层：构建在数据层之上，是知识图谱的核心。</li></ul><p>2.知识图谱的原始数据类型：</p><ul><li>结构化数据：是指知识定义和表示都比较完备的数据，如关系数据库；</li><li>半结构化数据：是指部分数据是结构化的，但存在大量结构化程度较低的数据，如XML、JSON；</li><li>非结构化数据：是指没有定义和规范约束的“自由”数据，如文本、视频、音频、图片；</li></ul><p>了解更多：<br><a href="http://www.360doc.com/content/20/0525/00/43535834_914347385.shtml">通俗易懂解释知识图谱</a></p><h2 id="确定性推导方法"><a href="#确定性推导方法" class="headerlink" title="确定性推导方法"></a>确定性推导方法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/lagoon_lala/article/details/85133897">确定性推理方法</a></p><h2 id="不确定性推导方法"><a href="#不确定性推导方法" class="headerlink" title="不确定性推导方法"></a>不确定性推导方法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/qq_31456593/article/details/78623871">不确定推理方法</a></p><h1 id="搜索求解策略"><a href="#搜索求解策略" class="headerlink" title="搜索求解策略"></a>搜索求解策略</h1><h2 id="搜索的概念"><a href="#搜索的概念" class="headerlink" title="搜索的概念"></a>搜索的概念</h2><p>1.搜索算法主要解决问题：</p><ul><li>是否一定能找到一个解。</li><li>找到的解是否是最佳解。</li><li>时间与空间复杂性如何。</li><li>是否终止运行或是否会陷入一个死循环</li></ul><p>2.搜索方向：</p><ul><li>从初始给出的条件出发；</li><li>从目的地出发，进行逆推算；</li><li>（A*算法）从开始状态出发作正向搜索，同时又从目的状态出发作逆向搜索，直到两条路径在中间的某处汇合为止；<h2 id="状态空间的搜索策略"><a href="#状态空间的搜索策略" class="headerlink" title="状态空间的搜索策略"></a>状态空间的搜索策略</h2>非专业作了解：<br><a href="https://blog.csdn.net/weixin_48615832/article/details/120330789">状态空间表示法</a></li></ul><h2 id="盲目的图搜索策略"><a href="#盲目的图搜索策略" class="headerlink" title="盲目的图搜索策略"></a>盲目的图搜索策略</h2><h3 id="回溯策略"><a href="#回溯策略" class="headerlink" title="回溯策略"></a>回溯策略</h3><p>1.回溯策略的数据结构：</p><ul><li>Pass集合：记录寻路算法中的可走路径，保存搜索路径的状态，如果找到了目的，该集合就是解；</li><li>Open集合：等待搜索或者待访问的状态集合；</li><li>Close集合：已经被访问的状态集合；</li></ul><h3 id="广度优先搜索策略"><a href="#广度优先搜索策略" class="headerlink" title="广度优先搜索策略"></a>广度优先搜索策略</h3><p>1.算法特点：如下俩点</p><ul><li>每次选择深度最浅的节点首先扩展，搜索是逐层进行的，如图5.6所示；</li><li>一种高价搜索，会遍历所有节点，但若有解存在，则必能找到它，且是最短路径（可以理解很多人沿着不同的方向走，人多力量大）；<br>  <img src="https://s1.ax1x.com/2022/03/09/bWbIYV.png" alt="广度优先算法搜索次序"></li></ul><p>2.算法描述如下：</p><ul><li>a：选择一个未访问的顶点入队；</li><li>b：从队里选出一个顶点V出队，并且标记为已经访问；</li><li>c：将顶点V的所有未被访问的邻接顶点入队并且设置该节点父节点为顶点V；</li><li>d：重复步骤a~b，直到所有顶点都已经被访问；</li><li>e：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）</li></ul><p>3.核心算法实现：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">/// &lt;summary&gt;/// 广度优先算法BFS/// &lt;/summary&gt;/// &lt;param name="originNode"&gt;起点位置&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标位置&lt;/param&gt;/// &lt;param name="passNodeList"&gt;可走路径&lt;/param&gt;public static void BFSSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeList){    Queue&lt;Node&gt; openQue = new Queue&lt;Node&gt;();    openQue.Enqueue(originNode);    while (openQue.Count &gt; 0)    {        Node head = openQue.Dequeue();        //获取该节点周围的节点        List&lt;Node&gt; neighborLst = Program.GetNeighbor(head);        //检查周围的节点        for (int i = 0; i &lt; neighborLst.Count; i++)        {            Node neighborNode = neighborLst[i];            //节点被访问或者是障碍物的直接继续            if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue;            //记录节点被访问            neighborNode.isVisit = true;            //记录父节点            neighborNode.parent = head;            openQue.Enqueue(neighborNode);            //这个时候整个地图已经遍历完了            if (neighborNode.Equals(targetNode))            {                //反向输出父节点，就是要找的路径                while (!neighborNode.Equals(originNode))                {                    neighborNode = neighborNode.parent;                    passNodeList.Add(neighborNode);                    neighborNode.nodeType = NodeType.Pass;                }                //最后添加目标点（其实直接返回目标节点也是可以的）                passNodeList.Add(targetNode);                targetNode.nodeType = NodeType.Pass;                return;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深度优先搜索策略"><a href="#深度优先搜索策略" class="headerlink" title="深度优先搜索策略"></a>深度优先搜索策略</h3><p>1.算法特点：</p><ul><li>扩展最深的节点的结果使得搜索沿着状态空间某条单一的路径从起始节点向下进行下去；仅当搜索到达一个没有后裔的状态时，才考虑另一条替代的路径；</li><li>为了保证找到解，应选择合适的深度限制值，或采取不断加大深度限制值的办法，反复搜索，直到找到解；</li><li>深度优先搜索并不能保证第一次搜索到的某个状态时的路径是到这个状态的最短路径，如果路径距离很重要的话，它应该尝试保留最短路径；</li></ul><p><img src="https://s1.ax1x.com/2022/03/09/bfMTyT.png" alt="深度优先算法搜索次序"></p><p>2.算法描述如下：</p><ul><li>a：选择传入的起始顶点，并将顶点标记已经访问；</li><li>b：访问邻接顶点，直到某个顶点没有邻接顶点再继续下一步；</li><li>c：回溯到上一层顶点，重复b步，直到所有顶点都被访问；</li><li>d：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）；</li></ul><p>3.核心算法实现：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">   /// &lt;summary&gt;   /// 深度优先算法BFS（简单实现，非最优路径）   /// &lt;/summary&gt;   /// &lt;param name="currentNode"&gt;当前位置&lt;/param&gt;   /// &lt;param name="originNode"&gt;起点位置&lt;/param&gt;   /// &lt;param name="targetNode"&gt;目标位置&lt;/param&gt;   /// &lt;param name="passNodeList"&gt;可走路径&lt;/param&gt;public static void DFSSearch(Node currentNode, Node originNode, Node targetNode,ref List&lt;Node&gt; passNodeList)   {       //标记该节点已经被访问currentNode.isVisit = true;       //获取该节点周围的节点List&lt;Node&gt; neighborLst = Program.GetNeighbor(currentNode);for(int i = 0; i &lt; neighborLst.Count; i++)       {Node neighborNode = neighborLst[i];           //节点被访问或者是障碍物的直接继续           if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue;           //记录父节点           neighborNode.parent = currentNode;           //递归调用,先深再广           DFSSearch(neighborNode, originNode, targetNode, ref passNodeList);           //这个时候已经找到目标节点了           if (neighborNode.Equals(targetNode))           {               //反向输出父节点，就是要找的路径               while (!neighborNode.Equals(originNode))               {                   neighborNode = neighborNode.parent;                   passNodeList.Add(neighborNode);                   neighborNode.nodeType = NodeType.Pass;               }               //最后添加目标点（其实直接返回目标节点也是可以的）               passNodeList.Add(targetNode);               targetNode.nodeType = NodeType.Pass;               return;           }       }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="启发式图搜索策略"><a href="#启发式图搜索策略" class="headerlink" title="启发式图搜索策略"></a>启发式图搜索策略</h2><h3 id="启发式策略"><a href="#启发式策略" class="headerlink" title="启发式策略"></a>启发式策略</h3><p>1.启发式信息定义：用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息；</p><p>2.启发式策略特点：重排Open表，选择最有希望的节点加以扩展；</p><p>3.启发信息分类：按以下俩种情况考虑</p><ul><li>按运用的方法分类：<ul><li>陈述性启发信息：用于更准确、更精炼地描述状态；</li><li>过程性启发信息：用于构造操作算子；</li><li>控制性启发信息：表示控制策略的知识；</li></ul></li><li>按作用分类：<ul><li>用于扩展节点的选择，即用于决定应先扩展哪一个节点，以免盲目扩展；</li><li>用于生成节点的选择，即用于决定要生成哪些后继节点，以免盲目生成过多无用的节点；</li><li>用于删除节点的选择，即用于决定删除哪些无用节点，以免造成进一步的时空浪费；   </li></ul></li></ul><h3 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h3><p>1.估价函数公式：用来估算初始节点经过 n节点到达目标节点的路径的最小代价，如下推理</p><ul><li>估价函数值f(n) ==&gt; g(n) + h(n);</li><li>g(n) ==&gt; 从当前节点到待访问节点n的实际代价（其实就是距离）</li><li>h(n) ==&gt; 从待访问节点n到终点的估算代价（其实就是方向）<ul><li>h(n) 比重大：降低搜索工作量，但可能导致找不到最优解；</li><li>h(n) 比重小：一般导致工作量加大，极限情况下变为盲目搜索，但可能可以找到最优解；</li></ul></li></ul><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>1.核心算法实现</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">/// &lt;summary&gt;/// A*启发式寻路算法/// &lt;/summary&gt;/// &lt;param name="originNode"&gt;起点&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标节点&lt;/param&gt;/// &lt;param name="passNodeLst"&gt;通行路径&lt;/param&gt;public static bool AstarSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeLst){//如果当前节点等于目标节点直接返回if (originNode.Equals(targetNode)){passNodeLst.Add(originNode);return true;}//下一次准备搜索的列表List&lt;Node&gt; openLst = new List&lt;Node&gt;();//关闭搜索节点列表List&lt;Node&gt; closeLst = new List&lt;Node&gt;();Node currentNode=originNode;openLst.Add(currentNode);while (openLst.Count &gt; 0){currentNode = GetMinF(openLst , currentNode, targetNode);//这个时候已经找到目标节点了if (currentNode.Equals(targetNode)){//反向输出父节点，就是要找的路径while (!currentNode.Equals(originNode)){passNodeLst.Add(currentNode);currentNode = currentNode.parent;currentNode.nodeType = NodeType.Pass;}//最后添加目标点（其实直接返回目标节点也是可以的）passNodeLst.Add(originNode);originNode.nodeType = NodeType.Pass;targetNode.nodeType = NodeType.Pass;return true;}openLst.Remove(currentNode);closeLst.Add(currentNode);           foreach (Node neighborNode in Program.GetNeighbor(currentNode))           {if (openLst.Contains(neighborNode) || neighborNode.nodeType == NodeType.Block|| closeLst.Contains(neighborNode)) continue;openLst.Add(neighborNode);}       }return false;}/// &lt;summary&gt;/// 估值函数（A*算法核心）/// &lt;/summary&gt;/// &lt;param name="openLst"&gt;开放节点&lt;/param&gt;/// &lt;param name="closeLst"&gt;关闭节点&lt;/param&gt;/// &lt;param name="currentNode"&gt;当前节点&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标节点&lt;/param&gt;/// &lt;returns&gt;返回估值后最小F的节点&lt;/returns&gt;public static Node GetMinF(List&lt;Node&gt; openLst, Node currentNode, Node targetNode){if(openLst.Count &lt;= 1)return currentNode;int minFVal = int.MaxValue;Node? nextNode = null;foreach (Node node in openLst){int fVal = GetG(currentNode, node) + GetH(node, targetNode);if (fVal &gt;= minFVal) continue;minFVal = fVal;nextNode = node;}if(nextNode != null) nextNode.parent = currentNode;return nextNode;}/// &lt;summary&gt;/// 获取G(M)值/// &lt;/summary&gt;public static int GetG(Node currentNode,Node nextNode)   {if (currentNode.xIndex == nextNode.xIndex || currentNode.yIndex == nextNode.yIndex) return 10;else return 14;}   /// &lt;summary&gt;   /// 获取H(M)值(这里采用欧式距离)   /// &lt;/summary&gt;   public static int GetH(Node currentNode, Node targetNode)   {int a=Math.Abs(currentNode.xIndex-targetNode.xIndex);int b=Math.Abs(currentNode.yIndex-targetNode.yIndex);return 10*(int)Math.Sqrt(a*a+b*b);   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;人工智能基本概念&quot;&gt;&lt;a href=&quot;#人工智能基本概念&quot; class=&quot;headerlink&quot; title=&quot;人工智能基本概念&quot;</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="人工智能" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>确定性物理库</title>
    <link href="https://wwy.wwywy.com/posts/2179.html"/>
    <id>https://wwy.wwywy.com/posts/2179.html</id>
    <published>2022-03-01T13:00:00.000Z</published>
    <updated>2022-03-06T14:09:35.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="帧同步" scheme="https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="确定性物理库" scheme="https://wwy.wwywy.com/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>定点数数学库</title>
    <link href="https://wwy.wwywy.com/posts/2178.html"/>
    <id>https://wwy.wwywy.com/posts/2178.html</id>
    <published>2022-03-01T13:00:00.000Z</published>
    <updated>2022-03-06T14:09:52.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定点数FInt"><a href="#定点数FInt" class="headerlink" title="定点数FInt"></a>定点数FInt</h1><p>基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化，使用位运算来直接操作二进制进行放大缩小，这里可以放大1024倍，也就是1&lt;&lt;10，使用完之后在缩小1024倍还原即可;<br>乘法还原正负不同问题：按照上面的流程，乘法运算后绝对值相同的正负数值经过还原后会出现不对等的问题，比如500乘FInt(0.3f)的RawInt值是是14，但是500乘FInt(-0.3f)的RawInt值却是-15，这是因为二进制中，正数由原码表示，负数由补码表示，补码是在原码的反码上再加一得来的，要简单的解决这一个问题可以对值进行取反运算再取反，让已经实现好的底层去解决；</p><h1 id="定点向量FVector3"><a href="#定点向量FVector3" class="headerlink" title="定点向量FVector3"></a>定点向量FVector3</h1><h1 id="常用运算FCalc"><a href="#常用运算FCalc" class="headerlink" title="常用运算FCalc"></a>常用运算FCalc</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定点数FInt&quot;&gt;&lt;a href=&quot;#定点数FInt&quot; class=&quot;headerlink&quot; title=&quot;定点数FInt&quot;&gt;&lt;/a&gt;定点数FInt&lt;/h1&gt;&lt;p&gt;基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="帧同步" scheme="https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
    <category term="第三方库" scheme="https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    <category term="定点数数学库" scheme="https://wwy.wwywy.com/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关-角色换装</title>
    <link href="https://wwy.wwywy.com/posts/1600.html"/>
    <id>https://wwy.wwywy.com/posts/1600.html</id>
    <published>2022-02-18T13:00:00.000Z</published>
    <updated>2022-03-03T10:03:36.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;待写&quot;&gt;&lt;a href=&quot;#待写&quot; class=&quot;headerlink&quot; title=&quot;待写&quot;&gt;&lt;/a&gt;待写&lt;/h1&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="换装" scheme="https://wwy.wwywy.com/tags/%E6%8D%A2%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关-.Net说明以及mono跨平台原理</title>
    <link href="https://wwy.wwywy.com/posts/1602.html"/>
    <id>https://wwy.wwywy.com/posts/1602.html</id>
    <published>2022-02-18T13:00:00.000Z</published>
    <updated>2022-03-22T02:42:48.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解-Net相关知识"><a href="#了解-Net相关知识" class="headerlink" title="了解.Net相关知识"></a>了解.Net相关知识</h1><h2 id="微软-Net概述"><a href="#微软-Net概述" class="headerlink" title="微软.Net概述"></a>微软.Net概述</h2><p>1.微软.Net说明：微软的.Net即不是编程语言也不是框架，是类似于互联网时代、次世代、21世纪的宣传口号，是一整套技术体系的统称，或者说是微软提供的技术水平的代号，本质上是微软为自己一系列取的一个代号，以下是包含内容；</p><ul><li>框架体系：.Net Framework、.Net Core、Mono等等；</li><li>开发语言：C#、VB、F#等等（C#是.Net平台主推的开发语言）；</li><li>开发工具：Visual Studio、Visual Studio Code 等等；</li></ul><p>2.微软实现.Net平台的目的：</p><ul><li>跨语言：只要是面向.NET平台的编程语言(C#、VB、C++、F#等等)，用其中一种语言编写的内容可以无缝地用在另一种语言编写的应用程序中；</li><li>跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的操作系统上，即代码不依赖于操作系统，也不依赖硬件环境；</li></ul><h2 id="Net跨语言"><a href="#Net跨语言" class="headerlink" title=".Net跨语言"></a>.Net跨语言</h2><p>1.跨语言公共语言规范：微软为了实现跨平台，制定了一些规范，只要一门语言支持这个规则，就能在.Net平台下开发应用程序，以下是规则说明；</p><ul><li>CLS（公共语言规范）：.Net专门参考每种语言找出语言间的共性，是一组语言互操作的标准规范；</li><li>CTS（公共类型系统）：当你设计面向.Net语言时需要遵守的一个体系，而刚才提到的CLS公共语言规范就是是CTS公共类型系统的子级，一个编程语言，如果它能够支持CTS，那么我们就称它为面向.NET平台的语言；</li><li>CLI（公共语言基础结构）：是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准；</li></ul><h2 id="Net虚拟机-CLR"><a href="#Net虚拟机-CLR" class="headerlink" title=".Net虚拟机(CLR)"></a>.Net虚拟机(CLR)</h2><p>1.CLR（公共语言运行时）说明：让应用程序在操作系统上运行，公共语言运行时，它是.Net Framework的基础，所有的.Net技术都是建立在此之上的，它是一个在执行时管理代码的代码，提供内存管理，线程管理等等核心服务，就好像一个小型的操作系统一样，所以形象的把它称为“.Net虚拟机”，Java的虚拟机也是类似这样的东西，如果想要应用程序在目标操作系统上能够运行，就必须依靠.Net提供的CLR环境来支持，它会把程序集中的IL（中间代码）翻译成机器码最终在操作系统上运行；</p><p>2.CLR做的事情：<br><img src="https://s1.ax1x.com/2022/03/21/qumuMq.png" alt="CLR做的事情"></p><h2 id="Net跨平台"><a href="#Net跨平台" class="headerlink" title=".Net跨平台"></a>.Net跨平台</h2><h3 id="Net-Framework"><a href="#Net-Framework" class="headerlink" title=".Net Framework"></a>.Net Framework</h3><ol><li>.Net Framework：.Net Framework 在2002年推出1.0版本，.NET Framework 是一个可以快速开发、部署网站服务及应用程序的开发框架，是 Windows 中的一个组件，部分开源，主要用于开发Windows下应用程序，包括公共语言运行时（Common Language Runtime, CLR），虚拟执行系统，.NET Framework 类库等，下面时详细说明；</li></ol><ul><li>只要支持CLS公共语言规范的语言都可以用于开发Windows下的各种应用程序和网站程序；</li><li>BCL（基础类库）和FCL（框架类库）：是这个框架体系中为我们实现好的各种API；</li><li>程序集：程序集的表现就是后缀为.dll或者.exe格式的文件，其中包含的最关键信息， PE头、CLR头（就是一些程序的格式信息，比如入口方法，版本号等等）</li><li>CIL代码（通用中间代码）：是介于源代码和机器码之间的代码之后会通过CLR产生机器码，CIL代码你可以理解为由于可能使用不同的代码进行开发，所以会将这些代码翻译为统一规范的中间代码；</li></ul><p><img src="https://s1.ax1x.com/2022/03/21/qunTHK.png" alt=".Net Framework的体系结构"></p><h3 id="Net-Core"><a href="#Net-Core" class="headerlink" title=".Net Core"></a>.Net Core</h3><ol><li>.Net Core：.Net Core 是2016年推出的.Net Framework的新一代版本，是.Net Framework的翻版实现，它是一个开源项目，它是基于.Net Framework来进行设计的主要目的就是跨平台，是.Net技术框架组成在Windows、MacOS、类Linux系统下的具体实现，它的原理就是为不同的操作系统实现对应的CLR公共语言运行时（.Net虚拟机），这样就可以在不同的平台上，将IL（中间代码）翻译成机器码最终在操作系统上运行了；</li></ol><p><img src="https://s1.ax1x.com/2022/03/21/quu5GQ.png" alt=".Net Core的体系结构"></p><h3 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h3><p>1.Mono：2004年由Xamarin公司（已被微软收购）所赞助的开源项目，它基于.Net的CLI（Common Language Infrastructure）公共语言基础结构，它相对.Net FrameWork最大的区别就是具备跨平台的能力，它不仅可以运行在Windows、MacOS、Linux等操作系统，甚至还可以运行在PS3、XBOX、Wii等主机平台上，也就是说在.Net Core出现之前，Mono是.Net平台实现跨平台的不二之选；</p><h1 id="Unity跨平台原理-Mono"><a href="#Unity跨平台原理-Mono" class="headerlink" title="Unity跨平台原理(Mono)"></a>Unity跨平台原理(Mono)</h1><p>1.Unity的组成：Unity的底层是通过C/C++来完成上层逻辑的，Unity主要包括两个部分：</p><ul><li>Unity Engine（引擎）：提供UnityEngine.dll动态库，各平台不同，C/C++编写，包含平台相关代码、图形API、物理引擎、灯光等等所有游戏引擎底层内容；</li><li>Unity Editor（编辑器）：提供UnityEditor.dll动态库，大部分由C#编写，用户脚本最初可以使用C#、JavaScript、Boo语言编写，项目代码最后由Mono编译；</li></ul><p>2.Mono组成：</p><ul><li>C#编译器（mcs）；</li><li>Mono Runtime 类似CLR公共语言运行时（虚拟机），包括JIT（Just in time）即时编译器、AOT（Ahead of time）提前编译器、GC、类库加载器 等；</li><li>BCL基础类库；</li><li>Mono类库：提供很多超出.Net的一些额外功能，主要用于构建各种操作系统上的应用；</li></ul><p>3.Unity跨平台的基本原理（Mono）：在Unity下使用各种语言进行逻辑实现，这些语言在发布时会被编译成，IL中间代码，最终这些中间代码在对应操作系统上，通过Mono VM（虚拟机），真正翻译成机器码运行起来；<br><img src="https://s1.ax1x.com/2022/03/21/qu1bUP.png" alt="Unity跨平台的基本原理"></p><p>4.Mono的特点：</p><ul><li>构建（最终打包时）速度快</li><li>Mono编译机制是JIT即时编译，所以支持更多类库</li><li>必须将代码发布为托管程序集（.dll文件）</li><li>Mono VM虚拟机平台维护麻烦，且部分平台不支持（WebGL）</li><li>由于Mono版本授权原因，C#很多新特性无法使用</li><li>IOS支持Mono，但不在允许32位的Mono应用提交到应用商店<br>  <img src="https://s1.ax1x.com/2022/03/21/qudQIJ.png" alt="Mono跨平台说明"></li></ul><p>5.基于Mono跨平台的优缺点：</p><ul><li>优点：只要在不同操作系统上实现Mono VM（虚拟机），那我们能够支持的平台就会“无限”多；</li><li>缺点：维护工作耗时耗力，当Unity版本更新时，Mono VM也需要维护和更新，那多对于N多个平台来说，工作量是非常大的。（Unity的工作量），低版本Mono无法支持新版本C#的强大新特性；</li></ul><h1 id="Unity跨平台原理-IL2CPP"><a href="#Unity跨平台原理-IL2CPP" class="headerlink" title="Unity跨平台原理(IL2CPP)"></a>Unity跨平台原理(IL2CPP)</h1><p>1.IL2CPP说明：L2CPP是在Unity4.6.1 p5之后的版本中，加入的脚本后处理方式，是继Mono之后的一种跨平台解决方案，顾名思义就是把，IL中间代码转译为CPP代码（C++），再利用各平台优化过的编译器编译为对应平台的目标代码，需要注意的是虽然中间代码变为了C++，但是内存管理还是遵循C#中GC的方式，这也是为什么有一个IL2CPP VM（虚拟机）存在的原因，它主要是用来完成GC管理，线程创建等服务工作的；</p><p>2.IL2CPP特点：</p><ul><li>相对Mono构建（最终打包时）速度慢；</li><li>只支持AOT提前编译；</li><li>可以启用引擎代码剥离来减少代码的大小；</li><li>程序的运行效率比Mono高，运行速度快；</li><li>多平台移植更加方便；<br>  <img src="https://s1.ax1x.com/2022/03/21/qudkPs.png" alt="IL2CPP跨平台说明"></li></ul><p>3.Mono和IL2CPP的区别：</p><ul><li>IL2CPP效率高于Mono，跨平台也更好维护，不使用热更新后者大量反射的化推荐使用IL2CPP；</li><li>Mono是JIT（半解释半编译程序或者说纯解释程序）即时编译，IL2CPP是AOT（预编译程序）提前编译，导致IL2CPP不能在运行时动态生成代码和类型，所以必须在编译时就完全确定需要用到的类型，举例：List<a>和List<b>中A和B是我们自定义的类，我能必须在代码中显示的调用过，IL2CPP才能保留List</b></a><b><a>和List<b>两个类型。如果在热更新时我们调用List<c>，但是它之前并没有在代码中显示调用过，那么这时就会出现报错等问题。主要就是因为JIT和AOT两个编译模式的不同造成的；</c></b></a></b></li><b><a><b></b></a></b></ul><b><a><b></b></a><b><h1 id="IL2CPP模式存在的问题"><a></a><a href="#IL2CPP模式存在的问题" class="headerlink" title="IL2CPP模式存在的问题"></a>IL2CPP模式存在的问题</h1><p>1.安装Unity IL2CPP打包工具：在Unityhub中下载 IL2CPP打包相关工具；</p><h2 id="IL2CPP打包泛型问题"><a href="#IL2CPP打包泛型问题" class="headerlink" title="IL2CPP打包泛型问题"></a>IL2CPP打包泛型问题</h2><p>1.问题说明：IL2CPP和Mono最大的区别是，不能在运行时动态生成代码和类型，就是说 泛型相关的内容，如果你在打包生成前没有把之后想要使用的泛型类型显示使用一次，那么之后如果使用没有被编译的类型，就会出现找不到类型的报错；</p><p>2.解决方案：其实就是在预言编译之前让IL2CPP知道我们需要使用这个内容，详细如下</p><ul><li>泛型类：声明一个类，然后在这个类中声明一些public的泛型类变量；</li><li>泛型方法：随便写一个静态方法，在将这个泛型方法在其中调用一下。这个静态方法无需被调用；</li></ul><h2 id="IL2CPP打包类型裁剪问题"><a href="#IL2CPP打包类型裁剪问题" class="headerlink" title="IL2CPP打包类型裁剪问题"></a>IL2CPP打包类型裁剪问题</h2><p>1.问题说明：IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后包的尺寸的目的，然而在实际使用过程中，很多类型有可能会被意外剪裁掉，造成运行时抛出找不到某个类型的异常，特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题；</p><p>2.解决方案：</p><ul><li>(1).IL2CPP处理模式时，将PlayerSetting-&gt;Other Setting-&gt;Managed Stripping Level(代码剥离)设置为Low；</li><li>Disable:Mono模式下才能设置为不删除任何代码 ；</li><li>Low:默认低级别，保守的删除代码，删除大多数无法访问的代码，同时也最大程度减少剥离实际使用的代码的可能性；</li><li>Medium:中等级别，不如低级别剥离谨慎，也不会达到高级别的极端；</li><li>Hight:高级别，尽可能多的删除无法访问的代码，有限优化尺寸减小。如果选择该模式一般需要配合link.xml使用；</li><li>(2).通过Unity提供的link.xml方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的,在Unity工程的Assets目录中（或其任何子目录中）建立一个叫link.xml的XML文件；</li></ul><p>3.link.xml声明格式举例说明：推荐看官网</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--程序集中保留类型和成员--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assembly</span> <span class="token attr-name">fullname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Assembly-CSharp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--保留命名空间中类以及参数preserve说明：all全部、fields字段、methods方法、nothing只保留类型--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span> <span class="token attr-name">fullname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyNameSpace.MyClass<span class="token punctuation">"</span></span> <span class="token attr-name">preserve</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assembly</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></b></b>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解-Net相关知识&quot;&gt;&lt;a href=&quot;#了解-Net相关知识&quot; class=&quot;headerlink&quot; title=&quot;了解.Net相关知识&quot;&gt;&lt;/a&gt;了解.Net相关知识&lt;/h1&gt;&lt;h2 id=&quot;微软-Net概述&quot;&gt;&lt;a href=&quot;#微软-Net概述&quot; cla</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="mono" scheme="https://wwy.wwywy.com/tags/mono/"/>
    
    <category term=".Net" scheme="https://wwy.wwywy.com/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件-Animancer插件使用</title>
    <link href="https://wwy.wwywy.com/posts/1577.html"/>
    <id>https://wwy.wwywy.com/posts/1577.html</id>
    <published>2022-01-29T13:00:00.000Z</published>
    <updated>2022-05-12T11:46:28.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Animancer介绍"><a href="#Animancer介绍" class="headerlink" title="Animancer介绍"></a>Animancer介绍</h1><h1 id="Animancer初步使用"><a href="#Animancer初步使用" class="headerlink" title="Animancer初步使用"></a>Animancer初步使用</h1><p>使用方法：添加Animator组件和AnimancerComponent相关组件，再编写脚本控制动画；</p><p>脚本案例：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public sealed class PlayAnimation : MonoBehaviour{    [SerializeField] private AnimancerComponent _Animancer;    [SerializeField] private AnimationClip _Clip;    private void OnEnable()    {        _Animancer.Play(_Clip);        var state = _Animancer.Play(_Clip);        state.Speed = ...                        state.Time = ...                     state.NormalizedTime = ...              state.Events.OnEnd = ...                   _Animancer.Play(_Clip).Time = 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer核心组件"><a href="#Animancer核心组件" class="headerlink" title="Animancer核心组件"></a>Animancer核心组件</h1><h2 id="AnimancerComponent"><a href="#AnimancerComponent" class="headerlink" title="AnimancerComponent"></a>AnimancerComponent</h2><p>说明：普通的动画师组件</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取Animator Controller组件animancer.Animator//2.获取Playableanimancer.Playable//3.获取该组件上的动画状态字典animancer.States//4.获取该组件上的动画层级animancer.Layers成员方法：//1.播放动画animancer.Play(AnimationClip, float, FadeMode)//2.使用键值播放动画。如果该键没有注册，返回nullanimancer.TryPlay(Object, float, FadeMode)//3.停止当前动画或者目标动画animancer.Stop(参数)//4.判断是否播放当前动画或者目标动画animancer.IsPlaying()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="NamedAnimancerComponent"><a href="#NamedAnimancerComponent" class="headerlink" title="NamedAnimancerComponent"></a>NamedAnimancerComponent</h2><p>说明：继承自AnimancerComponent并添加一个数组，并按名称注册动画，可以使用名字播放动画，这与 Unity 的旧版组件非常相似；</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">增加的成员变量：//1.获取动画源列表animancer.Animations//1.获取默认动画源animancer.DefaultAnimation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HybridAnimancerComponent"><a href="#HybridAnimancerComponent" class="headerlink" title="HybridAnimancerComponent"></a>HybridAnimancerComponent</h2><p>说明：继承自NamedAnimancerComponent，并且添加了控制器，可以融合Animator Controller组件和Animancer；</p><h1 id="Animancer动画状态"><a href="#Animancer动画状态" class="headerlink" title="Animancer动画状态"></a>Animancer动画状态</h1><p>动画状态说明：播放动画时，Animancer会创建一个状态来管理它并跟踪它的进度，如果以后再次播放相同的动画，它将重用相同的状态；</p><p>AnimancerState类API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取动画源文件state.Clip//2.动画事件集合state.Events//3.动画的长度state.Length//4.动画的速度state.Speed//5.状态的开始时间，该变量改变，动画事件也会变state.NormalizedTime//6.状态的结束时间，该变量改变，动画事件也会变state.NormalizedEndTime//7.状态的事件集合state.Events成员方法：//1.销毁动画state.Destroy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要访问和创建状态的方法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.此属性存储该方法最近返回的状态var state = animancer.States.Current;//2.此属性存储最近由 Layer 的方法返回的状态var state = animancer.Layers[x].CurrentState;//3.索引器获取var state = animancer.States[clip];//4.方法获取animancer.States.TryGet(clip, out var state);//5.如果已存在的状态，则此方法将返回该状态。否则它将创建并返回一个新的var state = animancer.States.GetOrCreate(clip);//6.创建新状态，即使该动画已存在一个状态。请注意，每个状态必须具有不同的密钥，否则将引发，注意key时object类型，所以会有装拆箱问题var state = animancer.States.Create(key, clip);//7.创建新状态，而不为其提供键。var state = new ClipState(clip);//8.如果存在的状态，则此方法将销毁该状态并返回，否则，它将返回falseanimancer.States.Destroy(clip);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer动画过渡"><a href="#Animancer动画过渡" class="headerlink" title="Animancer动画过渡"></a>Animancer动画过渡</h1><p>过渡说明：Animancer中除了使用Clip动画源文件来进行使用，也可以使用ClipTransition播放动画，并且这样效果更好；</p><p>过渡类类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//基本过渡：1.ClipTransition：实现ITransition接口，最基本的过渡类型，FadeDuration可以控制动画淡入淡出过渡的时长，Speed控制速度，StartTime和EndTime控制起始时间，同时动画支持添加帧事件；2.ClipTransitionSequence：继承自ClipTransition并简单地添加一个数组，这些数组将在第一个之后按顺序播放（使用他们的每个结束事件来播放下一个）；3.PlayableAssetTransition//混合过渡：1.ManualMixerTransition：简单的混合动画；2.LinearMixerTransition：1D混合动画，用一个参数控制，参数信息和Animator里的混合一致；3.MixerTransition2D：2D混合模式，用俩个参数控制，参数信息和Animator里的混合一致；//控制器过渡：1.ControllerTransition：使用控制器文件；//过渡资源1.过渡类+Asset：过渡资源在资源面板下可以创建该过渡资源文件，和上面不同的时，过渡文件整个项目全局共享，而不是每个对象都有自己单独的过渡。它们都遵循相同的命名约定；2.过渡类+Asset.UnShared:不共享分过渡资源，一般用不着；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer混合"><a href="#Animancer混合" class="headerlink" title="Animancer混合"></a>Animancer混合</h1><h2 id="动画淡入淡出"><a href="#动画淡入淡出" class="headerlink" title="动画淡入淡出"></a>动画淡入淡出</h2><p>淡入淡出说明：淡入淡出通常不用于动画，因为它们不能混合，但是对于骨架动画非常有用，因为它允许角色模型从一个动画的结束姿势平滑地过渡到另一个动画的起始姿势，而不需要两个姿势完全相同。这也意味着，如果动画在任何时候被中断，过渡仍然可以是平滑的；</p><p>常用淡入淡出类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.参数值按百分比计算下标0:FadeMode.FixedSpeed//2.参数根据事件计算下标1:FadeMode.FixedDuration//3.好像是不会创建的新的状态下标2:FadeMode.FromStart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画的层"><a href="#动画的层" class="headerlink" title="动画的层"></a>动画的层</h2><p>层说明：基本和Animator使用方法一致；</p><p>AnimancerLayer类API说明</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">重要成员变量：//1.层级下标layer.Index//2.层级叠加模式还是覆盖模式layer.IsAdditive//3.层权重layer.Weight重要成员方法：//1.设置骨骼蒙版layer.SetMask(AvatarMask)//2.设置层权重layer.SetWeight(float)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>混合树说明：基本和Animator使用方法一致；</p><p>混合树使用：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//混合类类型说明1.ManualMixerState：没有参数2.LinearMixerState：float参数，线性插值算法3.CartesianMixerState：Vector参数，梯度波段O(n2)插值算法4.DirectionalMixerState：Vector参数，极地梯度波段O(n2)插值算法//案例public sealed class LinearMixerExample : MonoBehaviour{    private AnimancerComponent _Animancer;    private AnimationClip _back;    private AnimationClip _forward;    private AnimationClip _left;    private AnimationClip _right;    private float _MovementSpeed;    public CartesianMixerState mixState;    private void Awake()    {        mixState = new CartesianMixerState();        //初始化混合动画        mixState.Initialize(_back, _forward，_left，_right);        //设置动画参数        mixState.SetThreshold(0, new Vector2(0, 0));        mixState.SetThreshold(1,new Vector2(0,-1));        mixState.SetThreshold(2, new Vector2(0, 1));        mixState.SetThreshold(3, new Vector2(-1, 0));        mixState.SetThreshold(4, new Vector2(1, 0));        //设置混合动画的同步，同步适用于移动，但对于空闲动画，通常应禁用同步        MixerState.AutoSynchronizeChildren = false;        mixer.DontSynchronizeChildren();        mixer.DontSynchronize(mixer.GetChild(0));        mixer.Synchronize(mixer.GetChild(1));        //播放        _Animancer.Play(mixState);    }    private void Update()    {            var input = new Vector2(    Input.GetAxisRaw("Horizontal"),    Input.GetAxisRaw("Vertical"));            mixState.Parameter = Vector2.MoveTowards(                mixState.Parameter,                input,                _MovementSpeed * Time.deltaTime);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer事件"><a href="#Animancer事件" class="headerlink" title="Animancer事件"></a>Animancer事件</h1><p>事件说明：基本和Animator使用方法一致，但是性能更好，且使用Clip文件使用时，每次都会创建垃圾，除非您缓存事件回调，而ClipTransition访问它将直接引用ClipTransition拥有的，因此当您再次播放时，您所做的任何修改都将保留。这意味着修改通常只应在启动时执行一次，而不是每次播放时都重复进行；</p><p>用法说明：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.添加事件state.Events.Add(0.4f, 事件);//2.结束事件，结束一定会调用  state.Events.OnEnd = 事件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer搭配推荐"><a href="#Animancer搭配推荐" class="headerlink" title="Animancer搭配推荐"></a>Animancer搭配推荐</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Animancer介绍&quot;&gt;&lt;a href=&quot;#Animancer介绍&quot; class=&quot;headerlink&quot; title=&quot;Animancer介绍&quot;&gt;&lt;/a&gt;Animancer介绍&lt;/h1&gt;&lt;h1 id=&quot;Animancer初步使用&quot;&gt;&lt;a href=&quot;#Anim</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="插件" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Animancer" scheme="https://wwy.wwywy.com/tags/Animancer/"/>
    
    <category term="Playable" scheme="https://wwy.wwywy.com/tags/Playable/"/>
    
  </entry>
  
  <entry>
    <title>ET6.0框架笔记</title>
    <link href="https://wwy.wwywy.com/posts/2112.html"/>
    <id>https://wwy.wwywy.com/posts/2112.html</id>
    <published>2022-01-24T13:00:00.000Z</published>
    <updated>2022-03-30T01:42:23.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ET6-0框架介绍"><a href="#ET6-0框架介绍" class="headerlink" title="ET6.0框架介绍"></a>ET6.0框架介绍</h1><h1 id="项目的初步运行"><a href="#项目的初步运行" class="headerlink" title="项目的初步运行"></a>项目的初步运行</h1><p>1.运行Unity客户端项目，并且打开编程软件进行初步编译；<br>2.打开服务端项目，第一次打开编译Client下的Mono文件夹；<br>3.重新编译整个解决方案；<br>4.客户端F5生成代码；</p><h1 id="ET前后端通讯机制"><a href="#ET前后端通讯机制" class="headerlink" title="ET前后端通讯机制"></a>ET前后端通讯机制</h1><p>登录实例：<br>1.通过NetKcpComponent组件创建Session会话连接；<br>2.Session（由ET框架管理）会话的Id和TChannel进行绑定；<br>3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；<br>4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器；</p><h1 id="ET的多线程和分布式"><a href="#ET的多线程和分布式" class="headerlink" title="ET的多线程和分布式"></a>ET的多线程和分布式</h1><p>第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；<br>第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；<br>第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；<br>第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；<br>ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构</p><p>登录实例（接上）：<br>1.网关负载均衡服务器随机分配网关配置；<br>2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；<br>3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；<br>4.游戏客户端和游戏网关建立正式连接；<br>5.登录进Map服务器<br>注意：C就是客户端，R是网关负载均衡服务器，G是网关；<br><img src="https://s4.ax1x.com/2022/02/21/HveY4J.png" alt="ET分布式说明"></p><h1 id="ET的ECS组件编程"><a href="#ET的ECS组件编程" class="headerlink" title="ET的ECS组件编程"></a>ET的ECS组件编程</h1><p>ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）；</p><p>遵守的编程原则：<br>1.实体即组件、组件即实体；<br>2.编写一个实体或者组件，绝不继承除Entity外的任何父类；<br>3.不使用任何虚函数，使用逻辑分发替代；<br>4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；<br>5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；<br>6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；<br>7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误；</p><p>其他原则：<br>1.系统命名必须是实体名+System；<br>2.系统必须是静态类；<br>3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；<br>4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.实体或者组件    public class Computer: Entity,IAwake,IUpdate,IDestroy    public class MouseComponent : Entity, IAwake    //2.系统    public static class ComputerSystem    {       //需要使用拓展方法        public static void Start(this Computer self)        {            Log.Debug("计算机启动");//这里可以调用身上的组件            self.GetComponent&lt;PCCaseComponent&gt;().StartPower();            self.GetComponent&lt;MonitorsComponent&gt;().DisPlay();        }    }//3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上    Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;();computer.AddComponent&lt;PCCaseComponent&gt;();computer.AddComponent&lt;MonitorsComponent&gt;();computer.AddComponent&lt;KeyBoardComponent&gt;();computer.AddComponent&lt;MouseComponent&gt;();computer.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中ECS编程的生命周期"><a href="#ET中ECS编程的生命周期" class="headerlink" title="ET中ECS编程的生命周期"></a>ET中ECS编程的生命周期</h1><p>  ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.生命周期函数类    public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt;    public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt;    public class ComputerDestroySystem : DestroySystem&lt;Computer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET的逻辑分发"><a href="#ET的逻辑分发" class="headerlink" title="ET的逻辑分发"></a>ET的逻辑分发</h1><p>OOP面向对象的缺点：继承层次过深时，牵一发而动全身；</p><p>ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承；</p><h1 id="ET的Scene层级树"><a href="#ET的Scene层级树" class="headerlink" title="ET的Scene层级树"></a>ET的Scene层级树</h1><p>Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id；</p><p>客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）:<br><img src="https://s4.ax1x.com/2022/02/20/HO46xg.png" alt="ET框架客户端Scene的层级关系"></p><p>服务端Scene的层级关系:<br><img src="https://s4.ax1x.com/2022/02/20/HOIEX4.png" alt="ET框架服务端Scene的层级关系"></p><p>服务端机器人Scene的层级关系<br><img src="https://s4.ax1x.com/2022/02/20/HOT9zT.png" alt="ET框架服务端机器人Scene的层级关系"></p><h1 id="ET的Excel配置工具"><a href="#ET的Excel配置工具" class="headerlink" title="ET的Excel配置工具"></a>ET的Excel配置工具</h1><p>Excel配置工具注意事项：<br>1.配置文件从第三行第三列开始写，跟VBA宏有关；<br>2.第一个类型字段名必须是Id；<br>3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；<br>4.加#是注释，仅给策划使用，不会添加到游戏数据中；<br>5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\Assets\Bundles\Config下；可以查看文本形式在Bin\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；<br>6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；<br>7.行是可以空行的，可以用来分类注释，目测加#；<br>8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；<br>9.配置工具支持的导表类型可以在Tools\Apps\EXcelExporter文件下的Convert静态类中定义或查看；<br>10.数组类型默认在配置文件中加英文,配置;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型//获取单个UnitConfig config = UnitConfigCategory.Instance.Get(1001)//获取所有var configs = UnitConfigCategory.Instance.GetAll()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的事件系统"><a href="#ET中的事件系统" class="headerlink" title="ET中的事件系统"></a>ET中的事件系统</h1><p>1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；<br>2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；<br>3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.定义事件，添加事件,必须EventType命名空间下进行定义        public struct InstallComputer        {            //定义参数            public Computer computer;        }        //2.调用事件，触发事件//同步PublishGame.EventSystem.Publish(new EventType.InstallComputer() { computer = computer });//同步PublishAnycsawait Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer });//异步PublishAnycsGame.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine();//3.编写事件触发逻辑    public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt;    {        //必须添加async        protected async override ETTask Run(InstallComputer arg)        {            Computer computer = arg.computer;            computer.AddComponent&lt;PCCaseComponent&gt;();            computer.AddComponent&lt;MonitorsComponent&gt;();            computer.AddComponent&lt;KeyBoardComponent&gt;();            computer.AddComponent&lt;MouseComponent&gt;();            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的ETTask异步编程"><a href="#ET中的ETTask异步编程" class="headerlink" title="ET中的ETTask异步编程"></a>ET中的ETTask异步编程</h1><p>同步操作：先完成其全部工作在返回调用者；<br>异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；<br>ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.ETTask函数编写//无返回值,参数类型用来控制取消异步函数public async ETTask TestAsync(ETCancellationToken cancellationToken)        {//表明该函数可能是同步函数await ETTask.CompletedTask;//第二参数同上bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken);//根据返回值控制if (rt) Log.Debug("函数取消了");else Log.Debug("继续执行下面逻辑");}//有返回值        public async ETTask&lt;int&gt; TestResultAsync()        {            await TimerComponent.Instance.WaitAsync(1000);return 10;        }        2.ETTask函数的调用//定义取消异步函数实例ETCancellationToken cancellationToken=new ETCancellationToken();//等待无返回值函数调用完成await TestAsync(cancellationToken);//不等待无返回值函数完成，执行下面逻辑TestAsync(cancellationToken).Coroutine();//等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题int value = await TestResultAsync();//取消函数cancellationToken.Cancel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Protobuf通讯消息"><a href="#ET中的Protobuf通讯消息" class="headerlink" title="ET中的Protobuf通讯消息"></a>ET中的Protobuf通讯消息</h1><p>Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。<br>Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；<br>Protobuf的Github开源地址 :<a href="https://github.com/protocolbuffers/protobuf">GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式</a></p><p>ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\Apps\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版;</p><p>.proto描叙文件编写的的注意事项：<br>1.Proto数据结构描叙文件存放在Proto文件夹下；<br>2.OuterMessage是定义客户端和服务端通信的消息；<br>3.InnerMessage是服务端内部通信的消息；<br>4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；<br>5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；<br>6.消息定义体中的Id不能重复；<br>7.生成的转换类型列表可以在Tools\Apps\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\Generate\Message下；<br>8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；<br>9.字符之间必须要留空格；<br>10.proto文件中的注释意义重大；</p><p>网络Handler消息编写注意事项<br>1.类名定义务必以消息类名+Handler作为声明<br>2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；<br>3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用<br>4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与；</p><h1 id="ET普通网络消息编写"><a href="#ET普通网络消息编写" class="headerlink" title="ET普通网络消息编写"></a>ET普通网络消息编写</h1><p>普通消息.proto文件编写：</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">// ResponseType R2C_LoginTest（普通请求消息一定要注释返回类）message C2R_LoginTest  // IRequest（普通请求消息必须注释）{    int32 RpcId = 90;（普通请求消息必须声明该字段）string Account = 1;string Password = 2;}message R2C_LoginTest  // IResponse（普通响应消息必须注释）{    int32 RpcId = 90;（普通响应消息必须声明该字段）int32 Error = 91;string Message = 92;string GateAddress = 1;string Key = 2;}message C2R_SayHello // IMessage（一般消息必须注释）{string Hello = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通消息C#代码：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.客户端编写登录逻辑        public static async ETTask LoginTest(Scene zoneScene, string address)        {            try            {                Session session = null;                R2C_LoginTest r2C_LoginTest = null;                try                {                    session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address));                    {                        r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = "123", Password = "456" });                        Log.Debug(r2C_LoginTest.Key);                        session.Send(new C2R_SayHello() { Hello = "你好" });                    }                }                finally                {                    session?.Dispose();                }            }            catch(Exception e)            {                Log.Error(e.ToString());            }        }//2.普通请求消息逻辑    [MessageHandler]    public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt;    {        protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply)        {            response.Key = "110";            reply();            await ETTask.CompletedTask;        }    }    //3.一般消息（不用响应）    [MessageHandler]    public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt;    {        protected override async ETTask Run(Session session, C2R_SayHello message)        {            Log.Debug(message.Hello);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Actor通信模型"><a href="#ET中的Actor通信模型" class="headerlink" title="ET中的Actor通信模型"></a>ET中的Actor通信模型</h1><p>Actor模型：<img src="https://s4.ax1x.com/2022/02/21/Hvl1zQ.png" alt="Actor模型"></p><p>Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。</p><p>ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生<br>动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理；</p><p>ActorLocation消息Proto文件编写:</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">//ResponseType M2C_TestActorLocationResponsemessage C2M_TestActorLocationReqeust // IActorLocationRequest{int32 RpcId = 90;string Content = 1;}message M2C_TestActorLocationResponse // IActorLocationResponse{int32 RpcId = 90;int32 Error = 91;string Message = 92;string Content = 1;}message C2M_TestActorLocationMessage // IActorLocationMessage{int32 RpcId = 90;string Content = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ActorLocation消息C#代码编写:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.客户端场景切换逻辑            try            {                Session session = zoneScene.GetComponent&lt;Session&gt;();                var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = "111" });                Log.Debug(message.Content);                session.Send(new C2M_TestActorLocationMessage() { Content = "22222" });            }            catch (Exception e)            {                Log.Error(e);            }            2.ActorLocation请求消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt;    {        protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply)        {            Log.Debug(request.Content);            response.Content = "333333";            reply();            await ETTask.CompletedTask;        }    }3.ActorLocation一般消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt;    {        protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message)        {            Log.Debug(message.Content);            //MessageHelper.SendToClient(entity, 发送给客户端的消息);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET教程登录实例"><a href="#ET教程登录实例" class="headerlink" title="ET教程登录实例"></a>ET教程登录实例</h1><p>实例步骤：<br>1.编写账号登录请求和响应俩条协议Proto；<br>2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；<br>3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;<br>4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）;</p><p>事后心得：<br>1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；<br>2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；<br>3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；<br>4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；<br>5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；<br>6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ET6-0框架介绍&quot;&gt;&lt;a href=&quot;#ET6-0框架介绍&quot; class=&quot;headerlink&quot; title=&quot;ET6.0框架介绍&quot;&gt;&lt;/a&gt;ET6.0框架介绍&lt;/h1&gt;&lt;h1 id=&quot;项目的初步运行&quot;&gt;&lt;a href=&quot;#项目的初步运行&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
    <category term="ET" scheme="https://wwy.wwywy.com/tags/ET/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统原理笔记</title>
    <link href="https://wwy.wwywy.com/posts/513.html"/>
    <id>https://wwy.wwywy.com/posts/513.html</id>
    <published>2022-01-08T13:00:00.000Z</published>
    <updated>2022-03-03T09:51:20.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-操作系统绪论"><a href="#1-操作系统绪论" class="headerlink" title="1   操作系统绪论"></a>1   操作系统绪论</h1><h2 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1  操作系统概念"></a>1.1  操作系统概念</h2><p>定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。</p><p><strong>特征：</strong>并发、共享、虚拟、异步。</p><h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2  操作系统发展历程"></a>1.2  操作系统发展历程</h2><p>手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。</p><h3 id="1-2-1单道批处理"><a href="#1-2-1单道批处理" class="headerlink" title="1.2.1单道批处理"></a>1.2.1单道批处理</h3><p><strong>原理：</strong>计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。</p><p><strong>特征：</strong>内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。</p><h3 id="1-2-2多道批处理"><a href="#1-2-2多道批处理" class="headerlink" title="1.2.2多道批处理"></a>1.2.2多道批处理</h3><p>原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。</p><p>特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。</p><h3 id="1-2-3分时系统"><a href="#1-2-3分时系统" class="headerlink" title="1.2.3分时系统"></a>1.2.3分时系统</h3><p>特征：多路性、独立性、及时性、交互性。</p><h3 id="1-2-4实时系统"><a href="#1-2-4实时系统" class="headerlink" title="1.2.4实时系统"></a>1.2.4实时系统</h3><p><strong>特征：</strong>多路性、独立性、及时性、交互性、可靠性。</p><h1 id="2-操作系统用户界面"><a href="#2-操作系统用户界面" class="headerlink" title="2   操作系统用户界面"></a>2   操作系统用户界面</h1><h2 id="2-1-作业"><a href="#2-1-作业" class="headerlink" title="2.1  作业"></a>2.1  作业</h2><p><strong>定义：</strong>分用户和系统角度去理解</p><p>a)     用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业；</p><p>b)     系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL)</p><h2 id="2-2-一般用户输入输出方式"><a href="#2-2-一般用户输入输出方式" class="headerlink" title="2.2  一般用户输入输出方式"></a>2.2  一般用户输入输出方式</h2><h3 id="2-2-1联机输入输出方式"><a href="#2-2-1联机输入输出方式" class="headerlink" title="2.2.1联机输入输出方式"></a>2.2.1联机输入输出方式</h3><h3 id="2-2-2脱机输入输出方式"><a href="#2-2-2脱机输入输出方式" class="headerlink" title="2.2.2脱机输入输出方式"></a>2.2.2脱机输入输出方式</h3><h3 id="2-2-3直接耦合方式"><a href="#2-2-3直接耦合方式" class="headerlink" title="2.2.3直接耦合方式"></a>2.2.3直接耦合方式</h3><h3 id="2-2-4Spooling系统"><a href="#2-2-4Spooling系统" class="headerlink" title="2.2.4Spooling系统"></a>2.2.4Spooling系统</h3><p><strong>原理：</strong>todo。</p><p><strong>特点：</strong>系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。</p><h3 id="2-2-5网络联机方式"><a href="#2-2-5网络联机方式" class="headerlink" title="2.2.5网络联机方式"></a>2.2.5网络联机方式</h3><h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3  系统调用"></a>2.3  系统调用</h2><p><strong>定义：</strong>系统调用是操作系统留给编程人员的唯一接口。</p><p><strong>原理：</strong>todo</p><h3 id="2-3-1系统调用指令"><a href="#2-3-1系统调用指令" class="headerlink" title="2.3.1系统调用指令"></a>2.3.1系统调用指令</h3><p>int和trap指令进行系统调用。</p><p>call和jmp指令进入普通过程调用(子调用)。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3   进程管理"></a>3   进程管理</h1><h2 id="3-1-进程的概念"><a href="#3-1-进程的概念" class="headerlink" title="3.1  进程的概念"></a>3.1  进程的概念</h2><p><strong>组成：</strong>进程=程序+数据+进程控制块(进程状态信息PCB)</p><p><strong>定义：</strong>进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p><strong>目的：</strong>对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性；</p><p><strong>优缺点：</strong>引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。</p><h2 id="3-2-进程和程序的区别"><a href="#3-2-进程和程序的区别" class="headerlink" title="3.2  进程和程序的区别"></a>3.2  进程和程序的区别</h2><p>a)     进程是动态的，程序是静态的；</p><p>b)     进程是暂时的，程序是永久的；</p><p>c)     组成不同，进程的组成包括程序；</p><p>d)    对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序；</p><p>e)    进程可以并行，具有独立性、异步性。</p><p>f)    进程是竞争计算机资源的基本单位。</p><h2 id="3-3-进程控制块-PCB"><a href="#3-3-进程控制块-PCB" class="headerlink" title="3.3  进程控制块(PCB)"></a>3.3  进程控制块(PCB)</h2><p>进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。</p><h3 id="3-3-1描述信息"><a href="#3-3-1描述信息" class="headerlink" title="3.3.1描述信息"></a>3.3.1描述信息</h3><h3 id="3-3-2控制信息"><a href="#3-3-2控制信息" class="headerlink" title="3.3.2控制信息"></a>3.3.2控制信息</h3><h3 id="3-3-3资源管理信息"><a href="#3-3-3资源管理信息" class="headerlink" title="3.3.3资源管理信息"></a>3.3.3资源管理信息</h3><h3 id="3-3-4CPU保护现场结构"><a href="#3-3-4CPU保护现场结构" class="headerlink" title="3.3.4CPU保护现场结构"></a>3.3.4CPU保护现场结构</h3><h2 id="3-4-进程上下文切换"><a href="#3-4-进程上下文切换" class="headerlink" title="3.4  进程上下文切换"></a>3.4  进程上下文切换</h2><p><strong>原因：</strong>进程中断、超时、进程调用。</p><p><strong>步骤：</strong></p><p>a)    保存被切换进程的正文部分到有关存储区。</p><p>b)    进程有关调度和资源分配程序执行，选取新的进程。</p><p>c)    新进程正文部分从存储区取出，激活选中进程执行。</p><h2 id="3-5-进程的状态和进程转换"><a href="#3-5-进程的状态和进程转换" class="headerlink" title="3.5  进程的状态和进程转换"></a>3.5  进程的状态和进程转换</h2><h3 id="3-5-1进程状态"><a href="#3-5-1进程状态" class="headerlink" title="3.5.1进程状态"></a>3.5.1进程状态</h3><p>初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止))</p><h3 id="3-5-2进程状态转换"><a href="#3-5-2进程状态转换" class="headerlink" title="3.5.2进程状态转换"></a>3.5.2进程状态转换</h3><h2 id="3-6-进程控制"><a href="#3-6-进程控制" class="headerlink" title="3.6  进程控制"></a>3.6  进程控制</h2><h3 id="3-6-1进程创建和撤销"><a href="#3-6-1进程创建和撤销" class="headerlink" title="3.6.1进程创建和撤销"></a>3.6.1进程创建和撤销</h3><h3 id="3-6-2进程阻塞和唤醒"><a href="#3-6-2进程阻塞和唤醒" class="headerlink" title="3.6.2进程阻塞和唤醒"></a>3.6.2进程阻塞和唤醒</h3><h3 id="3-6-3进程的挂起和激活"><a href="#3-6-3进程的挂起和激活" class="headerlink" title="3.6.3进程的挂起和激活"></a>3.6.3进程的挂起和激活</h3><h2 id="3-7-进程互斥和同步"><a href="#3-7-进程互斥和同步" class="headerlink" title="3.7  进程互斥和同步"></a>3.7  进程互斥和同步</h2><h3 id="3-7-1临界区和临界资源"><a href="#3-7-1临界区和临界资源" class="headerlink" title="3.7.1临界区和临界资源"></a>3.7.1临界区和临界资源</h3><p>临界资源是一次仅允许一个进程使用的共享资源。</p><p>临界区是每个进程访问临界资源的那段代码。</p><h3 id="3-7-2信号量和PV原语"><a href="#3-7-2信号量和PV原语" class="headerlink" title="3.7.2信号量和PV原语"></a>3.7.2信号量和PV原语</h3><p>信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。</p><p>信号量的数值仅能由P、V原语操作改变。</p><h3 id="3-7-3互斥的概念"><a href="#3-7-3互斥的概念" class="headerlink" title="3.7.3互斥的概念"></a>3.7.3互斥的概念</h3><p><strong>定义：</strong>不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。</p><h3 id="3-7-4同步的概念"><a href="#3-7-4同步的概念" class="headerlink" title="3.7.4同步的概念"></a>3.7.4同步的概念</h3><p><strong>定义：</strong>对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。</p><h2 id="3-8-进程通信"><a href="#3-8-进程通信" class="headerlink" title="3.8  进程通信"></a>3.8  进程通信</h2><p>Todo</p><h2 id="3-9-死锁问题"><a href="#3-9-死锁问题" class="headerlink" title="3.9  死锁问题"></a>3.9  死锁问题</h2><h3 id="3-9-1死锁的概念"><a href="#3-9-1死锁的概念" class="headerlink" title="3.9.1死锁的概念"></a>3.9.1死锁的概念</h3><p><strong>定义：</strong> 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。</p><p><strong>起因：</strong>并发进程的资源竞争</p><p><strong>条件：</strong>同时具备互斥条件、不剥夺条件、部分分配、环路条件。</p><h3 id="3-9-2死锁的解决方案"><a href="#3-9-2死锁的解决方案" class="headerlink" title="3.9.2死锁的解决方案"></a>3.9.2死锁的解决方案</h3><h4 id="3-9-2-1-死锁预防"><a href="#3-9-2-1-死锁预防" class="headerlink" title="3.9.2.1    死锁预防"></a>3.9.2.1    死锁预防</h4><h4 id="3-9-2-2-死锁避免"><a href="#3-9-2-2-死锁避免" class="headerlink" title="3.9.2.2    死锁避免"></a>3.9.2.2    死锁避免</h4><p>最具代表性的避免算法-银行家算法</p><h4 id="3-9-2-3-死锁的检测和恢复"><a href="#3-9-2-3-死锁的检测和恢复" class="headerlink" title="3.9.2.3    死锁的检测和恢复"></a>3.9.2.3    死锁的检测和恢复</h4><h2 id="3-10-线程"><a href="#3-10-线程" class="headerlink" title="3.10    线程"></a>3.10    线程</h2><h3 id="3-10-1-线程的基本概念"><a href="#3-10-1-线程的基本概念" class="headerlink" title="3.10.1 线程的基本概念"></a>3.10.1 线程的基本概念</h3><p>定义：引入线程后，线程是操作系统调度和分配的基本单位。</p><p>组成：线程=？+线程控制块(TCB)</p><h3 id="3-10-2-线程状态和线程控制块-TCB"><a href="#3-10-2-线程状态和线程控制块-TCB" class="headerlink" title="3.10.2 线程状态和线程控制块(TCB)"></a>3.10.2 线程状态和线程控制块(TCB)</h3><p>线程状态：执行状态、就绪状态、阻塞(等待)状态</p><p>线程控制块数据结构包括：</p><p>a)     线程标识符</p><p>b)     一组寄存器</p><p>c)     线程执行状态</p><p>d)     优先级</p><p>e)     线程专有存储区</p><p>f)     信号屏蔽</p><p>g)    堆栈指针</p><h3 id="3-10-3-线程和进程的区别"><a href="#3-10-3-线程和进程的区别" class="headerlink" title="3.10.3 线程和进程的区别"></a>3.10.3 线程和进程的区别</h3><p>从以下六点讨论</p><p>a)     调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。</p><p>b)     并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。</p><p>c)     拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。</p><p>d)     独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。</p><p>e)     系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。</p><p>f)     支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。</p><h1 id="4-处理机调度"><a href="#4-处理机调度" class="headerlink" title="4   处理机调度"></a>4   处理机调度</h1><h2 id="4-1-调度层级"><a href="#4-1-调度层级" class="headerlink" title="4.1  调度层级"></a>4.1  调度层级</h2><p>一个作业提交后，往往会经历三种层级（加线程四种）</p><h3 id="4-1-1作业调度"><a href="#4-1-1作业调度" class="headerlink" title="4.1.1作业调度"></a>4.1.1作业调度</h3><p>又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。</p><h4 id="4-1-1-1-周转时间相关"><a href="#4-1-1-1-周转时间相关" class="headerlink" title="4.1.1.1    周转时间相关"></a>4.1.1.1    周转时间相关</h4><p>周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间</p><p>平均周转时间=所有作业周转时间之和/总作业数</p><p>带权周转时间=作业周转时间/作业执行时间</p><p>平均带权周转时间=所有带权作业周转时间之和/总作业数</p><h4 id="4-1-1-2-响应时间，截止时间和系统吞吐量"><a href="#4-1-1-2-响应时间，截止时间和系统吞吐量" class="headerlink" title="4.1.1.2     响应时间，截止时间和系统吞吐量"></a>4.1.1.2     响应时间，截止时间和系统吞吐量</h4><p>响应时间是提交请求和返回该请求的响应之间使用的时间<br>截止时间是某任务必须开始执行或者必须完成的最迟时间<br>吞吐量是对单位时间内完成的工作量的量度</p><h3 id="4-1-2交换调度"><a href="#4-1-2交换调度" class="headerlink" title="4.1.2交换调度"></a>4.1.2交换调度</h3><p>又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存</p><h3 id="4-1-3进程调度"><a href="#4-1-3进程调度" class="headerlink" title="4.1.3进程调度"></a>4.1.3进程调度</h3><p>又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式</p><h4 id="4-1-3-1-非抢占方式"><a href="#4-1-3-1-非抢占方式" class="headerlink" title="4.1.3.1    非抢占方式"></a>4.1.3.1    非抢占方式</h4><p>一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。</p><h4 id="4-1-3-2-抢占方式"><a href="#4-1-3-2-抢占方式" class="headerlink" title="4.1.3.2     抢占方式"></a>4.1.3.2     抢占方式</h4><p>系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程</p><p>a)     优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU</p><p>b)     短作业优先原则：就绪的短进程有权抢占长进程的CPU</p><p>c)     时间片原则：一个时间片用完后，系统重新进行进程调度</p><h3 id="4-1-4线程调度"><a href="#4-1-4线程调度" class="headerlink" title="4.1.4线程调度"></a>4.1.4线程调度</h3><p>Todo</p><h2 id="4-2-作业和进程的关系"><a href="#4-2-作业和进程的关系" class="headerlink" title="4.2  作业和进程的关系"></a>4.2  作业和进程的关系</h2><p>系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。</p><h2 id="4-3-调度算法"><a href="#4-3-调度算法" class="headerlink" title="4.3  调度算法"></a>4.3  调度算法</h2><p>宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。</p><p>​    微观调度：轮转法、优先级法、多级反馈轮转法。</p><h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5   存储管理"></a>5   存储管理</h1><h2 id="5-1-存储器结构"><a href="#5-1-存储器结构" class="headerlink" title="5.1  存储器结构"></a>5.1  存储器结构</h2><p>由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。</p><h3 id="5-1-1寄存器"><a href="#5-1-1寄存器" class="headerlink" title="5.1.1寄存器"></a>5.1.1寄存器</h3><p>寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。</p><h3 id="5-1-2高速缓存"><a href="#5-1-2高速缓存" class="headerlink" title="5.1.2高速缓存"></a>5.1.2高速缓存</h3><p>它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。</p><h3 id="5-1-3主存输器"><a href="#5-1-3主存输器" class="headerlink" title="5.1.3主存输器"></a>5.1.3主存输器</h3><p>简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。</p><h3 id="5-1-4磁盘缓存"><a href="#5-1-4磁盘缓存" class="headerlink" title="5.1.4磁盘缓存"></a>5.1.4磁盘缓存</h3><p>目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。</p><h2 id="5-2-程序的处理阶段"><a href="#5-2-程序的处理阶段" class="headerlink" title="5.2  程序的处理阶段"></a>5.2  程序的处理阶段</h2><p>主要有编译，链接，装入，下面主要讲链接和装入。</p><h3 id="5-2-1程序的链接"><a href="#5-2-1程序的链接" class="headerlink" title="5.2.1程序的链接"></a>5.2.1程序的链接</h3><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。<br>链接又可分为静态链接，装入时动态链接，运行时动态链接。</p><h3 id="5-2-2程序的装入"><a href="#5-2-2程序的装入" class="headerlink" title="5.2.2程序的装入"></a>5.2.2程序的装入</h3><p>分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。</p><h2 id="5-3-地址变换"><a href="#5-3-地址变换" class="headerlink" title="5.3  地址变换"></a>5.3  地址变换</h2><h3 id="5-3-1静态地址重定向"><a href="#5-3-1静态地址重定向" class="headerlink" title="5.3.1静态地址重定向"></a>5.3.1静态地址重定向</h3><p><strong>原理：</strong>Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。</p><h3 id="5-3-2动态地址重定位"><a href="#5-3-2动态地址重定位" class="headerlink" title="5.3.2动态地址重定位"></a>5.3.2动态地址重定位</h3><p><strong>关系：</strong>MA(物理地址)=BR(基址地址)+VR(虚拟地址)。</p><p>原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。</p><h2 id="5-4-分区存储管理"><a href="#5-4-分区存储管理" class="headerlink" title="5.4  分区存储管理"></a>5.4  分区存储管理</h2><p>分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。</p><h3 id="5-4-1固态分区法"><a href="#5-4-1固态分区法" class="headerlink" title="5.4.1固态分区法"></a>5.4.1固态分区法</h3><p>原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。</p><p>优点:易于实现，开销小。</p><p>缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。</p><h3 id="5-4-2动态分区法"><a href="#5-4-2动态分区法" class="headerlink" title="5.4.2动态分区法"></a>5.4.2动态分区法</h3><p><strong>原理：</strong>动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。</p><p><strong>优点：</strong>没有内碎片；</p><p><strong>缺点：</strong>有外碎片；</p><p><strong>算法：</strong>根据情况有以下俩种，着重介绍三种</p><p>a)     基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法</p><p>b)     基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法</p><h4 id="5-4-2-2-最先适应法"><a href="#5-4-2-2-最先适应法" class="headerlink" title="5.4.2.2     最先适应法"></a>5.4.2.2     最先适应法</h4><h4 id="5-4-2-3-最佳适应法"><a href="#5-4-2-3-最佳适应法" class="headerlink" title="5.4.2.3     最佳适应法"></a>5.4.2.3     最佳适应法</h4><h4 id="5-4-2-4-最坏适应法"><a href="#5-4-2-4-最坏适应法" class="headerlink" title="5.4.2.4     最坏适应法"></a>5.4.2.4     最坏适应法</h4><h3 id="5-4-3页式管理（离散分配）"><a href="#5-4-3页式管理（离散分配）" class="headerlink" title="5.4.3页式管理（离散分配）"></a>5.4.3页式管理（离散分配）</h3><p>基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。</p><h4 id="5-4-3-1-静态页式管理"><a href="#5-4-3-1-静态页式管理" class="headerlink" title="5.4.3.1    静态页式管理"></a>5.4.3.1    静态页式管理</h4><p>原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。</p><h4 id="5-4-3-2-动态页式管理"><a href="#5-4-3-2-动态页式管理" class="headerlink" title="5.4.3.2    动态页式管理"></a>5.4.3.2    动态页式管理</h4><h3 id="5-4-4段式和段页式管理"><a href="#5-4-4段式和段页式管理" class="headerlink" title="5.4.4段式和段页式管理"></a>5.4.4段式和段页式管理</h3><p>基本思想：todo</p><h4 id="5-4-4-1-段式管理"><a href="#5-4-4-1-段式管理" class="headerlink" title="5.4.4.1     段式管理"></a>5.4.4.1     段式管理</h4><p>原理：todo</p><h4 id="5-4-4-2-段页式管理"><a href="#5-4-4-2-段页式管理" class="headerlink" title="5.4.4.2     段页式管理"></a>5.4.4.2     段页式管理</h4><p>原理：todo</p><h3 id="5-4-5覆盖和交换技术"><a href="#5-4-5覆盖和交换技术" class="headerlink" title="5.4.5覆盖和交换技术"></a>5.4.5覆盖和交换技术</h3><h2 id="5-5-虚拟存输器"><a href="#5-5-虚拟存输器" class="headerlink" title="5.5  虚拟存输器"></a>5.5  虚拟存输器</h2><h3 id="5-5-1虚拟存储的实现方式"><a href="#5-5-1虚拟存储的实现方式" class="headerlink" title="5.5.1虚拟存储的实现方式"></a>5.5.1虚拟存储的实现方式</h3><p>虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式：</p><h4 id="5-5-1-1-分页请求系统"><a href="#5-5-1-1-分页请求系统" class="headerlink" title="5.5.1.1     分页请求系统"></a>5.5.1.1     分页请求系统</h4><p>在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。<br>  硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上</p><h4 id="5-5-1-2-请求分段系统"><a href="#5-5-1-2-请求分段系统" class="headerlink" title="5.5.1.2     请求分段系统"></a>5.5.1.2     请求分段系统</h4><p>在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页”</p><h3 id="5-5-2页面置换算法"><a href="#5-5-2页面置换算法" class="headerlink" title="5.5.2页面置换算法"></a>5.5.2页面置换算法</h3><h4 id="5-5-2-1-随机淘汰算法"><a href="#5-5-2-1-随机淘汰算法" class="headerlink" title="5.5.2.1     随机淘汰算法"></a>5.5.2.1     随机淘汰算法</h4><p>随机地选择某个用户地页面并将其换出。</p><h4 id="5-5-2-2-最佳置换算法（理想型淘汰算法OPT）"><a href="#5-5-2-2-最佳置换算法（理想型淘汰算法OPT）" class="headerlink" title="5.5.2.2     最佳置换算法（理想型淘汰算法OPT）"></a>5.5.2.2     最佳置换算法（理想型淘汰算法OPT）</h4><p>其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。</p><h4 id="5-5-2-3-先进先出置换算法（FIFO）"><a href="#5-5-2-3-先进先出置换算法（FIFO）" class="headerlink" title="5.5.2.3     先进先出置换算法（FIFO）"></a>5.5.2.3     先进先出置换算法（FIFO）</h4><p>总是先淘汰最先进入内存的页面。</p><h4 id="5-5-2-4-最近最久未使用算法（LRU）"><a href="#5-5-2-4-最近最久未使用算法（LRU）" class="headerlink" title="5.5.2.4     最近最久未使用算法（LRU）"></a>5.5.2.4     最近最久未使用算法（LRU）</h4><p>选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。</p><h4 id="5-5-2-5-最少使用置换算法（LFU）"><a href="#5-5-2-5-最少使用置换算法（LFU）" class="headerlink" title="5.5.2.5     最少使用置换算法（LFU）"></a>5.5.2.5     最少使用置换算法（LFU）</h4><p>在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。</p><h4 id="5-5-2-6-Clock置换算法"><a href="#5-5-2-6-Clock置换算法" class="headerlink" title="5.5.2.6     Clock置换算法"></a>5.5.2.6     Clock置换算法</h4><p>是一种LRU算法<br>每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；<br>当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；<br>再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面；</p><h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6   文件系统"></a>6   文件系统</h1><h2 id="6-1-文件系统基本概念"><a href="#6-1-文件系统基本概念" class="headerlink" title="6.1  文件系统基本概念"></a>6.1  文件系统基本概念</h2><p><strong>目的：</strong>文件系统地出现是为了更好地管理软件资源</p><p><strong>文件系统的定义：</strong>操作系统中与管理文件有关的软件和数据称为文件系统</p><p><strong>文件的定义：</strong>文件时一段程序和数据的集合</p><p><strong>文件的分类：</strong>按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。</p><h2 id="6-2-文件的逻辑结构和存取方式"><a href="#6-2-文件的逻辑结构和存取方式" class="headerlink" title="6.2  文件的逻辑结构和存取方式"></a>6.2  文件的逻辑结构和存取方式</h2><h3 id="6-2-1逻辑结构"><a href="#6-2-1逻辑结构" class="headerlink" title="6.2.1逻辑结构"></a>6.2.1逻辑结构</h3><p><strong>字符流的无结构文件：</strong>管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。</p><p><strong>记录式的有结构文件：</strong>把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。</p><h4 id="6-2-1-1-连续结构"><a href="#6-2-1-1-连续结构" class="headerlink" title="6.2.1.1     连续结构"></a>6.2.1.1     连续结构</h4><h4 id="6-2-1-2-多重结构"><a href="#6-2-1-2-多重结构" class="headerlink" title="6.2.1.2     多重结构"></a>6.2.1.2     多重结构</h4><h4 id="6-2-1-3-转置结构"><a href="#6-2-1-3-转置结构" class="headerlink" title="6.2.1.3     转置结构"></a>6.2.1.3     转置结构</h4><h4 id="6-2-1-4-顺序结构"><a href="#6-2-1-4-顺序结构" class="headerlink" title="6.2.1.4     顺序结构"></a>6.2.1.4     顺序结构</h4><h3 id="6-2-2逻辑存储方法"><a href="#6-2-2逻辑存储方法" class="headerlink" title="6.2.2逻辑存储方法"></a>6.2.2逻辑存储方法</h3><h4 id="6-2-2-1-顺序存输方法"><a href="#6-2-2-1-顺序存输方法" class="headerlink" title="6.2.2.1     顺序存输方法"></a>6.2.2.1     顺序存输方法</h4><h4 id="6-2-2-2-随机存输方法"><a href="#6-2-2-2-随机存输方法" class="headerlink" title="6.2.2.2     随机存输方法"></a>6.2.2.2     随机存输方法</h4><h4 id="6-2-2-3-按关键字存输方法"><a href="#6-2-2-3-按关键字存输方法" class="headerlink" title="6.2.2.3    按关键字存输方法"></a>6.2.2.3    按关键字存输方法</h4><p>多用于复杂文件系统。</p><h3 id="6-2-3逻辑搜索方式"><a href="#6-2-3逻辑搜索方式" class="headerlink" title="6.2.3逻辑搜索方式"></a>6.2.3逻辑搜索方式</h3><p>文件的获取是要找到文件内容所在的逻辑地址</p><h4 id="6-2-3-1-线性搜索法"><a href="#6-2-3-1-线性搜索法" class="headerlink" title="6.2.3.1     线性搜索法"></a>6.2.3.1     线性搜索法</h4><h4 id="6-2-3-2-散列法"><a href="#6-2-3-2-散列法" class="headerlink" title="6.2.3.2     散列法"></a>6.2.3.2     散列法</h4><h4 id="6-2-3-3-二分搜索法"><a href="#6-2-3-3-二分搜索法" class="headerlink" title="6.2.3.3     二分搜索法"></a>6.2.3.3     二分搜索法</h4><h2 id="6-3-文件的物理结构和存储设备"><a href="#6-3-文件的物理结构和存储设备" class="headerlink" title="6.3  文件的物理结构和存储设备"></a>6.3  文件的物理结构和存储设备</h2><h3 id="6-3-1文件物理结构"><a href="#6-3-1文件物理结构" class="headerlink" title="6.3.1文件物理结构"></a>6.3.1文件物理结构</h3><h4 id="6-3-1-1-连续文件"><a href="#6-3-1-1-连续文件" class="headerlink" title="6.3.1.1    连续文件"></a>6.3.1.1    连续文件</h4><p>连续文件采用连续分配方式：</p><p><strong>特点：</strong>为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。<br><strong>优点：</strong>顺序访问容易; 顺序访问速度快;<br><strong>缺点：</strong>要求有连续的存储空间; 必须事先知道文件的长度;</p><h4 id="6-3-1-2-串联文件"><a href="#6-3-1-2-串联文件" class="headerlink" title="6.3.1.2    串联文件"></a>6.3.1.2    串联文件</h4><p>串联文件采用链接分配</p><p><strong>特点：</strong>文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；<br><strong>优点：</strong>没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间;</p><h4 id="6-3-1-3-索引文件"><a href="#6-3-1-3-索引文件" class="headerlink" title="6.3.1.3    索引文件"></a>6.3.1.3    索引文件</h4><p>索引文件采用索引分配</p><p><strong>特点：</strong>每个文件都有自己的索引块，这是一个磁盘块地址的数组。</p><h3 id="6-3-2文件存储设备"><a href="#6-3-2文件存储设备" class="headerlink" title="6.3.2文件存储设备"></a>6.3.2文件存储设备</h3><p>存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。</p><h4 id="6-3-2-1-顺序存取存储设备—磁带"><a href="#6-3-2-1-顺序存取存储设备—磁带" class="headerlink" title="6.3.2.1    顺序存取存储设备—磁带"></a>6.3.2.1    顺序存取存储设备—磁带</h4><p><strong>特点：</strong>只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。</p><p><strong>影响因素：</strong>信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。</p><h4 id="6-3-2-2-直接存取存储设备—磁盘"><a href="#6-3-2-2-直接存取存储设备—磁盘" class="headerlink" title="6.3.2.2     直接存取存储设备—磁盘"></a>6.3.2.2     直接存取存储设备—磁盘</h4><h2 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4  文件存储空间管理"></a>6.4  文件存储空间管理</h2><p>文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。</p><h3 id="6-4-1空闲目录管理"><a href="#6-4-1空闲目录管理" class="headerlink" title="6.4.1空闲目录管理"></a>6.4.1空闲目录管理</h3><h3 id="6-4-2空闲链块法"><a href="#6-4-2空闲链块法" class="headerlink" title="6.4.2空闲链块法"></a>6.4.2空闲链块法</h3><h3 id="6-4-3位示图"><a href="#6-4-3位示图" class="headerlink" title="6.4.3位示图"></a>6.4.3位示图</h3><h2 id="6-5-文件目录管理"><a href="#6-5-文件目录管理" class="headerlink" title="6.5  文件目录管理"></a>6.5  文件目录管理</h2><p>从文件管理角度看，一个文件包括文件说明和文件体。</p><h3 id="6-5-1文件目录的种类"><a href="#6-5-1文件目录的种类" class="headerlink" title="6.5.1文件目录的种类"></a>6.5.1文件目录的种类</h3><h4 id="6-5-1-1-单级文件目录"><a href="#6-5-1-1-单级文件目录" class="headerlink" title="6.5.1.1     单级文件目录"></a>6.5.1.1     单级文件目录</h4><p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。</p><h4 id="6-5-1-2-两级文件目录"><a href="#6-5-1-2-两级文件目录" class="headerlink" title="6.5.1.2     两级文件目录"></a>6.5.1.2     两级文件目录</h4><p>目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB；</p><h4 id="6-5-1-3-树形结构目录"><a href="#6-5-1-3-树形结构目录" class="headerlink" title="6.5.1.3     树形结构目录"></a>6.5.1.3     树形结构目录</h4><p>多级目录结构又称为树型目录结构；<br>主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点；</p><h3 id="6-5-2文件目录的共享"><a href="#6-5-2文件目录的共享" class="headerlink" title="6.5.2文件目录的共享"></a>6.5.2文件目录的共享</h3><p>从系统管理的方式来看，有三种方法可以实现文件共享</p><h4 id="6-5-2-1-绕道法"><a href="#6-5-2-1-绕道法" class="headerlink" title="6.5.2.1     绕道法"></a>6.5.2.1     绕道法</h4><h4 id="6-5-2-2-链接法"><a href="#6-5-2-2-链接法" class="headerlink" title="6.5.2.2     链接法"></a>6.5.2.2     链接法</h4><h4 id="6-5-2-3-基本文件目录表（BFD）"><a href="#6-5-2-3-基本文件目录表（BFD）" class="headerlink" title="6.5.2.3    基本文件目录表（BFD）"></a>6.5.2.3    基本文件目录表（BFD）</h4><h3 id="6-5-3目录管理"><a href="#6-5-3目录管理" class="headerlink" title="6.5.3目录管理"></a>6.5.3目录管理</h3><p>文件目录管理应该存放在磁盘，其他的没理解todo</p><h2 id="6-6-文件存取控制"><a href="#6-6-文件存取控制" class="headerlink" title="6.6  文件存取控制"></a>6.6  文件存取控制</h2><p>用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。</p><h3 id="6-6-1存取控制矩阵"><a href="#6-6-1存取控制矩阵" class="headerlink" title="6.6.1存取控制矩阵"></a>6.6.1存取控制矩阵</h3><h3 id="6-6-2存取控制表"><a href="#6-6-2存取控制表" class="headerlink" title="6.6.2存取控制表"></a>6.6.2存取控制表</h3><h3 id="6-6-3口令方式"><a href="#6-6-3口令方式" class="headerlink" title="6.6.3口令方式"></a>6.6.3口令方式</h3><h3 id="6-6-4密码方式"><a href="#6-6-4密码方式" class="headerlink" title="6.6.4密码方式"></a>6.6.4密码方式</h3><p>密码方式是保密性最好的验证方式。</p><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7    设备管理"></a>7    设备管理</h1><h2 id="7-1-设备的分类"><a href="#7-1-设备的分类" class="headerlink" title="7.1  设备的分类"></a>7.1  设备的分类</h2><p>在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。</p><h2 id="7-2-数据传输控制方式"><a href="#7-2-数据传输控制方式" class="headerlink" title="7.2  数据传输控制方式"></a>7.2  数据传输控制方式</h2><p>设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。</p><h3 id="7-2-1程序直接控制方式"><a href="#7-2-1程序直接控制方式" class="headerlink" title="7.2.1程序直接控制方式"></a>7.2.1程序直接控制方式</h3><p>由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。</p><h3 id="7-2-2中断方式"><a href="#7-2-2中断方式" class="headerlink" title="7.2.2中断方式"></a>7.2.2中断方式</h3><p>I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。</p><h3 id="7-2-3DMA方式"><a href="#7-2-3DMA方式" class="headerlink" title="7.2.3DMA方式"></a>7.2.3DMA方式</h3><p>在外围设备和内存之间开辟直接的数据交换通道。</p><h3 id="7-2-4通道控制方式"><a href="#7-2-4通道控制方式" class="headerlink" title="7.2.4通道控制方式"></a>7.2.4通道控制方式</h3><p>以内存为中心，实现设备和内存直接交换数据的控制的方式。</p><h2 id="7-3-中断技术"><a href="#7-3-中断技术" class="headerlink" title="7.3  中断技术"></a>7.3  中断技术</h2><p><strong>原理：</strong>中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。</p><p><strong>过程：</strong>判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点</p><h3 id="7-3-1中断技术的分类"><a href="#7-3-1中断技术的分类" class="headerlink" title="7.3.1中断技术的分类"></a>7.3.1中断技术的分类</h3><p>中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。</p><h4 id="7-3-1-1-外中断"><a href="#7-3-1-1-外中断" class="headerlink" title="7.3.1.1    外中断"></a>7.3.1.1    外中断</h4><p>一般是来自处理机和内存外部的中断</p><h4 id="7-3-1-2-内中断（陷阱）"><a href="#7-3-1-2-内中断（陷阱）" class="headerlink" title="7.3.1.2    内中断（陷阱）"></a>7.3.1.2    内中断（陷阱）</h4><p>一般是来自处理机和内存内部的中断</p><h4 id="7-3-1-3-软中断"><a href="#7-3-1-3-软中断" class="headerlink" title="7.3.1.3    软中断"></a>7.3.1.3    软中断</h4><p>是通信进程之间模拟硬中断的一种信号通信方式</p><h2 id="7-4-缓冲技术"><a href="#7-4-缓冲技术" class="headerlink" title="7.4  缓冲技术"></a>7.4  缓冲技术</h2><p><strong>目的：</strong>缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。</p><p><strong>分类：</strong>缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。</p><h3 id="7-4-1缓冲池的结构"><a href="#7-4-1缓冲池的结构" class="headerlink" title="7.4.1缓冲池的结构"></a>7.4.1缓冲池的结构</h3><p>缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。</p><h3 id="7-4-2缓冲池管理"><a href="#7-4-2缓冲池管理" class="headerlink" title="7.4.2缓冲池管理"></a>7.4.2缓冲池管理</h3><p>Todo</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-操作系统绪论&quot;&gt;&lt;a href=&quot;#1-操作系统绪论&quot; class=&quot;headerlink&quot; title=&quot;1   操作系统绪论&quot;&gt;&lt;/a&gt;1   操作系统绪论&lt;/h1&gt;&lt;h2 id=&quot;1-1-操作系统概念&quot;&gt;&lt;a href=&quot;#1-1-操作系统概念&quot; cla</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计算机操作系统" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机操作系统" scheme="https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-FairyGUI</title>
    <link href="https://wwy.wwywy.com/posts/1542.html"/>
    <id>https://wwy.wwywy.com/posts/1542.html</id>
    <published>2021-12-12T13:00:00.000Z</published>
    <updated>2022-03-03T10:08:03.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FairyGUI概叙"><a href="#FairyGUI概叙" class="headerlink" title="FairyGUI概叙"></a>FairyGUI概叙</h1><h1 id="FairyGUI基础"><a href="#FairyGUI基础" class="headerlink" title="FairyGUI基础"></a>FairyGUI基础</h1><h1 id="FairyGUI基本元件"><a href="#FairyGUI基本元件" class="headerlink" title="FairyGUI基本元件"></a>FairyGUI基本元件</h1><h1 id="FairyGUI控件"><a href="#FairyGUI控件" class="headerlink" title="FairyGUI控件"></a>FairyGUI控件</h1><h2 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h2><h2 id="字体处理"><a href="#字体处理" class="headerlink" title="字体处理"></a>字体处理</h2><h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><h2 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h2><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h2 id="关联系统"><a href="#关联系统" class="headerlink" title="关联系统"></a>关联系统</h2><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="单选和多选框"><a href="#单选和多选框" class="headerlink" title="单选和多选框"></a>单选和多选框</h2><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><h2 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h2><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><h2 id="滚动容器"><a href="#滚动容器" class="headerlink" title="滚动容器"></a>滚动容器</h2><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h2><h1 id="Unity中的使用必备"><a href="#Unity中的使用必备" class="headerlink" title="Unity中的使用必备"></a>Unity中的使用必备</h1><h2 id="组件拓展类"><a href="#组件拓展类" class="headerlink" title="组件拓展类"></a>组件拓展类</h2><h2 id="分辨率自适应"><a href="#分辨率自适应" class="headerlink" title="分辨率自适应"></a>分辨率自适应</h2><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><h2 id="拖拽相关"><a href="#拖拽相关" class="headerlink" title="拖拽相关"></a>拖拽相关</h2><h2 id="插入其他对象"><a href="#插入其他对象" class="headerlink" title="插入其他对象"></a>插入其他对象</h2><h2 id="DrawCall优化"><a href="#DrawCall优化" class="headerlink" title="DrawCall优化"></a>DrawCall优化</h2><h1 id="FairyGUI进阶"><a href="#FairyGUI进阶" class="headerlink" title="FairyGUI进阶"></a>FairyGUI进阶</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="多国语言"><a href="#多国语言" class="headerlink" title="多国语言"></a>多国语言</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h2 id="弹出功能"><a href="#弹出功能" class="headerlink" title="弹出功能"></a>弹出功能</h2><h2 id="曲面UI"><a href="#曲面UI" class="headerlink" title="曲面UI"></a>曲面UI</h2><h2 id="动效"><a href="#动效" class="headerlink" title="动效"></a>动效</h2><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FairyGUI概叙&quot;&gt;&lt;a href=&quot;#FairyGUI概叙&quot; class=&quot;headerlink&quot; title=&quot;FairyGUI概叙&quot;&gt;&lt;/a&gt;FairyGUI概叙&lt;/h1&gt;&lt;h1 id=&quot;FairyGUI基础&quot;&gt;&lt;a href=&quot;#FairyGUI基础&quot;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="GUI解决方案" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="FairyGUI" scheme="https://wwy.wwywy.com/tags/FairyGUI/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关-Excel编辑器工具</title>
    <link href="https://wwy.wwywy.com/posts/1601.html"/>
    <id>https://wwy.wwywy.com/posts/1601.html</id>
    <published>2021-11-16T13:00:00.000Z</published>
    <updated>2022-04-30T00:18:35.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Excel介绍"><a href="#Excel介绍" class="headerlink" title="Excel介绍"></a>Excel介绍</h1><p>1.Excel的本质：Excel表本质上也是一堆数据，只不过它有自己的存储读取规则，如果我们想要通过代码读取它，那么必须知道它的存储规则，官网是专门提供了对应的DLL文件用来解析Excel文件的；</p><p>2.获取Excel数据信息的意义：</p><ul><li>可以根据表中数据来动态的生成相关数据，如数据结构类、容器类、二进制数据类；</li><li>转成二进制数据也可以提升读取效率，提升数据安全性；</li></ul><h1 id="Excel官方工具使用"><a href="#Excel官方工具使用" class="headerlink" title="Excel官方工具使用"></a>Excel官方工具使用</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">//主要知识点：//1.FileStream读取文件流//2.IExcelDataReader类，从流中读取Excel数据//3.DataSet 数据集合类 将Excel数据转存进其中方便读取//4.DataTable 数据表类 表示Excel文件中的一个表//5.DataRow 数据行类 表示某张表中的一行数据[MenuItem("GameTool/读取Excel里的具体信息")]private static void ReadExcel(){    using (FileStream fs = File.Open(Application.dataPath + "/ArtRes/Excel/PlayerInfo.xlsx", FileMode.Open, FileAccess.Read))    {        IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);        DataSet result = excelReader.AsDataSet();        for (int i = 0; i &lt; result.Tables.Count; i++)        {            //得到其中一张表的具体数据            DataTable table = result.Tables[i];            Debug.Log("表名：" + result.Tables[i].TableName);            Debug.Log("行数：" + result.Tables[i].Rows.Count);            Debug.Log("列数：" + result.Tables[i].Columns.Count);            //得到其中一行的数据            DataRow row = table.Rows[0];            //得到行中某一列的信息            Debug.Log(row[1].ToString());            DataRow row;            for (int j = 0; j &lt; table.Rows.Count; j++)            {                //得到每一行的信息                row = table.Rows[j];                Debug.Log("*********新的一行************");                for (int k = 0; k &lt; table.Columns.Count; k++)                {                    //得到每一列的信息                    Debug.Log(row[k].ToString());                }            }        }        fs.Close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="制定规则"><a href="#制定规则" class="headerlink" title="制定规则"></a>制定规则</h1><p>1.Excel读取规则：</p><ul><li>数据类型生成要知道字段名，容器（一般字典）要知道主键，二进制要知道从哪行哪列开始；</li><li>第一行是字段名，第二行是数据类型，第三行容器可以再加一个key表示主键（也可以默认第一列），第四行是中文解释（给策划写的，不会生成进去）；</li><li>下方的表名作为生成的类型名；</li></ul><h1 id="Excel工具编写"><a href="#Excel工具编写" class="headerlink" title="Excel工具编写"></a>Excel工具编写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Excel介绍&quot;&gt;&lt;a href=&quot;#Excel介绍&quot; class=&quot;headerlink&quot; title=&quot;Excel介绍&quot;&gt;&lt;/a&gt;Excel介绍&lt;/h1&gt;&lt;p&gt;1.Excel的本质：Excel表本质上也是一堆数据，只不过它有自己的存储读取规则，如果我们想要通过</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Excel" scheme="https://wwy.wwywy.com/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Lua语言</title>
    <link href="https://wwy.wwywy.com/posts/02900.html"/>
    <id>https://wwy.wwywy.com/posts/02900.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-03-23T00:52:14.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
    <category term="Lua" scheme="https://wwy.wwywy.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>C++入门</title>
    <link href="https://wwy.wwywy.com/posts/1344.html"/>
    <id>https://wwy.wwywy.com/posts/1344.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-05-01T07:17:38.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基本概念"><a href="#C-基本概念" class="headerlink" title="C++基本概念"></a>C++基本概念</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1.语言的发展：二进制值类==&gt;汇编语言==&gt;中高级语言(C,C++,Java)</p><p>2.C++说明：C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程，C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点，C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序；</p><p>3.C++发展时间：</p><ul><li>1998：C++98，第一个C++标准；</li><li>2003：C++03，第二个C++标准；</li><li>2011：C++11，第三个C++标准；</li><li>2014：C++14，第四个C++标准；</li><li>2017：C++17，第五个C++标准；</li></ul><h2 id="环境的建立"><a href="#环境的建立" class="headerlink" title="环境的建立"></a>环境的建立</h2><p>1.C++编译器：</p><ul><li>GCC编译器：</li><li>Visual Studio IDEA：</li></ul><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>1.编译&amp;执行：</p><ul><li>打开一个文本编辑器，添加上述代码；</li><li>保存文件为 hello.cpp；</li><li>打开命令提示符，进入到保存文件所在的目录；</li><li>键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件；</li><li>现在，键入 ‘ a.out’ 来运行程序；</li><li>您可以看到屏幕上显示 ‘ Hello World ‘；</li></ul><p>2.C++ 标识符：C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9），C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符；</p><p>3.C++关键字：</p><p><a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com)</a></p><p>4.C++注释：和C#一致；</p><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><table><thead><tr><th>类型</th><th>关键字</th><th>初始化默认值</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>字符型</td><td>char</td><td>‘\0’</td><td>1 个字节</td><td>-128 到 127 或者 0 到 255</td></tr><tr><td>无符号字符型</td><td>unsigned char</td><td>0</td><td>1 个字节</td><td>0 到 255</td></tr><tr><td>有符号字符型</td><td>signed char</td><td>0</td><td>1 个字节</td><td>-128 到 127</td></tr><tr><td>整形</td><td>int</td><td>0</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>无符号整形</td><td>unsigned int</td><td>0</td><td>4 个字节</td><td>0 到 4294967295</td></tr><tr><td>有符号整形</td><td>signed int</td><td>0</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>短整形</td><td>short int</td><td>0</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>无符号短整形</td><td>unsigned short int</td><td>0</td><td>2 个字节</td><td>0 到 65,535</td></tr><tr><td>有符号短整形</td><td>signed short int</td><td>0</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>长整形</td><td>long int</td><td>0</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>无符号长整形</td><td>signed long int</td><td>0</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>有符号长整形</td><td>unsigned long int</td><td>0</td><td>8 个字节</td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td>单精度浮点型</td><td>float</td><td>0</td><td>4 个字节</td><td>精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td>双精度浮点型</td><td>double</td><td>0</td><td>8 个字节</td><td>双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td>双精度长浮点型</td><td>long double</td><td>0</td><td>16 个字节</td><td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td>宽字符型</td><td>wchar_t</td><td>‘\0’</td><td>2 或 4 个字节</td><td>1 个宽字符（等价==&gt;typedef short int wchar_t）</td></tr><tr><td>无类型</td><td>void</td><td>-</td><td>-</td><td>表示类型的缺失</td></tr></tbody></table><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>1.作用域说明：主要是三个地方可以定义变量</p><ul><li>局部变量：在函数或一个代码块内部声明的变量；</li><li>全局变量：在所有函数外部声明的变量；</li><li>形式参数：在函数参数的定义中声明的变量，而调用方则被称为实际参数；</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>1.C++声明常量：常量最好全大写</p><ul><li>#define 预处理器：语法格式#define 预处理名 常量值；</li><li>const 关键字：语法格式const 数据类型 变量名 = 常量值；</li></ul><h2 id="修饰符类型"><a href="#修饰符类型" class="headerlink" title="修饰符类型"></a>修饰符类型</h2><p>1.修饰符：修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型；修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀（例如：unsigned long int，其中int可以省略）；</p><ul><li>signed：有符号类型；</li><li>unsigned：无符号类型；</li><li>long：长类型；</li><li>short：短类型；</li></ul><p>2.类型限定符：类型限定符提供了变量的额外信息：</p><ul><li>const：const 类型的对象在程序执行期间不能被修改改变；</li><li>volatile：修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率；</li><li>restrict：由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict；</li></ul><h2 id="存储类-型"><a href="#存储类-型" class="headerlink" title="存储类(型)"></a>存储类(型)</h2><p>1.存储类说明：存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们所修饰的类型之前，下面列出 C++ 程序中可用的存储类（从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用）</p><ul><li>auto(C++17删除)：根据初始化表达式自动推断被声明的变量的类型，用于两种情况，声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符；</li><li>register：用于定义存储在寄存器中而不是 RAM 中的局部变量，这意味着变量的最大尺寸等于寄存器的大小，且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）；</li><li>static：</li><li>extern：</li><li>mutable：</li><li>thread_local (C++11)：</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h1 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h1><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-基本概念&quot;&gt;&lt;a href=&quot;#C-基本概念&quot; class=&quot;headerlink&quot; title=&quot;C++基本概念&quot;&gt;&lt;/a&gt;C++基本概念&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://wwy.wwywy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-基于Lua的热更新解决方案</title>
    <link href="https://wwy.wwywy.com/posts/1569.html"/>
    <id>https://wwy.wwywy.com/posts/1569.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-03-12T06:21:03.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热更新介绍"><a href="#热更新介绍" class="headerlink" title="热更新介绍"></a>热更新介绍</h1><p>1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅速修复Bug、提升玩家留存率；</p><p>2.热更新分类：以下俩种</p><ul><li>资源的热更新：Unity内置的有AssetBundle来进行资源热更；</li><li>逻辑的热更新：也就是对代码的热更新，一般使用xlua、tolua；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热更新介绍&quot;&gt;&lt;a href=&quot;#热更新介绍&quot; class=&quot;headerlink&quot; title=&quot;热更新介绍&quot;&gt;&lt;/a&gt;热更新介绍&lt;/h1&gt;&lt;p&gt;1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="热更新" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Lua" scheme="https://wwy.wwywy.com/tags/Lua/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="AssetBundle" scheme="https://wwy.wwywy.com/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件-Odin插件使用</title>
    <link href="https://wwy.wwywy.com/posts/1578.html"/>
    <id>https://wwy.wwywy.com/posts/1578.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-04-07T08:43:56.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热更新介绍"><a href="#热更新介绍" class="headerlink" title="热更新介绍"></a>热更新介绍</h1><p>1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅速修复Bug、提升玩家留存率；</p><p>2.热更新分类：以下俩种</p><ul><li>资源的热更新：Unity内置的有AssetBundle来进行资源热更；</li><li>逻辑的热更新：也就是对代码的热更新，一般使用xlua、tolua；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热更新介绍&quot;&gt;&lt;a href=&quot;#热更新介绍&quot; class=&quot;headerlink&quot; title=&quot;热更新介绍&quot;&gt;&lt;/a&gt;热更新介绍&lt;/h1&gt;&lt;p&gt;1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="插件" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Odin" scheme="https://wwy.wwywy.com/tags/Odin/"/>
    
    <category term="编辑器" scheme="https://wwy.wwywy.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
</feed>
