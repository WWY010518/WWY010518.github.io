<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雪夜の自我救赎</title>
  
  <subtitle>雪夜の博客</subtitle>
  <link href="https://wwy.wwywy.com/atom.xml" rel="self"/>
  
  <link href="https://wwy.wwywy.com/"/>
  <updated>2022-07-09T15:44:55.116Z</updated>
  <id>https://wwy.wwywy.com/</id>
  
  <author>
    <name>雪夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ILRuntiome热更新技术</title>
    <link href="https://wwy.wwywy.com/posts/1570.html"/>
    <id>https://wwy.wwywy.com/posts/1570.html</id>
    <published>2022-07-09T13:00:00.000Z</published>
    <updated>2022-07-09T15:44:55.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ILRuntime介绍"><a href="#ILRuntime介绍" class="headerlink" title="ILRuntime介绍"></a>ILRuntime介绍</h1><p>  ILRuntime项目为基于C#的平台（例如Unity）提供了一个纯C#实现，快速、方便且可靠的IL运行时，使得能够在不支持JIT的硬件环境（如iOS）能够实现代码的热更新。</p><h2 id="ILRuntime的优势"><a href="#ILRuntime的优势" class="headerlink" title="ILRuntime的优势"></a>ILRuntime的优势</h2><p>  同市面上的其他热更方案相比，ILRuntime主要有以下优点：</p><ul><li>无缝访问C#工程的现成代码，无需额外抽象脚本API</li><li>直接使用VS2015进行开发，ILRuntime的解译引擎支持.Net 4.6编译的DLL</li><li>执行效率是L#的10-20倍</li><li>选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右（从脚本调用GameObject之类的接口）</li><li>支持跨域继承</li><li>完整的泛型支持</li><li>拥有Visual Studio的调试插件，可以实现真机源码级调试。支持Visual Studio 2015 Update3 以及Visual Studio 2017和Visual Studio 2019</li><li>最新的2.0版引入的寄存器模式将数学运算性能进行了大幅优化</li></ul><h2 id="C-vs-Lua"><a href="#C-vs-Lua" class="headerlink" title="C# vs Lua"></a>C# vs Lua</h2><p>  目前市面上主流的热更方案，主要分为Lua的实现和用C#的实现，两种实现方式各有各的优缺点；</p><ul><li>Lua：Lua是一个已经非常成熟的解决方案，但是对于Unity项目而言，也有非常明显的缺点。就是如果使用Lua来进行逻辑开发，就势必要求团队当中的人员需要同时对Lua和C#都特别熟悉，或者将团队中的人员分成C#小组和Lua小组。不管哪一种方案，对于中小型团队都是非常痛苦的一件事情；</li><li>用C#来作为热更语言最大的优势就是项目可以用同一个语言来进行开发，对Unity项目而言，这种方式肯定是开发效率最高的，最新2.0版本的ILRuntime，加入了<a href="https://ourpalm.github.io/ILRuntime/public/v1/guide/register-vm.html">寄存器模式</a>，在10多项测试用例当中的性能，均已超过lua53版xlua；</li></ul><h2 id="性能对比注意事项"><a href="#性能对比注意事项" class="headerlink" title="性能对比注意事项"></a>性能对比注意事项</h2><p>  如果需要测试ILRuntime对比Lua的性能Benchmark，需要确认以下几点，ILRuntime设计上为了在开发时提供更多的调试支持。在Unity Editor中运行会有很多额外的性能开销，因此在Unity Editor中直接测试并不能代表ILRuntime的实际运行性能。</p><ul><li>ILRuntime加载的dll文件是<code>Release</code>模式编译的</li><li>dll中对外部API的调用都进行了<code>CLR绑定</code></li><li>确保<code>没有勾选Development Build</code>的情况下发布成正式真机运行包，而<code>不是在Editor中直接运行</code></li><li>可以直接使用Demo工程中提供的性能测试进行对比</li></ul><h2 id="调试插件"><a href="#调试插件" class="headerlink" title="调试插件"></a>调试插件</h2><p>  ILRuntime提供了一个支持Visual Studio 2015、Visual Studio 2017和Visual Studio 2019的调试插件，用来源码级调试你的热更脚本，你可以在<a href="https://github.com/Ourpalm/ILRuntime/releases">这里</a>下载到最新的Visual Studio调试插件。</p><p><strong>使用方法如下：</strong></p><ul><li>安装ILRuntime调试插件，并重新启动VS2015或VS2017、VS2019</li><li>确保dll和pdb都加载完毕。</li><li>运行Unity工程，并保证执行过appdomain.DebugService.StartDebugService（56000）;来启动调试服务器</li><li>用VisualStudio打开热更DLL项目</li><li>点击菜单中的Debug-&gt;Attach to ILRuntime按钮。注意，不是“附加Unity调试程序”</li><li>在弹出来的窗口中填入被调试的主机的IP地址以及调试服务器的端口</li><li>点击Attach按钮后，即可像UnityVS一样下断点调试</li></ul><h1 id="ILRuntime环境搭建"><a href="#ILRuntime环境搭建" class="headerlink" title="ILRuntime环境搭建"></a>ILRuntime环境搭建</h1><h2 id="导入ILRuntime"><a href="#导入ILRuntime" class="headerlink" title="导入ILRuntime"></a>导入ILRuntime</h2><p>  ILRuntime1.6版新增了Package Manager发布，使用Unity2018以上版本可以直接通过Package Manager安装，如果你使用的是Unity，或者无法在PackageManager中找到ILRuntime，则需要按照以下步骤设置项目；</p><ul><li>首先需要在项目的Packages/manifest.json中，添加ILRuntime的源信息，在这个文件的dependencies节点前增加以下代码<pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">"scopedRegistries": [  {    "name": "ILRuntime",    "url": "https://registry.npmjs.org",    "scopes": [      "com.ourpalm"    ]  }],<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li> 然后通过Unity的菜单，打开Package Manager，将上部标签页选项选择为All Packages，Advanced里勾上Show Preview Packages，等待Unity加载完包信息，应该就能在左侧列表中找到ILRuntime，点击安装即可Window-&gt;Package Manager；</li><li> 部分Unity版本可以无法直接在列表中刷出ILRuntime，如果左边列表找不着，那就在项目的manifest.json中的dependencies段的开头，增加如下代码手动将ILRuntime添加进项目；<pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">"com.ourpalm.ilruntime": "1.6.0",<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>示例导入工程后有可能因为没开启unsafe导致编译报错，可以在PlayerSettings中勾选Allow unsafe code解决编译问题；</li></ul><h2 id="创建HotFix项目"><a href="#创建HotFix项目" class="headerlink" title="创建HotFix项目"></a>创建HotFix项目</h2><ul><li><p>首先创建一个C#类库工程，接下来，我们将开始配置这个热更工程，以便我们在里面可以编写业务代码；</p></li><li><p>在Unity项目创建一个DLL文件夹，将UnityEngine和UnityEngine.CoreModule放进去，使用文本编辑器打开HotFix.csproj这个文件，配置如下内容，注意路径可能本人不一致，或者你也可以直接在VS中添加依赖项；</p></li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">&lt;ItemGroup&gt;  &lt;Reference Include="Assembly-CSharp"&gt; //Unity项目编译后的程序集，路径如下    &lt;HintPath&gt;..\..\..\..\Library\ScriptAssemblies\Assembly-CSharp.dll&lt;/HintPath&gt;    &lt;Private&gt;false&lt;/Private&gt;  &lt;/Reference&gt;  &lt;Reference Include="UnityEngine"&gt;    &lt;HintPath&gt;..\..\..\..\DLL\UnityEngine.dll&lt;/HintPath&gt;    &lt;Private&gt;false&lt;/Private&gt;  &lt;/Reference&gt;  &lt;Reference Include="UnityEngine.CoreModule"&gt;    &lt;HintPath&gt;..\..\..\..\DLL\UnityEngine.CoreModule.dll&lt;/HintPath&gt;    &lt;Private&gt;false&lt;/Private&gt;  &lt;/Reference&gt;&lt;/ItemGroup&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接下来我们就可以在热更工程编写代码了，我们在HotFix工程中新增一个c#文件，名字叫AppMain.cs 如图所示，解释一下，就是把路径Assets\GAssets\CSProject~\HotFix\bin\Debug\netstandard2.1\下生成的HotFix.dll和HotFix.pdb拷贝到Assets\StreamingAssets\路径下，并且给文件加上.txt后缀名 ；</li></ul><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using UnityEngine;namespace HotFix{    public class AppMain    {        public static void Start()        {            Debug.Log("AppMain::Start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>接下来我们要配置一下这个热更工程的dll输入路径，右键项目属性，在生成事件后填入如下内容；</li></ul><pre class="line-numbers language-Bat" data-language="Bat"><code class="language-Bat">Copy "$(TargetDir)HotFix.dll" "$(TargetDir)..\..\..\..\..\..\StreamingAssets\HotFix.dll.txt"Copy "$(TargetDir)HotFix.pdb" "$(TargetDir)..\..\..\..\..\..\StreamingAssets\HotFix.pdb.txt"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Unity中调用"><a href="#Unity中调用" class="headerlink" title="Unity中调用"></a>Unity中调用</h2><p>热更部分已经配置好了，接下来，我们要在主工程启动ILRuntime的运行时环境，并且加载热更代码，运行起来，具体步骤如下，新建一个c#文件Startup.cs 里面的内容如下，然后运行即可，就可以看到控制台输出了AppMain::Start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System.Collections;using System.Collections.Generic;using System.IO;using UnityEngine;using UnityEngine.Networking;public class Startup : MonoBehaviour{    private ILRuntime.Runtime.Enviorment.AppDomain appdomain;    void Start()    {        StartCoroutine(LoadILRuntime());    }    IEnumerator LoadILRuntime()    {        appdomain = new ILRuntime.Runtime.Enviorment.AppDomain();        UnityWebRequest webRequest = UnityWebRequest.Get(StreamingAssetsPath("HotFix.dll.txt"));        yield return webRequest.SendWebRequest();        if (webRequest.result != UnityWebRequest.Result.Success)        {            yield break;        }        byte[] dll = webRequest.downloadHandler.data;        webRequest.Dispose();        webRequest = UnityWebRequest.Get(StreamingAssetsPath("HotFix.pdb.txt"));        yield return webRequest.SendWebRequest();        if (webRequest.result != UnityWebRequest.Result.Success)        {            yield break;        }        byte[] pdb = webRequest.downloadHandler.data;        webRequest.Dispose();        appdomain.LoadAssembly(new MemoryStream(dll), new MemoryStream(pdb), new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider());        OnILRuntimeInitialized();    }    void OnILRuntimeInitialized()    {        appdomain.Invoke("HotFix.AppMain", "Start", null, null);    }    public string StreamingAssetsPath(string fileName)    {        string path = Application.streamingAssetsPath + "/" + fileName;        return path;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="热更代码中编写Mono脚本"><a href="#热更代码中编写Mono脚本" class="headerlink" title="热更代码中编写Mono脚本"></a>热更代码中编写Mono脚本</h1><p>  我们在常规的unity代码编写流程，是实现一个monobehaviour脚本，挂载在一个GameObject对象上，通过实现Awake，Start，Update，OnDestroy 这样一些函数驱动游戏逻辑的执行，在ILRuntime中，我们在热更工程中编写的代码本质上是脚本，也就是文本字符串，在Unity主工程看来，并没有什么monobehaviour脚本被创建出来，但我们依然希望在热更工程中像常规的Unity项目一样，使用monobehaviour脚本的模式编写代码，那怎么实现呢？</p><p>实现方法步骤：</p><ul><li><p>在主工程中，实现一个真正的monobehaviour脚本命名为MonoProxy，作为代理，以后无论热更工程的任何GameObject想要挂载脚本，都挂载这个固定的MonoProxy类；</p></li><li><p>热更工程将一个自定义的热更脚本和这个MonoProxy类绑定，这样Unity在运行时通过驱动MonoProxy类，然后这个MonoProxy类将驱动行为转移到这个热更脚本上，从而驱动这个热更脚本的运行；</p></li><li><p>为了规范热更热更脚本的编写严谨性，在热更工程中，定义一个热更脚本的基类MonoBase，所有需要挂载在GameObject上的热更脚本(当然这个并不是真正的挂载，真正挂载的是代理类MonoProxy)都必须继承这个MonoBase类；</p></li><li><p>具体代码如下</p><p>在主工程中实现的MonoProxy代理类</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using ILRuntime.CLR.TypeSystem;using System.Collections;using System.Collections.Generic;using System.Reflection;using UnityEngine;/// &lt;summary&gt;/// 在GameObject上挂载的真正的脚本对象MonoProxy/// 运行时，会把逻辑执行转交给绑定的对应热更脚本对象ScriptObject/// &lt;/summary&gt;public class MonoProxy : MonoBehaviour{    /// &lt;summary&gt;    /// 当前这个MonoProxy对象映射的热更脚本的类型字符串    /// &lt;/summary&gt;    public string ScriptName;    /// &lt;summary&gt;    /// 映射的热更脚本的类型的对象    /// &lt;/summary&gt;    public object ScriptObject;    /// &lt;summary&gt;    /// 将本MonoProxy对象和一个热更脚本绑定在一起    /// &lt;/summary&gt;    /// &lt;param name="scriptName"&gt;&lt;/param&gt;    public void Bind(string scriptName)    {        ScriptName = "HotFix." + scriptName;        ScriptObject = Startup.appdomain.Instantiate(ScriptName);        IType scriptIType = Startup.appdomain.LoadedTypes[ScriptName];        FieldInfo goField = scriptIType.ReflectionType.GetField("gameObject");        goField.SetValue(ScriptObject, gameObject);//为什么不实现Awke函数，而在这里申明，因为该函数是在AddComponent后就立马调用的，Mono脚本可能在HotFix中添加，而这时参数并未传递进来，会出问题        Startup.appdomain.Invoke(ScriptName, "Awake", ScriptObject, null);    }        void Start()    {        Startup.appdomain.Invoke(ScriptName, "Start", ScriptObject, null);    }    void Update()    {        Startup.appdomain.Invoke(ScriptName, "Update", ScriptObject, null);    }    private void OnDestroy()    {        Startup.appdomain.Invoke(ScriptName, "OnDestroy", ScriptObject, null);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>  热更工程中的MonoBase类（即所有需要挂载的热更脚本的基类）</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using System.Collections.Generic;using System.Text;using UnityEngine;namespace HotFix{    public class MonoBase    {        public GameObject gameObject;        public virtual void Awake() { }        public virtual void Start() { }        public virtual void Update() { }        public virtual void OnDestroy() { }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  创建一个HelloComponent脚本集成自MonoBase进行实验：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using System.Collections.Generic;using System.Text;using UnityEngine;namespace HotFix{    public class HelloComponent : MonoBase    {        public override void Awake()        {            Debug.Log(gameObject.name + " HelloComponent::Awake");                  }        public override void Start()        {            Debug.Log(gameObject.name + " HelloComponent::Start");        }        public override void Update()        {            Debug.Log(gameObject.name + " HelloComponent::Update " + Time.deltaTime);        }        public override void OnDestroy()        {            Debug.Log(gameObject.name + " HelloComponent::OnDestroy ");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  演示下使用，在热更工程中创建一个GameObject，命名为Hello，并且挂载一个脚本HelloComponent，编译运行后就能看到效果了：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using System;using UnityEngine;namespace HotFix{    public class AppMain    {        public static void Start()        {            GameObject go = new GameObject("HelloGo");            MonoProxy monoProxy = go.AddComponent&lt;MonoProxy&gt;();            monoProxy.Bind("HelloComponent");        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ILRuntime（适配器）"><a href="#ILRuntime（适配器）" class="headerlink" title="ILRuntime（适配器）"></a>ILRuntime（适配器）</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">//调用协程来举例子gameObject.GetComponent&lt;MonoProxy&gt;().StartCoroutine(Coroutine());//定义的协程函数public System.Collections.IEnumerator Coroutine(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  对于这行代码，StartCoroutine确实需要一个真正的协程对象，而这里Coroutine()返回的却是一个ILTypeInstance对象，因为在热更代码中，我们这些创建的类型对象大多数在Unity主工程看来都是ILTypeInstance对象，并没有什么真正意义的协程对象被创建出来！！</p><p>  所以ILRuntime运行到这行代码时，发现需要的类型（协程对象）和传入的实际类型（ILTypeInstance对象）不一致时，ILRuntime运行时会试图查找是否有相应的CrossBindingAdaptor类型可以把传入的当前类型对象转换成需要的类型对象，如果有，就用当前类型对象作为输入创建一个需要的类型对象，并且调用这个新的类新对象！！</p><p>  以上就是ILRuntime所谓的跨域继承，其实并没有什么继承，本来就是两个类型，用户需要自己实现这个转换过程，实现方法就是自定义一个CrossBindingAdaptor的派生类，并且注册到ILRuntime运行时中去，以下是适配器的基本写法；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">using ILRuntime.CLR.Method;using ILRuntime.Runtime.Enviorment;using ILRuntime.Runtime.Intepreter;using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class CoroutineAdapter : CrossBindingAdaptor{    public override Type BaseCLRType    {        get        {            return null;        }    }    public override Type[] BaseCLRTypes    {        get        {            //跨域继承只能有1个Adapter，因此应该尽量避免一个类同时实现多个外部接口，对于coroutine来说是IEnumerator&lt;object&gt;,IEnumerator和IDisposable，            //ILRuntime虽然支持，但是一定要小心这种用法，使用不当很容易造成不可预期的问题            //日常开发如果需要实现多个DLL外部接口，请在Unity这边先做一个基类实现那些个接口，然后继承那个基类            return new Type[] { typeof(IEnumerator&lt;object&gt;), typeof(IEnumerator), typeof(IDisposable) };        }    }    public override Type AdaptorType    {        get        {            return typeof(Adaptor);        }    }    public override object CreateCLRInstance(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance)    {        return new Adaptor(appdomain, instance);    }    /// &lt;summary&gt;    /// Coroutine生成的类实现了IEnumerator&lt;System.Object&gt;, IEnumerator, IDisposable 所以都要实现    /// 这个可以通过reflector之类的IL反编译软件得知    /// &lt;/summary&gt;    internal class Adaptor : IEnumerator&lt;System.Object&gt;, IEnumerator, IDisposable, CrossBindingAdaptorType    {        ILTypeInstance instance;        ILRuntime.Runtime.Enviorment.AppDomain appdomain;        public Adaptor()        {        }        public Adaptor(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance)        {            this.appdomain = appdomain;            this.instance = instance;        }        public ILTypeInstance ILInstance { get { return instance; } }        IMethod mCurrentMethod;        bool mCurrentMethodGot;        public object Current        {            get            {                if (!mCurrentMethodGot)                {                    mCurrentMethod = instance.Type.GetMethod("get_Current", 0);                    if (mCurrentMethod == null)                    {                        //这里写System.Collections.IEnumerator.get_Current而不是直接get_Current是因为coroutine生成的类是显式实现这个接口的，通过Reflector等反编译软件可得知                        //为了兼容其他只实现了单一Current属性的，所以上面先直接取了get_Current                        mCurrentMethod = instance.Type.GetMethod("System.Collections.IEnumerator.get_Current", 0);                    }                    mCurrentMethodGot = true;                }                if (mCurrentMethod != null)                {                    object res = appdomain.Invoke(mCurrentMethod, instance, null);                    return res;                }                else                {                    return null;                }            }        }        IMethod mDisposeMethod;        bool mDisposeMethodGot;        public void Dispose()        {            if (!mDisposeMethodGot)            {                mDisposeMethod = instance.Type.GetMethod("Dispose", 0);                if (mDisposeMethod == null)                {                    mDisposeMethod = instance.Type.GetMethod("System.IDisposable.Dispose", 0);                }                mDisposeMethodGot = true;            }            if (mDisposeMethod != null)            {                appdomain.Invoke(mDisposeMethod, instance, null);            }        }        IMethod mMoveNextMethod;        bool mMoveNextMethodGot;        public bool MoveNext()        {            if (!mMoveNextMethodGot)            {                mMoveNextMethod = instance.Type.GetMethod("MoveNext", 0);                mMoveNextMethodGot = true;            }            if (mMoveNextMethod != null)            {                return (bool)appdomain.Invoke(mMoveNextMethod, instance, null);            }            else            {                return false;            }        }        IMethod mResetMethod;        bool mResetMethodGot;        public void Reset()        {            if (!mResetMethodGot)            {                mResetMethod = instance.Type.GetMethod("Reset", 0);                mResetMethodGot = true;            }            if (mResetMethod != null)            {                appdomain.Invoke(mResetMethod, instance, null);            }        }        public override string ToString()        {            IMethod m = appdomain.ObjectType.GetMethod("ToString", 0);            m = instance.Type.GetVirtualMethod(m);            if (m == null || m is ILMethod)            {                return instance.ToString();            }            else                return instance.Type.FullName;        }    }}//同时需要注册适配器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ILRuntime介绍&quot;&gt;&lt;a href=&quot;#ILRuntime介绍&quot; class=&quot;headerlink&quot; title=&quot;ILRuntime介绍&quot;&gt;&lt;/a&gt;ILRuntime介绍&lt;/h1&gt;&lt;p&gt;  ILRuntime项目为基于C#的平台（例如Unity）提供了一</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="热更新" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="AssetBundle" scheme="https://wwy.wwywy.com/tags/AssetBundle/"/>
    
    <category term="ILRuntimes" scheme="https://wwy.wwywy.com/tags/ILRuntimes/"/>
    
  </entry>
  
  <entry>
    <title>情商的修炼之道</title>
    <link href="https://wwy.wwywy.com/posts/321.html"/>
    <id>https://wwy.wwywy.com/posts/321.html</id>
    <published>2022-05-22T13:00:00.000Z</published>
    <updated>2022-05-27T08:51:20.204Z</updated>
    
    <content type="html"><![CDATA[<p>（这是我博客中最珍贵最重要的心得，人生往往是经历无数后悔才能实现的自我救赎，而高情商可以让你少走很多弯路）</p><h1 id="何为情商"><a href="#何为情商" class="headerlink" title="何为情商"></a>何为情商</h1><h2 id="情商的本质"><a href="#情商的本质" class="headerlink" title="情商的本质"></a>情商的本质</h2><p>  情商的本质就是情绪，体现在以下几点；</p><ul><li>论点一：情商高的表现之一就是让别人开心，跟你在一起很舒适，有情感上的共鸣；</li><li>论点二：同时，高情商在让别人开心的同时，也让自己开心，而那种靠牺牲自己，为难自己去让去别人感到舒适的，这并不是高情商；</li><li>结论：总之，真正的高情商是在自己和别人的情绪之间找到一个和谐点，彼此都特别愉快的实现共赢；</li></ul><h2 id="情商的层级"><a href="#情商的层级" class="headerlink" title="情商的层级"></a>情商的层级</h2><p>  情商也是有层次的，请慢慢尝试从这几步去提升自己的情商</p><ul><li>认识自己的情绪；</li><li>管理自己的情绪；</li><li>认知他人的情绪；</li><li>影响他人的情绪；</li></ul><h1 id="认识自己的情绪"><a href="#认识自己的情绪" class="headerlink" title="认识自己的情绪"></a>认识自己的情绪</h1><h2 id="接受自己的情绪："><a href="#接受自己的情绪：" class="headerlink" title="接受自己的情绪："></a>接受自己的情绪：</h2><ul><li>原因：一味的压抑自己的情绪并不是高情商的表现，当你被别人骂了，自己不开心时，却总安慰自己说没事，去学习、工作的时候就是很开心，隐藏自己的笑容却内心苦苦的，那只是憋屈和强忍；</li><li>结论：所以，我们得先学会人有这种情绪，才是解决这个情绪的开始，而接受、了解自己的情绪的情绪就得先从下面三点入手；</li></ul><h2 id="给情绪上标签"><a href="#给情绪上标签" class="headerlink" title="给情绪上标签"></a>给情绪上标签</h2><ul><li><p>原因：情绪并没有我们眼里的那么简单，也许大部分人仍然认为情绪就是喜悦、愤怒和悲伤，但是这只是表面上直观的情绪；我们实际感受到的情绪，往往是通过别人的”外在表现”或者自己想要表达的”感受”而体现出的情绪，这些情绪其实是有着很明显的特征的，是有标签的；</p></li><li><p>例如：生活中就有一些这样的情绪在悄无声息的影响着我们的行为和判断力，你肯定遇到过这样的场景，”啊！！！我不明白我为什么当时会那样子，我好后悔，我明明不是这样想的，但我却说出那样的话”，这种情况就是你不理解的情绪悄无声息的影响了你的判断能力，让你的大脑过热；</p></li><li><p>结论：所以，认识自己情绪的第一步，就是给情绪贴上标签，要明确情绪之间的界限感，对情绪进行区分，而不是永远都只是感觉很糟糕，我们要能感知更多的情绪；</p></li></ul><p><img src="https://s1.ax1x.com/2022/05/22/OzOs9s.png" alt="情绪的分类"><br><a href="https://imgtu.com/i/OzOs9s"><img src="https://s1.ax1x.com/2022/05/22/OzOs9s.png" alt="OzOs9s.png"></a></p><h2 id="情绪分级"><a href="#情绪分级" class="headerlink" title="情绪分级"></a>情绪分级</h2><ul><li>结论：除了要对情绪进行分类，了解自己处于哪一种情绪外，还要对情绪进行分级；</li><li>例如：比如把愤怒分为1~5级，明白自己当前情绪是哪一种程度级别；</li></ul><h2 id="自我反省"><a href="#自我反省" class="headerlink" title="自我反省"></a>自我反省</h2><ul><li>例如：每天晚上躺在床上反思自己的所作所为，为什么要那样做，是因为生气了吗，没有生气那么为什么要这么做，生气了那么生气程度是否太过火了，</li><li>结论：不断的反思自己，这样才会更加”熟悉”自己的情绪，特别注意的是，这是一个长远的、需要坚持的过程；</li></ul><h1 id="管理自己的情绪"><a href="#管理自己的情绪" class="headerlink" title="管理自己的情绪"></a>管理自己的情绪</h1><h2 id="慢-静下来"><a href="#慢-静下来" class="headerlink" title="慢/静下来"></a>慢/静下来</h2><ul><li>原因：人本来就是动物，天生的生理习惯就是有情绪就立刻表达出来，但是这种表达方式往往都是野蛮和不理智的，遇到不如意的事情就会动手打人、辱骂，这些都是马上表达的结果；</li><li>结论：有激烈情绪时，慢下来或者干脆什么都不做，给大脑一个处理时间；</li></ul><h2 id="与自己对话"><a href="#与自己对话" class="headerlink" title="与自己对话"></a>与自己对话</h2><ul><li>结论：情绪激烈时注意提醒自己，我现在的情绪如何，我正在做什么，我现在的情绪如何，养成习惯，你就会慢慢的越来越理智；</li></ul><h2 id="学习更好的情绪"><a href="#学习更好的情绪" class="headerlink" title="学习更好的情绪"></a>学习更好的情绪</h2><ul><li>例如：看书、刷剧、与人交流；</li><li>结论：学习更好的情绪表达方式，做生活的观察者、学习者；</li></ul><h1 id="认知他人的情绪"><a href="#认知他人的情绪" class="headerlink" title="认知他人的情绪"></a>认知他人的情绪</h1><h2 id="理解对方的表达"><a href="#理解对方的表达" class="headerlink" title="理解对方的表达"></a>理解对方的表达</h2><ul><li>前提：能听得懂别人说的什么话、表达的什么意思，对语文水平还是有一定要求的；</li><li>例如：你去邀约别人，而别人说我比较忙，过几天去，但是你过了几天竟然还去邀约别人，其实这只是一种委婉的拒绝方式；</li><li>结论：能了解别人表达的情绪；</li></ul><h2 id="提升共情能力"><a href="#提升共情能力" class="headerlink" title="提升共情能力"></a>提升共情能力</h2><ul><li>反例：你的朋友考试得了大鸭蛋，他难受极了，找你来倾诉，但是你却哈哈哈乐了；</li><li>正例：多去和亲近的人分享自己的生活和感受，慢慢的就在数据交换之中逐渐熟悉非我的思维模式，也就是说多去了解别人是咋想的，多进行换位思考，慢慢的就会让别人喜欢上你；</li><li>结论：核心是换位思考，能体会到别人的感受，有情感上的共鸣；</li></ul><h2 id="学会观察语言外的语言"><a href="#学会观察语言外的语言" class="headerlink" title="学会观察语言外的语言"></a>学会观察语言外的语言</h2><ul><li>结论：刻意或者不经意表露出来的行为或动作，比如身体语言；</li><li>例如：<ul><li>俩手交叉：他可能对这事情并不是很关心；</li><li>眼神飘忽不定不集中：可能心里装着别的事情；</li><li>交谈后匆匆离开：说明这次交流对他并不是很重要；</li><li>下意识撅嘴：表示对你所说并不满意；</li></ul></li></ul><h1 id="影响别人的情绪"><a href="#影响别人的情绪" class="headerlink" title="影响别人的情绪"></a>影响别人的情绪</h1><p>（不要做一些伤天害理的事情^_^）</p><h2 id="让自己能接近别人"><a href="#让自己能接近别人" class="headerlink" title="让自己能接近别人"></a>让自己能接近别人</h2><ul><li>例如：你身边那些人缘好活跃的人，往往之后会给你深刻的印象，它们就会影响到你的情绪，可能很多话你现在还历历在目，而内心封闭的人往往不能影响别人的情绪，他们很大的原因就是缺乏鼓励，缺乏正反馈，时间长了就不敢主动和陌生人对话，所以要做一个擅长社交的人，容易被别人接纳的人；</li><li>结论：接近别人，做个积极交际的人，不要自我封闭；</li></ul><h2 id="更加完美的表达自己的想法"><a href="#更加完美的表达自己的想法" class="headerlink" title="更加完美的表达自己的想法"></a>更加完美的表达自己的想法</h2><ul><li>例如：内容复杂时先说结论、在一个观点后分条理陈列理由、把最重要的情况说在前面、描述抽象事物时恰当的运用比喻；</li><li>方法：经常写作，记录想法，不断完善、修改；</li><li>结论：把自己的想法完美的表达出来；</li></ul><h2 id="操控别人情绪（请用于正道）"><a href="#操控别人情绪（请用于正道）" class="headerlink" title="操控别人情绪（请用于正道）"></a>操控别人情绪（请用于正道）</h2><ul><li>前提：做到前面内容，并熟练运用；</li><li>结论：抓住别人的心理诉求，然后……；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;（这是我博客中最珍贵最重要的心得，人生往往是经历无数后悔才能实现的自我救赎，而高情商可以让你少走很多弯路）&lt;/p&gt;
&lt;h1 id=&quot;何为情商&quot;&gt;&lt;a href=&quot;#何为情商&quot; class=&quot;headerlink&quot; title=&quot;何为情商&quot;&gt;&lt;/a&gt;何为情商&lt;/h1&gt;&lt;h2 </summary>
      
    
    
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="为人处世" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/%E4%B8%BA%E4%BA%BA%E5%A4%84%E4%B8%96/"/>
    
    
    <category term="情商" scheme="https://wwy.wwywy.com/tags/%E6%83%85%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="https://wwy.wwywy.com/posts/520.html"/>
    <id>https://wwy.wwywy.com/posts/520.html</id>
    <published>2022-03-03T13:00:00.000Z</published>
    <updated>2022-06-25T23:32:06.704Z</updated>
    
    <content type="html"><![CDATA[<p>重要信息：老师电话13574404624</p><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><h2 id="什么是编译原理"><a href="#什么是编译原理" class="headerlink" title="什么是编译原理"></a>什么是编译原理</h2><p>1.计算机编译语言的层次：</p><ul><li>机器语言：可以直接被计算机直接理解；</li><li>汇编语言：引入助记符，但是还是难以被直接理解，由汇编语言到机器语言是通过汇编的形式；</li><li>高级语言：能直接理解的，由高级语言到汇编语言或者机器语言是通过编译的形式；</li></ul><h2 id="编译程序补充说明"><a href="#编译程序补充说明" class="headerlink" title="编译程序补充说明"></a>编译程序补充说明</h2><p>1.编译程序的功能：是把高级语言翻译成等价的目标程序，编译程序把”源语言”翻译成二进制文件的”目标语言”的过程，目标程序可以独立源程序运行（注意编译和运行是分俩个阶段的）；</p><p>2.编译器的系统位置以及语言处理流程：源程序=&gt;经过预处理源程序=&gt;汇编语言程序=&gt;可重定位机器码=&gt;目标机器代码；</p><ul><li>预处理器：把存储在不同文件中的源程序聚合在一起，把被成为宏的缩写语句转换为原始语句；</li><li>编译器：如上；</li><li>汇编器：进行可重定位，可重定位指的是在内存中存放的起始位置L不是固定的，而起始位置+相对地址=绝对地址；</li><li>链接器/加载器：其中加载器修改可重定位地址，将修改后的指令和数据放到内存中适当位置，而链接器将多个可重定位的机器代码文件连接到一起以及解决外部内存地址问题；</li></ul><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><p>1.编译过程的划分：分俩批次</p><ul><li>第一批次：分析/前端部分，与源语言相关；<ul><li>词法分析：分析各个短语的词性；</li><li>语法分析：划分句子，也就是句子的中的短语；</li><li>语义分析：就是分析源语言的语义，分析各个短语在句子中占什么成分，语义分析的结果一般直接用中间代码表示，所以这俩个可以一起实现，同时语法分析时分许句子时同时结合语义分析，所以该三个阶段可以一起实现，这个技术被称为语法制导翻译；</li><li>第二批次：综合/后端部分，与目标语言相关，中间代码生成其实也属于前端部分；</li></ul></li></ul><ul><li>中间代码生成；</li><li>代码优化：代码优化一般中间代码和目标机器代码都需要优化；</li><li>目标代码生成；</li></ul><h2 id="解释程序"><a href="#解释程序" class="headerlink" title="解释程序"></a>解释程序</h2><p>1.解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析上基本同编译过程一致，但是运行用户程序时，它是直接执行源程序或者说源程序的内部形式（中间代码），解释程序不会生成目标代码；</p><h2 id="编译程序和解释程序的区别"><a href="#编译程序和解释程序的区别" class="headerlink" title="编译程序和解释程序的区别"></a>编译程序和解释程序的区别</h2><p>1.区别：</p><ul><li><p>相同点：</p><ul><li>都有相同的词法、语法、语义分析过程；</li></ul></li><li><p>不同点：</p><ul><li>编译程序运行速度会更快，编译程序是生成目标代码后再运行的，而解释程序是一边翻译一边执行；</li><li>编译程序安全性更高，因为编译程序生成的目标代码是二进制形式的；</li><li>编译程序不参与用户程序运行控制，而解释程序参与；</li><li>解释程序不需要同机器码打交道，实现起来比较简单，且便于在不同平台上移植；</li></ul></li></ul><h2 id="前端部分简单介绍"><a href="#前端部分简单介绍" class="headerlink" title="前端部分简单介绍"></a>前端部分简单介绍</h2><p>1.词法分析主要任务：从左到由逐行扫描程序的字符，识别出各个单词，确定单词的类型，将识别出的单词转换成统一的机内表示——语法单元(token)形式，token&lt;种别码，属性值&gt;，第一分量表示种别码，第二个表示值；</p><table><thead><tr><th>单词类型</th><th>种别</th><th>种别码</th></tr></thead><tbody><tr><td>关键字/保留字</td><td>if,else,then</td><td>一词一码</td></tr><tr><td>标识符</td><td>变量名、数组名、记录名</td><td>多词一码</td></tr><tr><td>常量</td><td>整形、浮点型、字符型、布尔型</td><td>一型一码</td></tr><tr><td>运算符</td><td>算数、关系、逻辑·</td><td>一词移码或者一型一码</td></tr><tr><td>界限符</td><td>; () = {} …</td><td>一词一码</td></tr></tbody></table><p>2.语法分析简单介绍：语法分析器从词法分析器输出的token序列种识别出各类短语，并构造语法分析树；</p><p>3.语义分析的主要任务：</p><ul><li>第一个任务：收集标识符的如下主要属性信息，存储在符号表中：<ul><li>种属（Kind）</li><li>类型（Type）</li><li>存储位置和长度</li><li>值和作用域</li><li>参数和返回值信息</li></ul></li><li>第二个任务：语义检查；<ul><li>变量或者过程未经申明就使用；</li><li>变量或者过程名重复声明；</li><li>运算分量类型不匹配； </li><li>操作符和操作数之间的类型不匹配； </li></ul></li></ul><h2 id="中间代码生成及编译器后端"><a href="#中间代码生成及编译器后端" class="headerlink" title="中间代码生成及编译器后端"></a>中间代码生成及编译器后端</h2><h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><h2 id="文法的概述"><a href="#文法的概述" class="headerlink" title="文法的概述"></a>文法的概述</h2><p>1.文法的定义：文法是语言的抽象规则（例如我们的语言都是遵守主谓宾这个文法）；</p><p>2.文法的描述：</p><ul><li>语法规则构成说明：通过建立一组规则，来描述句子的语法结构，例如：<ul><li>&lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt;</li><li>&lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt;</li><li>&lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt;……..</li></ul></li><li>规则推导：有了一组规则，可以按照一定的方式来推导产生句子（方法从一个要识别的符号开始推导，即用相应规则的右部去替代规则的左部）<ul><li>&lt;句子&gt; =&gt; &lt;主语&gt;&lt;谓语&gt;</li><li>&lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt;</li></ul></li></ul><h2 id="符号和符号串"><a href="#符号和符号串" class="headerlink" title="符号和符号串"></a>符号和符号串</h2><p>1.字母表：字母表是元素的非空有穷集合，字母表中的元素被称为符号，字母表的运算有乘积、n次幂、正闭包、克林闭包；</p><p>2.符号串：由字母表中符号组成的任意又穷序列称为符号串（例如011101是字母表{0,1}上的字符串）；</p><ul><li>空串：是长度为0的串，用ε表示；</li><li>连接运算：将俩个串进行相连；</li><li>幂运算：串的0次幂等于ε，否则S^n = S^n-1*S；</li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>1.文法G=（Vn,Vt,P,Z）</p><ul><li>Vn：非终结符，是用来表示句子成分的符号，有时也称为“语法变量”；</li><li>Vt：终结符，是文法所定义的语言的基本符号，有时也称为token；</li><li>P：产生式或规则的集合，描述了将终结符和非终结符组成串的方法，产生式的一般形式：α→β，α称为产生出式的头或者左部，β称为产生式的体或者右部；</li><li>Z：开始符合 （Z∈Vn），表示文法中的最大语法成分；</li></ul><p>例如：文法G=（Vn,Vt,P,S）,Vn={S}，Vt={0,1}，P={S=&gt;0S1,S=&gt;01}，S为开始符号；</p><p>2.符号约定：</p><ul><li>终结符：a、b、c；</li><li>非终结符：A、B、C；</li><li>文法符号：X、Y、Z；</li><li>终结符号串：u、v……z；</li><li>文法符号串：α、β；</li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><p>1.推导：用产生式的右部替换产生式的左部，是一个自顶向下的过程；</p><p>2.规约：用产生式的左部替换产生式的右部，是一个自底向上的过程，规约是推导的逆过程；</p><p>3.句子和句型：句子是推导出后只包含终结符得就是句子，否则是句型；</p><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><p>1..最左推导和最右推导：没搞懂；</p><p>3.文法的等价：若L(G1)=L(G2)，则称文法G1和G2是等价的，既然说文法是等价的，所以文法可以是多重的，不同的文法实现同样的功能；</p><p>1.文法的类型：低级文法包含高级文法，高级文法一定是低级文法</p><ul><li>0型文法（短语文法）：对于产生式α→β的结构中，α至少含有一个非终结符；</li><li>1型文法（上下文有关）：对于产生式式α→β，都有|β|&gt;=|α|，仅仅S→ε除外；</li><li>2型文法（上下文无关）：对于产生式α→β，α只能是非终结符，产生式型的形式可变形为A→β；</li><li>3型文法（正规文法）：<ul><li>左线性文法：A→wβ | A→w</li><li>右线性文法： A→βw | A→w</li></ul></li></ul><h2 id="CFG的分析树"><a href="#CFG的分析树" class="headerlink" title="CFG的分析树"></a>CFG的分析树</h2><p>1.二义性文法：</p><ul><li>定义：如果一个文法可以为某个句子生成多颗分析树，则称这个文法时二义性的；</li><li>判定：大多数时候我们都希望文法不是歧义性的，可以给出一组充分条件，满足这组充分条件的文法是无二义性的；</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>1.运算类型：</p><ul><li>*：克林闭包；</li><li>连接；</li><li>|：或运算；</li></ul><h2 id="递归文法"><a href="#递归文法" class="headerlink" title="递归文法"></a>递归文法</h2><p>例如（定义变量）：变量名 x,y,z;,可以推理得：S=&gt;aAb，而A=&gt;B|BcA;</p><p>例如（加减乘除）：E=&gt;E+T|T;T=&gt;T*F|F;F=&gt;(E)|a；</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="有穷自动机的分类（FA）"><a href="#有穷自动机的分类（FA）" class="headerlink" title="有穷自动机的分类（FA）"></a>有穷自动机的分类（FA）</h2><p>1.有穷自动机（FA）：是一个五元组 M：</p><ul><li>有穷状态集；</li><li>输入字母表；</li><li>转换函数；</li><li>开始状态；</li><li>接受状态|终止状态；</li></ul><p>2.区别：不确定的有穷自动机（NFA）和确定的有穷自动机（DFA）区别在于转换函数可以有多个能到达的状态集合；</p><h2 id="从正则表达式到有穷自动机"><a href="#从正则表达式到有穷自动机" class="headerlink" title="从正则表达式到有穷自动机"></a>从正则表达式到有穷自动机</h2><p>[![正则表达式到又穷自动机]<br>(<a href="https://s1.ax1x.com/2022/06/09/XyQ3Of.md.png)]">https://s1.ax1x.com/2022/06/09/XyQ3Of.md.png)]</a><br>(<a href="https://imgtu.com/i/XyQ3Of">https://imgtu.com/i/XyQ3Of</a>)</p><h2 id="由NFA到DFA的转换"><a href="#由NFA到DFA的转换" class="headerlink" title="由NFA到DFA的转换"></a>由NFA到DFA的转换</h2><p>1.将NFA的状态组成一个新的状态，如以下r=aa*bb*cc的表示<br>[![由NFA到DFA]<br>(<a href="https://s1.ax1x.com/2022/06/09/XyQsmT.md.png)]">https://s1.ax1x.com/2022/06/09/XyQsmT.md.png)]</a><br>(<a href="https://imgtu.com/i/XyQsmT">https://imgtu.com/i/XyQsmT</a>)</p><p>2.子集构造法实例：<br>[![带有ε的NFA到DFA]<br>(<a href="https://s1.ax1x.com/2022/06/09/XyQbAe.md.png)]">https://s1.ax1x.com/2022/06/09/XyQbAe.md.png)]</a><br>(<a href="https://imgtu.com/i/XyQbAe">https://imgtu.com/i/XyQbAe</a>)</p><h1 id="自顶向下语法分析方法（重点）"><a href="#自顶向下语法分析方法（重点）" class="headerlink" title="自顶向下语法分析方法（重点）"></a>自顶向下语法分析方法（重点）</h1><h2 id="自顶向下分析概述"><a href="#自顶向下分析概述" class="headerlink" title="自顶向下分析概述"></a>自顶向下分析概述</h2><p>1.</p><h1 id="自顶向上优先分析"><a href="#自顶向上优先分析" class="headerlink" title="自顶向上优先分析"></a>自顶向上优先分析</h1><h1 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h1><h1 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h1><h1 id="静态语义分析和中间代码生成"><a href="#静态语义分析和中间代码生成" class="headerlink" title="静态语义分析和中间代码生成"></a>静态语义分析和中间代码生成</h1><h1 id="运行时存储组织"><a href="#运行时存储组织" class="headerlink" title="运行时存储组织"></a>运行时存储组织</h1><h1 id="代码优化和目标代码生成"><a href="#代码优化和目标代码生成" class="headerlink" title="代码优化和目标代码生成"></a>代码优化和目标代码生成</h1><p>1.代码优化：</p><ul><li>常数合并：编译时将常数运算进行合并；</li><li>常数传播：</li><li>代数化简：消掉没有必要的代数，例如x+0 = x；</li><li>削弱运算强度：将高复杂度度运算替换为低复杂度运算；</li></ul><h1 id="补录"><a href="#补录" class="headerlink" title="补录"></a>补录</h1><p>tracert -d 查看网络路节点</p><p>1.编译器的定义<br>2.考PL/0语言<br>3.考LL(1)<br>4.几天的课：运行时存储器组织、优化和目标代码生成，拍照的东西<br>5.上次课：抽象语法树和利波兰式<br>6.今天的课：运行时存储器组织、优化和目标代码生成，拍照的东西<br>7.分析设计题，老师最后讲</p><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><h2 id="文法和语言-1"><a href="#文法和语言-1" class="headerlink" title="文法和语言"></a>文法和语言</h2><p>1.文法：</p><ul><li>文法是语言的形式化的描述工具；</li><li>文法是一个四元组；</li><li>文法是等价的，可以进行改造，文法分类成0、1、2、3型文法；</li><li>推导完成的叫句子，中间的过程叫句型，逆推导的过程叫归约；</li><li>同一个文法在推导过程中语法树是否具有二义性，是否进行改造；</li></ul><p>2.</p><h1 id="A卷考试重点"><a href="#A卷考试重点" class="headerlink" title="A卷考试重点"></a>A卷考试重点</h1><p>  写无聊语言的杀，啥也不写的杀，下个学期的补考也杀，带*号的题目不全；</p><h2 id="选择题-（40）"><a href="#选择题-（40）" class="headerlink" title="选择题-（40）"></a>选择题-（40）</h2><p>1.期中考试题（GCC）<br>2.以及目标代码生成、代码优化</p><h2 id="解答题（30）"><a href="#解答题（30）" class="headerlink" title="解答题（30）"></a>解答题（30）</h2><p>1.何为编译器，编译器的组成部分，编译器的各组成部分作用；</p><p>a、编译器是将高级语言翻译成等价的目标语言的程序；</p><p>b、编译器由词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成组成：</p><p>c、如下：</p><ul><li>词法分析：主要将字符从左至右读入源程序，对构成源程序的字符进行扫描和分解；</li><li>语法分析：在词法分析的基础上将单词序列分解为各类语法短语，这中语法短语也称为语法单位，可表示为语法树；</li><li>语义分析：审查源程序有无语义错误，为代码生成阶段收集类型信息；</li><li>中间代码生成：在进行语法分析和语义分析后，有的编译程序变成一种内部表现形式，这种表现形似就是中间代码；</li><li>代码优化：对中间代码进行变化或者改造，目的是使生成的目标代码更高效； </li><li>目标代码生成：将中间代码变换为特定机器上的绝对指令或者重定位的指令代码或者某种汇编指令代码；</li></ul><p>2.何为PL/0语言，试用PL/0语言描述xx算法；</p><p>a、如下：</p><ul><li>PL/0语言是Pascal的一个子集；</li><li>PL/0语言编译系统由PL/0编译程序和P-code解释程序组成；</li></ul><p>3.如何判断一个文法是LL(1)的，若有文法xx，试将其改造成LL(1)文法；</p><p>a、如下：</p><ul><li>文法不含左递归；</li><li>产生式的候选首符集俩俩不相交；</li></ul><p>4.请结合C语言说明函数参数传递的方式和不同；</p><p>a、如下：</p><ul><li><p>按值传递：将实参的值拷贝给形参、有内存分配和释放、不改变外部的值；</p></li><li><p>地址传递：将形参是指针变量，指针的值拷贝形参指针的值，有内存分配和释放、改变外部值；</p></li><li><p>引用传递：形参是实参的引用，无内存分配，改变外部值；</p></li></ul><p>5.给出表达式的抽象语法树和利波兰式；</p><p>6.请简述代码生成时的指令调度；代码生成，寄存器</p><h2 id="分析设计题（30）"><a href="#分析设计题（30）" class="headerlink" title="分析设计题（30）"></a>分析设计题（30）</h2><p>给出文法：S→A，A→BA，A→c，B→aB，B→b<br>1.构造活前缀DFA<br>2.构造LR(0)分析表，Action表和Goto表；<br>3.给出输入串，写出分析过程（状态栈）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">例题：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="B卷考试重点"><a href="#B卷考试重点" class="headerlink" title="B卷考试重点"></a>B卷考试重点</h1><h2 id="解答题（70）"><a href="#解答题（70）" class="headerlink" title="解答题（70）"></a>解答题（70）</h2><p>1.何为编译器，解释编译器的组成，解释各个编译器的作用；<br>2.linux系统在C语言的编译过程；<br>3.何为FA、NFA、DFA，以及将DFA转换成DFA；<br>4.何为文法，举例说明文法的分类；<br>5.LR(0)的分析表<br>6.请把利波兰式复原成为算数表达式，并且将抽象语法树画出来；<br>7.请生成下列语句的目标代码(x=x+1)；</p><h2 id="分析设计题（30）-1"><a href="#分析设计题（30）-1" class="headerlink" title="分析设计题（30）"></a>分析设计题（30）</h2><p>1.请参考c语言的变量定义语句，根据要求写出文法<br>2.计算非终结符<br>3.根据文法写出语法分析程序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重要信息：老师电话13574404624&lt;/p&gt;
&lt;h1 id=&quot;引论&quot;&gt;&lt;a href=&quot;#引论&quot; class=&quot;headerlink&quot; title=&quot;引论&quot;&gt;&lt;/a&gt;引论&lt;/h1&gt;&lt;h2 id=&quot;什么是编译原理&quot;&gt;&lt;a href=&quot;#什么是编译原理&quot; class=&quot;he</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="编译原理" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关-.Net说明以及mono跨平台原理</title>
    <link href="https://wwy.wwywy.com/posts/1602.html"/>
    <id>https://wwy.wwywy.com/posts/1602.html</id>
    <published>2022-02-18T13:00:00.000Z</published>
    <updated>2022-03-22T02:42:48.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解-Net相关知识"><a href="#了解-Net相关知识" class="headerlink" title="了解.Net相关知识"></a>了解.Net相关知识</h1><h2 id="微软-Net概述"><a href="#微软-Net概述" class="headerlink" title="微软.Net概述"></a>微软.Net概述</h2><p>1.微软.Net说明：微软的.Net即不是编程语言也不是框架，是类似于互联网时代、次世代、21世纪的宣传口号，是一整套技术体系的统称，或者说是微软提供的技术水平的代号，本质上是微软为自己一系列取的一个代号，以下是包含内容；</p><ul><li>框架体系：.Net Framework、.Net Core、Mono等等；</li><li>开发语言：C#、VB、F#等等（C#是.Net平台主推的开发语言）；</li><li>开发工具：Visual Studio、Visual Studio Code 等等；</li></ul><p>2.微软实现.Net平台的目的：</p><ul><li>跨语言：只要是面向.NET平台的编程语言(C#、VB、C++、F#等等)，用其中一种语言编写的内容可以无缝地用在另一种语言编写的应用程序中；</li><li>跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的操作系统上，即代码不依赖于操作系统，也不依赖硬件环境；</li></ul><h2 id="Net跨语言"><a href="#Net跨语言" class="headerlink" title=".Net跨语言"></a>.Net跨语言</h2><p>1.跨语言公共语言规范：微软为了实现跨平台，制定了一些规范，只要一门语言支持这个规则，就能在.Net平台下开发应用程序，以下是规则说明；</p><ul><li>CLS（公共语言规范）：.Net专门参考每种语言找出语言间的共性，是一组语言互操作的标准规范；</li><li>CTS（公共类型系统）：当你设计面向.Net语言时需要遵守的一个体系，而刚才提到的CLS公共语言规范就是是CTS公共类型系统的子级，一个编程语言，如果它能够支持CTS，那么我们就称它为面向.NET平台的语言；</li><li>CLI（公共语言基础结构）：是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准；</li></ul><h2 id="Net虚拟机-CLR"><a href="#Net虚拟机-CLR" class="headerlink" title=".Net虚拟机(CLR)"></a>.Net虚拟机(CLR)</h2><p>1.CLR（公共语言运行时）说明：让应用程序在操作系统上运行，公共语言运行时，它是.Net Framework的基础，所有的.Net技术都是建立在此之上的，它是一个在执行时管理代码的代码，提供内存管理，线程管理等等核心服务，就好像一个小型的操作系统一样，所以形象的把它称为“.Net虚拟机”，Java的虚拟机也是类似这样的东西，如果想要应用程序在目标操作系统上能够运行，就必须依靠.Net提供的CLR环境来支持，它会把程序集中的IL（中间代码）翻译成机器码最终在操作系统上运行；</p><p>2.CLR做的事情：<br><img src="https://s1.ax1x.com/2022/03/21/qumuMq.png" alt="CLR做的事情"></p><h2 id="Net跨平台"><a href="#Net跨平台" class="headerlink" title=".Net跨平台"></a>.Net跨平台</h2><h3 id="Net-Framework"><a href="#Net-Framework" class="headerlink" title=".Net Framework"></a>.Net Framework</h3><ol><li>.Net Framework：.Net Framework 在2002年推出1.0版本，.NET Framework 是一个可以快速开发、部署网站服务及应用程序的开发框架，是 Windows 中的一个组件，部分开源，主要用于开发Windows下应用程序，包括公共语言运行时（Common Language Runtime, CLR），虚拟执行系统，.NET Framework 类库等，下面时详细说明；</li></ol><ul><li>只要支持CLS公共语言规范的语言都可以用于开发Windows下的各种应用程序和网站程序；</li><li>BCL（基础类库）和FCL（框架类库）：是这个框架体系中为我们实现好的各种API；</li><li>程序集：程序集的表现就是后缀为.dll或者.exe格式的文件，其中包含的最关键信息， PE头、CLR头（就是一些程序的格式信息，比如入口方法，版本号等等）</li><li>CIL代码（通用中间代码）：是介于源代码和机器码之间的代码之后会通过CLR产生机器码，CIL代码你可以理解为由于可能使用不同的代码进行开发，所以会将这些代码翻译为统一规范的中间代码；</li></ul><p><img src="https://s1.ax1x.com/2022/03/21/qunTHK.png" alt=".Net Framework的体系结构"></p><h3 id="Net-Core"><a href="#Net-Core" class="headerlink" title=".Net Core"></a>.Net Core</h3><ol><li>.Net Core：.Net Core 是2016年推出的.Net Framework的新一代版本，是.Net Framework的翻版实现，它是一个开源项目，它是基于.Net Framework来进行设计的主要目的就是跨平台，是.Net技术框架组成在Windows、MacOS、类Linux系统下的具体实现，它的原理就是为不同的操作系统实现对应的CLR公共语言运行时（.Net虚拟机），这样就可以在不同的平台上，将IL（中间代码）翻译成机器码最终在操作系统上运行了；</li></ol><p><img src="https://s1.ax1x.com/2022/03/21/quu5GQ.png" alt=".Net Core的体系结构"></p><h3 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h3><p>1.Mono：2004年由Xamarin公司（已被微软收购）所赞助的开源项目，它基于.Net的CLI（Common Language Infrastructure）公共语言基础结构，它相对.Net FrameWork最大的区别就是具备跨平台的能力，它不仅可以运行在Windows、MacOS、Linux等操作系统，甚至还可以运行在PS3、XBOX、Wii等主机平台上，也就是说在.Net Core出现之前，Mono是.Net平台实现跨平台的不二之选；</p><h1 id="Unity跨平台原理-Mono"><a href="#Unity跨平台原理-Mono" class="headerlink" title="Unity跨平台原理(Mono)"></a>Unity跨平台原理(Mono)</h1><p>1.Unity的组成：Unity的底层是通过C/C++来完成上层逻辑的，Unity主要包括两个部分：</p><ul><li>Unity Engine（引擎）：提供UnityEngine.dll动态库，各平台不同，C/C++编写，包含平台相关代码、图形API、物理引擎、灯光等等所有游戏引擎底层内容；</li><li>Unity Editor（编辑器）：提供UnityEditor.dll动态库，大部分由C#编写，用户脚本最初可以使用C#、JavaScript、Boo语言编写，项目代码最后由Mono编译；</li></ul><p>2.Mono组成：</p><ul><li>C#编译器（mcs）；</li><li>Mono Runtime 类似CLR公共语言运行时（虚拟机），包括JIT（Just in time）即时编译器、AOT（Ahead of time）提前编译器、GC、类库加载器 等；</li><li>BCL基础类库；</li><li>Mono类库：提供很多超出.Net的一些额外功能，主要用于构建各种操作系统上的应用；</li></ul><p>3.Unity跨平台的基本原理（Mono）：在Unity下使用各种语言进行逻辑实现，这些语言在发布时会被编译成，IL中间代码，最终这些中间代码在对应操作系统上，通过Mono VM（虚拟机），真正翻译成机器码运行起来；<br><img src="https://s1.ax1x.com/2022/03/21/qu1bUP.png" alt="Unity跨平台的基本原理"></p><p>4.Mono的特点：</p><ul><li>构建（最终打包时）速度快</li><li>Mono编译机制是JIT即时编译，所以支持更多类库</li><li>必须将代码发布为托管程序集（.dll文件）</li><li>Mono VM虚拟机平台维护麻烦，且部分平台不支持（WebGL）</li><li>由于Mono版本授权原因，C#很多新特性无法使用</li><li>IOS支持Mono，但不在允许32位的Mono应用提交到应用商店<br>  <img src="https://s1.ax1x.com/2022/03/21/qudQIJ.png" alt="Mono跨平台说明"></li></ul><p>5.基于Mono跨平台的优缺点：</p><ul><li>优点：只要在不同操作系统上实现Mono VM（虚拟机），那我们能够支持的平台就会“无限”多；</li><li>缺点：维护工作耗时耗力，当Unity版本更新时，Mono VM也需要维护和更新，那多对于N多个平台来说，工作量是非常大的。（Unity的工作量），低版本Mono无法支持新版本C#的强大新特性；</li></ul><h1 id="Unity跨平台原理-IL2CPP"><a href="#Unity跨平台原理-IL2CPP" class="headerlink" title="Unity跨平台原理(IL2CPP)"></a>Unity跨平台原理(IL2CPP)</h1><p>1.IL2CPP说明：L2CPP是在Unity4.6.1 p5之后的版本中，加入的脚本后处理方式，是继Mono之后的一种跨平台解决方案，顾名思义就是把，IL中间代码转译为CPP代码（C++），再利用各平台优化过的编译器编译为对应平台的目标代码，需要注意的是虽然中间代码变为了C++，但是内存管理还是遵循C#中GC的方式，这也是为什么有一个IL2CPP VM（虚拟机）存在的原因，它主要是用来完成GC管理，线程创建等服务工作的；</p><p>2.IL2CPP特点：</p><ul><li>相对Mono构建（最终打包时）速度慢；</li><li>只支持AOT提前编译；</li><li>可以启用引擎代码剥离来减少代码的大小；</li><li>程序的运行效率比Mono高，运行速度快；</li><li>多平台移植更加方便；<br>  <img src="https://s1.ax1x.com/2022/03/21/qudkPs.png" alt="IL2CPP跨平台说明"></li></ul><p>3.Mono和IL2CPP的区别：</p><ul><li>IL2CPP效率高于Mono，跨平台也更好维护，不使用热更新后者大量反射的化推荐使用IL2CPP；</li><li>Mono是JIT（半解释半编译程序或者说纯解释程序）即时编译，IL2CPP是AOT（预编译程序）提前编译，导致IL2CPP不能在运行时动态生成代码和类型，所以必须在编译时就完全确定需要用到的类型，举例：List<a>和List<b>中A和B是我们自定义的类，我能必须在代码中显示的调用过，IL2CPP才能保留List</b></a><b><a>和List<b>两个类型。如果在热更新时我们调用List<c>，但是它之前并没有在代码中显示调用过，那么这时就会出现报错等问题。主要就是因为JIT和AOT两个编译模式的不同造成的；</c></b></a></b></li><b><a><b></b></a></b></ul><b><a><b></b></a><b><h1 id="IL2CPP模式存在的问题"><a></a><a href="#IL2CPP模式存在的问题" class="headerlink" title="IL2CPP模式存在的问题"></a>IL2CPP模式存在的问题</h1><p>1.安装Unity IL2CPP打包工具：在Unityhub中下载 IL2CPP打包相关工具；</p><h2 id="IL2CPP打包泛型问题"><a href="#IL2CPP打包泛型问题" class="headerlink" title="IL2CPP打包泛型问题"></a>IL2CPP打包泛型问题</h2><p>1.问题说明：IL2CPP和Mono最大的区别是，不能在运行时动态生成代码和类型，就是说 泛型相关的内容，如果你在打包生成前没有把之后想要使用的泛型类型显示使用一次，那么之后如果使用没有被编译的类型，就会出现找不到类型的报错；</p><p>2.解决方案：其实就是在预言编译之前让IL2CPP知道我们需要使用这个内容，详细如下</p><ul><li>泛型类：声明一个类，然后在这个类中声明一些public的泛型类变量；</li><li>泛型方法：随便写一个静态方法，在将这个泛型方法在其中调用一下。这个静态方法无需被调用；</li></ul><h2 id="IL2CPP打包类型裁剪问题"><a href="#IL2CPP打包类型裁剪问题" class="headerlink" title="IL2CPP打包类型裁剪问题"></a>IL2CPP打包类型裁剪问题</h2><p>1.问题说明：IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后包的尺寸的目的，然而在实际使用过程中，很多类型有可能会被意外剪裁掉，造成运行时抛出找不到某个类型的异常，特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题；</p><p>2.解决方案：</p><ul><li>(1).IL2CPP处理模式时，将PlayerSetting-&gt;Other Setting-&gt;Managed Stripping Level(代码剥离)设置为Low；</li><li>Disable:Mono模式下才能设置为不删除任何代码 ；</li><li>Low:默认低级别，保守的删除代码，删除大多数无法访问的代码，同时也最大程度减少剥离实际使用的代码的可能性；</li><li>Medium:中等级别，不如低级别剥离谨慎，也不会达到高级别的极端；</li><li>Hight:高级别，尽可能多的删除无法访问的代码，有限优化尺寸减小。如果选择该模式一般需要配合link.xml使用；</li><li>(2).通过Unity提供的link.xml方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的,在Unity工程的Assets目录中（或其任何子目录中）建立一个叫link.xml的XML文件；</li></ul><p>3.link.xml声明格式举例说明：推荐看官网</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--程序集中保留类型和成员--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assembly</span> <span class="token attr-name">fullname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Assembly-CSharp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--保留命名空间中类以及参数preserve说明：all全部、fields字段、methods方法、nothing只保留类型--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span> <span class="token attr-name">fullname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyNameSpace.MyClass<span class="token punctuation">"</span></span> <span class="token attr-name">preserve</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>all<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assembly</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></b></b>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;了解-Net相关知识&quot;&gt;&lt;a href=&quot;#了解-Net相关知识&quot; class=&quot;headerlink&quot; title=&quot;了解.Net相关知识&quot;&gt;&lt;/a&gt;了解.Net相关知识&lt;/h1&gt;&lt;h2 id=&quot;微软-Net概述&quot;&gt;&lt;a href=&quot;#微软-Net概述&quot; cla</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="mono" scheme="https://wwy.wwywy.com/tags/mono/"/>
    
    <category term=".Net" scheme="https://wwy.wwywy.com/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件-Animancer插件使用</title>
    <link href="https://wwy.wwywy.com/posts/1577.html"/>
    <id>https://wwy.wwywy.com/posts/1577.html</id>
    <published>2022-01-29T13:00:00.000Z</published>
    <updated>2022-05-12T11:46:28.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Animancer介绍"><a href="#Animancer介绍" class="headerlink" title="Animancer介绍"></a>Animancer介绍</h1><h1 id="Animancer初步使用"><a href="#Animancer初步使用" class="headerlink" title="Animancer初步使用"></a>Animancer初步使用</h1><p>使用方法：添加Animator组件和AnimancerComponent相关组件，再编写脚本控制动画；</p><p>脚本案例：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public sealed class PlayAnimation : MonoBehaviour{    [SerializeField] private AnimancerComponent _Animancer;    [SerializeField] private AnimationClip _Clip;    private void OnEnable()    {        _Animancer.Play(_Clip);        var state = _Animancer.Play(_Clip);        state.Speed = ...                        state.Time = ...                     state.NormalizedTime = ...              state.Events.OnEnd = ...                   _Animancer.Play(_Clip).Time = 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer核心组件"><a href="#Animancer核心组件" class="headerlink" title="Animancer核心组件"></a>Animancer核心组件</h1><h2 id="AnimancerComponent"><a href="#AnimancerComponent" class="headerlink" title="AnimancerComponent"></a>AnimancerComponent</h2><p>说明：普通的动画师组件</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取Animator Controller组件animancer.Animator//2.获取Playableanimancer.Playable//3.获取该组件上的动画状态字典animancer.States//4.获取该组件上的动画层级animancer.Layers成员方法：//1.播放动画animancer.Play(AnimationClip, float, FadeMode)//2.使用键值播放动画。如果该键没有注册，返回nullanimancer.TryPlay(Object, float, FadeMode)//3.停止当前动画或者目标动画animancer.Stop(参数)//4.判断是否播放当前动画或者目标动画animancer.IsPlaying()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="NamedAnimancerComponent"><a href="#NamedAnimancerComponent" class="headerlink" title="NamedAnimancerComponent"></a>NamedAnimancerComponent</h2><p>说明：继承自AnimancerComponent并添加一个数组，并按名称注册动画，可以使用名字播放动画，这与 Unity 的旧版组件非常相似；</p><p>AnimancerComponent类中的API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">增加的成员变量：//1.获取动画源列表animancer.Animations//1.获取默认动画源animancer.DefaultAnimation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HybridAnimancerComponent"><a href="#HybridAnimancerComponent" class="headerlink" title="HybridAnimancerComponent"></a>HybridAnimancerComponent</h2><p>说明：继承自NamedAnimancerComponent，并且添加了控制器，可以融合Animator Controller组件和Animancer；</p><h1 id="Animancer动画状态"><a href="#Animancer动画状态" class="headerlink" title="Animancer动画状态"></a>Animancer动画状态</h1><p>动画状态说明：播放动画时，Animancer会创建一个状态来管理它并跟踪它的进度，如果以后再次播放相同的动画，它将重用相同的状态；</p><p>AnimancerState类API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">成员变量：//1.获取动画源文件state.Clip//2.动画事件集合state.Events//3.动画的长度state.Length//4.动画的速度state.Speed//5.状态的开始时间，该变量改变，动画事件也会变state.NormalizedTime//6.状态的结束时间，该变量改变，动画事件也会变state.NormalizedEndTime//7.状态的事件集合state.Events成员方法：//1.销毁动画state.Destroy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要访问和创建状态的方法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.此属性存储该方法最近返回的状态var state = animancer.States.Current;//2.此属性存储最近由 Layer 的方法返回的状态var state = animancer.Layers[x].CurrentState;//3.索引器获取var state = animancer.States[clip];//4.方法获取animancer.States.TryGet(clip, out var state);//5.如果已存在的状态，则此方法将返回该状态。否则它将创建并返回一个新的var state = animancer.States.GetOrCreate(clip);//6.创建新状态，即使该动画已存在一个状态。请注意，每个状态必须具有不同的密钥，否则将引发，注意key时object类型，所以会有装拆箱问题var state = animancer.States.Create(key, clip);//7.创建新状态，而不为其提供键。var state = new ClipState(clip);//8.如果存在的状态，则此方法将销毁该状态并返回，否则，它将返回falseanimancer.States.Destroy(clip);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer动画过渡"><a href="#Animancer动画过渡" class="headerlink" title="Animancer动画过渡"></a>Animancer动画过渡</h1><p>过渡说明：Animancer中除了使用Clip动画源文件来进行使用，也可以使用ClipTransition播放动画，并且这样效果更好；</p><p>过渡类类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//基本过渡：1.ClipTransition：实现ITransition接口，最基本的过渡类型，FadeDuration可以控制动画淡入淡出过渡的时长，Speed控制速度，StartTime和EndTime控制起始时间，同时动画支持添加帧事件；2.ClipTransitionSequence：继承自ClipTransition并简单地添加一个数组，这些数组将在第一个之后按顺序播放（使用他们的每个结束事件来播放下一个）；3.PlayableAssetTransition//混合过渡：1.ManualMixerTransition：简单的混合动画；2.LinearMixerTransition：1D混合动画，用一个参数控制，参数信息和Animator里的混合一致；3.MixerTransition2D：2D混合模式，用俩个参数控制，参数信息和Animator里的混合一致；//控制器过渡：1.ControllerTransition：使用控制器文件；//过渡资源1.过渡类+Asset：过渡资源在资源面板下可以创建该过渡资源文件，和上面不同的时，过渡文件整个项目全局共享，而不是每个对象都有自己单独的过渡。它们都遵循相同的命名约定；2.过渡类+Asset.UnShared:不共享分过渡资源，一般用不着；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer混合"><a href="#Animancer混合" class="headerlink" title="Animancer混合"></a>Animancer混合</h1><h2 id="动画淡入淡出"><a href="#动画淡入淡出" class="headerlink" title="动画淡入淡出"></a>动画淡入淡出</h2><p>淡入淡出说明：淡入淡出通常不用于动画，因为它们不能混合，但是对于骨架动画非常有用，因为它允许角色模型从一个动画的结束姿势平滑地过渡到另一个动画的起始姿势，而不需要两个姿势完全相同。这也意味着，如果动画在任何时候被中断，过渡仍然可以是平滑的；</p><p>常用淡入淡出类型：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.参数值按百分比计算下标0:FadeMode.FixedSpeed//2.参数根据事件计算下标1:FadeMode.FixedDuration//3.好像是不会创建的新的状态下标2:FadeMode.FromStart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画的层"><a href="#动画的层" class="headerlink" title="动画的层"></a>动画的层</h2><p>层说明：基本和Animator使用方法一致；</p><p>AnimancerLayer类API说明</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">重要成员变量：//1.层级下标layer.Index//2.层级叠加模式还是覆盖模式layer.IsAdditive//3.层权重layer.Weight重要成员方法：//1.设置骨骼蒙版layer.SetMask(AvatarMask)//2.设置层权重layer.SetWeight(float)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>混合树说明：基本和Animator使用方法一致；</p><p>混合树使用：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//混合类类型说明1.ManualMixerState：没有参数2.LinearMixerState：float参数，线性插值算法3.CartesianMixerState：Vector参数，梯度波段O(n2)插值算法4.DirectionalMixerState：Vector参数，极地梯度波段O(n2)插值算法//案例public sealed class LinearMixerExample : MonoBehaviour{    private AnimancerComponent _Animancer;    private AnimationClip _back;    private AnimationClip _forward;    private AnimationClip _left;    private AnimationClip _right;    private float _MovementSpeed;    public CartesianMixerState mixState;    private void Awake()    {        mixState = new CartesianMixerState();        //初始化混合动画        mixState.Initialize(_back, _forward，_left，_right);        //设置动画参数        mixState.SetThreshold(0, new Vector2(0, 0));        mixState.SetThreshold(1,new Vector2(0,-1));        mixState.SetThreshold(2, new Vector2(0, 1));        mixState.SetThreshold(3, new Vector2(-1, 0));        mixState.SetThreshold(4, new Vector2(1, 0));        //设置混合动画的同步，同步适用于移动，但对于空闲动画，通常应禁用同步        MixerState.AutoSynchronizeChildren = false;        mixer.DontSynchronizeChildren();        mixer.DontSynchronize(mixer.GetChild(0));        mixer.Synchronize(mixer.GetChild(1));        //播放        _Animancer.Play(mixState);    }    private void Update()    {            var input = new Vector2(    Input.GetAxisRaw("Horizontal"),    Input.GetAxisRaw("Vertical"));            mixState.Parameter = Vector2.MoveTowards(                mixState.Parameter,                input,                _MovementSpeed * Time.deltaTime);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer事件"><a href="#Animancer事件" class="headerlink" title="Animancer事件"></a>Animancer事件</h1><p>事件说明：基本和Animator使用方法一致，但是性能更好，且使用Clip文件使用时，每次都会创建垃圾，除非您缓存事件回调，而ClipTransition访问它将直接引用ClipTransition拥有的，因此当您再次播放时，您所做的任何修改都将保留。这意味着修改通常只应在启动时执行一次，而不是每次播放时都重复进行；</p><p>用法说明：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.添加事件state.Events.Add(0.4f, 事件);//2.结束事件，结束一定会调用  state.Events.OnEnd = 事件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Animancer搭配推荐"><a href="#Animancer搭配推荐" class="headerlink" title="Animancer搭配推荐"></a>Animancer搭配推荐</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Animancer介绍&quot;&gt;&lt;a href=&quot;#Animancer介绍&quot; class=&quot;headerlink&quot; title=&quot;Animancer介绍&quot;&gt;&lt;/a&gt;Animancer介绍&lt;/h1&gt;&lt;h1 id=&quot;Animancer初步使用&quot;&gt;&lt;a href=&quot;#Anim</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="插件" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Animancer" scheme="https://wwy.wwywy.com/tags/Animancer/"/>
    
    <category term="Playable" scheme="https://wwy.wwywy.com/tags/Playable/"/>
    
  </entry>
  
  <entry>
    <title>ET6.0框架笔记</title>
    <link href="https://wwy.wwywy.com/posts/2112.html"/>
    <id>https://wwy.wwywy.com/posts/2112.html</id>
    <published>2022-01-24T13:00:00.000Z</published>
    <updated>2022-03-30T01:42:23.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ET6-0框架介绍"><a href="#ET6-0框架介绍" class="headerlink" title="ET6.0框架介绍"></a>ET6.0框架介绍</h1><h1 id="项目的初步运行"><a href="#项目的初步运行" class="headerlink" title="项目的初步运行"></a>项目的初步运行</h1><p>1.运行Unity客户端项目，并且打开编程软件进行初步编译；<br>2.打开服务端项目，第一次打开编译Client下的Mono文件夹；<br>3.重新编译整个解决方案；<br>4.客户端F5生成代码；</p><h1 id="ET前后端通讯机制"><a href="#ET前后端通讯机制" class="headerlink" title="ET前后端通讯机制"></a>ET前后端通讯机制</h1><p>登录实例：<br>1.通过NetKcpComponent组件创建Session会话连接；<br>2.Session（由ET框架管理）会话的Id和TChannel进行绑定；<br>3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；<br>4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器；</p><h1 id="ET的多线程和分布式"><a href="#ET的多线程和分布式" class="headerlink" title="ET的多线程和分布式"></a>ET的多线程和分布式</h1><p>第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；<br>第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；<br>第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；<br>第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；<br>ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构</p><p>登录实例（接上）：<br>1.网关负载均衡服务器随机分配网关配置；<br>2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；<br>3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；<br>4.游戏客户端和游戏网关建立正式连接；<br>5.登录进Map服务器<br>注意：C就是客户端，R是网关负载均衡服务器，G是网关；<br><img src="https://s4.ax1x.com/2022/02/21/HveY4J.png" alt="ET分布式说明"></p><h1 id="ET的ECS组件编程"><a href="#ET的ECS组件编程" class="headerlink" title="ET的ECS组件编程"></a>ET的ECS组件编程</h1><p>ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）；</p><p>遵守的编程原则：<br>1.实体即组件、组件即实体；<br>2.编写一个实体或者组件，绝不继承除Entity外的任何父类；<br>3.不使用任何虚函数，使用逻辑分发替代；<br>4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；<br>5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；<br>6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；<br>7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误；</p><p>其他原则：<br>1.系统命名必须是实体名+System；<br>2.系统必须是静态类；<br>3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；<br>4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.实体或者组件    public class Computer: Entity,IAwake,IUpdate,IDestroy    public class MouseComponent : Entity, IAwake    //2.系统    public static class ComputerSystem    {       //需要使用拓展方法        public static void Start(this Computer self)        {            Log.Debug("计算机启动");//这里可以调用身上的组件            self.GetComponent&lt;PCCaseComponent&gt;().StartPower();            self.GetComponent&lt;MonitorsComponent&gt;().DisPlay();        }    }//3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上    Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;();computer.AddComponent&lt;PCCaseComponent&gt;();computer.AddComponent&lt;MonitorsComponent&gt;();computer.AddComponent&lt;KeyBoardComponent&gt;();computer.AddComponent&lt;MouseComponent&gt;();computer.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中ECS编程的生命周期"><a href="#ET中ECS编程的生命周期" class="headerlink" title="ET中ECS编程的生命周期"></a>ET中ECS编程的生命周期</h1><p>  ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.生命周期函数类    public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt;    public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt;    public class ComputerDestroySystem : DestroySystem&lt;Computer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET的逻辑分发"><a href="#ET的逻辑分发" class="headerlink" title="ET的逻辑分发"></a>ET的逻辑分发</h1><p>OOP面向对象的缺点：继承层次过深时，牵一发而动全身；</p><p>ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承；</p><h1 id="ET的Scene层级树"><a href="#ET的Scene层级树" class="headerlink" title="ET的Scene层级树"></a>ET的Scene层级树</h1><p>Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id；</p><p>客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）:<br><img src="https://s4.ax1x.com/2022/02/20/HO46xg.png" alt="ET框架客户端Scene的层级关系"></p><p>服务端Scene的层级关系:<br><img src="https://s4.ax1x.com/2022/02/20/HOIEX4.png" alt="ET框架服务端Scene的层级关系"></p><p>服务端机器人Scene的层级关系<br><img src="https://s4.ax1x.com/2022/02/20/HOT9zT.png" alt="ET框架服务端机器人Scene的层级关系"></p><h1 id="ET的Excel配置工具"><a href="#ET的Excel配置工具" class="headerlink" title="ET的Excel配置工具"></a>ET的Excel配置工具</h1><p>Excel配置工具注意事项：<br>1.配置文件从第三行第三列开始写，跟VBA宏有关；<br>2.第一个类型字段名必须是Id；<br>3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；<br>4.加#是注释，仅给策划使用，不会添加到游戏数据中；<br>5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\Assets\Bundles\Config下；可以查看文本形式在Bin\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；<br>6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；<br>7.行是可以空行的，可以用来分类注释，目测加#；<br>8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；<br>9.配置工具支持的导表类型可以在Tools\Apps\EXcelExporter文件下的Convert静态类中定义或查看；<br>10.数组类型默认在配置文件中加英文,配置;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型//获取单个UnitConfig config = UnitConfigCategory.Instance.Get(1001)//获取所有var configs = UnitConfigCategory.Instance.GetAll()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的事件系统"><a href="#ET中的事件系统" class="headerlink" title="ET中的事件系统"></a>ET中的事件系统</h1><p>1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；<br>2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；<br>3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.定义事件，添加事件,必须EventType命名空间下进行定义        public struct InstallComputer        {            //定义参数            public Computer computer;        }        //2.调用事件，触发事件//同步PublishGame.EventSystem.Publish(new EventType.InstallComputer() { computer = computer });//同步PublishAnycsawait Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer });//异步PublishAnycsGame.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine();//3.编写事件触发逻辑    public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt;    {        //必须添加async        protected async override ETTask Run(InstallComputer arg)        {            Computer computer = arg.computer;            computer.AddComponent&lt;PCCaseComponent&gt;();            computer.AddComponent&lt;MonitorsComponent&gt;();            computer.AddComponent&lt;KeyBoardComponent&gt;();            computer.AddComponent&lt;MouseComponent&gt;();            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的ETTask异步编程"><a href="#ET中的ETTask异步编程" class="headerlink" title="ET中的ETTask异步编程"></a>ET中的ETTask异步编程</h1><p>同步操作：先完成其全部工作在返回调用者；<br>异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；<br>ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.ETTask函数编写//无返回值,参数类型用来控制取消异步函数public async ETTask TestAsync(ETCancellationToken cancellationToken)        {//表明该函数可能是同步函数await ETTask.CompletedTask;//第二参数同上bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken);//根据返回值控制if (rt) Log.Debug("函数取消了");else Log.Debug("继续执行下面逻辑");}//有返回值        public async ETTask&lt;int&gt; TestResultAsync()        {            await TimerComponent.Instance.WaitAsync(1000);return 10;        }        2.ETTask函数的调用//定义取消异步函数实例ETCancellationToken cancellationToken=new ETCancellationToken();//等待无返回值函数调用完成await TestAsync(cancellationToken);//不等待无返回值函数完成，执行下面逻辑TestAsync(cancellationToken).Coroutine();//等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题int value = await TestResultAsync();//取消函数cancellationToken.Cancel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Protobuf通讯消息"><a href="#ET中的Protobuf通讯消息" class="headerlink" title="ET中的Protobuf通讯消息"></a>ET中的Protobuf通讯消息</h1><p>Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。<br>Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；<br>Protobuf的Github开源地址 :<a href="https://github.com/protocolbuffers/protobuf">GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式</a></p><p>ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\Apps\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版;</p><p>.proto描叙文件编写的的注意事项：<br>1.Proto数据结构描叙文件存放在Proto文件夹下；<br>2.OuterMessage是定义客户端和服务端通信的消息；<br>3.InnerMessage是服务端内部通信的消息；<br>4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；<br>5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；<br>6.消息定义体中的Id不能重复；<br>7.生成的转换类型列表可以在Tools\Apps\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\Generate\Message下；<br>8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；<br>9.字符之间必须要留空格；<br>10.proto文件中的注释意义重大；</p><p>网络Handler消息编写注意事项<br>1.类名定义务必以消息类名+Handler作为声明<br>2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；<br>3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用<br>4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与；</p><h1 id="ET普通网络消息编写"><a href="#ET普通网络消息编写" class="headerlink" title="ET普通网络消息编写"></a>ET普通网络消息编写</h1><p>普通消息.proto文件编写：</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">// ResponseType R2C_LoginTest（普通请求消息一定要注释返回类）message C2R_LoginTest  // IRequest（普通请求消息必须注释）{    int32 RpcId = 90;（普通请求消息必须声明该字段）string Account = 1;string Password = 2;}message R2C_LoginTest  // IResponse（普通响应消息必须注释）{    int32 RpcId = 90;（普通响应消息必须声明该字段）int32 Error = 91;string Message = 92;string GateAddress = 1;string Key = 2;}message C2R_SayHello // IMessage（一般消息必须注释）{string Hello = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通消息C#代码：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.客户端编写登录逻辑        public static async ETTask LoginTest(Scene zoneScene, string address)        {            try            {                Session session = null;                R2C_LoginTest r2C_LoginTest = null;                try                {                    session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address));                    {                        r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = "123", Password = "456" });                        Log.Debug(r2C_LoginTest.Key);                        session.Send(new C2R_SayHello() { Hello = "你好" });                    }                }                finally                {                    session?.Dispose();                }            }            catch(Exception e)            {                Log.Error(e.ToString());            }        }//2.普通请求消息逻辑    [MessageHandler]    public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt;    {        protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply)        {            response.Key = "110";            reply();            await ETTask.CompletedTask;        }    }    //3.一般消息（不用响应）    [MessageHandler]    public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt;    {        protected override async ETTask Run(Session session, C2R_SayHello message)        {            Log.Debug(message.Hello);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Actor通信模型"><a href="#ET中的Actor通信模型" class="headerlink" title="ET中的Actor通信模型"></a>ET中的Actor通信模型</h1><p>Actor模型：<img src="https://s4.ax1x.com/2022/02/21/Hvl1zQ.png" alt="Actor模型"></p><p>Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。</p><p>ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生<br>动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理；</p><p>ActorLocation消息Proto文件编写:</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">//ResponseType M2C_TestActorLocationResponsemessage C2M_TestActorLocationReqeust // IActorLocationRequest{int32 RpcId = 90;string Content = 1;}message M2C_TestActorLocationResponse // IActorLocationResponse{int32 RpcId = 90;int32 Error = 91;string Message = 92;string Content = 1;}message C2M_TestActorLocationMessage // IActorLocationMessage{int32 RpcId = 90;string Content = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ActorLocation消息C#代码编写:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.客户端场景切换逻辑            try            {                Session session = zoneScene.GetComponent&lt;Session&gt;();                var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = "111" });                Log.Debug(message.Content);                session.Send(new C2M_TestActorLocationMessage() { Content = "22222" });            }            catch (Exception e)            {                Log.Error(e);            }            2.ActorLocation请求消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt;    {        protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply)        {            Log.Debug(request.Content);            response.Content = "333333";            reply();            await ETTask.CompletedTask;        }    }3.ActorLocation一般消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt;    {        protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message)        {            Log.Debug(message.Content);            //MessageHelper.SendToClient(entity, 发送给客户端的消息);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET教程登录实例"><a href="#ET教程登录实例" class="headerlink" title="ET教程登录实例"></a>ET教程登录实例</h1><p>实例步骤：<br>1.编写账号登录请求和响应俩条协议Proto；<br>2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；<br>3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;<br>4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）;</p><p>事后心得：<br>1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；<br>2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；<br>3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；<br>4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；<br>5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；<br>6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ET6-0框架介绍&quot;&gt;&lt;a href=&quot;#ET6-0框架介绍&quot; class=&quot;headerlink&quot; title=&quot;ET6.0框架介绍&quot;&gt;&lt;/a&gt;ET6.0框架介绍&lt;/h1&gt;&lt;h1 id=&quot;项目的初步运行&quot;&gt;&lt;a href=&quot;#项目的初步运行&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
    <category term="ET" scheme="https://wwy.wwywy.com/tags/ET/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-Editor</title>
    <link href="https://wwy.wwywy.com/posts/1560.html"/>
    <id>https://wwy.wwywy.com/posts/1560.html</id>
    <published>2021-12-09T13:00:00.000Z</published>
    <updated>2022-07-09T16:18:14.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Editor文件夹"><a href="#Editor文件夹" class="headerlink" title="Editor文件夹"></a>Editor文件夹</h1><p>1.Editor介绍：以下介绍</p><ul><li>Editor文件夹可以放在项目的任何文件夹下，可以有多个；</li><li>放在其中的内容，项目打包时不会被打包到项目中；</li><li>一般编辑器相关代码都可以放在该文件夹中；</li><li>要想访问Editor的代码，必须也放在该文件夹下；</li></ul><h1 id="添加菜单栏"><a href="#添加菜单栏" class="headerlink" title="添加菜单栏"></a>添加菜单栏</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.编辑器菜单栏添加新的选项入口    //可以通过Unity提供我们的MenuItem特性在菜单栏添加选项按钮    //特性名：MenuItem    //命名空间：UnityEditor    //规则一：一定是静态方法    //规则二：我们这个菜单栏按钮 必须有至少一个斜杠 不然会报错 它不支持只有一个菜单栏入口     //规则三：这个特性可以用在任意的类当中    [MenuItem("GameTool/Test")]    private static void Test()2.刷新Project窗口内容        //类名：AssetDatabase        //命名空间：UnityEditor        //方法：Refresh        Directory.CreateDirectory(Application.dataPath + "/测试文件夹");        AssetDatabase.Refresh();3.Editor文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Editor文件夹&quot;&gt;&lt;a href=&quot;#Editor文件夹&quot; class=&quot;headerlink&quot; title=&quot;Editor文件夹&quot;&gt;&lt;/a&gt;Editor文件夹&lt;/h1&gt;&lt;p&gt;1.Editor介绍：以下介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Editor文件夹可以放在</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="UnityEditor" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="UnityEditor" scheme="https://wwy.wwywy.com/tags/UnityEditor/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-InputSystem</title>
    <link href="https://wwy.wwywy.com/posts/1547.html"/>
    <id>https://wwy.wwywy.com/posts/1547.html</id>
    <published>2021-11-13T13:00:00.000Z</published>
    <updated>2022-07-09T16:17:09.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InputSystem概述"><a href="#InputSystem概述" class="headerlink" title="InputSystem概述"></a>InputSystem概述</h1><p>1.InputSystem说明：Unity提供的新的用于检测玩家设备输入的系统，InputSystem让我们可以专注于功能逻辑开发，不用操心输入检测相关代码；</p><p>2.InputSystem导入说明：packageManager中导入Input System</p><p>3.InputSystem选择说明：导入InputSystem包后，老的输入系统会被禁用掉，可以在File——&gt;Build Setting——&gt;Player Setting——&gt;Other——&gt;Active Input Handling中可以同时启用也可以只启用其中之一,每次启用后会重启Unity；</p><h1 id="InputSystem知识点"><a href="#InputSystem知识点" class="headerlink" title="InputSystem知识点"></a>InputSystem知识点</h1><h2 id="代码检测输入"><a href="#代码检测输入" class="headerlink" title="代码检测输入"></a>代码检测输入</h2><p>1.代码直接监听的说明：这种观察者模式的监听方式和InputManager是基本类似的，但是这也就是InputManager的弊端，所以直接得代码检测方式对于InputSystem一般是简单做法或者是有特殊需求才使用的，新输入系统的设计初衷就是想提升开发者的开发效率，不提倡写代码来处理输入逻辑，之后我们学了配置文件相关知识后，都是通过配置文件来设置监听（监视窃听）的输入事件类型，我们只需要把工作重心放在输入触发后的逻辑处理；</p><h3 id="键盘输入监听（Keyboard）"><a href="#键盘输入监听（Keyboard）" class="headerlink" title="键盘输入监听（Keyboard）"></a>键盘输入监听（Keyboard）</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.获取当前键盘设别        //新输入系统 提供了对应的输入设备类 帮助我们对某一种设备输入进行检测        //需要引用命名空间UnityEngine.InputSystem;        Keyboard keyBoard = Keyboard.current;2.单个按键监听        //首先要得到某一个按键 通过键盘类对象 点出 各种按键 来获取        //按下        keyBoard.按键.wasPressedThisFrame        //抬起        keyBoard.按键.wasReleasedThisFrame        //长按        keyBoard.按键.isPressed        //可以处理 任意键 按下 抬起 长按 相关的逻辑        Keyboard.current.anyKey.监听类型（同上）3.通过时间监听按键按下        //通过给keyboard对象中的 文本输入事件 添加委托函数        //便可以获得每次输入的内容        keyBoard.onTextInput += (c) =&gt;        {            print("通过lambda表达式" + c);        };        keyBoard.onTextInput += TextInput;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="鼠标输入监听（Mouse）"><a href="#鼠标输入监听（Mouse）" class="headerlink" title="鼠标输入监听（Mouse）"></a>鼠标输入监听（Mouse）</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.获取当前鼠标设备（需要引用命名空间）        Mouse mouse = Mouse.current;        2.鼠标各键位 按下 抬起 长按        //鼠标左键        mouse.leftButton.监听类型（同上）        //鼠标右键        mouse.rightButton.监听类型（同上）        //鼠标中键        mouse.middleButton.监听类型（同上）        //鼠标 向前向后键        mouse.forwardButton.监听类型（同上）        mouse.backButton.监听类型（同上）3.鼠标位置相关        //获取当前鼠标位置（屏幕坐标）        mouse.position.ReadValue();        //得到鼠标两帧之间的一个偏移向量（其实就是获取鼠标滑动方向）        mouse.delta.ReadValue();        //鼠标中间 滚轮的方向向量        mouse.scroll.ReadValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="触屏输入监听（Touchscreen）"><a href="#触屏输入监听（Touchscreen）" class="headerlink" title="触屏输入监听（Touchscreen）"></a>触屏输入监听（Touchscreen）</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.获取当前触屏设备        Touchscreen ts = Touchscreen.current;        //由于触屏相关都是在移动平台或提供触屏的设备上使用        //所以在使用时最好做一次判空2.得到触屏手指信息        //得到触屏手指数量        ts.touches.Count        //获取指定单个索引手指        TouchControl tc = ts.touches[0];        //按下 抬起 长按         tc.press.监听类型（同上）        //点击手势        tc.tap.isPressed        //连续点击次数        tc.tapCount;3.手指位置等相关信息        //位置        print(tc.position.ReadValue());        //第一次接触时位置        print(tc.startPosition.ReadValue());        //接触区域大小        tc.radius.ReadValue();        //偏移位置        tc.delta.ReadValue();        //得到当前手指的 状态（阶段）        UnityEngine.InputSystem.TouchPhase tp = tc.phase.ReadValue();        switch (tp)        {            //无            case UnityEngine.InputSystem.TouchPhase.None:                break;            //开始接触            case UnityEngine.InputSystem.TouchPhase.Began:                break;            //移动            case UnityEngine.InputSystem.TouchPhase.Moved:                break;            //结束            case UnityEngine.InputSystem.TouchPhase.Ended:                break;            //取消            case UnityEngine.InputSystem.TouchPhase.Canceled:                break;            //静止            case UnityEngine.InputSystem.TouchPhase.Stationary:                break;            default:                break;        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="手柄输入监听（Gamepad）"><a href="#手柄输入监听（Gamepad）" class="headerlink" title="手柄输入监听（Gamepad）"></a>手柄输入监听（Gamepad）</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.获取当前手柄        Gamepad gamePad = Gamepad.current;2.手柄摇杆        //摇杆方向        //左摇杆        gamePad.leftStick.ReadValue()        //右摇杆        gamePad.rightStick.ReadValue()        //左遥感按键监听        gamePad.leftStickButton.监听类型（同上）        //右摇杆按键监听        gamePad.rightStickButton.监听类型（同上）3.手柄方向键        //对应手柄上4个方向键 上下左右        gamePad.dpad.left.监听类型（同上）        gamePad.dpad.right.监听类型（同上）        gamePad.dpad.up.监听类型（同上）        gamePad.dpad.down.监听类型（同上）4.手柄右侧按键        //通用        //Y、△        //gamePad.buttonNorth        //A、X        //gamePad.buttonSouth        //X、□        //gamePad.buttonWest        //B、○        //gamePad.buttonEast        //wasPressedThisFrame        //wasReleasedThisFrame        //isPressed        //手柄右侧按钮 x ○ △ □ A B Y         //○        //gamePad.circleButton        //△        //gamePad.triangleButton        //□        //gamePad.squareButton        //X        //gamePad.crossButton        //x        //gamePad.xButton        //a        //gamePad.aButton        //b        //gamePad.bButton        //Y        //gamePad.yButton5.手柄中央按键        //中央键        //gamePad.startButton        //gamePad.selectButton        //wasPressedThisFrame        //wasReleasedThisFrame        //isPressed6.手柄肩部按键        //左上右上 肩部键位        //左右前方肩部键        //gamePad.leftShoulder        //gamePad.rightShoulder        //左右后方触发键        //gamePad.leftTrigger        //gamePad.rightTrigger        //wasPressedThisFrame        //wasReleasedThisFrame        //isPressed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他输入监听"><a href="#其他输入监听" class="headerlink" title="其他输入监听"></a>其他输入监听</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.其他类型说明：        //其它        //Joystick—摇杆        //Pen—电子笔        //Sensor（传感器）        //https://docs.unity3d.com/Packages/com.unity.inputsystem@1.2/manual/Sensors.html#accelerometer        //Gyroscope—陀螺仪        //GravitySensor—重力传感器        //加速传感器        //光照传感器        //等等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="InputAction类"><a href="#InputAction类" class="headerlink" title="InputAction类"></a>InputAction类</h2><p>1.InputAction说明：顾名思义，InputAction是InputSystem帮助我们封装的输入动作类，它的主要作用，是不需要我们通过写代码的形式来处理输入，而是直接在Inspector窗口编辑想要处理的输入类型，当输入触发时，我们只需要把精力花在输入触发后的逻辑处理上；我们在想要用于处理输入动作的类中，申明对应的InputAction类型的成员变量（注意：需要引用命名空间UnityEngine.InputSystem）；</p><h3 id="InputAction使用API"><a href="#InputAction使用API" class="headerlink" title="InputAction使用API"></a>InputAction使用API</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.启动输入检测move.Enable();2.操作监听相关//开始操作move.started += TestFun;//真正触发move.performed += (context) =&gt;{}；//结束操作move.canceled += (context) =&gt;{}；3.关键参数CallbackContext//当前状态//没有启用 Disabled//等待 Waiting//开始 Started//触发 Performed//结束 Canceledcontext.phase//动作行为信息context.action.name;//控件信息context.control.name;//获取值context.ReadValue&lt;要获取的类型&gt;;//持续时间context.duration;//开始时间context.startTime;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="InputAction齿轮面板参数"><a href="#InputAction齿轮面板参数" class="headerlink" title="InputAction齿轮面板参数"></a>InputAction齿轮面板参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Actions：输入动作设置，设置检测哪些输入Action Type：动作类型Value-值类型，主要用于状态连续更改的输入，例如鼠标的移动，手柄的遥感。如果有多个设备绑定这个Action，只会发送其中一个设备（最受控制的）的输入：Button：按钮类型，用于每次按下时触发的Action<span class="token punctuation">;</span>Pass Through：直通类型，和Value一样，区别在于如果有多个设备绑定这个Action，会发送所有设备的输入<span class="token punctuation">;</span>Control Type-控制类型，在这里选择对应的类型，之后在选择对应设备按键相关属性时，会根据你选择内容的不同，筛选对应内容，这上面显示的内容就是各设备属性的返回值类型，当你选择他们后，非选择的类型将不会在之后的按键设置中出现，很多内容我们基本用不到，相当于是在这里筛选输入设备：Any：任何指Analog：模拟值，浮点数Axis：一维轴浮点数，例如：摇杆输入返回值Bone：骨骼Digital：数字Double：浮点Dpad：4向按钮，例如：摇杆上的D-padEyes：VR相关数值Integer：整数Quaternion：四元数Stick：摇杆相关Touch：触屏相关Vector2：2维向量Vector3：3维向量<span class="token number">2</span>.Interactions-相互作用设置，用于特殊输入，比如长按、多次点击等等，当满足条件时才会触发这个行为（设置长按时间、点击次数等等，3个事，开始started，触发performed，结束canceled）：Hold：适用于需要输入设备保持一段时间的操作。当按钮按下会触发started，若在松开按钮前，按住时间大于等于Hold Time则会触发performed（时间一到就触发），否则触发canceled；Tap：和Hold相反，需要在一段时间内按下松开来触发。当按钮按下会触发started，若在Max Tap Duriation时间内（小于）松开按钮，触发performed，否则触发canceled；SlowTap：类似Hold，但是它在按住时间大于等于Max Tap Duriation的时候，并不会立刻触发performed，而是会在松开的时候才触发performed；MultiTap：用作于多次点击，例如双击或者三连击。Tap Count为点击次数，Max Tap Spacing为每次点击之间的间隔（默认值为 <span class="token number">2</span> * Max Tap Duration）。Max Tap Duration为每次点击的持续时间，即按下和松开按钮的这段时间。当每次点击时间小于Max Tap Duration，且点击间隔时间小于Max Tap Spacing，点击Tap Count次，触发performed。Press可以实现类似按钮的操作Press Only：按下的时候触发started和performed。不触发canceledRelease Only：按下的时候触发started，松开的时候触发performedPress And Release：按下的时候触发started和performed，松开的时候会再次触发started和performed。不触发canceled；Press Point：在Input System中，每个按钮都有对应的浮点值，例如普通的按钮，将会在0（未按下）和1（按下）之间。因此我们可以利用这个值（Press Point）来进行区分，当大于等于这个值则认为按钮按下了。<span class="token number">3</span>.Processors-值处理加工设置，对得到的值进行处理加工：Clamp：将输入值钳制到<span class="token punctuation">[</span>min<span class="token punctuation">..</span>max<span class="token punctuation">]</span>范围。Invert：反转控件中的值（即，将值乘以-1）。Invert Vector <span class="token number">2</span>：反转控件中的值（即，将值乘以-1）。如果invertX为真，则反转矢量的x轴；如果invertY为真，则反转矢量的y轴。Invert Vector <span class="token number">3</span>：反转控件中的值（即，将值乘以-1）。如果反转x为真，则反转矢量的x轴；如果反转y为真，则反转y轴；如果反转z为真，则反转z轴。Normalize：如果最小值<span class="token operator">&gt;</span><span class="token operator">=</span>零，则将<span class="token punctuation">[</span>min<span class="token punctuation">..</span>max<span class="token punctuation">]</span>范围内的输入值规格化为无符号规格化形式<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">1</span><span class="token punctuation">]</span>，如果最小值<span class="token operator">&lt;</span>零，则将输入值规格化为有符号规格化形式<span class="token punctuation">[</span>-1<span class="token punctuation">..</span><span class="token number">1</span><span class="token punctuation">]</span>。Normalize Vector <span class="token number">2</span>：将输入向量规格化为单位长度（1）。Normalize Vector <span class="token number">3</span>：将输入向量规格化为单位长度（1）Scale：将所有输入值乘以系数。Scale Vector <span class="token number">2</span>：将所有输入值沿x轴乘以x，沿y轴乘以y。Scale Vector <span class="token number">3</span>：将所有输入值沿x轴乘以x，沿y轴乘以y，沿z轴乘以z。Axis Deadzone：axis死区处理器缩放控件的值，使绝对值小于最小值的任何值为0，绝对值大于最大值的任何值为1或-1。许多控件没有精确的静止点（也就是说，当控件位于中心时，它们并不总是精确报告0）。在死区处理器上使用最小值可避免此类控件的无意输入。此外，当轴一直移动时，某些控件不一致地报告其最大值。在死区处理器上使用最大值可确保在这种情况下始终获得最大值。Stick Deadzone：摇杆死区处理器缩放Vector2控件（如摇杆）的值，以便任何幅值小于最小值的输入向量都将得到（0,0），而任何幅值大于最大值的输入向量都将规格化为长度1。许多控件没有精确的静止点（也就是说，当控件位于中心时，它们并不总是精确地报告0,0）。在死区处理器上使用最小值可避免此类控件的无意输入。此外，当轴一直移动时，某些控件不一致地报告其最大值。在死区处理器上使用最大值可确保在这种情况下始终获得最大值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="InputAction添加面板参数"><a href="#InputAction添加面板参数" class="headerlink" title="InputAction添加面板参数"></a>InputAction添加面板参数</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Add Binding:添加新的输入绑定（单按键输入）；<span class="token number">2</span>.Add Positive<span class="token punctuation">\</span>Negative Binding Or Add 1D Axis Composite<span class="token punctuation">(</span><span class="token number">2019</span>版本<span class="token punctuation">)</span>：添加1D轴组合（类似Input中的水平竖直热键，返回-1~1之间的一个值）Negative：负面按键，例如 <span class="token number">0</span>~-1Positive：正向按键，例如 <span class="token number">0</span>~1Composite Type：复合类型MinValue：最小值MaxValue：最大值Which Side Wins：哪一方获胜（当同时按下时如何处理）Neither：双方没有优先权，返回MinValue和MaxValue的中间值Positive：正面优先，返回maxValueNegative：负面优先，返回minValue<span class="token number">3</span>.Add Up<span class="token punctuation">\</span>Down<span class="token punctuation">\</span>Left<span class="token punctuation">\</span>Right Composite Or Add 2D Vector Composite（2019版本）:添加2D向量组合（类似将Input中的水平竖直热键组合在一起，得到的Vector中的x，y分别表示两个轴）Up:上 <span class="token punctuation">(</span> <span class="token number">0</span> , <span class="token number">1</span> <span class="token punctuation">)</span>Down：下 <span class="token punctuation">(</span> <span class="token number">0</span> , -1 <span class="token punctuation">)</span>Left：左 <span class="token punctuation">(</span> -1 , <span class="token number">0</span> <span class="token punctuation">)</span>Right：右 <span class="token punctuation">(</span> <span class="token number">1</span> , <span class="token number">0</span> <span class="token punctuation">)</span>Composite Type：复合类型Mode：处理模式Analog：模拟值，浮点值Digital Normalized：单位化向量Digital：未单位化的向量<span class="token number">4</span>.Add Up<span class="token punctuation">\</span>Down<span class="token punctuation">\</span>Left<span class="token punctuation">\</span>Right<span class="token punctuation">\</span>Forward<span class="token punctuation">\</span>Backward Composite-添加3D向量组合：和2D类似；<span class="token number">5</span>.Add Button With One Modifier Composite:添加带有一个复合修改器的按钮（可以理解为双组合键， 比如Ctrl+C、Ctrl+V）Modifier：复合输入内容Button：触发输入内容<span class="token punctuation">(</span>举例：复制按键Ctrl+C,Ctrl为Modifier,C为Button<span class="token punctuation">)</span><span class="token number">6</span>.Add Button With Two Modifier Composite-添加带有两个复合修改器的按钮（可以理解为三组合键，比如Ctrl+K+U）:Modifier：复合输入内容Button：触发输入内容<span class="token punctuation">(</span>举例：复制按键Ctrl+K+U,Ctrl为Modifier1,K为Modifier2,U为Button<span class="token punctuation">)</span><span class="token number">7</span>.输入类型说明：Path：从哪个控件接受输入Usages：常用用法GamePad：游戏手柄Joystick：操纵杆Keyboard：键盘Mouse：鼠标Pen：笔Pointer：指针Sensor：传感器TouchScreen：触屏Tracked Device：履带装置XR Controller：XR 控制器XR HMD：XR 头戴显示器Other：其它<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="InputSystemPackage设置"><a href="#InputSystemPackage设置" class="headerlink" title="InputSystemPackage设置"></a>InputSystemPackage设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.UpdateMode：更新模式Process Events In Dynamic Update：在动态更新中处理事件Process Events In Fixed Update：在固定更新中处理事件Process Events Manually：手动处理事件<span class="token number">2</span>.Background Behavior：后台行为Reset And Disable Non Background Devices：重置和禁用非后台设备Reset And Disable All Devices：重置和禁用所有设备Ignore Focus：忽略焦点<span class="token number">3</span>.Filter Noise on .current：过滤当前设备的噪音<span class="token number">4</span>.Compensate Orientation：定向补偿<span class="token number">5</span>.Default Deadzone Min：默认死区最小值<span class="token number">6</span>.Default Deadzone Max：默认死区最大值<span class="token number">7</span>.Default Button Press Point：默认按钮按下点<span class="token number">8</span>.Button Release Threshold：按钮释放阈值<span class="token number">9</span>.Default Tap TIme：默认点击时间<span class="token number">10</span>.Default Slow Tap Time：默认慢速点击时间<span class="token number">11</span>.Default Hold Time：默认保持时间<span class="token number">12</span>.Tap Radius：点击半径<span class="token number">13</span>.MultTap Delay TIme：多次点击延迟时间<span class="token number">14</span>.Supported Devices：支持的设备，如果希望输入系统支持其可以识别的所有输入设备，请将支持的设备保留为空；但是，如果您只对某一组设备感兴趣，那么在此处添加它们将缩小编辑器中显示的范围，并避免从与项目无关的设备获取输入；在此处添加设备时，任何未被分类为受支持的设备都将显示在输入调试器的“不受支持的设备”下；<span class="token number">15</span>.Motion Usage：动作使用<span class="token number">16</span>.Description：描述<span class="token number">17</span>.Play Mode Input Behavior：播放模式输入行为Pointers And Keyboards Respect Game View Focus：指针和键盘遵守游戏视图焦点All Devices Respect Game View Focus：所有设备都遵守游戏视图焦点All Device Input Always Goes To Game View：所有设备输入始终进入游戏视图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="InputActions输入动作配置文件"><a href="#InputActions输入动作配置文件" class="headerlink" title="InputActions输入动作配置文件"></a>InputActions输入动作配置文件</h2><p>1.输入配置文件说明：输入系统中提供了一种输入配置文件，你可以理解它是InputAction的集合，可以在一个文件中编辑多个InputAction的信息，里面记录了想要处理的行为和动作（也就是InputAction的相关信息），我们可以在其中自己定义 InputAction（比如：开火、移动、旋转等），然后为这个InputAction关联对应的输入动作，之后将该配置文件和PlayerInput进行关联，PlayerInput会自动帮助我们解析该文件，当触发这些InputAction输入动作时会以分发事件的形式通知我们执行行为；</p><p>2.创建输入配置文件：在Project窗口右键Create创建InputActions配置文件；</p><h3 id="输入配置文件"><a href="#输入配置文件" class="headerlink" title="输入配置文件"></a>输入配置文件</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.（左边）ActionMaps:行动地图窗口,可以理解为配置文件中的行为分组配置,可以配置多套操作规范;2.（中间）Actions 输入动作窗口,我们在这里可以创建各种InputAciton;3.（右边）Properties 输入操作绑定的输入属性4.(上方)工具栏-提供保存、搜索等功能按键:Add Control:设置控制方案:Gamepad：手柄Joystick：摇杆KeyboardMouse：键盘鼠标Touch：触屏XR：VR/AR等All Devices：设备选择,当切换了控制方案后,该控制方案可能是由多个设备配合控制,可以在这里进一步筛选对应设备Save Asset:保存配置按钮;Auto-Save：自动保存配置;搜索栏：可以搜索对应动作行为;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入配置文件生成C-代码"><a href="#输入配置文件生成C-代码" class="headerlink" title="输入配置文件生成C#代码"></a>输入配置文件生成C#代码</h2><p>1.根据配置文件生成C#代码：选择InputActions文件后，在Inspector窗口设置生成路径，类名，命名空间，应用后生成代码；</p><p>2.使用生成后的输入代码</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.创建生成的代码对象input = new 类名();2.激活输入input.Enable();3.事件监听input.Input名.按钮名.performed += (context) =&gt;{}；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PlayerInput"><a href="#PlayerInput" class="headerlink" title="PlayerInput"></a>PlayerInput</h2><p>1.PlayerInput说明：PlayerInput是InputSystem提供的，专门用于接受玩家输入来处理自定义逻辑的组件，选择任意对象（一般为一个玩家对象）为其添加PlayerInput组件即可，工作原理如下：</p><ul><li>配置输入文件（InputActions文件）；</li><li>通过PlayerInput关联配置文件，它会自动解析该配置文件；</li><li>关联对应的响应函数，处理对应逻辑；</li></ul><h3 id="PlayerInput组件面板说明："><a href="#PlayerInput组件面板说明：" class="headerlink" title="PlayerInput组件面板说明："></a>PlayerInput组件面板说明：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Actions-行为,一套输入动作和玩家相关联，帮助我们监听一些按键的输入:Default Control Scheme：默认启用哪一个控制方案Default Actions Map：默认启用哪一个行为映射方案<span class="token number">2</span>.Camera：关联摄像机，当分屏设置时才需修改此选项<span class="token number">3</span>.Behavior：如何通知游戏对象上执行对应逻辑SendMessage：将逻辑脚本挂载在和PlayerInput同一对象上，会通过SendMessage通知执行对应函数BroadcastMessage：，将逻辑脚本挂载在其自身或子对象上。会通过BroadcastMessage通知执行对应函数Invoke UnityEvent Actions：通过拖拽脚本关联函数指明想要执行的函数逻辑Invoke CSharp Events：通过Csharp事件监听处理对应逻辑，通过获取PlayerInput进行事件监听<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PlayerInputBehavior详细说明"><a href="#PlayerInputBehavior详细说明" class="headerlink" title="PlayerInputBehavior详细说明"></a>PlayerInputBehavior详细说明</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.Send Messages        //在自定义脚本中        //申明名为 "On+行为名" 的函数        //没有参数 或者 参数类型为InputValue        //将该自定义脚本挂载到PlayerInput依附的对象上        //当触发对应输入时 会自动调用函数        //并且还有默认的3个和设备相关的函数可以调用        //设备注册(当控制器从设备丢失中恢复并再次运行时会触发)：OnDeviceRegained(PlayerInput input)        //设备丢失（玩家失去了分配给它的设备之一，例如，当无线设备耗尽电池时）：OnDeviceLost(PlayerInput input)        //控制器切换：OnControlsChanged(PlayerInput input)2.Broadcast Messages        //基本和SendMessage规则一致        //唯一的区别是，自定义脚本不仅可以挂载在PlayerInput依附的对象上        //还可以挂载在其子对象下        3.Invoke Unity Events        //该模式可以让我们在Inspector窗口上通过拖拽的形式关联响应函数        //但是注意：响应函数的参数类型 需要改为 InputAction.CallbackContext        4.Invoke C Sharp Events        //1.获取PlayerInput组件        PlayerInput input = this.GetComponent&lt;PlayerInput&gt;();        //手动获取需要的值，比如在Update中获取值        input.currentActionMap["Move"].ReadValue&lt;Vector2&gt;()                //2.获取对应事件进行委托函数添加        input.onDeviceLost += OnDeviceLost;        input.onDeviceRegained += OnDeviceRegained;        input.onControlsChanged += OnControlsChanged;        input.onActionTriggered += OnActionTrigger;                //3.当触发输入时会自动触发事件调用对应函数        //用Switch来集中处理    public void OnActionTrigger(InputAction.CallbackContext context)    {        switch (context.action.name)        {            case "Fire":                //输入阶段的判断 触发阶段 才去做逻辑                if(context.phase == InputActionPhase.Performed)                    print("开火");                break;            case "Look":                print("看向");                print(context.ReadValue&lt;Vector2&gt;());                break;            case "Move":                print("移动");                print(context.ReadValue&lt;Vector2&gt;());                break;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PlayerInputManager"><a href="#PlayerInputManager" class="headerlink" title="PlayerInputManager"></a>PlayerInputManager</h2><p>1.PlayerInputManager 组件主要是用于管理本地多人输入的输入管理器，它主要管理玩家加入和离开；</p><h3 id="PlayerInputManager组件面板说明"><a href="#PlayerInputManager组件面板说明" class="headerlink" title="PlayerInputManager组件面板说明"></a>PlayerInputManager组件面板说明</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Notification Behavior-当玩家进入时PlayerInputManager如何通知关联的对象，它的工作方式和PlayerInput相同：Join Behavior：玩家加入的机制Join Players When Button Is Pressed：当有新设备加入按下任意键，或者没有任何玩家时按下任意键；Join Players When Join Action Is Triggered：当有新设备加入按下指定按键触发玩家加入；Join Players Manually：不要自动加入玩家，需要自己手动加入玩家；Player Prefab：挂载PlayerInput组件的游戏对象Joining Enabled By Default：启用后，新加玩家按照JoinBehavior的规则加入Limit Number Of Players：启用后，可以限制加入游戏的玩家数量Max Player Count：允许参加游戏的最大玩家数Enable Split_Screen：如果启用，会自动为每个对象分配可用屏幕区域的一部分，用于多人分屏游戏Maintain Aspect Ratio：假值使游戏能够生成屏幕区域，其纵横比与细分屏幕时的屏幕分辨率不同Set Fixed Number：如果该值大于零，则PlayerInputManager始终将屏幕分割为固定数量的矩形，而不考虑实际的玩家数量。Screen Rectangle：可用于分配播放器拆分屏幕的规范化屏幕矩形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="UGUI配合使用"><a href="#UGUI配合使用" class="headerlink" title="UGUI配合使用"></a>UGUI配合使用</h2><p>1.InputSystem对UI的支持：新输入系统InputSystem不支持IMGUI（GUI）注意：编辑器代码不受影响，新输入系统支持UGUI，但是需要使用新输入系统输入模块（Input System UI Input Module），如果当前激活的是InputSystem，那么OnGUI中的输入判断相关内容不会被触发，你必须要选择Both或者只激活老输入系统InputManager才能让OnGUI中内容有用；</p><p>2.更多支持说明</p><p><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.2/manual/UISupport.html">UI 支持|输入系统|1.2.0 (unity3d.com)</a></p><h3 id="Input-System-UI-Input-Module组件参数说明"><a href="#Input-System-UI-Input-Module组件参数说明" class="headerlink" title="Input System UI Input Module组件参数说明"></a>Input System UI Input Module组件参数说明</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Move Repeat Delay：生成初始IMoveHandler之间的初始延迟（秒）。OnMove导航事件，并在移动操作保持激活状态时生成重复的导航事件：<span class="token number">2</span>.Move Repeat Rate：移动动作保持激活时，生成重复导航事件之间的间隔（秒）。请注意，这是由帧速率限制的；每帧不会有多个移动重复事件，因此，如果帧速率低于重复率，则有效重复率将低于此设置。<span class="token number">3</span>.XR Tracking Origin：XR设备相关Deselect On Background CLick：默认情况下，当指针被点击并且没有击中任何游戏对象时，当前选择被清除。然而，这可能会妨碍键盘和游戏板导航，因为它们需要关闭当前选定的对象。要防止自动取消选择，请将此属性设置为false。<span class="token number">4</span>.Pointer Behavior-如何处理将输入送入UI的多个指针：Single Mouse Or Pen BUt Multi Touch And Track：对于未分类为触摸或跟踪输入的所有输入，其行为类似于单个统一指针，对于跟踪和触摸输入，其行为类似于所有指针；例如，如果在鼠标和笔上接收到并发输入，则将两者的输入馈送到同一UI指针实例中；其中一个的位置输入将覆盖另一个的位置。请注意，当从触摸或跟踪设备接收到输入时，鼠标和笔的单个统一指针将被删除，包括在鼠标/笔光标当前悬停在对象上时发送的IPointerExit事件。Single Unified Pointer：所有指针输入都是统一的，因此只有一个指针。这包括触摸和跟踪输入。例如，这意味着，无论有多少设备将输入输入输入点，只有帧中最后一个这样的输入才会生效并成为当前UI指针的位置。All Pointers As Is：UI输入模块不会统一任何指针输入。任何设备，包括提供输入指针类型动作的触摸和跟踪设备，都将是其自己的指针（或触摸输入的多个指针）；注意：这可能意味着UI中将有任意数量的指针，并且可能同时指向多个对象。<span class="token number">5</span>.Actions Asset：包含控制UI的所有操作的输入操作资产。您可以使用以下属性选择资产中的哪些操作对应于哪些UI输入；默认情况下，这将引用名为DefaultInputActions的内置资产，该资产包含用于驱动UI的常见默认操作。如果要设置自己的操作，请创建自定义输入操作资源并在此处分配。在Inspector中将新资源引用指定给此字段时，编辑器会尝试根据常用命名约定自动将操作映射到UI输入。<span class="token number">6</span>.Point：提供2D屏幕位置的动作。用作指向UI元素的光标，以实现鼠标样式的UI交互；设置为传递操作类型和向量2值类型。<span class="token number">7</span>.Left Click：映射到用于与UI交互的主光标按钮的操作；设置为传递操作类型和按钮值类型。<span class="token number">8</span>.Middle Click：映射到用于与UI交互的中间光标按钮的操作；设置为传递操作类型和按钮值类型。<span class="token number">9</span>.Right Click：映射到用于与UI交互的辅助光标按钮的操作；设置为传递操作类型和按钮值类型。<span class="token number">10</span>.Scroll Wheel：提供手势输入以允许在UI中滚动的操作；设置为传递操作类型和向量2值类型。<span class="token number">11</span>.Move：一种操作，提供用于选择当前活动用户界面的二维矢量。这允许游戏板或箭头键样式的UI导航；设置为传递操作类型和向量2值类型<span class="token number">12</span>.Submit：与当前选择的UI接触或“单击”的操作；设置为按钮动作类型。<span class="token number">13</span>.Cancel：退出与当前选定UI的任何交互的操作；设置为按钮动作类型。<span class="token number">14</span>.Tracked Position：提供一个或多个空间跟踪设备（如XR hand控制器）的3D位置的动作。结合跟踪设备方向，这允许通过指向空间中的UI可选择项进行XR样式的UI交互；设置为传递操作类型和向量3值类型。<span class="token number">15</span>.Tracked Orientation：传递表示一个或多个空间跟踪设备（如XR hand控制器）旋转的四元数的操作。结合跟踪设备位置，这允许通过指向空间中的UI可选择项进行XR样式的UI交互；设置为传递操作类型和四元数值类型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Multiplayer-Event-System多人组件说明"><a href="#Multiplayer-Event-System多人组件说明" class="headerlink" title="Multiplayer Event System多人组件说明"></a>Multiplayer Event System多人组件说明</h3><p>1.使用条件说明：如果同一设备上的多人游戏，每个人想要使用自己的一套独立UI，需要将EventSystem中的EventSystem组件替换为Multiplayer Event System组件；</p><p>2.Multiplayer Event System组件说明：与EventSystem组件不同，可以在场景中同时激活多个MultiplayerEventSystem，这样，您可以有多个玩家，每个玩家都有自己的InputSystemUIInputModule和MultiplayerEventSystem组件，每个玩家都可以有自己的一组操作来驱动自己的UI实例，如果您正在使用PlayerInput组件，还可以设置PlayerInput以自动配置玩家的InputSystemUIInputModule以使用玩家的操作；MultilayerEventSystem组件的属性与事件系统中的属性相同，此外，MultiplayerEventSystem组件还添加了一个playerRoot属性，您可以将其设置为一个游戏对象，该游戏对象包含此事件系统应在其层次结构中处理的所有UI可选择项；</p><h3 id="Tracked-Device-Raycaster组件配对VR中Canvas组件"><a href="#Tracked-Device-Raycaster组件配对VR中Canvas组件" class="headerlink" title="Tracked Device Raycaster组件配对VR中Canvas组件"></a>Tracked Device Raycaster组件配对VR中Canvas组件</h3><p>1.使用条件说明：如果想在VR项目中使用新输入系统配合UGUI使用，需要在Canvas对象上添加Tracked Device Raycaster组件；</p><h3 id="On-Screen组件（绝对重点）"><a href="#On-Screen组件（绝对重点）" class="headerlink" title="On-Screen组件（绝对重点）"></a>On-Screen组件（绝对重点）</h3><p>1.使用说明：On-Screen组件可以模拟UI和用户操作的交互，如On-Screen Button用来按钮交互，On-Screen Stick用来摇杆交互</p><h2 id="InputDebug"><a href="#InputDebug" class="headerlink" title="InputDebug"></a>InputDebug</h2><p>1.InputDebug说明：InputDebug顾名思义是输入调试器的意思，我们可以通过输入调试窗口检测输入相关信息，当我们的输入不按预期工作时，可以通过它来排查问题；</p><p>2.打开InputDebug窗口</p><ul><li>1.Window(窗口)-&gt;Analysis(分析)-&gt;Input Debugger(输入调试器)</li><li>2.PlayerInput组件-&gt;Open Input Debugger</li></ul><h3 id="InputDebug窗口信息说明"><a href="#InputDebug窗口信息说明" class="headerlink" title="InputDebug窗口信息说明"></a>InputDebug窗口信息说明</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Add Devices Not Listed <span class="token keyword">in</span> Supported Devices：添加未在支持的设备中列出的设备；<span class="token number">2</span>.Enable Event Diagnostics：启用事件诊断；<span class="token number">3</span>.Simulate TOuch Input From Mouse or pen：模拟鼠标或笔的触摸输入；<span class="token number">4</span>.Remote Devices：远程设备；<span class="token number">5</span>.Devices：系统中当前所有输入设备列表；<span class="token number">6</span>.Unsupported：不支持、无法识别的设备列表；<span class="token number">7</span>.Layouts：设备布局列表，所有已注册的设备控制列表；<span class="token number">8</span>.Abstract Devices：抽象设备；<span class="token number">9</span>.Specific Devices：特定设备；<span class="token number">10</span>.Settings：设置相关，默认的一些特殊输入设置；<span class="token number">11</span>.Metrics：指标相关，输入系统资源使用情况的统计信息；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><h2 id="InputSystem专门任意键方案（改键）"><a href="#InputSystem专门任意键方案（改键）" class="headerlink" title="InputSystem专门任意键方案（改键）"></a>InputSystem专门任意键方案（改键）</h2><p>1.方案说明：InputSystem.onAnyButtonPress.CallOnce((control) =&gt;（）；</p><ul><li>如果用Call 按键盘会报错 但是也能正常执行；</li><li>用CallOnce 只会执行一次 但是不会报错；</li></ul><h2 id="Json手动加载输入配置文件"><a href="#Json手动加载输入配置文件" class="headerlink" title="Json手动加载输入配置文件"></a>Json手动加载输入配置文件</h2><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">string json = Resources.Load&lt;TextAsset&gt;("PlayerInputTest").text;InputActionAsset asset = InputActionAsset.FromJson(json);input.actions = asset;input.onActionTriggered += (context) =&gt;{    if(context.phase == InputActionPhase.Performed)    {        switch (context.action.name)        {            case "Move":                print("移动");                break;            case "Look":                print("看向");                break;            case "Fire":                print("开火");                break;        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改键"><a href="#改键" class="headerlink" title="改键"></a>改键</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;InputSystem概述&quot;&gt;&lt;a href=&quot;#InputSystem概述&quot; class=&quot;headerlink&quot; title=&quot;InputSystem概述&quot;&gt;&lt;/a&gt;InputSystem概述&lt;/h1&gt;&lt;p&gt;1.InputSystem说明：Unity提供的新的</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="InputSystem" scheme="https://wwy.wwywy.com/tags/InputSystem/"/>
    
  </entry>
  
  <entry>
    <title>C++入门</title>
    <link href="https://wwy.wwywy.com/posts/1344.html"/>
    <id>https://wwy.wwywy.com/posts/1344.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-05-01T07:17:38.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基本概念"><a href="#C-基本概念" class="headerlink" title="C++基本概念"></a>C++基本概念</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1.语言的发展：二进制值类==&gt;汇编语言==&gt;中高级语言(C,C++,Java)</p><p>2.C++说明：C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程，C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点，C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序；</p><p>3.C++发展时间：</p><ul><li>1998：C++98，第一个C++标准；</li><li>2003：C++03，第二个C++标准；</li><li>2011：C++11，第三个C++标准；</li><li>2014：C++14，第四个C++标准；</li><li>2017：C++17，第五个C++标准；</li></ul><h2 id="环境的建立"><a href="#环境的建立" class="headerlink" title="环境的建立"></a>环境的建立</h2><p>1.C++编译器：</p><ul><li>GCC编译器：</li><li>Visual Studio IDEA：</li></ul><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>1.编译&amp;执行：</p><ul><li>打开一个文本编辑器，添加上述代码；</li><li>保存文件为 hello.cpp；</li><li>打开命令提示符，进入到保存文件所在的目录；</li><li>键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件；</li><li>现在，键入 ‘ a.out’ 来运行程序；</li><li>您可以看到屏幕上显示 ‘ Hello World ‘；</li></ul><p>2.C++ 标识符：C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9），C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符；</p><p>3.C++关键字：</p><p><a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com)</a></p><p>4.C++注释：和C#一致；</p><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><table><thead><tr><th>类型</th><th>关键字</th><th>初始化默认值</th><th>位</th><th>范围</th></tr></thead><tbody><tr><td>字符型</td><td>char</td><td>‘\0’</td><td>1 个字节</td><td>-128 到 127 或者 0 到 255</td></tr><tr><td>无符号字符型</td><td>unsigned char</td><td>0</td><td>1 个字节</td><td>0 到 255</td></tr><tr><td>有符号字符型</td><td>signed char</td><td>0</td><td>1 个字节</td><td>-128 到 127</td></tr><tr><td>整形</td><td>int</td><td>0</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>无符号整形</td><td>unsigned int</td><td>0</td><td>4 个字节</td><td>0 到 4294967295</td></tr><tr><td>有符号整形</td><td>signed int</td><td>0</td><td>4 个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>短整形</td><td>short int</td><td>0</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>无符号短整形</td><td>unsigned short int</td><td>0</td><td>2 个字节</td><td>0 到 65,535</td></tr><tr><td>有符号短整形</td><td>signed short int</td><td>0</td><td>2 个字节</td><td>-32768 到 32767</td></tr><tr><td>长整形</td><td>long int</td><td>0</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>无符号长整形</td><td>signed long int</td><td>0</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>有符号长整形</td><td>unsigned long int</td><td>0</td><td>8 个字节</td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td>单精度浮点型</td><td>float</td><td>0</td><td>4 个字节</td><td>精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td>双精度浮点型</td><td>double</td><td>0</td><td>8 个字节</td><td>双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td>双精度长浮点型</td><td>long double</td><td>0</td><td>16 个字节</td><td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td>宽字符型</td><td>wchar_t</td><td>‘\0’</td><td>2 或 4 个字节</td><td>1 个宽字符（等价==&gt;typedef short int wchar_t）</td></tr><tr><td>无类型</td><td>void</td><td>-</td><td>-</td><td>表示类型的缺失</td></tr></tbody></table><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>1.作用域说明：主要是三个地方可以定义变量</p><ul><li>局部变量：在函数或一个代码块内部声明的变量；</li><li>全局变量：在所有函数外部声明的变量；</li><li>形式参数：在函数参数的定义中声明的变量，而调用方则被称为实际参数；</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>1.C++声明常量：常量最好全大写</p><ul><li>#define 预处理器：语法格式#define 预处理名 常量值；</li><li>const 关键字：语法格式const 数据类型 变量名 = 常量值；</li></ul><h2 id="修饰符类型"><a href="#修饰符类型" class="headerlink" title="修饰符类型"></a>修饰符类型</h2><p>1.修饰符：修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型；修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀（例如：unsigned long int，其中int可以省略）；</p><ul><li>signed：有符号类型；</li><li>unsigned：无符号类型；</li><li>long：长类型；</li><li>short：短类型；</li></ul><p>2.类型限定符：类型限定符提供了变量的额外信息：</p><ul><li>const：const 类型的对象在程序执行期间不能被修改改变；</li><li>volatile：修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率；</li><li>restrict：由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict；</li></ul><h2 id="存储类-型"><a href="#存储类-型" class="headerlink" title="存储类(型)"></a>存储类(型)</h2><p>1.存储类说明：存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们所修饰的类型之前，下面列出 C++ 程序中可用的存储类（从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用）</p><ul><li>auto(C++17删除)：根据初始化表达式自动推断被声明的变量的类型，用于两种情况，声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符；</li><li>register：用于定义存储在寄存器中而不是 RAM 中的局部变量，这意味着变量的最大尺寸等于寄存器的大小，且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）；</li><li>static：</li><li>extern：</li><li>mutable：</li><li>thread_local (C++11)：</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h1 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h1><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-基本概念&quot;&gt;&lt;a href=&quot;#C-基本概念&quot; class=&quot;headerlink&quot; title=&quot;C++基本概念&quot;&gt;&lt;/a&gt;C++基本概念&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C++" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C++" scheme="https://wwy.wwywy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Lua热更新技术</title>
    <link href="https://wwy.wwywy.com/posts/1569.html"/>
    <id>https://wwy.wwywy.com/posts/1569.html</id>
    <published>2021-10-28T13:00:00.000Z</published>
    <updated>2022-07-09T16:18:34.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="热更新介绍"><a href="#热更新介绍" class="headerlink" title="热更新介绍"></a>热更新介绍</h1><p>1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅速修复Bug、提升玩家留存率；</p><p>2.热更新分类：以下俩种</p><ul><li>资源的热更新：Unity内置的有AssetBundle来进行资源热更；</li><li>逻辑的热更新：也就是对代码的热更新，一般使用xlua、tolua；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;热更新介绍&quot;&gt;&lt;a href=&quot;#热更新介绍&quot; class=&quot;headerlink&quot; title=&quot;热更新介绍&quot;&gt;&lt;/a&gt;热更新介绍&lt;/h1&gt;&lt;p&gt;1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    <category term="热更新" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
    
    <category term="Lua" scheme="https://wwy.wwywy.com/tags/Lua/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="AssetBundle" scheme="https://wwy.wwywy.com/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法格式（.md后缀-使用typora）</title>
    <link href="https://wwy.wwywy.com/posts/1.html"/>
    <id>https://wwy.wwywy.com/posts/1.html</id>
    <published>2021-09-28T13:00:00.000Z</published>
    <updated>2022-03-11T14:59:00.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本语法格式"><a href="#Markdown基本语法格式" class="headerlink" title="Markdown基本语法格式"></a>Markdown基本语法格式</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#标题1 （大）</span><span class="token comment">##标题2</span><span class="token comment">###标题3</span><span class="token comment">####标题4 （小）</span>以此类推 最高标题6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">​```代码块名称<span class="token punctuation">(</span>可以输入各种语言java、c++、html等<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//加粗**加粗**//代码高亮显示<span class="token operator">==</span>高亮<span class="token operator">==</span>//删除线~~删除线~~//斜体  *斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//引用语法<span class="token operator">&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>作者：泽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//分割线---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="图片插入："><a href="#图片插入：" class="headerlink" title="图片插入："></a>图片插入：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//在线图片与本地图片<span class="token operator">!</span><span class="token punctuation">[</span>照片名子<span class="token punctuation">]</span>（/image/me.png）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//超链接语法<span class="token punctuation">[</span>超链接名字<span class="token punctuation">]</span>（https://gihub.com/yerenping）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//无需列表- 目录1  -后加空格- 目录2- 目录3//有序列表  <span class="token number">1</span>+. +名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右键》插入》表格用代码过于复杂不推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="用-Markdown-写数学公式"><a href="#用-Markdown-写数学公式" class="headerlink" title="用 Markdown 写数学公式"></a>用 Markdown 写数学公式</h1><p>Markdown 是很优秀的标记语言，目前很多平台都带 $\TeX$ 公式引擎（XTeX, Mathjax 等）的 Markdown 编辑器。文章介绍使用 Typora 客户端做公式笔记，主要为多行公式的 $\TeX$ 语法和公式识别两个问题。</p><p>Markdown 的用法本文不再赘述了，直接讲一下公式的问题：</p><h2 id="行内公式和简单单行公式"><a href="#行内公式和简单单行公式" class="headerlink" title="行内公式和简单单行公式"></a>行内公式和简单单行公式</h2><p>行内公式：</p><pre class="line-numbers language-none"><code class="language-none">系统状态方程 $\dot{x}=Ax$ 的解为 $x=e^Ax(0)$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果：</p><p>系统状态方程 $\dot{x}=Ax$ 的解为 $x=e^Ax(0)$</p><p>简单行间公式：</p><pre class="line-numbers language-none"><code class="language-none">系统状态方程 $\dot{x}=Ax$ 的解为$$x=e^Ax(0)$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果：</p><p>系统状态方程 $\dot{x}=Ax$ 的解为<br>$$<br>x=e^Ax(0)<br>$$<br>Remark：</p><ul><li>在 Typora 中，公式功能需要自行开启</li><li>在 Typora 中，默认是无编号，需要自行开启</li></ul><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><h3 id="简单多行公式"><a href="#简单多行公式" class="headerlink" title="简单多行公式"></a>简单多行公式</h3><p>用法：用两个<code>$$</code> 嵌套，或者使用 <code>\begin{equation}\end{equation}</code></p><p>示例：</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">$$f_1(x)<span class="token function selector">\\</span> <span class="token comment">% 使用 \\ 换行</span>f_2(x)<span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">Multi1</span><span class="token punctuation">}</span><span class="token comment">% 设置 label 是为了方便引用</span><span class="token equation string">$$$$</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">equation</span><span class="token punctuation">}</span>f_1(x)<span class="token function selector">\\</span>f_2(x)<span class="token function selector">\notag</span><span class="token comment">% \notag 取消编号</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">equation</span><span class="token punctuation">}</span>$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果<br>$$<br>f_1(x)\<br>f_2(x)\label{Multi1}<br>$$</p><p>$$<br>\begin{equation}<br>f_1(x)\<br>f_2(x)\notag<br>\end{equation}<br>$$</p><p>Remark:</p><ul><li>设置 label 可以很方便的引用公式，使用 <code>\eqref{}</code> 引用</li><li><code>\notag</code> 可以取消编号，相应的，<code>\tag{}</code> 可以设置任意的标注内容</li></ul><h3 id="array-环境"><a href="#array-环境" class="headerlink" title="array 环境"></a>array 环境</h3><p><code>array</code> 环境用于简单的多行公式，比式 $\eqref{Multi1}$ 多了一个对对齐选项</p><p>用法：<code>\begin{array}{l}\end{array}</code>，<code>l</code> 为对齐方式。<code>l</code>eft, <code>r</code>ight, <code>c</code>enter</p><p>示例：</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">$$<span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">equation</span><span class="token punctuation">}</span><span class="token function selector">\dot</span><span class="token punctuation">{</span><span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">}</span>=f(<span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>)=<span class="token function selector">\left</span><span class="token function selector">\{</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">array</span><span class="token punctuation">}</span><span class="token punctuation">{</span>ll<span class="token punctuation">}</span> <span class="token comment">% 对齐选项有l/c/r(对应左中右)，需要几列就写几个</span>f_<span class="token punctuation">{</span>1<span class="token punctuation">}</span>(<span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>) <span class="token punctuation">&amp;</span> <span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span> <span class="token function selector">\in</span> S_<span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token function selector">\\</span>f_<span class="token punctuation">{</span>2<span class="token punctuation">}</span>(<span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>) <span class="token punctuation">&amp;</span> <span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span> <span class="token function selector">\in</span> S_<span class="token punctuation">{</span>2<span class="token punctuation">}</span> <span class="token comment">% &amp; 分列，\\ 分行</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">array</span><span class="token punctuation">}</span><span class="token function selector">\right</span>.<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">equation</span><span class="token punctuation">}</span>$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果：<br>$$<br>\begin{equation}<br>\dot{\boldsymbol{x}}=f(\boldsymbol{x})<br>=\left{<br>    \begin{array}{ll}<br>        f_{1}(\boldsymbol{x}) &amp; \boldsymbol{x} \in S_{1} \<br>        f_{2}(\boldsymbol{x}) &amp; \boldsymbol{x} \in S_{2}<br>    \end{array}\right.<br>\end{equation}<br>$$<br>Remark: </p><ul><li><code>\left\{</code> 和 <code>\right.</code> 用于自适应括号大小，只需要单边括号时，另一侧括号用 <code>.</code> 代替</li><li>大括号在 $\LaTeX$ 中用作参数括号，需要加转义字符 <code>\</code> 使用</li><li><code>array</code> 环境中需要几列就设置几列的对齐方式，使用 <code>&amp;</code> 分列，<code>\\</code> 分行</li><li><code>\boldsymbol{}</code> 用于粗体数学符号</li><li><code>array</code> 也用于矩阵输入，但矩阵现多使用 <code>matrix</code> 环境</li></ul><h3 id="aligned-环境"><a href="#aligned-环境" class="headerlink" title="aligned 环境"></a>aligned 环境</h3><p><code>aligned</code> 环境用于需要设置对齐点的多行公式</p><p>用法：<code>\begin{aligned}\end{ailgned}</code></p><p>示例：</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">$$<span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">equation</span><span class="token punctuation">}</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">aligned</span><span class="token punctuation">}</span><span class="token punctuation">&amp;</span><span class="token function selector">\dot</span><span class="token punctuation">{</span><span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">}</span>=A <span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>+B <span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>u<span class="token punctuation">}</span>, <span class="token function selector">\quad</span> <span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>(0)=<span class="token function selector">\boldsymbol</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span>_<span class="token punctuation">{</span>0<span class="token punctuation">}</span><span class="token function selector">\\</span><span class="token comment">% 使用 &amp; 设置对齐点，使用 \\ 分行</span><span class="token punctuation">&amp;</span>y=C x+D u<span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">aligned</span><span class="token punctuation">}</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">equation</span><span class="token punctuation">}</span>$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果：<br>$$<br>\begin{equation}\begin{aligned}<br>&amp;\dot{\boldsymbol{x}}=A \boldsymbol{x}+B \boldsymbol{u}, \quad \boldsymbol{x}(0)=\boldsymbol{x}_{0}\<br>&amp;y=C x+D u<br>\end{aligned}\end{equation}<br>$$<br>Remark:</p><ul><li><p><code>aligned</code> 需要 <code>amsmath</code> 宏包支持，现在大部分的引擎都会带有该宏包</p></li><li><p><code>\quad</code> 用于生成空白间距，类似的命令有：<code>\qquad</code> <code>\,</code> <code>\:</code> <code>\;</code> （正间距）<code>\!</code> （负间距）</p></li><li><p>嵌套的 <code>equation</code> 环境是为了生成编号</p></li><li><p>在 $\LaTeX$ 中<code>aligned</code> 是无法单独使用的，必须嵌套在 <code>equation</code> 环境中，在很多其他基于 $TeX$ 的引擎中，都默认省去了 <code>equation</code> 环境，任何行间公式都是当做 <code>equaiton</code> 环境处理，所以会出现 <code>aligned</code> 能够单独使用的情况，但是在需要编号的时候，<code>aligned</code> 是无法自动生成编号的，这是可以嵌套一个 <code>equation</code> 环境来生成编号</p></li></ul><h2 id="简单宏定义"><a href="#简单宏定义" class="headerlink" title="简单宏定义"></a>简单宏定义</h2><p>宏定义能够实现自定义算符、简化过于冗长的命令</p><p>自定义命令用法：<code>\newcommand\定义命令[参数个数]{内容}</code>（内容中用 #1, #2, #3 … 来设置形参）</p><p>自定义算符用法：<code>\DeclareMathOperator{\定义命令}{算符}</code></p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">$$\newcommand{\bx}{\boldsymbol{x}} \notag\DeclareMathOperator{\sign}{sign}$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果：$\sign{x},\bx$ (<code>\sign{x},\bx</code>)</p><p>Remark:</p><ul><li>声明需在文章最开头设置</li><li>在 Typora 中，如果公式渲染异常，可以再编辑中找到刷新公式</li></ul><h2 id="公式识别问题"><a href="#公式识别问题" class="headerlink" title="公式识别问题"></a>公式识别问题</h2><p>[Mathpix][] 提供 $\LaTeX$ 公式识别，准确度很高，每月 50 次免费，推荐注册可以获得 50-200 次额外次数，API 可以获得没有 1000 次，日常使用是足够了。</p><p><img src="https://img-blog.csdnimg.cn/20200316163542293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1MzM1MDI2MQ==,size_16,color_FFFFFF,t_70" alt="Mathpix识别效果"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>文章简单介绍了几个多行公式的实现，这里再贴出几个文档，以飨读者：</p><p>MathJax参考文档：<a href="http://docs.mathjax.org/en/latest/">http://docs.mathjax.org/en/latest/</a></p><p>LaTeX参考文档：<a href="http://www.ctan.org/pkg/lshort-zh-cn">http://www.ctan.org/pkg/lshort-zh-cn</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown基本语法格式&quot;&gt;&lt;a href=&quot;#Markdown基本语法格式&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法格式&quot;&gt;&lt;/a&gt;Markdown基本语法格式&lt;/h1&gt;&lt;h2 id=&quot;标题：&quot;&gt;&lt;a href=&quot;#标题</summary>
      
    
    
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Markdown" scheme="https://wwy.wwywy.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>游戏程序基础框架实例</title>
    <link href="https://wwy.wwywy.com/posts/2056.html"/>
    <id>https://wwy.wwywy.com/posts/2056.html</id>
    <published>2021-09-20T13:00:00.000Z</published>
    <updated>2022-07-09T16:21:05.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例管理者基类"><a href="#单例管理者基类" class="headerlink" title="单例管理者基类"></a>单例管理者基类</h1><h2 id="不继承自Mono"><a href="#不继承自Mono" class="headerlink" title="不继承自Mono"></a>不继承自Mono</h2><p>1.利用单例模式和泛形去实现模块管理者基类；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">public class SingletonBase&lt;T&gt; where T:new(){    private static T instance;    public static T GetInstance()    {        if (instance == null) instance = new T();        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承自Mono"><a href="#继承自Mono" class="headerlink" title="继承自Mono"></a>继承自Mono</h2><p>1.直接实例化通过生成游戏对象并且附加脚本；<br>2.Awake实例化的话要保证单例的唯一性；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour{    private static T instance;    public static T GetInstance()    {        if (instance == null)        {            GameObject go = new GameObject            {                name = typeof(T).Name,            };            instance = go.AddComponent&lt;T&gt;();            DontDestroyOnLoad(go);        }        return instance;    }    protected virtual void Awake()    {        if (instance == null)        {            instance = this as T;            DontDestroyOnLoad(gameObject);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事件管理者"><a href="#事件管理者" class="headerlink" title="事件管理者"></a>事件管理者</h1><p>1.观察者模式，利用了泛形和委托（事件）<br>2.这里的事件字典只能对付小游戏，大型游戏仍是不够</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public interface IEventInfo { } public class EventInfo : IEventInfo{    public event UnityAction actions;    public EventInfo(UnityAction action)    {        actions += action;    }    public void EventTrigger()    {        actions?.Invoke();    }}public class EventInfo&lt;T&gt; : IEventInfo{    public event UnityAction&lt;T&gt; actions;    public EventInfo(UnityAction&lt;T&gt; action)    {        actions += action;    }    public void EventTrigger(T Info)    {        actions?.Invoke(Info);    }}public class EventMgr : SingletonBase&lt;EventMgr&gt;{    //暂时只定义一个字典进行储存，小游戏够用了    private Dictionary&lt;string, IEventInfo&gt; eventDic = new Dictionary&lt;string, IEventInfo&gt;();     public void AddListenter(string name,UnityAction action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions += action;        else eventDic.Add(name,new EventInfo(action));    }    public void AddListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions += action;        else eventDic.Add(name, new EventInfo&lt;T&gt;(action));    }    public void RemoveListenter(string name, UnityAction action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions -= action;    }    public void RemoveListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions -= action;    }    public void EventTrigger(string name)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).EventTrigger();    }    public void EventTrigger&lt;T&gt;(string name,T info)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).EventTrigger(info);    }    public void Clear()    {        eventDic.Clear();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Mono根节点"><a href="#Mono根节点" class="headerlink" title="Mono根节点"></a>Mono根节点</h1><p>1.可以创建一个全局唯一的Mono节点使用<br>2.实现游戏入口继承自该节点即可，但是实现Awake单例</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class MonoRoot : SingletonMono&lt;MonoRoot&gt;{    private event UnityAction updateActions;    protected override void Awake()    {        base.Awake();    }    protected virtual void Update()    {        updateActions?.Invoke();    }    public void AddUpdateListenter(UnityAction updateAction)    {        updateActions += updateAction;    }    public void RemoveUpdateListenter(UnityAction updateAction)    {        updateActions -= updateAction;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="资源加载管理者"><a href="#资源加载管理者" class="headerlink" title="资源加载管理者"></a>资源加载管理者</h1><p>1.资源加载有同步加载和异步加载，异步加载用协程实现<br>2.资源加载管理者包括场景切换，以及配置文件加载</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class ResMgr : SingletonBase&lt;ResMgr&gt;{    #region 资源加载    private Dictionary&lt;string,Object&gt; ObjCacheDic=new Dictionary&lt;string, Object&gt;();    public T LoadObj&lt;T&gt;(string path , bool isIns=true , bool isCache= true ) where T : Object    {        T obj;        if (ObjCacheDic.TryGetValue(path, out Object cacheObj)) obj = cacheObj as T;        else         {            obj = Resources.Load&lt;T&gt;(path);            if (isCache) ObjCacheDic.Add(path, obj);        };        if (obj is GameObject &amp;&amp; isIns) return GameObject.Instantiate(obj);        else return obj;    }    public void LoadObjAsyn&lt;T&gt;(string path,UnityAction&lt;T&gt; callback, bool isIns = true, bool isCache = true) where T : Object    {        if (ObjCacheDic.TryGetValue(path, out Object obj))        {            if (obj is GameObject &amp;&amp; isIns)                callback(GameObject.Instantiate(obj) as T);            else                callback(obj as T);        }        else MonoRoot.GetInstance().StartCoroutine(ReallyLoadObjAsyn(path, callback, isIns, isCache));    }    public IEnumerator ReallyLoadObjAsyn&lt;T&gt;(string path, UnityAction&lt;T&gt; callback, bool isIns, bool isCache) where T : Object    {        ResourceRequest r = Resources.LoadAsync&lt;T&gt;(path);        yield return r;        if(isCache) ObjCacheDic.Add(path, r.asset);        if (r.asset is GameObject &amp;&amp; isIns)            callback(GameObject.Instantiate(r.asset) as T);        else            callback(r.asset as T);    }    #endregion        #region 场景切换    public void LoadScene(string name, UnityAction fun)    {        //场景同步加载        SceneManager.LoadScene(name);        //加载完成过后 才会去执行fun        fun();    }    public void LoadSceneAsyn(string name, UnityAction fun)    {        MonoRoot.GetInstance().StartCoroutine(ReallyLoadSceneAsyn(name, fun));    }    public IEnumerator ReallyLoadSceneAsyn(string name, UnityAction fun)    {        AsyncOperation op = SceneManager.LoadSceneAsync(name);        while (!op.isDone)        {            //这里可以去做一些事情，例如更新进度条            //EventMgr.GetInstance().EventTrigger("更新进度条", op.progress);            yield return op.progress;        }        //加载完成过后 才会去执行fun        fun();    }     #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="缓存池管理者"><a href="#缓存池管理者" class="headerlink" title="缓存池管理者"></a>缓存池管理者</h1><p>1.用一个类类型去包装缓存队列，这个类里面应该封装了获取和设置缓存对象的方法<br>2.缓存池目前只支持预制物的缓存</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PoolMgr :SingletonBase&lt;PoolMgr&gt; {    private Dictionary&lt;string, PoolData&gt; poolDic=new Dictionary&lt;string, PoolData&gt;();    private GameObject poolRoot;    public void GetObj(string name, UnityAction&lt;GameObject&gt; callBack)    {        if(poolDic.TryGetValue(name, out PoolData poolData) &amp;&amp; poolData.Count &gt; 0)        {            callBack(poolData.GetObj());        }        else        {            //创建资源应使用资源路径            ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(name, (go) =&gt;{                go.name = name;                callBack(go);            });        }    }    public void PushObj(string name,GameObject obj)    {        if(poolRoot=null)poolRoot=new GameObject("PoolRoot");        if(poolDic.TryGetValue(name,out PoolData poolData)) poolData.PushObj(obj);        else poolDic.Add(name, new PoolData(obj,poolRoot));    }    public void  Clear()    {        poolDic.Clear();        poolRoot = null;    }}public class PoolData{    private GameObject parentRoot;    private Queue&lt;GameObject&gt; objQue;    public PoolData(GameObject obj,GameObject poolObj)    {        parentRoot = new GameObject($"{obj.name}Root");        parentRoot.transform.parent = poolObj.transform;        objQue = new Queue&lt;GameObject&gt;();    }    public int Count    {        get { return objQue.Count; }    }    public void PushObj(GameObject obj)    {        //存起来        objQue.Enqueue(obj);        //失活 让其隐藏        obj.SetActive(false);        //设置父对象        obj.transform.parent = parentRoot.transform;    }    public GameObject GetObj()    {        //取出第一个        GameObject obj = objQue.Dequeue();        //激活 让其显示        obj.SetActive(true);        //断开了父子关系        obj.transform.parent = null;        return obj;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="输入管理者"><a href="#输入管理者" class="headerlink" title="输入管理者"></a>输入管理者</h1><p>1.输入管理者耦合事件监听和Mono根节点</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class InputMgr : SingletonBase&lt;InputMgr&gt;{    private bool isStart = false;    public InputMgr()    {        MonoMgr.GetInstance().AddUpdateListener(UpdateIpt);    }    public void StartOrEndCheck(bool isOpen)    {        isStart = isOpen;    }    private void CheckKeyCode(KeyCode key)    {        //事件中心模块 分发按下抬起事件        if (Input.GetKeyDown(key))            EventCenter.GetInstance().EventTrigger("某键按下", key);        //事件中心模块 分发按下抬起事件        if (Input.GetKeyUp(key))            EventCenter.GetInstance().EventTrigger("某键抬起", key);    }    private void UpdateIpt()    {        //没有开启输入检测 就不去检测 直接return        if (!isStart)            return;        CheckKeyCode(KeyCode.W);        CheckKeyCode(KeyCode.S);        CheckKeyCode(KeyCode.A);        CheckKeyCode(KeyCode.D);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="音效管理者"><a href="#音效管理者" class="headerlink" title="音效管理者"></a>音效管理者</h1><p>1.一般音效资源应该做缓存池处理</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class MusicMgr : MonoBehaviour{    private bool isMute = false;    //背景音乐源    private AudioSource bkSource;    //背景音乐大小    private float bkValue = 1;    //一般音乐列表    private List&lt;AudioSource&gt; sourceLst = new List&lt;AudioSource&gt;();    //背景音乐大小    private float soundValue = 1;    //音乐源节点    private GameObject musicRoot;    public MusicMgr()    {        MonoMgr.GetInstance().AddUpdateListener(UpdateMsc);    }    //音乐播放完就回收    private void UpdateMsc()    {        for (int i = sourceLst.Count - 1; i &gt;= 0; --i)        {            if (!sourceLst[i].isPlaying)            {                GameObject.Destroy(sourceLst[i]);                sourceLst.RemoveAt(i);            }        }    }    public void PlayBkMusic(string name)    {        if(!musicRoot) musicRoot=new GameObject("MusicRoot");        if (bkSource) bkSource = musicRoot.AddComponent&lt;AudioSource&gt;();        //异步加载背景音乐 加载完成后 播放        ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;("Music/BK/" + name, (clip) =&gt;        {            bkSource.clip = clip;            bkSource.loop = true;            bkSource.volume = bkValue;            bkSource.Play();        });    }    public void PauseBKMusic()    {        bkSource?.Pause();    }    public void StopBKMusic()    {        bkSource?.Stop();    }    public void ChangeBKValue(float v)    {        bkValue = v;        if (bkSource == null) bkSource.volume = bkValue;    }    public void PlaySound(string name, bool isLoop=false, GameObject parent=null, UnityAction&lt;AudioSource&gt; callBack = null)    {        if (!musicRoot) musicRoot = new GameObject("MusicRoot");        //当音效资源异步加载结束后 再添加一个音效        ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;("Music/Sound/" + name, (clip) =&gt;        {            AudioSource source;            if (parent) source=parent.AddComponent&lt;AudioSource&gt;();            else source = musicRoot.AddComponent&lt;AudioSource&gt;();            source.clip = clip;            source.loop = isLoop;            source.volume = soundValue;            source.Play();            sourceLst.Add(source);            if (callBack != null)                callBack(source);        });    }    public void ChangeSoundValue(float value)    {        soundValue = value;        for (int i = 0; i &lt; sourceLst.Count; ++i)            sourceLst[i].volume = value;    }    public void StopSound(AudioSource source)    {        if (sourceLst.Contains(source))        {            sourceLst.Remove(source);            source.Stop();            GameObject.Destroy(source);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="UI管理者和UI面板基类"><a href="#UI管理者和UI面板基类" class="headerlink" title="UI管理者和UI面板基类"></a>UI管理者和UI面板基类</h1><h2 id="面板基类"><a href="#面板基类" class="headerlink" title="面板基类"></a>面板基类</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class BasePanel : MonoBehaviour{    //通过里式转换原则 来存储所有的控件    private Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt; controlDic = new Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt;();    protected virtual void Awake()    {        FindChildrenControl&lt;Button&gt;();        FindChildrenControl&lt;Image&gt;();        FindChildrenControl&lt;Text&gt;();        FindChildrenControl&lt;Toggle&gt;();        FindChildrenControl&lt;Slider&gt;();        FindChildrenControl&lt;ScrollRect&gt;();        FindChildrenControl&lt;InputField&gt;();    }    public virtual void ShowMe()    {    }    public virtual void HideMe()    {    }    protected virtual void OnClick(string btnName)    {    }    protected virtual void OnValueChanged(string toggleName, bool value)    {    }    protected T GetControl&lt;T&gt;(string controlName) where T : UIBehaviour    {        if (controlDic.ContainsKey(controlName))        {            for (int i = 0; i &lt; controlDic[controlName].Count; ++i)            {                if (controlDic[controlName][i] is T)                    return controlDic[controlName][i] as T;            }        }        return null;    }    private void FindChildrenControl&lt;T&gt;() where T : UIBehaviour    {        T[] controls = this.GetComponentsInChildren&lt;T&gt;();        for (int i = 0; i &lt; controls.Length; ++i)        {            string objName = controls[i].gameObject.name;            if (controlDic.ContainsKey(objName))                controlDic[objName].Add(controls[i]);            else                controlDic.Add(objName, new List&lt;UIBehaviour&gt;() { controls[i] });            //如果是按钮控件            if (controls[i] is Button)            {                (controls[i] as Button).onClick.AddListener(() =&gt;                {                    OnClick(objName);                });            }            //如果是单选框或者多选框            else if (controls[i] is Toggle)            {                (controls[i] as Toggle).onValueChanged.AddListener((value) =&gt;                {                    OnValueChanged(objName, value);                });            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="UI管理者"><a href="#UI管理者" class="headerlink" title="UI管理者"></a>UI管理者</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class UIMgr : SingletonBase&lt;UIMgr&gt;{    public Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;();    private Transform bot;    private Transform mid;    private Transform top;    private Transform system;    //记录我们UI的Canvas父对象 方便以后外部可能会使用它    public RectTransform canvas;    public UIMgr()    {        //创建Canvas 让其过场景的时候 不被移除        GameObject obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;("UI/Canvas");        canvas = obj.transform as RectTransform;        GameObject.DontDestroyOnLoad(obj);        //找到各层        bot = canvas.Find("Bot");        mid = canvas.Find("Mid");        top = canvas.Find("Top");        system = canvas.Find("System");        //创建EventSystem 让其过场景的时候 不被移除        obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;("UI/EventSystem");        GameObject.DontDestroyOnLoad(obj);    }    /// &lt;summary&gt;    /// 通过层级枚举 得到对应层级的父对象    /// &lt;/summary&gt;    /// &lt;param name="layer"&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public Transform GetLayerFather(EUIayer layer)    {        switch (layer)        {            case EUIayer.Bot:                return this.bot;            case EUIayer.Mid:                return this.mid;            case EUIayer.Top:                return this.top;            case EUIayer.System:                return this.system;        }        return null;    }    /// &lt;summary&gt;    /// 显示面板    /// &lt;/summary&gt;    /// &lt;typeparam name="T"&gt;面板脚本类型&lt;/typeparam&gt;    /// &lt;param name="panelName"&gt;面板名&lt;/param&gt;    /// &lt;param name="layer"&gt;显示在哪一层&lt;/param&gt;    /// &lt;param name="callBack"&gt;当面板预设体创建成功后 你想做的事&lt;/param&gt;    public void ShowPanel&lt;T&gt;(string panelName, EUIayer layer = EUIayer.Mid, UnityAction&lt;T&gt; callBack = null) where T : BasePanel    {        if (panelDic.ContainsKey(panelName))        {            panelDic[panelName].ShowMe();            // 处理面板创建完成后的逻辑            if (callBack != null)                callBack(panelDic[panelName] as T);            //避免面板重复加载 如果存在该面板 即直接显示 调用回调函数后  直接return 不再处理后面的异步加载逻辑            return;        }        ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;("UI/" + panelName, (obj) =&gt;        {            //把他作为 Canvas的子对象            //并且 要设置它的相对位置            //找到父对象 你到底显示在哪一层            Transform father = bot;            switch (layer)            {                case EUIayer.Mid:                    father = mid;                    break;                case EUIayer.Top:                    father = top;                    break;                case EUIayer.System:                    father = system;                    break;            }            //设置父对象  设置相对位置和大小            obj.transform.SetParent(father);            obj.transform.localPosition = Vector3.zero;            obj.transform.localScale = Vector3.one;            (obj.transform as RectTransform).offsetMax = Vector2.zero;            (obj.transform as RectTransform).offsetMin = Vector2.zero;            //得到预设体身上的面板脚本            T panel = obj.GetComponent&lt;T&gt;();            // 处理面板创建完成后的逻辑            if (callBack != null)                callBack(panel);            panel.ShowMe();            //把面板存起来            panelDic.Add(panelName, panel);        });    }    /// &lt;summary&gt;    /// 隐藏面板    /// &lt;/summary&gt;    /// &lt;param name="panelName"&gt;&lt;/param&gt;    public void HidePanel(string panelName)    {        if (panelDic.ContainsKey(panelName))        {            panelDic[panelName].HideMe();            GameObject.Destroy(panelDic[panelName].gameObject);            panelDic.Remove(panelName);        }    }    /// &lt;summary&gt;    /// 得到某一个已经显示的面板 方便外部使用    /// &lt;/summary&gt;    public T GetPanel&lt;T&gt;(string name) where T : BasePanel    {        if (panelDic.ContainsKey(name))            return panelDic[name] as T;        return null;    }    /// &lt;summary&gt;    /// 给控件添加自定义事件监听    /// &lt;/summary&gt;    /// &lt;param name="control"&gt;控件对象&lt;/param&gt;    /// &lt;param name="type"&gt;事件类型&lt;/param&gt;    /// &lt;param name="callBack"&gt;事件的响应函数&lt;/param&gt;    public static void AddCustomEventListener(UIBehaviour control, EventTriggerType type, UnityAction&lt;BaseEventData&gt; callBack)    {        EventTrigger trigger = control.GetComponent&lt;EventTrigger&gt;();        if (trigger == null)            trigger = control.gameObject.AddComponent&lt;EventTrigger&gt;();        EventTrigger.Entry entry = new EventTrigger.Entry();        entry.eventID = type;        entry.callback.AddListener(callBack);        trigger.triggers.Add(entry);    }}/// &lt;summary&gt;/// UI层级/// &lt;/summary&gt;public enum EUIayer{    Bot,    Mid,    Top,    System,}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例管理者基类&quot;&gt;&lt;a href=&quot;#单例管理者基类&quot; class=&quot;headerlink&quot; title=&quot;单例管理者基类&quot;&gt;&lt;/a&gt;单例管理者基类&lt;/h1&gt;&lt;h2 id=&quot;不继承自Mono&quot;&gt;&lt;a href=&quot;#不继承自Mono&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-Addressables</title>
    <link href="https://wwy.wwywy.com/posts/1549.html"/>
    <id>https://wwy.wwywy.com/posts/1549.html</id>
    <published>2021-08-21T13:00:00.000Z</published>
    <updated>2022-07-09T16:17:35.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Addressables概述"><a href="#Addressables概述" class="headerlink" title="Addressables概述"></a>Addressables概述</h1><p>1.Addressables说明：Addressables是基于AssetBundle架构做的高阶流程，目的是实现资源自动化管理，Addressables翻译过来是可寻址的意思，它是可寻址资源管理系统，是Unity从2018.2版本开始，建议用于替代AssetBundle的高阶资源管理系统，在之后的Unity的新版本中，AssetBundle将渐渐被淘汰；</p><p>2.Addressables的优点：</p><ul><li>自动化管理AB包打包、发布、加载；</li><li>可以更方便的进行本地、远程资源的加载；</li><li>系统会自动处理资源关联性；</li><li>内存管理更方便；</li><li>迭代更方便；</li></ul><p>3.Addressables使用方法：</p><ul><li>导入包：在Package Manager中导入该包；</li><li>创建配置文件：在Window找到Addressables中的Groups点击创建配置文件，或者直接在Inspector窗口勾选Addressable就会自动创建；</li></ul><h1 id="资源加载基础"><a href="#资源加载基础" class="headerlink" title="资源加载基础"></a>资源加载基础</h1><h2 id="寻址资源设置"><a href="#寻址资源设置" class="headerlink" title="寻址资源设置"></a>寻址资源设置</h2><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.让资源变为可寻址资源:        //方法一：选中资源，勾选Inspector窗口中的Addressable        //方法二：选中资源，拖入Addressables Groups窗口中        //注意：        //1.C#代码无法作为可寻址资源        //2.Resources文件夹下资源如果变为寻址资源，会移入Resources_moved文件夹中        //  原因：Resources文件夹下资源会最终打包出去，如果变为可寻址资源意味着想通过Addressables进行管理        //  那么它就没有必要通过Resources方式去加载和打包，所以会自动迁移，避免重复打包，浪费空间        //3.右键选择资源时菜单内容        //Move Addressables to Group：将该资源放入到现有的另一个组中        //Move Addressables to New Gourp：使用与当前组相同设置创建一个新租，并将该资源放入该新组中        //Rmove Addressables：移除资源，该资源会变为不可寻址资源        //Simplify Addressable Names：简化可寻址资源名，会删除名称中的路径和拓展，简化缩短名称        //Copy Address to Clipboard：将地址复制到剪贴板        //Change Address：改名        //Create New Group：创建新租2.资源组窗口讲解:(1).资源信息（关键）        //1.GroupName\Addressable Name：分组名\可寻址名（可重名，描述资源）        //2.Path：路径（不可重复，资源定位）        //3.Labels：标签（可重复、可用于区分资源种类，例如青铜装备、黄金装备）(2).创建分组相关        //Create——&gt;Group        //Packed Assets:打包资源分组        //Blank(no schema):空白（无架构）        //区别：Packed Assets默认自带默认打包加载相关设置信息，Blank没有相关信息需要自己关联        //组对于我们来说意义重大，之后在资源打包时，一个组可以作为一个或多个AB包        //关于组设置相关信息，之后详细讲解(3).选中某一组后右键        //Remove Group(s):移除组，组中所有资源恢复为不可寻址资源        //Simplify Addressable Names:简化可寻址名称，会删除名称中的路径和拓展，简化缩短名称        //Set as Default:设置为默认组，当直接勾选资源中的Addressable时，会自动加入该组        //Inspect Group Setting:快速选中关联的组相关配置文件        //Rename:重命名        //Create New Group:创建新组(4).配置概述相关        //Manage Profiles：管理配置文件        //可以配置打包目标、本地远程的打包加载路径等等信息（之后再详细讲解）(5).Tools工具相关        //Inspect System Settings：检查系统设置        //Check for content Update Restrictions:检查内容更新限制        //Window：打开Addressables相关窗口        //Groups View：分组视图相关        //  Show Sprite and Subobject Addressable：显示可寻址对象的精灵和子对象，一般想要看到图集资源内内容时可以勾选该选项        //  Group Hierarchy with Dashes：带破折号的组层次结构(6).Play Mode Script播放模式脚本（编辑模式下如何运行）        //确定在编辑器播放模式下运行游戏时，可寻址系统如何访问可寻址资源        //Use Asset Database（fastest）：        //使用资源数据库（最快的），一般在开发阶段使用，使用此选项时，您不必打包可寻址内容，它会直接使用文件夹中的资源        //在实际开发时，可以不使用这种模式，这种模式没有测试的意义        //Simulate Groups（advanced）：        //模拟组（后期），一般在测试阶段使用，分析布局和依赖项的内容，而不创建AB包        //通过ResourceManager从资产数据库加载资产，就像通过AB包加载一样        //通过引入时间延迟，模拟远程资产绑定的下载速度和本地绑定的文件加载速度        //在开发阶段可以使用这个模式来进行资源加载        //Use Existing Build（requires built groups）：        //正儿八经的从AB包加载资源        //使用现有AB包（需要构建AB包），一般在最终发布测试阶段使用        //从早期内容版本创建的AB包加载资产        //在使用此选项之前，必须使用生成脚本（如默认生成脚本）打包资源        //远程内容必须托管在用于生成内容的配置文件的RemoteLoadPath上(7).Build（构建打包相关）        //New Build：构建AB包资源（相当于打包资源分组）        //Update a Previour Build：更新以前的版本        //Clean Build：清空之前的构建资源3.资源名注意事项:        //1.资源路径一定不允许相同（后缀不同，名字相同可以）        //2.资源名我们可以随意修改        //3.之后在加载资源时我们可以使用名字和标签作为双标识加载指定资源        //4.我们可以按规则将资源进行分组,比如：角色、装备、怪物、UI等等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指定资源加载（不常用）"><a href="#指定资源加载（不常用）" class="headerlink" title="指定资源加载（不常用）"></a>指定资源加载（不常用）</h2><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.Addressables中的资源标识类        //AssetReference                通用资源标识类 可以用来加载任意类型资源        //AssetReferenceAtlasedSprite   图集资源标识类        //AssetReferenceGameObject      游戏对象资源标识类        //AssetReferenceSprite          精灵图片资源标识类        //AssetReferenceTexture         贴图资源标识类        //AssetReferenceTexture2D        //AssetReferenceTexture3D        //AssetReferenceT&lt;&gt;             指定类型标识类        //通过不同类型标识类对象的申明 我们可以在Inspector窗口中筛选关联的资源对象2.加载资源        //注意：所有Addressables加载相关都使用异步加载        //需要引用命名空间：using UnityEngine.ResourceManagement.AsyncOperations;        //AsyncOperationHandle&lt;GameObject&gt; handle = assetReference.LoadAssetAsync&lt;GameObject&gt;();        //加载成功后使用        //1.通过事件函数传入的参数判断加载是否成功 并且创建        //2.通过资源标识类对象判断 并且创建        //一步到位，通过异步加载返回值 对完成进行事件监听        assetReference.LoadAssetAsync&lt;GameObject&gt;().Completed += (handle) =&gt;        {            //使用传入的参数（建议）            //判断是否加载成功            if (handle.Status == AsyncOperationStatus.Succeeded)            {                GameObject cube = Instantiate(handle.Result);                //一定资源加载过后 使用完后 再去释放                assetReference.ReleaseAsset();            }                       //使用标识类创建,现在不推荐            //if(assetReference.IsDone)Instantiate(assetReference.Asset);        };3.加载场景        sceneReference.LoadSceneAsync().Completed += (handle) =&gt;        {            //初始化场景的一些信息，和资源加载相同            print("场景加载结束");        };4.释放资源        //释放资源相关API        //ReleaseAsset        //写在外部是不合理的，一般写在加载字资源后        //assetReference.ReleaseAsset();        //1.释放资源方法后,资源标识类中的资源会置空，但是AsyncOperationHandle类中的对象不为空        //2.释放资源不会影响场景中被实例化出来的对象，但是会影响使用的资源，例如贴图等，和AssetBundle是一样的；        5.直接实例化对象        //只适用于 想要实例化的 对象 才会直接使用该方法 一般都是GameObject预设体        gameobjcetReference.InstantiateAsync();        6.自定义标识类        //自定义类 继承AssetReferenceT&lt;Material&gt;类 即可自定义一个指定类型的标识类        //该功能主要用于Unity2020.1之前，因为之前的版本不能直接使用AssetReferenceT泛型字段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h2><p>1.Label标签的作用：可以在寻址资源设置中，为相同作用的资源（模型、贴图、材质、UI等），我们可以让他们的资源名相同，通过标签Label区分他们来加载使用；</p><p>2.Label标签特性约束：通过特性[AssetReferenceUILabelRestriction()]来约束资源，里面可以填多个标签名；</p><h2 id="动态加载资源"><a href="#动态加载资源" class="headerlink" title="动态加载资源"></a>动态加载资源</h2><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.通过资源名或标签名动态加载单个资源        //命名空间：        //UnityEngine.AddressableAssets 和 UnityEngine.ResourceManagement.AsyncOperations                //参数名可以是资源名也可以是标签名        Addressables.LoadAssetAsync&lt;GameObject&gt;("Red").Completed += (handle) =&gt;        {            //判断加载成功            if (handle.Status == AsyncOperationStatus.Succeeded)                Instantiate(handle.Result);            //一定要是 加载完成后 使用完毕后 再去释放            //需要指定要释放哪一个返回值,不管任何资源 只要释放后 都会影响之前在使用该资源的对象            Addressables.Release(handle);        };        //注意：        //1.如果存在同名或同标签的同类型资源，我们无法确定加载的哪一个，它会自动加载找到的第一个满足条件的对象        //2.如果存在同名或同标签的不同类型资源，我们可以根据泛型类型来决定加载哪一个2.根据资源名或标签名加载多个对象        //加载资源        //参数一：资源名或标签名        //参数二：加载结束后的回调函数        //参数三：如果为true表示当资源加载失败时，会自动将已加载的资源和依赖都释放掉；如果为false，需要自己手动来管理释放        AsyncOperationHandle&lt;IList&lt;Object&gt;&gt; handle = Addressables.LoadAssetsAsync&lt;Object&gt;("Red", (obj) =&gt;        {            //释放资源            Addressables.Release(obj);        });3.根据多种信息加载对象        //参数一：想要加载资源的条件列表（资源名、Lable名）        //参数二：每个加载资源结束后会调用的函数，会把加载到的资源传入该函数中        //参数三：可寻址的合并模式，用于合并请求结果的选项。        //如果键（Cube，Red）映射到结果（[1,2,3]，[1,3,4]），数字代表不同的资源        //None：不发生合并，将使用第一组结果 结果为[1,2,3]        //UseFirst：应用第一组结果 结果为[1,2,3]        //Union：合并所有结果 结果为[1,2,3,4]        //Intersection：使用相交结果 结果为[1,3]        //参数四：如果为true表示当资源加载失败时，会自动将已加载的资源和依赖都释放掉        //      如果为false，需要自己手动来管理释放        List&lt;string&gt; strs = new List&lt;string&gt;() { "Cube", "HD" };        Addressables.LoadAssetsAsync&lt;Object&gt;(strs, (obj) =&gt; {            print(obj.name);        }, Addressables.MergeMode.Intersection);4.动态加载场景        //参数一：场景名        //参数二：加载模式 （叠加还是单独,叠加就是两个场景一起显示,单独就是只保留新加载的场景，正常情况为单独）        //参数三：场景加载是否激活，如果为false，加载完成后不会直接切换，需要自己使用返回值中的ActivateAsync方法        //参数四：场景加载的异步操作优先级        Addressables.LoadSceneAsync("SampleScene", UnityEngine.SceneManagement.LoadSceneMode.Single, false).Completed += (obj)=&gt; {            //比如说 手动激活场景            obj.Result.ActivateAsync().completed += (a) =&gt;            {                //然后再去创建场景上的对象                //然后再去隐藏 加载界面                //注意：场景资源也是可以释放的，并不会影响当前已经加载出来的场景，因为场景的本质只是配置文件                Addressables.Release(obj);            };        };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h1><h2 id="Profile概述配置窗口"><a href="#Profile概述配置窗口" class="headerlink" title="Profile概述配置窗口"></a>Profile概述配置窗口</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Profiles窗口打开方式        //方法一：Window <span class="token operator">&gt;</span> Asset Management <span class="token operator">&gt;</span> Addressables <span class="token operator">&gt;</span> Profiles        //方法二：在AddressableAssetSettings中打开        //方法三：在Addressables Groups窗口中打开<span class="token number">2</span>.Profiles窗口参数相关<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>.右侧BuildTarget：构建目标，可以在这里设置是哪个平台，默认是你激活哪个平台就是哪个平台LocalBuildPath：本地构建路径，默认在项目的Library库文件夹中LocalLoadPath：本地加载路径，在哪里加载本地已有的资源RemoteBuildPath：远程构建路径RemoteLoadPath：远程加载路径，在哪里下载远程内容和目录<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>.左侧Profile：概述文件Variable：变量（所有概述文件通用）Build Load Path Variables：构建加载路径变量（所有概述文件通用）<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>.注意：<span class="token number">1</span>.一般情况下，不要去修改本地构建和加载路径默认值<span class="token number">2</span>.当我们针对不同平台远程分发内容时，通过多个配置文件最方便。如果你想要最终的发布包包含所有内容，那么一个默认配置就够了<span class="token number">3</span>.Profiles变量语法        //所有的变量类型都是string字符串类型        //你可以在其中填写一些固定的路径或值来决定路径        //还可以使用两个语法指示符让原本的静态属性变成动态属性        //<span class="token punctuation">[</span><span class="token punctuation">]</span>:方括号，可以使用它包裹变量，在打包构建时会计算方括号包围的内容        //比如        //使用自己的变量<span class="token punctuation">[</span>BuildTarget<span class="token punctuation">]</span>        //使用别的脚本中变量<span class="token punctuation">[</span>UnityEditor.EditorUserBuildSettings.activeBuildTarget<span class="token punctuation">]</span>        //在打包构建时，会使用方括号内变量对应的字符串拼接到目录中        //<span class="token punctuation">{</span><span class="token punctuation">}</span>:大括号，可以使用它包裹变量，在运行时会计算大括号包围的内容        //比如        //使用别的脚本中变量<span class="token punctuation">{</span>UnityEngine.AddressableAssets.Addressables.RuntimePath<span class="token punctuation">}</span>        //注意：方括号和大括号中使用的变量一定是静态变量或者属性。名称、类型、命名空间必须匹配        //比如在运行时 UnityEditor编辑器命名空间下的内容是不能使用的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Addressables-Hosting可寻址托管窗口"><a href="#Addressables-Hosting可寻址托管窗口" class="headerlink" title="Addressables Hosting可寻址托管窗口"></a>Addressables Hosting可寻址托管窗口</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Addressables Hosting可寻址托管窗口的作用        //一般资源服务器需要将其搭建为http服务器        //这样才能进行资源的上传和下载        //而Unity为了简化本地测试的这一过程        //提供了快捷搭建http服务器的工具        // Addressables Hosting 窗口        //通过它我们可以将我们的本机模拟为一台远端服务器来进行远端发布加载测试        //可以帮助我们快速的进行远程打包下载的相关测试        //简单理解就是把本机作为一台资源服务器<span class="token number">2</span>.打开可寻址托管窗口        //方法一：Window <span class="token operator">&gt;</span> Asset Management <span class="token operator">&gt;</span> Addressables <span class="token operator">&gt;</span> Hosting        //方法二：Addressables Groups窗口中 <span class="token operator">&gt;</span> Tools <span class="token operator">&gt;</span> Window <span class="token operator">&gt;</span> Hosting Services<span class="token number">3</span>.可寻址托管窗口参数<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>.左边区域：Local Hosting：本地托管，通过本机模拟加载相关内容Custom Service：自定义服务<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>.右边区域:Service Name：服务器名称Service Type（ID）：服务器类型Port：端口号（一般不自己设置，避免和其它应用产生冲突）Upload Speed（kb/s）：上载速度Enable：是否启用，启用后会自动分配端口号Hosting Service Variables-托管服务变量<span class="token punctuation">(</span>IP地址、端口号等，我们可以使用这些变量名来编辑Addressables Profiles中的发布和加载相关路径，如http://<span class="token punctuation">[</span>PrivateIpAddress<span class="token punctuation">]</span>:<span class="token punctuation">[</span>HostingServicePort<span class="token punctuation">]</span>/<span class="token punctuation">[</span>BuildTarget<span class="token punctuation">]</span><span class="token punctuation">)</span>：Variable Name：变量名Value：值<span class="token number">4</span>.注意事项        //Addressable Hosting窗口创建的本地服务器有时候会失效        //可以在资料区下载第三方工具 让本机变为一个http服务器 模拟远端加载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事件查看窗口"><a href="#事件查看窗口" class="headerlink" title="事件查看窗口"></a>事件查看窗口</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.事件查看查看说明        //使用可寻址事件查看窗口可以监视可寻址资源的资源内存管理        //该窗口        //1.显示应用程序何时加载和卸载资源        //2.显示所有可寻址系统操作的引用计数        //3.显示应用程序帧率和分配的内存总量近似图        //我们可以通过它来检查可寻址资源对性能的影响        //并检查没有释放的资源<span class="token number">2</span>.打开事件查看窗口        //注意：使用事件查看窗口的前提要打开AddressablesAssetSettings配置文件中的事件发送开关        //1.Window <span class="token operator">&gt;</span> Asset Management <span class="token operator">&gt;</span> Addressables <span class="token operator">&gt;</span> Event Viewer        //2.Addressabeles Groups <span class="token operator">&gt;</span> Window <span class="token operator">&gt;</span> Event Viewer        <span class="token number">3</span>.事件查看窗口参数<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>.左上角：Clear Event：清楚所有记录的帧，会清空窗口中所有内容；Unhide All Hidden Events：显示你隐藏的所有事件内容（当我们右键一个内容隐藏后才会显示该选项）；<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>.右上角：Frame：显示当前所在帧数；左按钮和右按钮：在记录的帧中前后切换查看信息；Current:选中当前帧；<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>.中央部分：FPS:应用的帧率；MonoHeap：正在使用的托管堆内存量；Event Counts：事件计数，某一帧中发生的可寻址事件的数量；Instantiation Counts:实例化计数，某一帧中Addressables.InstantiateAsync的调用数量；线性图标：显示统计的什么时候加载释放资源的信息；Event 相关：显示当前帧中发生的可寻址操作的事件；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析窗口"><a href="#分析窗口" class="headerlink" title="分析窗口"></a>分析窗口</h2><p><a href="https://docs.unity.cn/Packages/com.unity.addressables@1.18/manual/AnalyzeTool.html">Analyze tool | Addressables | 1.18.19 (unity.cn)</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.分析窗口说明：        //分析窗口是一种收集项目可寻址布局信息的工具        //它是一种信息工具，可以让我们对可寻址文件布局做出更明智的决定<span class="token number">2</span>.打开分析窗口：        //1.Window <span class="token operator">&gt;</span> Asset Management <span class="token operator">&gt;</span> Addressables <span class="token operator">&gt;</span> Analyze        //2.Addressabeles Groups <span class="token operator">&gt;</span> Window <span class="token operator">&gt;</span> Analyze<span class="token number">3</span>.分析窗口参数说明：<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>.上方三个按钮:Analyze Selected Rules：分析选定的规则<span class="token punctuation">;</span>Clear Selected Rules：清除选定规则<span class="token punctuation">;</span>Fix Selected Rules：修复选定规则<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>.下方的内容Analyze Rules（分析规则）a.Fixable Rules-可修复的规则（提供了分析和修复两种功能的规则出现在这里）：Check Duplicate Bundle Dependencies:检查重复的AB包依赖项，比如资源a和b，都使用了材质c，a和b是可寻址资源，c不是可寻址资源，a，b分别在两个AB包中，那么这时两个AB包中都会有资源c，这时就可以通过该规则排查出该问题，那么这时我们可以选择自己重新处理后打包，也可以选择修复功能，建议使用自己处理问题，因为某些特殊情况它也会认为有问题，比如，一个FBX中有多个网格信息a，b，这时我们分别把网格a放入包A，网格b放入包B，它也会认为A和B有重复资源，但其实他们并没有重复；b.Unfixable Rules-不可修复的规则（对于只有分析功能，没有修复功能的规则在这里出现）:Check Resources to Addressable Duplicate Dependencies:检查可寻址重复依赖项的资源,同时出现在可寻址资源和应用程序构建的资源中,比如一个资源A，它是可寻址资源,但是它同时在Resources、StreamingAssets等特殊文件夹中，最终会被打包出去<span class="token punctuation">;</span>Check Scene to Addressable Duplicate Dependencies:检查场景到可寻址重复依赖项,同时出现在可寻址资源和某一个场景中,比如一个资源A，它是可寻址资源但是它有直接出现在某一个场景中,这时你需要自己根据需求进行处理<span class="token punctuation">;</span>Bundle Layout Preview:AB包布局预览<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="构建布局报告"><a href="#构建布局报告" class="headerlink" title="构建布局报告"></a>构建布局报告</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.构建布局报告说明：        //构建布局报告提供了有关可寻址资源的构建打包的详细信息和统计信息        //包括        //1.AB包的描述        //2.每个资源和AB包的大小        //3.解析作为依赖项隐式包含在AB包中的不可寻址资源        //4.AB包的依赖关系        //我们可以通过查看报告文件获取这些信息        <span class="token number">2</span>.如何查看构建布局报告：        //1.启用调试构建布局功能        //Edit <span class="token operator">&gt;</span> Preferences <span class="token operator">&gt;</span> Addressables        //启用Debug Build Layout        //2.只要我们构建打包可寻址资源后        //就可以在Library/com.unity.addressables/文件夹中找到buildlayout.txt文件        <span class="token number">3</span>.构建布局报告的内容：        //内容中主要包含：        //1.摘要信息<span class="token punctuation">(</span>包括AB包数量、大小等等<span class="token punctuation">)</span>        //2.每组相关信息（哪些资源，几个包，包大小等等）        //3.依赖相关信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h1><p>1.配置文件分类：我们在导入Addressables包之后创建的那些就是配置文件，AddressableAssetsData文件夹下的内容都是本质为ScriptableObject的数据配置文件，他们会影响我们的打包方式等等相关内容；</p><ul><li>AssetGroups(资源组)：当我们创建一个组就会多一些相关数据配置文件</li><li>AssetGroupTemplates：资源组模板，主要是对资源组的一些默认设置，可以自己创建模板在Project窗口右键或者点击+号，Create(创建)——&gt;Addressables(可寻址)——&gt;Group Templates(组模板)——&gt;Blank Group Template(空白组模板)；<ul><li>Packed Assets：默认的打包资源数据配置模板；</li></ul></li><li>DataBuilders：数据生成器，这些内容决定了在不同模式下，资源打包和使用的方式；<ul><li>BuildScriptFastMode：构建脚本快速模式 ；</li><li>BuildScriptPackedMode：构建脚本打包模式；</li><li>BuildScriptPackedPlayMode：构建脚本打包播放模式；</li><li>BuildScriptVirtualMode：构建脚本虚拟模式；</li></ul></li><li>AddressableAssetSettings：可寻址资源设置，该配置文件可以设置一些可寻址资源的一些公共设置；</li><li>DefaultObject：默认对象；</li></ul><h2 id="AddressableAssetSetting配置（可寻址资源设置）"><a href="#AddressableAssetSetting配置（可寻址资源设置）" class="headerlink" title="AddressableAssetSetting配置（可寻址资源设置）"></a>AddressableAssetSetting配置（可寻址资源设置）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Profile-概述配置:Profile In Use：可以在这选择使用的是哪一套配置文件Manage Profiles：点击它会打开管理配置文件窗口<span class="token number">2</span>.Diagnostics-诊断:Send Profiler Events：启用分析器事件，启用它后我们可以在Event Viewer窗口查看Addressable相关信息Log Runtime Exceptions：记录运行时加载相关的异常<span class="token number">3</span>.Catalog-目录相关设置，将资源的地址映射到其物理位置:Player Version Override：重写用于制定远程目录名称的时间戳,如果不设置默认使用时间戳作为远程目录命名<span class="token punctuation">;</span>Compress Local Catalog：在压缩的AssetBundle文件中生成目录。可以压缩大小，但是会增加生成和加载的时间Optimize Catalog Size：通过为内部ID创建查找表来减小目录的大小。会增加加载目录所需的时间<span class="token number">4</span>.Content Update-内容更新:Disable Catalog Update on Startup：当可寻址系统在运行时初始化时，禁用自动检查更新的远程目录。您可以手动检查更新的目录。Content State Build Path：在何处生成由默认生成脚本生成的内容状态文件。Build Remote Catalog-构建远程目录<span class="token punctuation">(</span>勾选后会出现新选项<span class="token punctuation">)</span>:Build <span class="token operator">&amp;</span> Load Paths：在何处生成和加载远程目录。从列表中选择一个配置文件路径，如果要分别设置生成路径和加载路径，请选择<span class="token operator">&lt;</span>custom<span class="token operator">&gt;</span>,仅在启用生成远程目录时可见<span class="token punctuation">;</span>Build Path：远程构建路径，在何处构建远程目录。通常，应该使用RemoteBuildPath配置文件变量,仅当将生成和加载路径设置为<span class="token operator">&lt;</span>custom<span class="token operator">&gt;</span>时显示<span class="token punctuation">;</span>Load Path：远程加载路径，用于访问远程目录的URL。通常，应该使用RemoteLoadPath配置文件变量,仅当将生成和加载路径设置为<span class="token operator">&lt;</span>custom<span class="token operator">&gt;</span>时显示<span class="token punctuation">;</span>Path Preview：路径预览<span class="token number">5</span>.<span class="token punctuation">(</span>不重要<span class="token punctuation">)</span>Custom Certificeate handle：用于自定义证书处理的类。该列表包含项目中扩展UnityEngine的所有类。网络。证书管理员。Max Concurrent Web Requests：系统对超过此限制的任何请求进行队列处理Catalog Download Timeout：等待目录文件下载的时间为多少秒。<span class="token number">6</span>.Build-生成构建相关设置：Ignore Invalid/Unsupported Files <span class="token keyword">in</span> Build：忽略生成中无效不受支持的文件，如果启用，Addressable生成脚本将排除无效或不受支持的文件，而不是中止生成；Unique Bundle IDs：唯一约束ID，是否为每个构建中的包生成一个唯一的名称；Contiguous Bundles：连续捆绑，生成更高效的捆绑包布局。如果您有Addressables <span class="token number">1.12</span>.1或更早版本生成的捆绑包，请禁用此选项以最小化捆绑包更改；Non-Recursive Dependency Calculation：非递归依赖计算，不使用递归计算依赖项；Shader Bundle Naming Prefix：着色器包命名前缀；MonoScript Bundle Naming Prefix：Mono脚本包命名前缀；Strip Unity Version From AssetBundles：从AssetBUndles中剥离Unity版本，决定是否从包头中删除版本信息；Disable Visible Sub Asset Representations：禁用可见子资源，如果您不直接使用子对象<span class="token punctuation">(</span>Sprite、子网格等<span class="token punctuation">)</span>，则启用此选项可以提高构建时间；<span class="token number">7</span>.Build and Play Mode Scripts-构建和编辑器模式脚本，在编辑器中进入播放模式时，选择Addressable系统如何加载资产，这些脚本处理默认的构建进程，并提供不同的方式在编辑模式下访问数据，我们可以在AddressableAssetData/DataBuilders文件夹中找到这些脚本，如果要为他们自定义脚本，那么对应的脚本需要时BuildScriptBase的子类，并且继承IDataBuilder：Use Asset Database：使用资源数据库Simulate Groups：模拟组Use Existing Build：使用现有版本Default Build Scripts:默认生成脚本<span class="token number">8</span>.Asset Group Templates-资源组模板:Packed Asset：打包资源,定义可用于创建新组的模板列表,创建新模板时，必须先将其添加到此列表中，然后才能使用它,Addressables包包含一个模板,其中包含默认构建脚本使用的模式。您可以在AddressableAssetData/AssetGroupTemplates文件夹中找到该模板。<span class="token number">9</span>.Initialization Objects-初始化对象列表：配置初始化对象，可以在Project右键Create<span class="token operator">&gt;</span>Addressables<span class="token operator">&gt;</span>Initialization<span class="token punctuation">(</span>初始化<span class="token punctuation">)</span><span class="token operator">&gt;</span>Cache Initialization Setting（缓存初始化设置）；Compress Bundles：是否压缩包Cache Directory Override：缓存目录覆盖<span class="token punctuation">[</span>Obsolete<span class="token punctuation">]</span>Expiration Delay：过期延迟（过时了）Limit Cache Size：限制缓存的大小Maximum Cache Size：最大缓存大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Packed-Assets打包资源配置"><a href="#Packed-Assets打包资源配置" class="headerlink" title="Packed Assets打包资源配置"></a>Packed Assets打包资源配置</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Content Packing <span class="token operator">&amp;</span> Loading：Build <span class="token operator">&amp;</span> Load Paths：配置文件路径对，定义可寻址构建系统在哪个路径为此组创建内容，以及可寻址系统在运行时在何处加载这些内容，只有定义为Custom时才会出现下面的选项；Build Path-打包路径：LocalBuildPath-本地路径RemoteBuildPath-远程路径Load Path-加载路径：LocalLoadPath-本地路径RemoteLoadPath-远程路径Path Preview：路径预览<span class="token number">2</span>.Advanced Options-高级选项:<span class="token punctuation">(</span><span class="token number">1</span>*<span class="token punctuation">)</span>.Asset Bundle Compression：AB包的压缩方式，默认为LZ4，它通常是最有效的选项，建议使用<span class="token punctuation">;</span>Uncompressed：不压缩，包较大，不推荐<span class="token punctuation">;</span>LZ4：压缩，相对LZMA大一点点，建议使用，用什么解压什么，内存占用低<span class="token punctuation">;</span>LZMA：压缩最小，解压慢，用一个资源要解压所有<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">2</span>*<span class="token punctuation">)</span>.Include In Build：包含在构建中，是否在内容生成中包含此组中的资源。如果取消勾选，那么在选择打包时，不会打包该组内容<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>Force Unique Provider：强制唯一提供者，Addressable是否对此组使用资源提供程序类的唯一实例。如果您有此组中的资产类型的自定义提供程序实现，并且这些提供程序的实例不能在组之间共享，则启用此选项。<span class="token punctuation">(</span><span class="token number">4</span>*<span class="token punctuation">)</span>.Use Asset Bundle Cache：使用AB包缓存，是否缓存远程分发的包<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">5</span>*<span class="token punctuation">)</span>.Asset Bundle CRC-是否在加载前验证AB包的完整性:Disabled：永远不检查完整性Enabled，Including Cached：检查完整性，包括缓存也检查Enabled，Excluding Cached：检查完整性，但是不检查缓存的包<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>.Use UnityWebRequest <span class="token keyword">for</span> Local Asset Bundle：加载AB包时，使用UnityWebRequestAssetBundle.GetAssetBundle而不是AssetBundle.LoadFromFileAsync；<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>.Request Timeout：下载远程包时超时的间隔时间<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>.Use Http Chunked Transfer：下载包时是否使用HTTP/1.1块传输编码方法<span class="token punctuation">(</span>在2019.3+中被废弃和忽略<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>.Http Redirect Limit：下载包时允许重定向的次数。无限制设置为-1<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>.Retry Count：重试失败下载的次数<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>.Include Addresses <span class="token keyword">in</span> Catalog：是否将地址字符串包括在目录中。如果不使用地址字符串在组中加载资产，则可以通过不包括它们来减小目录的大小<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">12</span>*<span class="token punctuation">)</span>.Include GUIDs <span class="token keyword">in</span> Catalog：是否在目录中包含GUID字符串。您必须包含guid字符串才能使用资产参考。如果不使用AssetReferences或GUID字符串在组中加载资产，则可以通过不包括它们来减小目录的大小<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">13</span>*<span class="token punctuation">)</span>.Include Labels <span class="token keyword">in</span> Catalog：是否在目录中包含标签字符串。如果不使用标签在组中加载资产，则可以通过不包括这些资产来缩小目录的大小<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">14</span>*<span class="token punctuation">)</span>.Internal Asset Naming Mode-如何在内部命名目录中的资源:Full Path：全路径FileName：文件名GUID：资源的Guid字符串Dynamic：Addressables根据组中的资源选择最小的内部名称<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>.Internal Bundle Id Mode-确定如何构造资产绑定的内部ID。例如，当您设置群GUID选项，Addressables通过将组名与包guid字符串组合来创建包ID:Group Guid：组的GuidGroup Guid Project Id Hash：组的ID和工程ID的哈希Group Guid Project Id Entries Hash：组的ID和工程ID项的哈希<span class="token punctuation">(</span><span class="token number">16</span>*<span class="token punctuation">)</span>.Cache Clear Behavior-确定安装的应用程序何时从缓存中清除AB包:Clear When Space Is Needed In Cache：在缓存中需要空间时清除<span class="token punctuation">;</span>Clear When When new Version Loaded：加载新版本时清楚<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">17</span>*<span class="token punctuation">)</span>.Bundle Mode-打包模式，如何将此组中的资产打包到包中：Pack Together：创建包含所有资产的单个包；Pack Separately：为组中的每个主要资产创建一个包。如精灵图片中的精灵图片被包装在一起。添加到组中的文件夹中的资产也打包在一起；Pack Together by Label：为共享相同标签组合的资产创建一个包；<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>.Bundle Naming Mode-如何构造AB包的文件名:Filename：文件名Append Hash to Filename：将哈希附加到文件名Use Hash of AssetBundle：使用AB包的哈希Use Hash of FileName：使用文件名的哈希<span class="token punctuation">(</span><span class="token number">19</span>*<span class="token punctuation">)</span>.Asset Load Mode-资源加载模式:Requested Asset And Dependencies：请求的资源和依赖项<span class="token punctuation">;</span>All Packed Assets And Dependencies：所有包中的资源和依赖项<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>.Asset Provider-资源提供者,定义提供程序类Addressable用于从该组生成的AssetBundles加载资产。将此选项设置为Bundles供应商的资产除非您有一个自定义提供程序实现来从资产绑定中提供资产:Content Catalog Provider：内容目录提供器AssetBundle Provider：AB包提供器Assets from AssetDatabase Provider：资源来自资源数据库提供器Sprites from Atlases Provider：精灵来自图集提供器Assets from bundles provider：资源来自绑定提供器Json Asset Provider：Json资源提供器Assets from Legacy Resources:资源来自遗留的Resources提供器Text Data Provider：文本数据提供器Virtual AssetBundle Provider：虚拟AB包提供器Assets from Virtual Bundles：资源来自虚拟绑定<span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span>.Asset Bundle Provider：AB包提供器,定义由该组生成的提供程序类Addressable用于加载AssetBundles。将此选项设置为资产束提供者除非您有一个自定义提供程序实现来提供资产绑定<span class="token punctuation">;</span><span class="token number">3</span>.Content Update Restricion-内容更新限制:Can Change Post Release：可以改变发行后内容，该模式不移动任何资源，如果包中的任何资源发生了更改，则重新构建整个包<span class="token punctuation">;</span>Cannot Change Post Release：无法改变发布后内容，如果包中任何资源已经改变，则<span class="token punctuation">[</span>检查内容更新限制<span class="token punctuation">]</span>工具会将其移动到为更新创建的新组中。在进行更新构建时，从这个新组创建的AssetBundles中的资产将覆盖现有包中的版本<span class="token punctuation">;</span><span class="token number">4</span>.Add Schema（添加模式）-你可以将任意数量的架构模式分配给一个组,我们甚至可以通过继承AddressableAssetGroupSchema定义自己的架构模式<span class="token punctuation">;</span>Content Packing Loading：内容打包加载相关<span class="token punctuation">;</span>Content Update Restriction：内容更新限制<span class="token punctuation">;</span>Resources and Built In Scenes：在内置数据中显示哪些类型的内置资源，可以选择是否显示 资源和内置场景<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="资源打包（发布）"><a href="#资源打包（发布）" class="headerlink" title="资源打包（发布）"></a>资源打包（发布）</h1><p>1.资源打包注意事项：</p><ul><li>场景资源始终有自己单独的包：当一个可寻址包中有场景资源和普通资源时，场景资源和其它资源始终会被分开打包；</li><li>资源依赖的注意事项：类似于AssetBundle，如果资源a和资源b都使用了资源c，但是资源a和b是可寻址资源但不在一个组中，而c不是可寻址资源，那么这时资源c分别会被打进a和b的包，相当于这时的c就被重复利用了，浪费了空间，较好的解决方案是:将c也作为可寻址资源， a-A包  b-B包  c-C包， 这时c不会被打进A、B包，A、B包只会依赖于C，而Addressable会自动帮助我们处理依赖问题；</li><li>合理安排可寻址资源分组：同类型，同作用放一起，比如角色组、怪物组、武器组、衣服组、登录UI组、装备UI组、音效组、可变贴图组、图集组等等；</li><li>关于包的数量（分组的数量）：要根据实际情况来对资源进行布局，包(分组)过多、包(分组)过大都不太好，要根据自己的实际情况进行组的安排；</li></ul><p>2.本地资源发布：所有组的加载和发布都选择本地路劲，LocalBuildPath-打包路径，LocalLoadPath-加载路径（注意：使用默认设置，当发布应用程序时，会自动帮我们将AB包放入StreamingAssets文件夹中，如果修改了路径，我们需要自己将内容放入StreamingAssets文件夹中）；</p><p>3.远程资源发布：在远端的电脑上搭建Http服务器，将打包出来的资源上传到对应服务器上即可，资源加载组时会自动判断是本地资源还是远端资源，无需向AssetBundle一样进行手动设置；</p><p>4.资源更新：当项目正式发布后，对于远程加载的资源，我们可以通过改变资源服务器上的AB包来更新游戏，和AssetBundle不同的是，Addressables会自动帮助我们判断哪些资源更新了，并加载最新的内容；</p><ul><li>整包更新：组设置为 Can Change Post Release，直接在Build中点击资源更新而不是发布，之后会让选择一个更新日志文件，覆盖即可，整包更新指，某一个分组的资源发生变化后，我们需要将其整体进行打包，这种方式适用于大范围资源更新时使用；</li><li>局部更新：组设置为 Cannot Change Post Release，首先先在Tools工具下检查更新，然后再Build中更新资源，这步同上，当资源有变化时，我们可以单位发生变化的内容变成AB包，之后使用该资源，Addressables会自动加载最新的内容，它相对整包更新来说，更节约时间和流量；</li></ul><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h2 id="资源加载相关"><a href="#资源加载相关" class="headerlink" title="资源加载相关"></a>资源加载相关</h2><h3 id="根据资源定位信息加载资源"><a href="#根据资源定位信息加载资源" class="headerlink" title="根据资源定位信息加载资源"></a>根据资源定位信息加载资源</h3><p>1.加载资源Addressables做的事情：</p><ul><li>1.查找指定键的资源位置；</li><li>2.收集依赖项列表；</li><li>3.下载所需的所有远程AB包；</li><li>4.将AB包加载到内存中；</li><li>5.设置Result资源对象的值；</li><li>6.更新Status状态变量参数并且调用完成事件Completed（如果我们启用了 Log Runtime Exceptions选项 会在Console窗口打印信息）；</li></ul><p>2.资源定位信息API使用： Addressables.LoadResourceLocationsAsync(基本和资源加载一样)，使用它可以获取一些额外信息，可以利用这些信息处理一些特殊需求，并且资源定位信息加载资源并不会加大我们的开销；</p><ul><li>PrimaryKey：资源主键（资源名）；</li><li>InternalId：资源内部ID（资源路径）；</li><li>ResourceType：资源类型（Type可以获取资源类型名）；<h3 id="异步加载的其他方式"><a href="#异步加载的其他方式" class="headerlink" title="异步加载的其他方式"></a>异步加载的其他方式</h3></li></ul><p>1.协同程序：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">IEnumerator LoadAsset(){    handle = Addressables.LoadAssetAsync&lt;GameObject&gt;("Cube");    //一定是没有加载成功 再去 yield return    if(!handle.IsDone)        yield return handle;    //加载成功 那么久可以使用了    if (handle.Status == AsyncOperationStatus.Succeeded)    {        print("协同程序创建对象");        Instantiate(handle.Result);    }    else        Addressables.Release(handle);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.异步函数（async和await ）</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">async void Load(){    handle = Addressables.LoadAssetAsync&lt;GameObject&gt;("Cube");    AsyncOperationHandle&lt;GameObject&gt; handle2 = Addressables.LoadAssetAsync&lt;GameObject&gt;("Sphere");    //单任务等待    //await handle.Task;    //多任务等待    await Task.WhenAll(handle.Task, handle2.Task);    print("异步函数的形式加载的资源");    Instantiate(handle.Result);    Instantiate(handle2.Result);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于AsyncOperationHandle"><a href="#关于AsyncOperationHandle" class="headerlink" title="关于AsyncOperationHandle"></a>关于AsyncOperationHandle</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.无类型句柄转换AsyncOperationHandle&lt;Texture2D&gt; handle = Addressables.LoadAssetAsync&lt;Texture2D&gt;("Cube");AsyncOperationHandle temp = handle;//把无类型句柄 转换为 有类型的泛型对象handle = temp.Convert&lt;Texture2D&gt;();2.获取加载进度        while (!handle.IsDone)        {            DownloadStatus info = handle.GetDownloadStatus();            //进度            print(info.Percent);            //字节加载进度 代表 AB包 加载了多少            //当前下载了多少内容 /  总体有多少内容 单位是字节数            print(info.DownloadedBytes + "/" + info.TotalBytes);            yield return 0;        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义更新目录和下载AB包"><a href="#自定义更新目录和下载AB包" class="headerlink" title="自定义更新目录和下载AB包"></a>自定义更新目录和下载AB包</h3><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.目录的作用        //目录文件的本质是Json文件和一个Hash文件        //其中记录的主要内容有        //Json文件中记录的是：        //1.加载AB包、图集、资源、场景、实例化对象所用的脚本（会通过反射去加载他们来使用）        //2.AB包中所有资源类型对应的类（会通过反射去加载他们来使用）        //3.AB包对应路径        //4.资源的path名        //等等        //Hash文件中记录的是：        //目录文件对应hash码（每一个文件都有一个唯一码，用来判断文件是否变化）        //更新时本地的文件hash码会和远端目录的hash码进行对比        //如果发现不一样就会更新目录文件        //当我们使用远端发布内容时，在资源服务器也会有一个目录文件        //Addressables会在运行时自动管理目录        //如果远端目录发生变化了(他会通过hash文件里面存储的数据判断是否是新目录)        //它会自动下载新版本并将其加载到内存中2.手动更新目录        //1.如果要手动更新目录 建议在设置中关闭自动更新        //2.自动检查所有目录是否有更新，并更新目录API        Addressables.UpdateCatalogs().Completed += (obj) =&gt;        {            Addressables.Release(obj);        };        //3.获取目录列表，再更新目录        //参数 bool 就是加载结束后 会不会自动释放异步加载的句柄        Addressables.CheckForCatalogUpdates(true).Completed += (obj) =&gt;        {            //如果列表里面的内容大于0 证明有可以更新的目录            if(obj.Result.Count &gt; 0)            {                //根据目录列表更新目录                Addressables.UpdateCatalogs(obj.Result, true).Completed += (handle) =&gt;                {                    //如果更新完毕 记得释放资源                    //Addressables.Release(handle);                    //Addressables.Release(obj);                };            }        };3.预加载包        //建议通过协程来加载        StartCoroutine(LoadAsset());    //定义协程    IEnumerator LoadAsset()    {        //1.首先获取下载包的大小        //可以传资源名、标签名、或者两者的组合        AsyncOperationHandle&lt;long&gt; handleSize = Addressables.GetDownloadSizeAsync(new List&lt;string&gt;() { "Cube", "Sphere", "SD" });        yield return handleSize;        //2.预加载        if(handleSize.Result &gt; 0)        {            //这样就可以异步加载 所有依赖的AB包相关内容了            AsyncOperationHandle handle = Addressables.DownloadDependenciesAsync(new List&lt;string&gt;() { "Cube", "Sphere", "SD" }, Addressables.MergeMode.Union);            while(!handle.IsDone)            {                //3.加载进度                DownloadStatus info = handle.GetDownloadStatus();                print(info.Percent);                print(info.DownloadedBytes + "/" + info.TotalBytes);                yield return 0;            }            Addressables.Release(handle);        }            }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引用计数规则"><a href="#引用计数规则" class="headerlink" title="引用计数规则"></a>引用计数规则</h3><p>1.引用计数规则说明：Addressables内部会通过引用计数帮助我们管理内存，我们只需要保证 加载和卸载资源配对使用即可，以下分俩步来解释；</p><ul><li>计数说明：当我们通过加载使用可寻址资源时，Addressables会在内部帮助我们进行引用计数，使用资源时，引用计数+1，释放资源时，引用计数-1，当可寻址资源的引用为0时，就可以卸载它了，同时，AB包也有自己的引用计数（Addressables把它也视为可寻址资源），和资源计数类似但是分开计算；</li><li>资源释放说明：为了避免内存泄露（不需要使用的内容残留在内存中），我们要保证加载资源和卸载资源是配对使用的，释放的资源不一定立即从内存中卸载，在卸载资源所属的AB包之前，不会释放资源使用的内存(比如自己所在的AB包 被别人使用时，这时AB包不会被卸载，所以自己还在内存中)，我们可以使用Resources.UnloadUnusedAssets卸载资源（建议在切换场景时调用）；</li></ul><h2 id="常见问题说明"><a href="#常见问题说明" class="headerlink" title="常见问题说明"></a>常见问题说明</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.用多包策略还是大包策略？        //1.AB包太多<span class="token punctuation">(</span>太小<span class="token punctuation">)</span>的问题        //  <span class="token number">1</span>-1:每个包都会有内存开销，如果加载过多的包可能会带来更多的内存消耗        //  <span class="token number">1</span>-2:并发下载的问题，如果包小而多，以为着下载包时可能需要更多的时间        //  <span class="token number">1</span>-3:目录文件会因为过多的包而变大，因为它要记录更多的包信息        //  <span class="token number">1</span>-4:复用资源的可能性更大，比如多个包使用同样一个资源，但是该资源不是寻址资源，那么在每个包中都会有该资源        //2.AB包太少<span class="token punctuation">(</span>太大<span class="token punctuation">)</span>的问题        //  <span class="token number">1</span>-1:过大的包如果下载失败，下次会重新下载，因为使用UnityWebRequest下载包时不会恢复失败的下载        //      比如100MB的包，下了50MB，玩家中断下载了，下次又得重新下        //  <span class="token number">1</span>-2:能单独加载，但是不能单独卸载，更大的包意味着包中有更多资源，比如加载了1个大包中100个资源        //      但是现在用完了99个，还剩一个再用，即使99都卸载了，但是由于引用计数这个大包也不会卸载        //      就会造成内存的浪费        //所以没有最好的策略，只有根据自己的项目需求合理安排分组打包        //要根据资源的使用情况来合理设置资源分组，在分组时权衡好各方面的问题<span class="token number">2</span>.哪种压缩方式更好？        //AB包的压缩方式：不压缩、LZ4、LZMA        //一般情况LZ4用于本地资源，LZMA用于远端资源        //主要原因是LZMA的压缩内容更小，更节约下载时间和流量        //注意：压缩不会影响加载内存的大小，只会影响包体大小，下载时间等        //但是也要根据实际情况        //比如：        //1.不压缩：包体并不大的单机游戏，使用不压缩最好，没有包体大小的压力，加载也是最快的，因为不用解压        //2.LZ4：它是基于块的压缩，所以提供了加载文件的能力，加载资源时不用全加载AB包，只加载使用的内容，相对LZMA来说更节约内存        //3.LZMA：不建议用它在本地内容中，因为它虽然包最小，但是加载最慢，用它只是为了节约下载时间和极限压缩包体大小        //综合来说，也没有最优的方式，还是要根据实际情况来选择        //个人认为LZ4压缩方式，是相对比较优秀的一种方式<span class="token number">3</span>.减小目录文件大小        //当我们想要极限压缩包体大小时，可能希望优化目录文件的大小        //1.压缩本地目录        //  AddressableAssetSettings <span class="token operator">&gt;</span> Catalog <span class="token operator">&gt;</span> Compress Local Catalog        //2.禁用内置场景和资源（Built In Data禁用）        //  默认Addressables提供了从Resources等内置资源文件夹中加载资源以及加载内置场景        //  如果你不通过Addressables加载他们，可以禁用，这样目录文件就不会包含其中信息        //  但是我们就只能使用老方法加载同名        //  个人建议取消，因为一般我们不会通过Addressables去加载非寻址资源<span class="token number">4</span>.其他事项        //1.关于AB包最大的限制，老版本不支持大于4G的包，虽然新版本中已经没有这个限制        //但是为了兼容性，还是建议大小控制在4G以下        //2.活用可寻址资源上的Groups View中的两个功能        //Show Sprite and Subobject Addresses:当窗口中内容特别多时，禁用它可以提升窗口加载的性能        //Group Hierarchy with Dashes：启用带破折号的层级结构        //                             可以让我们在内容特别多时以层级结构查看分组信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Addressables概述&quot;&gt;&lt;a href=&quot;#Addressables概述&quot; class=&quot;headerlink&quot; title=&quot;Addressables概述&quot;&gt;&lt;/a&gt;Addressables概述&lt;/h1&gt;&lt;p&gt;1.Addressables说明：Addre</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Addressables" scheme="https://wwy.wwywy.com/tags/Addressables/"/>
    
  </entry>
  
  <entry>
    <title>Git版本控制工具使用</title>
    <link href="https://wwy.wwywy.com/posts/64.html"/>
    <id>https://wwy.wwywy.com/posts/64.html</id>
    <published>2021-07-01T13:00:00.000Z</published>
    <updated>2022-07-09T16:12:20.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的介绍"><a href="#Git的介绍" class="headerlink" title="Git的介绍"></a>Git的介绍</h1><p>1.Git是什么：Git是目前世界上最先进的分布式版本控制系统，工作流程，Workspace（工作区）——Index / Stage（暂存区）——Repository（本地仓库）——Remote（远程仓库）；</p><p>2.SVN与Git的最主要的区别：</p><ul><li>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了；</li><li>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了；</li></ul><p>3.Git的安装和配置：在Windows下安装Git如下步骤</p><ul><li>从官网下载Git安装，并且打开Git Bash，打开成功说明安装成功；</li><li>安装后进行配置，git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，配置用户名（user.name）以及配置邮箱（user.email）；</li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>1.版本库的说明：什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”；</p><ul><li>在任意目录下，使用命令git init把这个目录变成git可以管理的仓库；</li><li>使用命令git add 文件名.后缀名添加到暂存区中；</li><li>再用命令git commit -m ‘注释’ 将文件提交到仓库；</li><li>提交文件前可以用git status查看下状态</li></ul><p>2.版本回退：</p><ul><li>用git log可以查看历史记录，查看的记录都是注释的，所以养成注释的良好习惯,参数加–pretty=oneline只显示版本信息；</li><li>git reflog来显示所有的操作，这样即使回滚了也能看到；</li><li>使用git reset –hard HEAD^将版本回退到上一个版本，HEAD指的是当前分支； <ul><li>^代表的是上个版本，如果上上个就是^^；</li><li>也可以在hard后面直接接版本号信息，直接恢复到那个状态；</li></ul></li></ul><p>3.工作区和暂存区的区别：、</p><ul><li>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴；</li><li>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD</li></ul><p>4.Git撤销修改和删除文件操作：</p><ul><li>撤销修改：目前来说有俩种方法，一是手动更改add再commit，第二种恢复上一个版本,但是如果俩种都不想使用，可以使用git checkout – 文件名 来丢弃工作区的修改（注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了）；</li><li>删除：使用rm 文件名命令就可以了，彻底删除再执行commit，没有commit用撤销修改命令就可以了；</li></ul><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>1.远程仓库说明：在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><ul><li>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令，ssh-keygen -t rsa –C “<a href="mailto:youremail@example.com">youremail@example.com</a>”，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人；</li><li>第二步：登录github，点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容；</li></ul><p>2.远程仓库的操作：</p><ul><li>创建远程仓库：登录github上，然后在右上角找到“create a new repo”创建一个新的仓库；</li><li>本地关联远程：使用git remote add origin 远程仓库名；</li><li>本地推送远程（先本地库后远程库）：使用git push [-u] origin master 命令把当前master分支推送到远端，加上-u参数，不仅进行推送，还会进行分支关联；</li><li>本地克隆远程（先远程库后本地库）：使用git clone 远程仓库名；</li></ul><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>1.分支的相关操作：</p><ul><li>查看分支：git branch</li><li>创建分支：git branch 分支名</li><li>切换分支：git checkout 分支名</li><li>创建+切换分支：git checkout –b 分支名</li><li>合并某分支到当前分支：git merge 分支名</li><li>删除分支：git branch –d 分支名</li></ul><p>2.分支冲突：Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容；</p><p>3.分支管理策略：</p><ul><li>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式，git merge –no-ff 分支名；</li><li>其次master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来；</li></ul><p>4.Bug分支：使用git stash隐藏工作现场；</p><h1 id="小乌龟Git教程"><a href="#小乌龟Git教程" class="headerlink" title="小乌龟Git教程"></a>小乌龟Git教程</h1><p><a href="http://t.zoukankan.com/yuxiangqiezi-p-12913827.html">git小乌龟的使用 - 走看看 (zoukankan.com)</a></p><h1 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h1><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#在当前目录新建一个Git代码库$ git init#新建一个目录，将其初始化为Git代码库$ git init [project-name]#下载一个项目和它的整个代码历史$ git clone [url]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@{0 day ago}"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 生成一个可供发布的压缩包$ git archive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git的介绍&quot;&gt;&lt;a href=&quot;#Git的介绍&quot; class=&quot;headerlink&quot; title=&quot;Git的介绍&quot;&gt;&lt;/a&gt;Git的介绍&lt;/h1&gt;&lt;p&gt;1.Git是什么：Git是目前世界上最先进的分布式版本控制系统，工作流程，Workspace（工作区）——I</summary>
      
    
    
    
    <category term="其他" scheme="https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Git" scheme="https://wwy.wwywy.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>常用排序算法</title>
    <link href="https://wwy.wwywy.com/posts/545.html"/>
    <id>https://wwy.wwywy.com/posts/545.html</id>
    <published>2021-06-30T13:00:00.000Z</published>
    <updated>2022-03-06T01:20:16.945Z</updated>
    
    <content type="html"><![CDATA[<p>列举一些常用的排序算法</p><p>#冒泡排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void BubbleSort(int[] array, int count){    //设置标识符，如果为false意为当前数组为有序，不需要再排序了    bool shouldSorted = true;    for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++)    {        shouldSorted = false;        for (int j = count - 1; j &gt; i; j--)        {            if (array[j - 1] &gt; array[j])            {                shouldSorted = true;                Utilities.Swap(ref array[j - 1], ref array[j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#选择排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void SelectSort(int[] array, int count){    int min;    for (int i = 0; i &lt; count - 1; i++)    {        min = i;        for (int j = i + 1; j &lt; count; j++)        {            if (array[min] &gt; array[j])            {                min = j;            }        }        if (min != i)        {            Utilities.Swap(ref array[min], ref array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#插入排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void InserSort(int[] array, int count){    int guard; //哨兵，用于暂存需要交换的值    for (int i = 0; i &lt; count - 1; i++)    {        if (array[i] &gt; array[i + 1])        {            guard = array[i + 1];            int j;            for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--)            {                array[j + 1] = array[j]; //赋值操作（依次后移）            }            array[j + 1] = guard;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#希尔排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 希尔排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void ShellSort(int[] array, int count){    int i, j, guard;    int increment = count;    do    {        increment = increment / 3 + 1; //增量序列        for (i = increment + 1; i &lt; count; i++)        {            if (array[i] &lt; array[i - increment])            {                guard = array[i]; //暂存在哨兵处                for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment)                {                    array[j + increment] = array[j]; //记录后移，查找插入位置                }                array[j + increment] = guard; //插入            }        }    } while (increment &gt; 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#堆排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 堆排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void HeapSort(int[] array, int count){    for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆    {        HeapAdjust(array, i, count - 1);    }    for (int i = count - 1; i &gt; 0; i--)    {        Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换        HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆    }}/// &lt;summary&gt;/// 堆排序_构造大顶堆函数/// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义/// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="startIndex"&gt;起始位置&lt;/param&gt;/// &lt;param name="endIndex"&gt;结束位置&lt;/param&gt;public static void HeapAdjust(int[] array, int startIndex, int endIndex){    int temp;    temp = array[startIndex];    for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选    {        if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1])        {            ++i; //i为关键字中较大记录的下标        }        if (temp &gt; array[i])        {            break; //rc应插入在位置s上        }        array[startIndex] = array[i];        startIndex = i;    }    array[startIndex] = temp; //插入}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#归并排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 归并排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void MergeSort(int[] array, int count){    int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果    int k = 1;    while (k &lt; count)    {        MergePass(array, tempArray, k, count); //array归并到tempArray        k = 2 * k; //子序列长度加倍        MergePass(tempArray, array, k, count); //tempArray归并到array        k = 2 * k; //子序列长度加倍    }}/// &lt;summary&gt;/// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="srChildLength"&gt;SR中子序列长度&lt;/param&gt;/// &lt;param name="arrayLength"&gt;原数组长度&lt;/param&gt;public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength){    int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数    while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2,            hasMergeCount + 2 * srChildLength - 2); //两两归并        hasMergeCount += 2 * srChildLength;    }    if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1);    }    else //若最后只剩下单个子序列    {        for (int j = hasMergeCount - 1; j &lt; arrayLength; j++)        {            tr[j] = sr[j];        }    }}/// &lt;summary&gt;/// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="sr1StartIndex"&gt;SR数组子序列1起始位置&lt;/param&gt;/// &lt;param name="sr1EndIndex"&gt;SR数组子序列1结束位置&lt;/param&gt;/// &lt;param name="sr2EndIndex"&gt;SR数组子序列2结束位置&lt;/param&gt;private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex){    int sr2StartIndex, currentProcess; //currentProcess为当前进度    for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex;        sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex;        currentProcess++) //两个SR有一个被榨干后就要退出循环    {        if (sr[sr1StartIndex] &lt; sr[sr2StartIndex])        {            tr[currentProcess] = sr[sr1StartIndex++];        }        else        {            tr[currentProcess] = sr[sr2StartIndex++];        }    }    if (sr1StartIndex &lt;= sr1EndIndex)    {        for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++)        {            tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR        }    }    if (sr2StartIndex &lt;= sr2EndIndex)    {        for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++)        {            tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#快速排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 快速排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void QuickSort(int[] array, int count){    QSort(array, 0, count - 1);}/// &lt;summary&gt;/// 快速排序_递归调用/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;private static void QSort(int[] array, int low, int high){    int pivot;    while (low &lt; high)    {        pivot = Partition(array, low, high);        QSort(array, low, pivot - 1);        //尾递归，可以减少一次递归堆栈深度        low = pivot + 1;    }}/// &lt;summary&gt;/// 获取枢轴数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static int Partition(int[] array, int low, int high){    int pivotkey;    int m = low + (high - low) / 2;    //下面是三数取中优化    //交换左端与右端数据，保证左端较小    if (array[low] &gt; array[high])    {        Utilities.Swap(ref array[low],ref array[high]);    }    //交换中间与右端数据，保证中间较小    if (array[m] &gt; array[high])    {        Utilities.Swap(ref array[m],ref array[high]);    }    //交换中间与左端数据，保证左端较小    if (array[m] &gt; array[low])    {        Utilities.Swap(ref array[low],ref array[m]);    }    //默认选取当前数组的第一个值作为枢轴值    pivotkey = array[low];    //枢轴备份    int pivotkeyback = pivotkey;    while (low &lt; high)    {        while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey)        {            high--;        }        array[low] = array[high];        while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey)        {            low++;        }        array[high] = array[low];    }    //将枢轴数值替换回array[low]    array[low] = pivotkeyback;    //返回当前枢轴下标    return low;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#各种排序时空复杂度<br><img src="img/01002-0001.png" alt="排序复杂图"><br>n: 数据规模<br>k: “桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;列举一些常用的排序算法&lt;/p&gt;
&lt;p&gt;#冒泡排序&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-c#&quot; data-language=&quot;c#&quot;&gt;&lt;code class=&quot;language-c#&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 冒</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构和算法" scheme="https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>游戏MVC系列框架</title>
    <link href="https://wwy.wwywy.com/posts/2051.html"/>
    <id>https://wwy.wwywy.com/posts/2051.html</id>
    <published>2021-06-15T13:00:00.000Z</published>
    <updated>2022-07-09T16:20:23.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑;</p><p>流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据;</p><p>总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架；</p><p>不使用MVC的逻辑：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevPanel : MonoBehaviour{      public Button btnLevUp;      public Button btnClose;            //展示UI面板      public static void ShowMe()    {    //todo    }        //隐藏UI面板    public static void HideMe()    {    //todo    }        void Start()    {        //2.监听事件        btnClose.onClick.AddListener(ClickClose);        btnLevUp.onClick.AddListener(ClickLevUp);    }        public void ClickClose()    {        Debug.Log("关闭");        HideMe();    }        public void ClickLevUp()    {        Debug.Log("升级");        //存储数据        //同步更新面板上的数据        UpdateInfo();        //更新主面板的内容        MainPanel.Panel.UpdateInfo();    }            //3.更新面板    public void UpdateInfo()    {    //更新数据    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发；</p><p>使用MVC：<br>Model层：负责增删查改获取界面上需要的数据</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevModel{    //定义数据    private int lev;    //外界只能获取字段    public int Lev    {        get        {            return lev;        }    }        //通知外部更新的事件    //通过它和外部建立联系 而不是直接获取外部的面板    private event UnityAction&lt;PlayerLevModel&gt; updateEvent;        //在外部第一次获取这个数据 如何获取    //通过单例模式 来达到数据的唯一性 和数据的获取    private static PlayerLevModel data = null;    public static PlayerLevModel Data    {        get        {            if( data == null )            {                data = new PlayerLevModel();                data.Init();            }            return data;        }    }        //数据相关的操作    // 初始化    public void Init()    {        lev = PlayerPrefs.GetInt("PlayerLev", 1);    }}    public void LevUp()    {        //升级 改变内容        lev += 1;        //改变过后保存        SaveData();    }            public void SaveData()    {        //把这些数据内容 存储到本地        PlayerPrefs.SetInt("PlayerLev", lev);        UpdateInfo();    }            public void AddEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent += function;    }    public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent -= function;    }    //通知外部更新外部数据的方法    private void UpdateInfo()    {        //找到对应的 使用数据的脚本 去更新数据        updateEvent?Invoke(this);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视图层：负责获取控件，更新控件信息</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevView : MonoBehaviour{      //1.找控件    public Button btnClose;    public Button btnLevUp;    //2.提供面板更新的相关方法给外部    public void UpdateInfo(PlayerModel data)    {        txtLev.text = "LV." + data.Lev;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevController : MonoBehaviour{    //视图实例，这里视图和控制在一个物体上    private PlayerLevView roleView;    private static PlayerLevController controller = null;    //控制层单例    public static PlayerLevController Controller    {        get        {            return controller;        }    }            public static void ShowMe()    {        if (controller == null)        {            //实例化面板对象            //设置它的父对象 为Canvas        }        //如果是隐藏的形式hide 在这要显示        controller.gameObject.SetActive(true);    }    public static void HideMe()    {        if (controller != null)        {            //方式一 直接删            //方式二 设置可见为隐藏        }    }            void Start()    {    //这里视图和控制在一个物体上        roleView = this.GetComponent&lt;RoleView&gt;();        //第一次更新面板        roleView.UpdateInfo(PlayerLevModel.Data);        roleView.btnClose.onClick.AddListener(ClickCloseBtn);        roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn);        //告知数据模块 当更新时 通知哪个函数做处理        PlayerModel.Data.AddEventListener(UpdateInfo);    }            private void ClickCloseBtn()    {        HideMe();    }    private void ClickLevUpBtn()    {        //通过数据模块 进行升级 达到数据改变        PlayerLevModel.Data.LevUp();    }    private void UpdateInfo( PlayerModel data )    {        if( roleView != null )        {            roleView.UpdateInfo(data);        }    }    private void OnDestroy()    {              PlayerLevModel.Data.RemoveEventListener(UpdateInfo);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好处：<br>1.各司其职，互不干涉 —— 编程思路更清晰<br>2.有利开发中的分工 —— 多人协同开发时，同步并行<br>3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率<br>缺点：<br>1.增加了程序文件的体量 —— 脚本由一变三<br>2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好<br>2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大）</p><h1 id="MV-的概念"><a href="#MV-的概念" class="headerlink" title="MV*的概念"></a>MV*的概念</h1><p>MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变；<br>  所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。</p><p><img src="https://s4.ax1x.com/2022/02/05/Hm6yN9.png" alt="相关的变种"></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>  切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部.</p><p>Model层:不变</p><p>View层:不能直接传入Model模型来更新</p><p>Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入；</p><h1 id="MVVM（MP）"><a href="#MVVM（MP）" class="headerlink" title="MVVM（MP）"></a>MVVM（MP）</h1><p>  MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细；</p><p>了解的话可以看看这些第三方MVVM框架：<br>loxodon-Framework:<a href="https://github.com/vovgou/loxodon-framework">vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)</a><br>uMVVM:<a href="https://github.com/MEyes/uMVVM">MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com)</a></p><p>所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心；</p><h1 id="MVE"><a href="#MVE" class="headerlink" title="MVE"></a>MVE</h1><p>  E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可；</p><h1 id="商业框架PureMVC"><a href="#商业框架PureMVC" class="headerlink" title="商业框架PureMVC"></a>商业框架PureMVC</h1><p>官网：<a href="http://puremvc.org/">PureMVC 框架</a><br>PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；<br>Model（数据模型）：关联Proxy(代理)对象，负责处理数据；<br>View（界面）：关联Mediator(中介)对象，负责处理界面；<br>Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；<br>Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；<br>Notification：通知，负责传递信息；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h1&gt;&lt;p&gt;基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller</summary>
      
    
    
    
    <category term="Game-Play" scheme="https://wwy.wwywy.com/categories/Game-Play/"/>
    
    <category term="技术架构" scheme="https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="游戏框架" scheme="https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    
    <category term="MVC" scheme="https://wwy.wwywy.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>C#各版本知识补充</title>
    <link href="https://wwy.wwywy.com/posts/1029.html"/>
    <id>https://wwy.wwywy.com/posts/1029.html</id>
    <published>2021-06-06T13:00:00.000Z</published>
    <updated>2022-03-22T09:57:43.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-版本和Unity的关系"><a href="#C-版本和Unity的关系" class="headerlink" title="C#版本和Unity的关系"></a>C#版本和Unity的关系</h1><p>1.各Unity支持的的C#版本说明：主要是不同Unity版本 使用的 C#编译器和脚本运行时版本不同，所以随着Unity的更新，它一般会采用较新的 编译器和运行时版本，新版本的脚本运行时将为Unity带来了大量的新版C#功能和.NET的功能，就意味着它可以支持更高版本的C#，以下是各版本支持的C#版本；</p><ul><li>Unity 2021.2 —— C# 9；</li><li>Unity 2020.3 —— C# 8；</li><li>Unity 2019.4 —— C# 7.3；</li><li>Unity 2018.3 —— C# 7 </li><li>Unity 2017   —— C# 6；</li><li>Unity 5.5    —— C# 4；</li></ul><p><a href="https://docs.unity3d.com/2020.3/Documentation/Manual/CSharpCompiler.html">Unity - 手动：C# 编译器 (unity3d.com)</a></p><p>2.Unity的.Net API兼容级别：在PlayerSetting-&gt;Other Setting-&gt;Api Compatibility Level中，我们可以设置.Net API的兼容级别：</p><ul><li>.Net 4.x（特殊需求时）:具备较为完整的.Net API，甚至包含了一些无法跨平台的API，如果你的应用主要针对Windows平台，并且会使用到.Net Standard 2.0中没有的功能时，选择使用它；</li><li>.Net Standard 2.0（建议使用）:是一个.Net标准API集合，相对.Net 4.x包含更少的内容，可以减小最终可执行文件大小，它具有更好的跨平台支持；</li></ul><h1 id="C-1-4功能和语法"><a href="#C-1-4功能和语法" class="headerlink" title="C# 1~4功能和语法"></a>C# 1~4功能和语法</h1><p>1.C#1~4语法说明：</p><ul><li>C# 1 —— 委托、事件（C#进阶）</li><li>C# 2 —— 泛型、匿名方法、迭代器、可空类型（C#进阶）</li><li>C# 3 ——隐式类型、对象集合初始化、Lambda表达式、匿名类型（C#进阶）；自动实现属性、拓展方法、分部类（C#核心）；Linq相关的表达式树（有时间再学）；</li><li>C# 4 ——泛型的协变和逆变（C#进阶）以及命名和可选参数和动态类型（下面讲的）；</li></ul><p>2.C#4中的命名和可选参数：有了命名参数，我们将不用匹配参数在所调用方法中的顺序，每个参数可以按照参数名字进行指定，例如Test(f:3.3f,i:5,b:false)，命名参数可以配合可选参数使用,让我们做到跳过其中的默认参数直接赋值后面的默认参数，可以让我们更方便的调用函数，少写一些重载函数；</p><p>3.C#4中的动态类型：动态类型可以节约代码量，可以理解成是当不确定对象类型，但是确定对象成员时，可以使用动态类型；</p><ul><li>关键词：dynamic；</li><li>作用：通过dynamic类型标识变量的使用和对其成员的引用绕过编译时类型检查，改为在运行时解析这些操作，在大多数情况下，dynamic类型和object类型行为类似，任何非Null表达式都可以转换为dynamic类型，dynamic类型和object类型不同之处在于，编译器不会对包含类型 dynamic 的表达式的操作进行解析或类型检查，编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作，在此过程中，dynamic 类型的变量会编译为 object 类型的变量，因此，dynamic 类型只在编译时存在，在运行时则不存在；</li><li>注意事项说明：<ul><li>使用dynamic功能 需要将Unity的.Net API兼容级别切换为.Net 4.x；</li><li>IL2CPP 不支持 C# dynamic 关键字。它需要 JIT 编译，而 IL2CPP 无法实现</li><li>动态类型是无法自动补全方法的，我们在书写时一定要保证方法的拼写正确性</li></ul></li></ul><h1 id="C-5功能和语法"><a href="#C-5功能和语法" class="headerlink" title="C# 5功能和语法"></a>C# 5功能和语法</h1><p>1.C# 5新增语法说明：</p><ul><li>调用方信息特性（C#进阶——特性）</li><li>异步方法async和await（C#进阶）</li></ul><h1 id="C-6功能和语法"><a href="#C-6功能和语法" class="headerlink" title="C# 6功能和语法"></a>C# 6功能和语法</h1><p>1.C# 6新增语法说明：</p><ul><li>=&gt;运算符（C#进阶——特殊语法 =&gt;）；</li><li>.Null 传播器（C#进阶——特殊语法 ?）；</li><li>字符串内插（C#进阶——特殊语法 $）；</li><li>静态导入（下面提及）；</li><li>异常筛选器（下面提及）；</li><li>nameof运算符（下面提及）；</li></ul><p>2.C# 6静态导入：例如using static UnityEngine.Mathf简化后面的使用;</p><ul><li>用法：在引用命名空间时，在using关键字后面加入static关键词；</li><li>作用：无需指定类型名称即可访问其静态成员和嵌套类型；</li><li>好处：节约代码量，可以写出更简洁的代码</li></ul><p>3.C# 6异常筛选器：例如when (e.Message.Contains(“404”))判断是否包含404字符串；</p><ul><li>用法：在异常捕获语句块中的Catch语句后通过加入when关键词来筛选异常&lt;when（表达式）该表达式返回值必须为bool值，如果为ture则执行异常处理，如果为false，则不执行;</li><li>作用：用于筛选异常;</li><li>好处：帮助我们更准确的排查异常，根据异常类型进行对应的处理</li></ul><p>4.C# 6nameof运算符：例如print(nameof(list.Count))打印的是Count这个字符串；</p><ul><li>用法：nameof(变量、类型、成员)通过该表达式，可以将他们的名称转为字符串；</li><li>作用：可以得到变量、类、函数等信息的具体字符串名称，可以配合反射使用；</li></ul><h1 id="C-7功能和语法"><a href="#C-7功能和语法" class="headerlink" title="C# 7功能和语法"></a>C# 7功能和语法</h1><p>1.C# 7新增语法说明：</p><ul><li>字面值改进（下面提及）；</li><li>out参数相关 和 弃元知识点（下面提及）；</li><li>ref 返回值（下面提及）；</li><li>本地函数（下面提及）；</li><li>抛出表达式（下面提及）；</li><li>元组（下面提及）；</li><li>模式匹配（下面提及）；</li></ul><p>2.C# 7字面值改进：例如int i = 9_9123_1239更加方便观看，但是不影响实际数值；</p><ul><li>基本概念：在声明数值变量时，为了方便查看数值，可以在数值之间插入_作为分隔符；</li><li>主要作用：方便数值变量的阅读；</li></ul><p>3.C# 7out参数相关 和 弃元知识点：</p><ul><li>用法：不需要再使用带有out参数的函数之前，声明对应变量，例如Calc(out int x)直接声明，后面也可以使用;<ul><li>结合var类型更简便(但是这种写法在存在重载时不能正常使用,必须明确调用的是谁)，例如Calc(out var b)；</li><li>可以使用_弃元符号 省略不想使用的参数，例如Calc(out _)； </li></ul></li><li>作用：简化代码，提高开发效率</li></ul><p>4.C# 7ref 返回值：</p><ul><li>基本概念：使用ref修饰临时变量和函数返回值，可以让赋值变为引用传递，如下主要使用几种场景：<ul><li>修饰值类型临时变量：例如ref int testI2 = ref testI = 900，值类型的改变和引用类型改值一样了；</li><li>获取对象中的参数： ref int atk = ref r.atk = 99，同上说明；</li><li>函数返回值：同上做法； </li></ul></li><li>作用：用于修改数据对象中的某些值类型变量</li></ul><p>5.C# 7本地函数：</p><ul><li>基本概念：在函数内部声明一个临时函数，如下注意：<ul><li>本地函数只能在声明该函数的函数内部使用；</li><li>本地函数可以使用声明自己的函数中的变量；</li></ul></li><li>作用：方便逻辑的封装；</li><li>建议：把本地函数写在主要逻辑的后面，方便代码的查看；</li></ul><h2 id="抛出表达式"><a href="#抛出表达式" class="headerlink" title="抛出表达式"></a>抛出表达式</h2><p>1.throw表达式回顾：抛出表达式，就是指抛出一个错误，一般的使用方式都是throw后面 new 一个异常类，异常基类是Exception，例如throw new NullReferenceException(“出错了”)，以下是常见的异常类；</p><ul><li>IndexOutOfRangeException：当一个数组的下标超出范围时运行时引发；</li><li>NullReferenceException：当一个空对象被引用时运行时引发；</li><li>ArgumentException：方法的参数是非法的；</li><li>ArgumentNullException： 一个空参数传递给方法，该方法不能接受该参数；</li><li>ArgumentOutOfRangeException： 参数值超出范围；</li><li>SystemException：其他用户可处理的异常的基本类；</li><li>OutOfMemoryException：内存空间不够；</li><li>StackOverflowException 堆栈溢出；</li><li>ArithmeticException：出现算术上溢或者下溢；</li><li>ArrayTypeMismatchException：试图在数组中存储错误类型的对象；</li><li>BadImageFormatException：图形的格式错误；</li><li>DivideByZeroException：除零异常；</li><li>DllNotFoundException：找不到引用的DLL；</li><li>FormatException：参数格式错误；</li><li>InvalidCastException：使用无效的类；</li><li>InvalidOperationException：方法的调用时间错误</li><li>MethodAccessException：试图访问思友或者受保护的方法；</li><li>MissingMemberException：访问一个无效版本的DLL；</li><li>NotFiniteNumberException：对象不是一个有效的成员；</li><li>NotSupportedException：调用的方法在类中没有实现；</li><li>InvalidOperationException：当对方法的调用对对象的当前状态无效时，由某些方法引发。 </li></ul><p>2.C# 7新增的更多表达式错误抛出：</p><ul><li>空合并操作符后用throw：例如str ?? throw new ArgumentNullException(nameof(str));</li><li>三目运算符后面用throw：例如index ? strs[index] : throw new IndexOutOfRangeException();</li><li>=&gt;符号后面直接throw：例如Action action = () =&gt; throw new Exception(“错了，不准用这个委托”); </li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>1.元组说明：</p><ul><li>基本概念:多个值的集合，相当于是一种快速构建数据结构类的方式，一般在函数存在多返回值时可以使用元组 (返回值1类型,返回值2类型,….) 来声明返回值，在函数内部返回具体内容时通过 (返回值1,返回值2,….)  进行返回；</li><li>主要作用：提升开发效率，更方便的处理多返回值等需要用到多个值时的需求；</li></ul><p>2.使用案例：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.无变量名元组的声明(获取值：Item'N'作为从左到右依次的参数，N从1开始)(int, float,bool,string) yz = (1, 5.5f, true, "123");print(yz.Item1);2.有变量名元组的声明(int i, float f, bool b, string str) yz2 = (1, 5.5f, true, "123");print(yz2.i);3.元组可以进行等于和不等于的判断//数量相同才比较，类型相同才比较，每一个参数的比较是通过==比较 如果都是true 则认为两个元组相等if (yz == yz2)    print("相等");else    print("不相等");            4.元组的应用——函数返回值//利用元组定义一个多返回的函数    private (string str, int i, float f) GetInfo(){return ("123", 2, 5.5f);}//元组的解构赋值(string myStr,int myInt,float myFloat) = GetInfo();//丢弃参数,利用传入 下划线_ 达到丢弃该参数不使用的作用(string ss, _, _) = GetInfo();5. 元组的应用——字典//字典中的键 需要用多个变量来控制Dictionary&lt;(int i, float f), string&gt; dic = new Dictionary&lt;(int i, float f), string&gt;();dic.Add((1, 2.5f), "123");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>1.模式匹配说明：</p><ul><li>基本概念：“模式匹配”是一种测试表达式是否具有特定特征的方法，在编程里指的是，把一个不知道具体数据信息的内容，通过一些固定的语法格式来确定模式数据的具体内容的过程，是一种语法元素，可以测试一个值是否满足某种条件，并可以从值中提取信息，在C#7中，模式匹配增强了两个现有的语言结构：<ul><li>is表达式可以在右侧写一个模式语法，而不仅仅是一个类型；</li><li>switch语句中的case ；</li></ul></li><li>主要作用：节约代码量，提高编程效率</li></ul><p>2.详细案例</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.常量模式(is 常量)：用于判断输入值是否等于某个值        object o = 1.5f;        if(o is 1)        {            print("o是1");        }        if(o is null)        {            print("o是null");        }2.类型模式(is 类型 变量名、case 类型 变量名)：用于判断输入值类型，如果类型相同，将输入值提取出来//判断某一个变量是否是某一个类型，如果满足会将该变量存入你申明的变量中        if (o is int i)print(i);        switch (o)        {            case int value:                print("int:" + value);                break;            case float value:                print("float:" + value);                break;            case null:                print("null");                break;            default:                break;        }    3.var模式：用于将输入值放入与输入值相同类型的新变量中，相当于是将变量装入一个和自己类型一样的变量中；        if (GetInt() is var k &amp;&amp; k &gt;= 0 &amp;&amp; k &lt;= 10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="C-8功能和语法"><a href="#C-8功能和语法" class="headerlink" title="C# 8功能和语法"></a>C# 8功能和语法</h1><p>1.C# 8新增语法说明:</p><ul><li>静态本地函数（下面提及）；</li><li>Using 声明（下面提及）；</li><li>Null 合并赋值（下面提及）；</li><li>解构函数Deconstruct （下面提及）；</li><li>模式匹配增强功能（下面提及）；</li></ul><p>2.C# 8静态本地函数：和本地函数基本一致；</p><ul><li>基本概念：静态本地函数就是在本地函数前方加入静态关键字，让本地函数不能够使用访问封闭范围内（也就是上层方法中）的任何变量；</li><li>作用：让本地函数只能处理逻辑，避免让它通过直接改变上层变量来处理逻辑造成逻辑混乱；</li></ul><p>3.C# 8Using 声明：例如using StreamWriter s2 = new StreamWriter(“文件路径”)；</p><ul><li>回顾using()语法：using(对象声明){}，当语句块结束 会自动帮助我们调用 对象的 Dispose这个方法 让其进行销毁；</li><li>基本概念：Using 声明就是对using（）语法的简写，会在上层语句块执行结束时释放该对象；</li><li>注意事项：<ul><li>使用该简化关键字前提是有上层语句块，if，函数都是；</li><li>使用using语法用在自定义类时，声明的对象必须继承System.IDisposable接口，因为必须具备Dispose方法，所以当声明没有继承该接口的对象时会报错； </li></ul></li></ul><p>4.C# 8Null 合并赋值：例如str ??= “1111”;</p><ul><li>基本概念：类似复合运算符，左边值 ??= 右边值，当左侧为空时才会把右侧值赋值给变量；</li><li>注意事项：由于左侧为空才会讲右侧赋值给变量，所以不为空的变量不会改变；</li></ul><p>5.C# 8解构函数Deconstruct（C# 7就有了）：例如类中定义了该函数的话直接解构 (string name, bool sex) = p;</p><ul><li>语法：在类的内部申明函数public void Deconstruct(out 变量类型 变量名, out 变量类型 变量名…..)；</li><li>基本概念：我们可以在自定义类当中声明解构函数，这样我们可以将该自定义类对象利用元组的写法对其进行变量的获取，相当于把不同的成员变量拆分到不同的临时变量中；</li><li>特点：一个类中可以有多个Deconstruct，但是参数数量不能相同；</li></ul><h2 id="模式匹配增强功能"><a href="#模式匹配增强功能" class="headerlink" title="模式匹配增强功能"></a>模式匹配增强功能</h2><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.模式匹配增强功能——Switch表达式：        //switch表达式是对有返回值的switch语句的缩写        //用=&gt;表达式符号代替case:组合        //用_弃元符号代替default        //它的使用限制，主要是用于switch语句当中只有一句代码用于返回值时使用        //语法：        // 函数声明 =&gt; 变量 switch        //{        //常量=&gt;返回值表达式,        //常量=&gt;返回值表达式,        //常量=&gt;返回值表达式,        //....        //_ =&gt; 返回值表达式,        //}        //例如一个根据枚举获取方向的方法    public Vector2 GetPos(PosType type) =&gt; type switch    {        PosType.Top_Left =&gt; new Vector2(0, 0),        PosType.Top_Right =&gt; new Vector2(1, 0),        PosType.Bottom_Left =&gt; new Vector2(0, 1),        PosType.Bottom_Right =&gt; new Vector2(1, 1),        _ =&gt; new Vector2(0, 0)    };2.模式匹配增强功能——属性模式：        //就是在常量模式的基础上判断对象上各属性        //用法：变量 is {属性:值, 属性:值}        if (info is { discount: "6折", isDiscount: true })print("信息相同"); //可以利用属性模式 结合 switch表达式 判断n个条件是否满足    public float GetMoney(DiscountInfo info, float money) =&gt; info switch    {        { discount: "5折", isDiscount: true } =&gt; money * .5f,        { discount: "6折", isDiscount: true } =&gt; money * .6f,        { discount: "7折", isDiscount: true } =&gt; money * .7f,        _ =&gt; money    };3.模式匹配增强功能——元组模式：        //属性模式我们可以在switch表达式中判断多个变量同时满足再返回什么        //但是它必须是一个数据结构类对象，判断其中的变量        //而元组模式可以更简单的完成这样的功能，我们不需要声明数据结构类，可以直接利用元组进行判断    //元组模式简单用法    if((ii, bb) is (11, true))        //元组结合switch模式使用    public float GetMoney(string discount, bool isDiscount, float money) =&gt; (discount, isDiscount) switch    {        ("5折", true) =&gt; money * .5f,        ("6折", true) =&gt; money * .6f,        ("7折", true) =&gt; money * .7f,        _ =&gt; money    };4.模式匹配增强功能——位置模式：        //如果自定义类中实现了解构函数        //那么我们可以直接用对应类对象与元组进行is判断        if(info is ("5折", true))//同样我们也可以配合switch表达式来处理逻辑    public float GetMoney(DiscountInfo info, float money) =&gt; info switch    {//补充：配合when关键字进行逻辑处理        ("5折", true) when money &gt; 100 =&gt; money * .5f,        ("6折", true) =&gt; money * .6f,        ("7折", true) =&gt; money * .7f,        _ =&gt; money    };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="C-其他知识补充"><a href="#C-其他知识补充" class="headerlink" title="C# 其他知识补充"></a>C# 其他知识补充</h1><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-版本和Unity的关系&quot;&gt;&lt;a href=&quot;#C-版本和Unity的关系&quot; class=&quot;headerlink&quot; title=&quot;C#版本和Unity的关系&quot;&gt;&lt;/a&gt;C#版本和Unity的关系&lt;/h1&gt;&lt;p&gt;1.各Unity支持的的C#版本说明：主要是不同Un</summary>
      
    
    
    
    <category term="编程语言" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="C#" scheme="https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
    <category term="C#" scheme="https://wwy.wwywy.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity相关-Excel编辑器工具</title>
    <link href="https://wwy.wwywy.com/posts/1601.html"/>
    <id>https://wwy.wwywy.com/posts/1601.html</id>
    <published>2021-04-16T13:00:00.000Z</published>
    <updated>2022-07-09T16:20:04.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Excel介绍"><a href="#Excel介绍" class="headerlink" title="Excel介绍"></a>Excel介绍</h1><p>1.Excel的本质：Excel表本质上也是一堆数据，只不过它有自己的存储读取规则，如果我们想要通过代码读取它，那么必须知道它的存储规则，官网是专门提供了对应的DLL文件用来解析Excel文件的；</p><p>2.获取Excel数据信息的意义：</p><ul><li>可以根据表中数据来动态的生成相关数据，如数据结构类、容器类、二进制数据类；</li><li>转成二进制数据也可以提升读取效率，提升数据安全性；</li></ul><h1 id="Excel官方工具使用"><a href="#Excel官方工具使用" class="headerlink" title="Excel官方工具使用"></a>Excel官方工具使用</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">//主要知识点：//1.FileStream读取文件流//2.IExcelDataReader类，从流中读取Excel数据//3.DataSet 数据集合类 将Excel数据转存进其中方便读取//4.DataTable 数据表类 表示Excel文件中的一个表//5.DataRow 数据行类 表示某张表中的一行数据[MenuItem("GameTool/读取Excel里的具体信息")]private static void ReadExcel(){    using (FileStream fs = File.Open(Application.dataPath + "/ArtRes/Excel/PlayerInfo.xlsx", FileMode.Open, FileAccess.Read))    {        IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs);        DataSet result = excelReader.AsDataSet();        for (int i = 0; i &lt; result.Tables.Count; i++)        {            //得到其中一张表的具体数据            DataTable table = result.Tables[i];            Debug.Log("表名：" + result.Tables[i].TableName);            Debug.Log("行数：" + result.Tables[i].Rows.Count);            Debug.Log("列数：" + result.Tables[i].Columns.Count);            //得到其中一行的数据            DataRow row = table.Rows[0];            //得到行中某一列的信息            Debug.Log(row[1].ToString());            DataRow row;            for (int j = 0; j &lt; table.Rows.Count; j++)            {                //得到每一行的信息                row = table.Rows[j];                Debug.Log("*********新的一行************");                for (int k = 0; k &lt; table.Columns.Count; k++)                {                    //得到每一列的信息                    Debug.Log(row[k].ToString());                }            }        }        fs.Close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="制定规则"><a href="#制定规则" class="headerlink" title="制定规则"></a>制定规则</h1><p>1.Excel读取规则：</p><ul><li>数据类型生成要知道字段名，容器（一般字典）要知道主键，二进制要知道从哪行哪列开始；</li><li>第一行是字段名，第二行是数据类型，第三行容器可以再加一个key表示主键（也可以默认第一列），第四行是中文解释（给策划写的，不会生成进去）；</li><li>下方的表名作为生成的类型名；</li></ul><h1 id="Excel工具编写"><a href="#Excel工具编写" class="headerlink" title="Excel工具编写"></a>Excel工具编写</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Excel介绍&quot;&gt;&lt;a href=&quot;#Excel介绍&quot; class=&quot;headerlink&quot; title=&quot;Excel介绍&quot;&gt;&lt;/a&gt;Excel介绍&lt;/h1&gt;&lt;p&gt;1.Excel的本质：Excel表本质上也是一堆数据，只不过它有自己的存储读取规则，如果我们想要通过</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="Excel" scheme="https://wwy.wwywy.com/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Unity进阶-ScriptableObject</title>
    <link href="https://wwy.wwywy.com/posts/1548.html"/>
    <id>https://wwy.wwywy.com/posts/1548.html</id>
    <published>2021-04-13T13:00:00.000Z</published>
    <updated>2022-07-09T16:17:19.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ScriptableObject概述"><a href="#ScriptableObject概述" class="headerlink" title="ScriptableObject概述"></a>ScriptableObject概述</h1><p>1.ScriptableObject说明：ScriptableObject是Unity提供的一个数据配置存储基类，它是一个可以用来保存大量数据的数据容器，就像是可以自定义的数据预制物资源文件，需要我们继承它来进行使用，它的主要作用是如下：</p><ul><li>数据复用（多个对象用同一个数据）</li><li>配置文件（配置游戏中的数据）</li><li>编辑模式下的数据持久化</li></ul><p>2.ScriptableObject优点：如下</p><ul><li>我们可以直接在Inspector窗口编辑配置数据，可以利用它来做配置文件；</li><li>处理重复数据，减少数据拷贝时造成的内存占用，可以利用它来做公共数据；</li><li>可以更方便的处理数据带来的多态行为；</li></ul><p>3.ScriptableObject持久化注意点：通过代码修改数据对象中内容，会影响数据文件，相当于达到了编辑器中数据持久化的目的(该数据持久化 只是在编辑模式下的持久,发布运行时并不会保存数据)；</p><h1 id="ScriptableObject数据文件创建"><a href="#ScriptableObject数据文件创建" class="headerlink" title="ScriptableObject数据文件创建"></a>ScriptableObject数据文件创建</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.自定义ScriptableObject数据容器        //1.继承ScriptableObject类        //2.在该类中声明成员（变量、方法等）        //注意：声明后，我们边可以在Inspector窗口中看到变化        //     我们可以在其中进行设置，但是这些设置都是默认数据，并没有真正使用他们        //     这些关联信息都是通过脚本文件对应的Unity配置文件meta进行记录的        //     目前该数据只是一个数据容器模板        //     有了它我们之后才能根据它的信息创建对应的数据资源文件2.根据自定义的ScriptableObject数据容器创建数据文件        //注意：        //该创建功能，其实就是根据自定义数据容器类创建了一个配置文件        //该文件中记录了对应的数据容器类信息，以及其中变量关联的信息        //之后我们在使用它时，本质上也是通过反射创建对象进行使用        //具体的方法有两种：        //1.为类添加CreateAssetMenu通过菜单创建资源特性        //[CreateAssetMenu(fileName = "默认文件名", menuName = "在Asset/Create菜单中显示的名字", order = 再Asset/Create菜单中的位置(多个时可以通过它来调整顺序))]        //2.利用ScriptableObject的静态方法创建数据对象        //书写创建数据资源文件的代码         MyData asset = ScriptableObject.CreateInstance&lt;MyData&gt;();        //通过编辑器API 根据数据创建一个数据资源文件        AssetDatabase.CreateAsset(asset, "Assets/Resources/MyDataTest.asset");        //保存创建的资源        AssetDatabase.SaveAssets();        //刷新界面        AssetDatabase.Refresh();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ScriptableObject数据文件使用"><a href="#ScriptableObject数据文件使用" class="headerlink" title="ScriptableObject数据文件使用"></a>ScriptableObject数据文件使用</h1><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">1.ScriptableObject数据文件的使用        //1.通过Inspector中的public变量进行关联        //1-1.创建一个数据文件        //1-2.在继承MonoBehaviour类中申明数据容器类型的成员        //    在Inspector窗口进行关联        //2.通过资源加载的信息关联        //加载数据文件资源        //注意：Resources、AB包、Addressables都支持加载继承ScriptableObject的数据文件        data = Resources.Load&lt;MyData&gt;("MyDataTest");        //注意：如果多个对象关联同一个数据容器文件，他们共享的是一个对象        //     因为是引用对象，所以在其中任何地方修改后，其它地方也会发生改变2.ScriptableObject的生命周期函数        //ScriptableObject和MonoBehavior很类似        //它也存在生命周期函数        //但是生命周期函数的数量更少        //主要做了解，一般我们使用较少        //Awake 数据文件创建时调用        //OnDestroy ScriptableObject 对象将被销毁时调用        //OnDisable ScriptableObject 对象销毁时、即将重新加载脚本程序集时 调用        //OnEnable ScriptableObject 创建或者加载对象时调用        //OnValidate 编辑器才会调用的函数，Unity在加载脚本或者Inspector窗口中更改值时调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ScriptableObject的非持久化和持久化"><a href="#ScriptableObject的非持久化和持久化" class="headerlink" title="ScriptableObject的非持久化和持久化"></a>ScriptableObject的非持久化和持久化</h1><p>1.ScriptableObject的非持久化数据说明：指的是不管在编辑器模式还是在发布后都 不会持久化的数据，我们可以根据自己的需求随时创建对应数据对象进行使用，就好像直接new一个数据结构类对象；</p><p>2.利用ScriptableObject生成非持久化的数据：利用ScriptableObject中的静态方法 CreateInstance&lt;&gt;()，通过这种方式创建出来的数据对象 它里面的默认值 不会受到脚本中设置的影响，该对象只存在于内存当中，可以被GC；</p><p>3.非持久化数据存在的意义：只是希望在运行时能有一组唯一的数据可以使用，但是这个数据又不太希望保存为数据资源文件浪费硬盘空间，那么ScriptableObject的非持久化数据就有了存在的意义（只在运行时使用，在编辑器模式下也不会保存在本地）</p><p>4.ScriptableObject真正意义的持久化：持久化（硬盘&lt;=&gt;内存），首先要理解的是ScriptableObject的主要意义并不是用来进行持久化的，但是我们也可以利用持久化的相关知识来进行运行时读取；</p><h1 id="ScriptableObject的应用"><a href="#ScriptableObject的应用" class="headerlink" title="ScriptableObject的应用"></a>ScriptableObject的应用</h1><h2 id="配置数据"><a href="#配置数据" class="headerlink" title="配置数据"></a>配置数据</h2><p>1.ScriptableObject配置说明：ScriptableObject适合用来作配置文件，结合List使用或者字典使用（集合类型遵守Unity规则，加上序列化标签），也可以在Excel中作配置，然后编辑器导出ScriptableObject文件；</p><h2 id="复用数据"><a href="#复用数据" class="headerlink" title="复用数据"></a>复用数据</h2><p>1.ScriptableObject复用数据说明：游戏实体中定义的数据是不同地址的，但是对于只用不变的数据，以面向对象的思想去声明是会存在内存浪费的，特别是像子弹这种类型，所以我们刻意利用ScriptableObject静态数据来进行共享使用，更加节约内存；</p><h2 id="数据带来的多态行为"><a href="#数据带来的多态行为" class="headerlink" title="数据带来的多态行为"></a>数据带来的多态行为</h2><p>1.ScriptableObject的多态：当数据不一样时带来的多态行为，依赖于抽象，而不依赖于实现，调用继承自ScriptableObject的数据类方法，但是实际调用的子类的多态方法（例如角色碰撞道具获得效果，基类只管获取道具的方法，具体是加血还是加攻击由子类决定）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ScriptableObject概述&quot;&gt;&lt;a href=&quot;#ScriptableObject概述&quot; class=&quot;headerlink&quot; title=&quot;ScriptableObject概述&quot;&gt;&lt;/a&gt;ScriptableObject概述&lt;/h1&gt;&lt;p&gt;1.Scri</summary>
      
    
    
    
    <category term="游戏引擎" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="Unity" scheme="https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"/>
    
    
    <category term="Unity" scheme="https://wwy.wwywy.com/tags/Unity/"/>
    
    <category term="ScriptableObject" scheme="https://wwy.wwywy.com/tags/ScriptableObject/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论</title>
    <link href="https://wwy.wwywy.com/posts/517.html"/>
    <id>https://wwy.wwywy.com/posts/517.html</id>
    <published>2021-03-02T13:00:00.000Z</published>
    <updated>2022-07-09T16:13:41.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="人工智能基本概念"><a href="#人工智能基本概念" class="headerlink" title="人工智能基本概念"></a>人工智能基本概念</h2><p>1.自然界四大奥秘：物质的本质、宇宙的起源、生命的本质、智能的发生；</p><p>2.智能的定义：智能是只是和智力的总和；</p><p>3.智能的特征：</p><ul><li>感知能力（游戏AI必须品）：主动信息的输入，实现视觉、听觉、触觉、嗅觉等感觉器官；</li><li>记忆力和思维能力：信息的存储和信息的模拟，记忆存储由感知器官感知到的外部信息以及由思维所产生的知识，思维能力对记忆的信息进行处理；<ul><li>逻辑思维（抽象思维）：例如理科生通过逻辑去肢解一道数学题；</li><li>形象思维（直感思维）：例如人的第五感；</li><li>顿悟思维（灵感思维）：例如牛顿如何发现了力学；</li></ul></li><li>学习能力：被动信息的输入，学习既可能是自觉的、有意识的，也可能是不自觉的、无意识的；既可以是有教师指导的，也可以是通过自己实践的；</li><li>行为能力（表达能力）：信息的输入，人工智能实现的目的；</li></ul><h2 id="人工智能发展简史"><a href="#人工智能发展简史" class="headerlink" title="人工智能发展简史"></a>人工智能发展简史</h2><p>人工智能发展史：了解就好了，知乎看看就好；<br><a href="https://zhuanlan.zhihu.com/p/43599960">人工智能发展史 - 知乎 (zhihu.com)</a></p><h2 id="人工智能研究的基本内容"><a href="#人工智能研究的基本内容" class="headerlink" title="人工智能研究的基本内容"></a>人工智能研究的基本内容</h2><p>1.知识表达：将人类知识形式化或者模型化，方法有符号表示法、连接机制表示法，简单点说就是建立一个能把人懂的东西弄成机器能懂的东西的东西；</p><p>2.机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主；</p><p>3.机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理；</p><p>4.机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识；</p><p>5.机器行为：计算机的表达能力，即“说”、“写”、“画”等能力；</p><h2 id="人工智能的主要研究领域"><a href="#人工智能的主要研究领域" class="headerlink" title="人工智能的主要研究领域"></a>人工智能的主要研究领域</h2><p>主要领域：自动定理证明、博弈、模式识别、机器视觉 、自然语言理解、机器翻译、智能信息检索 、数据挖掘与知识发现、专家系统、自动程序设计、机器人、组合优化问题、人工神经网络；</p><p>其他领域：分布式人工智能与多智能体、智能控制、智能仿真、智能CAD 、智能CAI  、智能管理与智能决策 、智能多媒体系统 、智能操作系统、智能计算机系统 、智能通信 、智能网络系统、人工生命 ；</p><h1 id="知识表示与知识图谱"><a href="#知识表示与知识图谱" class="headerlink" title="知识表示与知识图谱"></a>知识表示与知识图谱</h1><h2 id="知识和知识表示"><a href="#知识和知识表示" class="headerlink" title="知识和知识表示"></a>知识和知识表示</h2><h3 id="知识的概念"><a href="#知识的概念" class="headerlink" title="知识的概念"></a>知识的概念</h3><p>1.知识的定义：把有关信息关联在一起所形成的信息结构；</p><p>2.知识的作用：反映了客观世界中事物之间的关系；</p><p>3.知识的特性：</p><ul><li>相对正确性：知识在一定的条件及环境下产生的才是正确的；</li><li>不确定性：<ul><li>随机性引起的不确定性 ：清明一般都会下雨，但是也有不下雨的时候；</li><li>模糊性引起的不确定性 ：根据人的外貌去判断年龄；</li><li>经验引起的不确定性：经历丰富的人相对知识也更加丰富；</li><li>不完全性引起的不确定性：比如对人类对宇宙的了解并不完整；</li></ul></li><li>可表示性和可利用性：知识可以用适当形式表示和利用；</li></ul><h3 id="知识表示的概念"><a href="#知识表示的概念" class="headerlink" title="知识表示的概念"></a>知识表示的概念</h3><p>1.知识表示的定义：将人类的知识形式化或者模型化（人类划重点）；</p><p>2.知识表示的作用：计算机可以接受的描述知识的数据结构</p><p>3.知识选择方法的原则：有利于知识的充分表示和分利用、便于组织、维护、管理、理解和实现；</p><h2 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/thsrobot/article/details/85211896"> 人工智能一阶谓词逻辑表示法</a></p><h2 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h2><p>非专业作了解：<br><a href="http://www.360doc.com/content/11/0502/21/2097544_113822638.shtml">产生式表示法</a></p><h2 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h2><p>非专业作了解：<br><a href="https://www.cnblogs.com/cy0628/p/13905601.html">知识表示之框架表示法</a></p><h2 id="知识图谱（推荐学习）"><a href="#知识图谱（推荐学习）" class="headerlink" title="知识图谱（推荐学习）"></a>知识图谱（推荐学习）</h2><p>定义：是一种揭示实体之间关系的语义网络；<br>目的：知识图谱的目的是为了提高搜索引擎的能力，改善用户的搜索质量以及搜索体验；</p><p>1.知识图谱的逻辑结构：</p><ul><li>数据层：主要是由一系列的事实组成，而知识以事实为单位进行存储。</li><li>模式层：构建在数据层之上，是知识图谱的核心。</li></ul><p>2.知识图谱的原始数据类型：</p><ul><li>结构化数据：是指知识定义和表示都比较完备的数据，如关系数据库；</li><li>半结构化数据：是指部分数据是结构化的，但存在大量结构化程度较低的数据，如XML、JSON；</li><li>非结构化数据：是指没有定义和规范约束的“自由”数据，如文本、视频、音频、图片；</li></ul><p>了解更多：<br><a href="http://www.360doc.com/content/20/0525/00/43535834_914347385.shtml">通俗易懂解释知识图谱</a></p><h2 id="确定性推导方法"><a href="#确定性推导方法" class="headerlink" title="确定性推导方法"></a>确定性推导方法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/lagoon_lala/article/details/85133897">确定性推理方法</a></p><h2 id="不确定性推导方法"><a href="#不确定性推导方法" class="headerlink" title="不确定性推导方法"></a>不确定性推导方法</h2><p>非专业作了解：<br><a href="https://blog.csdn.net/qq_31456593/article/details/78623871">不确定推理方法</a></p><h1 id="搜索求解策略"><a href="#搜索求解策略" class="headerlink" title="搜索求解策略"></a>搜索求解策略</h1><h2 id="搜索的概念"><a href="#搜索的概念" class="headerlink" title="搜索的概念"></a>搜索的概念</h2><p>1.搜索算法主要解决问题：</p><ul><li>是否一定能找到一个解。</li><li>找到的解是否是最佳解。</li><li>时间与空间复杂性如何。</li><li>是否终止运行或是否会陷入一个死循环</li></ul><p>2.搜索方向：</p><ul><li>从初始给出的条件出发；</li><li>从目的地出发，进行逆推算；</li><li>（A*算法）从开始状态出发作正向搜索，同时又从目的状态出发作逆向搜索，直到两条路径在中间的某处汇合为止；<h2 id="状态空间的搜索策略"><a href="#状态空间的搜索策略" class="headerlink" title="状态空间的搜索策略"></a>状态空间的搜索策略</h2>非专业作了解：<br><a href="https://blog.csdn.net/weixin_48615832/article/details/120330789">状态空间表示法</a></li></ul><h2 id="盲目的图搜索策略"><a href="#盲目的图搜索策略" class="headerlink" title="盲目的图搜索策略"></a>盲目的图搜索策略</h2><h3 id="回溯策略"><a href="#回溯策略" class="headerlink" title="回溯策略"></a>回溯策略</h3><p>1.回溯策略的数据结构：</p><ul><li>Pass集合：记录寻路算法中的可走路径，保存搜索路径的状态，如果找到了目的，该集合就是解；</li><li>Open集合：等待搜索或者待访问的状态集合；</li><li>Close集合：已经被访问的状态集合；</li></ul><h3 id="广度优先搜索策略"><a href="#广度优先搜索策略" class="headerlink" title="广度优先搜索策略"></a>广度优先搜索策略</h3><p>1.算法特点：如下俩点</p><ul><li>每次选择深度最浅的节点首先扩展，搜索是逐层进行的，如图5.6所示；</li><li>一种高价搜索，会遍历所有节点，但若有解存在，则必能找到它，且是最短路径（可以理解很多人沿着不同的方向走，人多力量大）；<br>  <img src="https://s1.ax1x.com/2022/03/09/bWbIYV.png" alt="广度优先算法搜索次序"></li></ul><p>2.算法描述如下：</p><ul><li>a：选择一个未访问的顶点入队；</li><li>b：从队里选出一个顶点V出队，并且标记为已经访问；</li><li>c：将顶点V的所有未被访问的邻接顶点入队并且设置该节点父节点为顶点V；</li><li>d：重复步骤a~b，直到所有顶点都已经被访问；</li><li>e：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）</li></ul><p>3.核心算法实现：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">/// &lt;summary&gt;/// 广度优先算法BFS/// &lt;/summary&gt;/// &lt;param name="originNode"&gt;起点位置&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标位置&lt;/param&gt;/// &lt;param name="passNodeList"&gt;可走路径&lt;/param&gt;public static void BFSSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeList){    Queue&lt;Node&gt; openQue = new Queue&lt;Node&gt;();    openQue.Enqueue(originNode);    while (openQue.Count &gt; 0)    {        Node head = openQue.Dequeue();        //获取该节点周围的节点        List&lt;Node&gt; neighborLst = Program.GetNeighbor(head);        //检查周围的节点        for (int i = 0; i &lt; neighborLst.Count; i++)        {            Node neighborNode = neighborLst[i];            //节点被访问或者是障碍物的直接继续            if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue;            //记录节点被访问            neighborNode.isVisit = true;            //记录父节点            neighborNode.parent = head;            openQue.Enqueue(neighborNode);            //这个时候整个地图已经遍历完了            if (neighborNode.Equals(targetNode))            {                //反向输出父节点，就是要找的路径                while (!neighborNode.Equals(originNode))                {                    neighborNode = neighborNode.parent;                    passNodeList.Add(neighborNode);                    neighborNode.nodeType = NodeType.Pass;                }                //最后添加目标点（其实直接返回目标节点也是可以的）                passNodeList.Add(targetNode);                targetNode.nodeType = NodeType.Pass;                return;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="深度优先搜索策略"><a href="#深度优先搜索策略" class="headerlink" title="深度优先搜索策略"></a>深度优先搜索策略</h3><p>1.算法特点：</p><ul><li>扩展最深的节点的结果使得搜索沿着状态空间某条单一的路径从起始节点向下进行下去；仅当搜索到达一个没有后裔的状态时，才考虑另一条替代的路径；</li><li>为了保证找到解，应选择合适的深度限制值，或采取不断加大深度限制值的办法，反复搜索，直到找到解；</li><li>深度优先搜索并不能保证第一次搜索到的某个状态时的路径是到这个状态的最短路径，如果路径距离很重要的话，它应该尝试保留最短路径；</li></ul><p><img src="https://s1.ax1x.com/2022/03/09/bfMTyT.png" alt="深度优先算法搜索次序"></p><p>2.算法描述如下：</p><ul><li>a：选择传入的起始顶点，并将顶点标记已经访问；</li><li>b：访问邻接顶点，直到某个顶点没有邻接顶点再继续下一步；</li><li>c：回溯到上一层顶点，重复b步，直到所有顶点都被访问；</li><li>d：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）；</li></ul><p>3.核心算法实现：</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">   /// &lt;summary&gt;   /// 深度优先算法BFS（简单实现，非最优路径）   /// &lt;/summary&gt;   /// &lt;param name="currentNode"&gt;当前位置&lt;/param&gt;   /// &lt;param name="originNode"&gt;起点位置&lt;/param&gt;   /// &lt;param name="targetNode"&gt;目标位置&lt;/param&gt;   /// &lt;param name="passNodeList"&gt;可走路径&lt;/param&gt;public static void DFSSearch(Node currentNode, Node originNode, Node targetNode,ref List&lt;Node&gt; passNodeList)   {       //标记该节点已经被访问currentNode.isVisit = true;       //获取该节点周围的节点List&lt;Node&gt; neighborLst = Program.GetNeighbor(currentNode);for(int i = 0; i &lt; neighborLst.Count; i++)       {Node neighborNode = neighborLst[i];           //节点被访问或者是障碍物的直接继续           if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue;           //记录父节点           neighborNode.parent = currentNode;           //递归调用,先深再广           DFSSearch(neighborNode, originNode, targetNode, ref passNodeList);           //这个时候已经找到目标节点了           if (neighborNode.Equals(targetNode))           {               //反向输出父节点，就是要找的路径               while (!neighborNode.Equals(originNode))               {                   neighborNode = neighborNode.parent;                   passNodeList.Add(neighborNode);                   neighborNode.nodeType = NodeType.Pass;               }               //最后添加目标点（其实直接返回目标节点也是可以的）               passNodeList.Add(targetNode);               targetNode.nodeType = NodeType.Pass;               return;           }       }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="启发式图搜索策略"><a href="#启发式图搜索策略" class="headerlink" title="启发式图搜索策略"></a>启发式图搜索策略</h2><h3 id="启发式策略"><a href="#启发式策略" class="headerlink" title="启发式策略"></a>启发式策略</h3><p>1.启发式信息定义：用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息；</p><p>2.启发式策略特点：重排Open表，选择最有希望的节点加以扩展；</p><p>3.启发信息分类：按以下俩种情况考虑</p><ul><li>按运用的方法分类：<ul><li>陈述性启发信息：用于更准确、更精炼地描述状态；</li><li>过程性启发信息：用于构造操作算子；</li><li>控制性启发信息：表示控制策略的知识；</li></ul></li><li>按作用分类：<ul><li>用于扩展节点的选择，即用于决定应先扩展哪一个节点，以免盲目扩展；</li><li>用于生成节点的选择，即用于决定要生成哪些后继节点，以免盲目生成过多无用的节点；</li><li>用于删除节点的选择，即用于决定删除哪些无用节点，以免造成进一步的时空浪费；   </li></ul></li></ul><h3 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h3><p>1.估价函数公式：用来估算初始节点经过 n节点到达目标节点的路径的最小代价，如下推理</p><ul><li>估价函数值f(n) ==&gt; g(n) + h(n);</li><li>g(n) ==&gt; 从当前节点到待访问节点n的实际代价（其实就是距离）</li><li>h(n) ==&gt; 从待访问节点n到终点的估算代价（其实就是方向）<ul><li>h(n) 比重大：降低搜索工作量，但可能导致找不到最优解；</li><li>h(n) 比重小：一般导致工作量加大，极限情况下变为盲目搜索，但可能可以找到最优解；</li></ul></li></ul><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>1.核心算法实现</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">/// &lt;summary&gt;/// A*启发式寻路算法/// &lt;/summary&gt;/// &lt;param name="originNode"&gt;起点&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标节点&lt;/param&gt;/// &lt;param name="passNodeLst"&gt;通行路径&lt;/param&gt;public static bool AstarSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeLst){//如果当前节点等于目标节点直接返回if (originNode.Equals(targetNode)){passNodeLst.Add(originNode);return true;}//下一次准备搜索的列表List&lt;Node&gt; openLst = new List&lt;Node&gt;();//关闭搜索节点列表List&lt;Node&gt; closeLst = new List&lt;Node&gt;();Node currentNode=originNode;openLst.Add(currentNode);while (openLst.Count &gt; 0){currentNode = GetMinF(openLst , currentNode, targetNode);//这个时候已经找到目标节点了if (currentNode.Equals(targetNode)){//反向输出父节点，就是要找的路径while (!currentNode.Equals(originNode)){passNodeLst.Add(currentNode);currentNode = currentNode.parent;currentNode.nodeType = NodeType.Pass;}//最后添加目标点（其实直接返回目标节点也是可以的）passNodeLst.Add(originNode);originNode.nodeType = NodeType.Pass;targetNode.nodeType = NodeType.Pass;return true;}openLst.Remove(currentNode);closeLst.Add(currentNode);           foreach (Node neighborNode in Program.GetNeighbor(currentNode))           {if (openLst.Contains(neighborNode) || neighborNode.nodeType == NodeType.Block|| closeLst.Contains(neighborNode)) continue;openLst.Add(neighborNode);}       }return false;}/// &lt;summary&gt;/// 估值函数（A*算法核心）/// &lt;/summary&gt;/// &lt;param name="openLst"&gt;开放节点&lt;/param&gt;/// &lt;param name="closeLst"&gt;关闭节点&lt;/param&gt;/// &lt;param name="currentNode"&gt;当前节点&lt;/param&gt;/// &lt;param name="targetNode"&gt;目标节点&lt;/param&gt;/// &lt;returns&gt;返回估值后最小F的节点&lt;/returns&gt;public static Node GetMinF(List&lt;Node&gt; openLst, Node currentNode, Node targetNode){if(openLst.Count &lt;= 1)return currentNode;int minFVal = int.MaxValue;Node? nextNode = null;foreach (Node node in openLst){int fVal = GetG(currentNode, node) + GetH(node, targetNode);if (fVal &gt;= minFVal) continue;minFVal = fVal;nextNode = node;}if(nextNode != null) nextNode.parent = currentNode;return nextNode;}/// &lt;summary&gt;/// 获取G(M)值/// &lt;/summary&gt;public static int GetG(Node currentNode,Node nextNode)   {if (currentNode.xIndex == nextNode.xIndex || currentNode.yIndex == nextNode.yIndex) return 10;else return 14;}   /// &lt;summary&gt;   /// 获取H(M)值(这里采用欧式距离)   /// &lt;/summary&gt;   public static int GetH(Node currentNode, Node targetNode)   {int a=Math.Abs(currentNode.xIndex-targetNode.xIndex);int b=Math.Abs(currentNode.yIndex-targetNode.yIndex);return 10*(int)Math.Sqrt(a*a+b*b);   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;h2 id=&quot;人工智能基本概念&quot;&gt;&lt;a href=&quot;#人工智能基本概念&quot; class=&quot;headerlink&quot; title=&quot;人工智能基本概念&quot;</summary>
      
    
    
    
    <category term="大学知识" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    <category term="CS基础" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"/>
    
    <category term="人工智能" scheme="https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
</feed>
