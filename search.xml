<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity角色换装</title>
      <link href="/posts/1552.html"/>
      <url>/posts/1552.html</url>
      
        <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 换装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity插件 - Animancer插件使用</title>
      <link href="/posts/1549.html"/>
      <url>/posts/1549.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Animancer </tag>
            
            <tag> Playable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET6.0框架笔记</title>
      <link href="/posts/2049.html"/>
      <url>/posts/2049.html</url>
      
        <content type="html"><![CDATA[<h1 id="ET6-0框架介绍"><a href="#ET6-0框架介绍" class="headerlink" title="ET6.0框架介绍"></a>ET6.0框架介绍</h1><h1 id="项目的初步运行"><a href="#项目的初步运行" class="headerlink" title="项目的初步运行"></a>项目的初步运行</h1><p>1.运行Unity客户端项目，并且打开编程软件进行初步编译；<br>2.打开服务端项目，第一次打开编译Client下的Mono文件夹；<br>3.重新编译整个解决方案；<br>4.客户端F5生成代码；</p><h1 id="ET前后端通讯机制"><a href="#ET前后端通讯机制" class="headerlink" title="ET前后端通讯机制"></a>ET前后端通讯机制</h1><p>登录实例：<br>1.通过NetKcpComponent组件创建Session会话连接；<br>2.Session（由ET框架管理）会话的Id和TChannel进行绑定；<br>3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；<br>4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器；</p><h1 id="ET的多线程和分布式"><a href="#ET的多线程和分布式" class="headerlink" title="ET的多线程和分布式"></a>ET的多线程和分布式</h1><p>第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；<br>第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；<br>第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；<br>第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；<br>ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构</p><p>登录实例（接上）：<br>1.网关负载均衡服务器随机分配网关配置；<br>2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；<br>3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；<br>4.游戏客户端和游戏网关建立正式连接；<br>5.登录进Map服务器<br>注意：C就是客户端，R是网关负载均衡服务器，G是网关；<br><img src="https://s4.ax1x.com/2022/02/21/HveY4J.png" alt="ET分布式说明"></p><h1 id="ET的ECS组件编程"><a href="#ET的ECS组件编程" class="headerlink" title="ET的ECS组件编程"></a>ET的ECS组件编程</h1><p>ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）；</p><p>遵守的编程原则：<br>1.实体即组件、组件即实体；<br>2.编写一个实体或者组件，绝不继承除Entity外的任何父类；<br>3.不使用任何虚函数，使用逻辑分发替代；<br>4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；<br>5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；<br>6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；<br>7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误；</p><p>其他原则：<br>1.系统命名必须是实体名+System；<br>2.系统必须是静态类；<br>3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；<br>4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.实体或者组件    public class Computer: Entity,IAwake,IUpdate,IDestroy    public class MouseComponent : Entity, IAwake    //2.系统    public static class ComputerSystem    {       //需要使用拓展方法        public static void Start(this Computer self)        {            Log.Debug("计算机启动");//这里可以调用身上的组件            self.GetComponent&lt;PCCaseComponent&gt;().StartPower();            self.GetComponent&lt;MonitorsComponent&gt;().DisPlay();        }    }//3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上    Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;();computer.AddComponent&lt;PCCaseComponent&gt;();computer.AddComponent&lt;MonitorsComponent&gt;();computer.AddComponent&lt;KeyBoardComponent&gt;();computer.AddComponent&lt;MouseComponent&gt;();computer.Start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中ECS编程的生命周期"><a href="#ET中ECS编程的生命周期" class="headerlink" title="ET中ECS编程的生命周期"></a>ET中ECS编程的生命周期</h1><p>  ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.生命周期函数类    public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt;    public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt;    public class ComputerDestroySystem : DestroySystem&lt;Computer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET的逻辑分发"><a href="#ET的逻辑分发" class="headerlink" title="ET的逻辑分发"></a>ET的逻辑分发</h1><p>OOP面向对象的缺点：继承层次过深时，牵一发而动全身；</p><p>ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承；</p><h1 id="ET的Scene层级树"><a href="#ET的Scene层级树" class="headerlink" title="ET的Scene层级树"></a>ET的Scene层级树</h1><p>Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id；</p><p>客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）:<br><img src="https://s4.ax1x.com/2022/02/20/HO46xg.png" alt="ET框架客户端Scene的层级关系"></p><p>服务端Scene的层级关系:<br><img src="https://s4.ax1x.com/2022/02/20/HOIEX4.png" alt="ET框架服务端Scene的层级关系"></p><p>服务端机器人Scene的层级关系<br><img src="https://s4.ax1x.com/2022/02/20/HOT9zT.png" alt="ET框架服务端机器人Scene的层级关系"></p><h1 id="ET的Excel配置工具"><a href="#ET的Excel配置工具" class="headerlink" title="ET的Excel配置工具"></a>ET的Excel配置工具</h1><p>Excel配置工具注意事项：<br>1.配置文件从第三行第三列开始写，跟VBA宏有关；<br>2.第一个类型字段名必须是Id；<br>3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；<br>4.加#是注释，仅给策划使用，不会添加到游戏数据中；<br>5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\Assets\Bundles\Config下；可以查看文本形式在Bin\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；<br>6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；<br>7.行是可以空行的，可以用来分类注释，目测加#；<br>8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；<br>9.配置工具支持的导表类型可以在Tools\Apps\EXcelExporter文件下的Convert静态类中定义或查看；<br>10.数组类型默认在配置文件中加英文,配置;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型//获取单个UnitConfig config = UnitConfigCategory.Instance.Get(1001)//获取所有var configs = UnitConfigCategory.Instance.GetAll()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的事件系统"><a href="#ET中的事件系统" class="headerlink" title="ET中的事件系统"></a>ET中的事件系统</h1><p>1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；<br>2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；<br>3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.定义事件，添加事件,必须EventType命名空间下进行定义        public struct InstallComputer        {            //定义参数            public Computer computer;        }        //2.调用事件，触发事件//同步PublishGame.EventSystem.Publish(new EventType.InstallComputer() { computer = computer });//同步PublishAnycsawait Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer });//异步PublishAnycsGame.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine();//3.编写事件触发逻辑    public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt;    {        //必须添加async        protected async override ETTask Run(InstallComputer arg)        {            Computer computer = arg.computer;            computer.AddComponent&lt;PCCaseComponent&gt;();            computer.AddComponent&lt;MonitorsComponent&gt;();            computer.AddComponent&lt;KeyBoardComponent&gt;();            computer.AddComponent&lt;MouseComponent&gt;();            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的ETTask异步编程"><a href="#ET中的ETTask异步编程" class="headerlink" title="ET中的ETTask异步编程"></a>ET中的ETTask异步编程</h1><p>同步操作：先完成其全部工作在返回调用者；<br>异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；<br>ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码;</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.ETTask函数编写//无返回值,参数类型用来控制取消异步函数public async ETTask TestAsync(ETCancellationToken cancellationToken)        {//表明该函数可能是同步函数await ETTask.CompletedTask;//第二参数同上bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken);//根据返回值控制if (rt) Log.Debug("函数取消了");else Log.Debug("继续执行下面逻辑");}//有返回值        public async ETTask&lt;int&gt; TestResultAsync()        {            await TimerComponent.Instance.WaitAsync(1000);return 10;        }        2.ETTask函数的调用//定义取消异步函数实例ETCancellationToken cancellationToken=new ETCancellationToken();//等待无返回值函数调用完成await TestAsync(cancellationToken);//不等待无返回值函数完成，执行下面逻辑TestAsync(cancellationToken).Coroutine();//等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题int value = await TestResultAsync();//取消函数cancellationToken.Cancel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Protobuf通讯消息"><a href="#ET中的Protobuf通讯消息" class="headerlink" title="ET中的Protobuf通讯消息"></a>ET中的Protobuf通讯消息</h1><p>Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。<br>Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；<br>Protobuf的Github开源地址 :<a href="https://github.com/protocolbuffers/protobuf">GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式</a></p><p>ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\Apps\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版;</p><p>.proto描叙文件编写的的注意事项：<br>1.Proto数据结构描叙文件存放在Proto文件夹下；<br>2.OuterMessage是定义客户端和服务端通信的消息；<br>3.InnerMessage是服务端内部通信的消息；<br>4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；<br>5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；<br>6.消息定义体中的Id不能重复；<br>7.生成的转换类型列表可以在Tools\Apps\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\Generate\Message下；<br>8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；<br>9.字符之间必须要留空格；<br>10.proto文件中的注释意义重大；</p><p>网络Handler消息编写注意事项<br>1.类名定义务必以消息类名+Handler作为声明<br>2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；<br>3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用<br>4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与；</p><h1 id="ET普通网络消息编写"><a href="#ET普通网络消息编写" class="headerlink" title="ET普通网络消息编写"></a>ET普通网络消息编写</h1><p>普通消息.proto文件编写：</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">// ResponseType R2C_LoginTest（普通请求消息一定要注释返回类）message C2R_LoginTest  // IRequest（普通请求消息必须注释）{    int32 RpcId = 90;（普通请求消息必须声明该字段）string Account = 1;string Password = 2;}message R2C_LoginTest  // IResponse（普通响应消息必须注释）{    int32 RpcId = 90;（普通响应消息必须声明该字段）int32 Error = 91;string Message = 92;string GateAddress = 1;string Key = 2;}message C2R_SayHello // IMessage（一般消息必须注释）{string Hello = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通消息C#代码：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.客户端编写登录逻辑        public static async ETTask LoginTest(Scene zoneScene, string address)        {            try            {                Session session = null;                R2C_LoginTest r2C_LoginTest = null;                try                {                    session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address));                    {                        r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = "123", Password = "456" });                        Log.Debug(r2C_LoginTest.Key);                        session.Send(new C2R_SayHello() { Hello = "你好" });                    }                }                finally                {                    session?.Dispose();                }            }            catch(Exception e)            {                Log.Error(e.ToString());            }        }//2.普通请求消息逻辑    [MessageHandler]    public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt;    {        protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply)        {            response.Key = "110";            reply();            await ETTask.CompletedTask;        }    }    //3.一般消息（不用响应）    [MessageHandler]    public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt;    {        protected override async ETTask Run(Session session, C2R_SayHello message)        {            Log.Debug(message.Hello);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET中的Actor通信模型"><a href="#ET中的Actor通信模型" class="headerlink" title="ET中的Actor通信模型"></a>ET中的Actor通信模型</h1><p>Actor模型：<img src="https://s4.ax1x.com/2022/02/21/Hvl1zQ.png" alt="Actor模型"></p><p>Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。</p><p>ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生<br>动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理；</p><p>ActorLocation消息Proto文件编写:</p><pre class="line-numbers language-Proto" data-language="Proto"><code class="language-Proto">//ResponseType M2C_TestActorLocationResponsemessage C2M_TestActorLocationReqeust // IActorLocationRequest{int32 RpcId = 90;string Content = 1;}message M2C_TestActorLocationResponse // IActorLocationResponse{int32 RpcId = 90;int32 Error = 91;string Message = 92;string Content = 1;}message C2M_TestActorLocationMessage // IActorLocationMessage{int32 RpcId = 90;string Content = 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ActorLocation消息C#代码编写:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">1.客户端场景切换逻辑            try            {                Session session = zoneScene.GetComponent&lt;Session&gt;();                var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = "111" });                Log.Debug(message.Content);                session.Send(new C2M_TestActorLocationMessage() { Content = "22222" });            }            catch (Exception e)            {                Log.Error(e);            }            2.ActorLocation请求消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt;    {        protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply)        {            Log.Debug(request.Content);            response.Content = "333333";            reply();            await ETTask.CompletedTask;        }    }3.ActorLocation一般消息逻辑    [ActorMessageHandler]    public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt;    {        protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message)        {            Log.Debug(message.Content);            //MessageHelper.SendToClient(entity, 发送给客户端的消息);            await ETTask.CompletedTask;        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ET教程登录实例"><a href="#ET教程登录实例" class="headerlink" title="ET教程登录实例"></a>ET教程登录实例</h1><p>实例步骤：<br>1.编写账号登录请求和响应俩条协议Proto；<br>2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；<br>3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;<br>4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）;</p><p>事后心得：<br>1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；<br>2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；<br>3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；<br>4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；<br>5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；<br>6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；</p>]]></content>
      
      
      <categories>
          
          <category> Game-Play </category>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
            <tag> 游戏框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统原理笔记</title>
      <link href="/posts/513.html"/>
      <url>/posts/513.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-操作系统绪论"><a href="#1-操作系统绪论" class="headerlink" title="1   操作系统绪论"></a>1   操作系统绪论</h1><h2 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1  操作系统概念"></a>1.1  操作系统概念</h2><p>定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。</p><p><strong>特征：</strong>并发、共享、虚拟、异步。</p><h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2  操作系统发展历程"></a>1.2  操作系统发展历程</h2><p>手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。</p><h3 id="1-2-1单道批处理"><a href="#1-2-1单道批处理" class="headerlink" title="1.2.1单道批处理"></a>1.2.1单道批处理</h3><p><strong>原理：</strong>计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。</p><p><strong>特征：</strong>内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。</p><h3 id="1-2-2多道批处理"><a href="#1-2-2多道批处理" class="headerlink" title="1.2.2多道批处理"></a>1.2.2多道批处理</h3><p>原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。</p><p>特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。</p><h3 id="1-2-3分时系统"><a href="#1-2-3分时系统" class="headerlink" title="1.2.3分时系统"></a>1.2.3分时系统</h3><p>特征：多路性、独立性、及时性、交互性。</p><h3 id="1-2-4实时系统"><a href="#1-2-4实时系统" class="headerlink" title="1.2.4实时系统"></a>1.2.4实时系统</h3><p><strong>特征：</strong>多路性、独立性、及时性、交互性、可靠性。</p><h1 id="2-操作系统用户界面"><a href="#2-操作系统用户界面" class="headerlink" title="2   操作系统用户界面"></a>2   操作系统用户界面</h1><h2 id="2-1-作业"><a href="#2-1-作业" class="headerlink" title="2.1  作业"></a>2.1  作业</h2><p><strong>定义：</strong>分用户和系统角度去理解</p><p>a)     用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业；</p><p>b)     系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL)</p><h2 id="2-2-一般用户输入输出方式"><a href="#2-2-一般用户输入输出方式" class="headerlink" title="2.2  一般用户输入输出方式"></a>2.2  一般用户输入输出方式</h2><h3 id="2-2-1联机输入输出方式"><a href="#2-2-1联机输入输出方式" class="headerlink" title="2.2.1联机输入输出方式"></a>2.2.1联机输入输出方式</h3><h3 id="2-2-2脱机输入输出方式"><a href="#2-2-2脱机输入输出方式" class="headerlink" title="2.2.2脱机输入输出方式"></a>2.2.2脱机输入输出方式</h3><h3 id="2-2-3直接耦合方式"><a href="#2-2-3直接耦合方式" class="headerlink" title="2.2.3直接耦合方式"></a>2.2.3直接耦合方式</h3><h3 id="2-2-4Spooling系统"><a href="#2-2-4Spooling系统" class="headerlink" title="2.2.4Spooling系统"></a>2.2.4Spooling系统</h3><p><strong>原理：</strong>todo。</p><p><strong>特点：</strong>系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。</p><h3 id="2-2-5网络联机方式"><a href="#2-2-5网络联机方式" class="headerlink" title="2.2.5网络联机方式"></a>2.2.5网络联机方式</h3><h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3  系统调用"></a>2.3  系统调用</h2><p><strong>定义：</strong>系统调用是操作系统留给编程人员的唯一接口。</p><p><strong>原理：</strong>todo</p><h3 id="2-3-1系统调用指令"><a href="#2-3-1系统调用指令" class="headerlink" title="2.3.1系统调用指令"></a>2.3.1系统调用指令</h3><p>int和trap指令进行系统调用。</p><p>call和jmp指令进入普通过程调用(子调用)。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3   进程管理"></a>3   进程管理</h1><h2 id="3-1-进程的概念"><a href="#3-1-进程的概念" class="headerlink" title="3.1  进程的概念"></a>3.1  进程的概念</h2><p><strong>组成：</strong>进程=程序+数据+进程控制块(进程状态信息PCB)</p><p><strong>定义：</strong>进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p><strong>目的：</strong>对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性；</p><p><strong>优缺点：</strong>引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。</p><h2 id="3-2-进程和程序的区别"><a href="#3-2-进程和程序的区别" class="headerlink" title="3.2  进程和程序的区别"></a>3.2  进程和程序的区别</h2><p>a)     进程是动态的，程序是静态的；</p><p>b)     进程是暂时的，程序是永久的；</p><p>c)     组成不同，进程的组成包括程序；</p><p>d)    对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序；</p><p>e)    进程可以并行，具有独立性、异步性。</p><p>f)    进程是竞争计算机资源的基本单位。</p><h2 id="3-3-进程控制块-PCB"><a href="#3-3-进程控制块-PCB" class="headerlink" title="3.3  进程控制块(PCB)"></a>3.3  进程控制块(PCB)</h2><p>进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。</p><h3 id="3-3-1描述信息"><a href="#3-3-1描述信息" class="headerlink" title="3.3.1描述信息"></a>3.3.1描述信息</h3><h3 id="3-3-2控制信息"><a href="#3-3-2控制信息" class="headerlink" title="3.3.2控制信息"></a>3.3.2控制信息</h3><h3 id="3-3-3资源管理信息"><a href="#3-3-3资源管理信息" class="headerlink" title="3.3.3资源管理信息"></a>3.3.3资源管理信息</h3><h3 id="3-3-4CPU保护现场结构"><a href="#3-3-4CPU保护现场结构" class="headerlink" title="3.3.4CPU保护现场结构"></a>3.3.4CPU保护现场结构</h3><h2 id="3-4-进程上下文切换"><a href="#3-4-进程上下文切换" class="headerlink" title="3.4  进程上下文切换"></a>3.4  进程上下文切换</h2><p><strong>原因：</strong>进程中断、超时、进程调用。</p><p><strong>步骤：</strong></p><p>a)    保存被切换进程的正文部分到有关存储区。</p><p>b)    进程有关调度和资源分配程序执行，选取新的进程。</p><p>c)    新进程正文部分从存储区取出，激活选中进程执行。</p><h2 id="3-5-进程的状态和进程转换"><a href="#3-5-进程的状态和进程转换" class="headerlink" title="3.5  进程的状态和进程转换"></a>3.5  进程的状态和进程转换</h2><h3 id="3-5-1进程状态"><a href="#3-5-1进程状态" class="headerlink" title="3.5.1进程状态"></a>3.5.1进程状态</h3><p>初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止))</p><h3 id="3-5-2进程状态转换"><a href="#3-5-2进程状态转换" class="headerlink" title="3.5.2进程状态转换"></a>3.5.2进程状态转换</h3><h2 id="3-6-进程控制"><a href="#3-6-进程控制" class="headerlink" title="3.6  进程控制"></a>3.6  进程控制</h2><h3 id="3-6-1进程创建和撤销"><a href="#3-6-1进程创建和撤销" class="headerlink" title="3.6.1进程创建和撤销"></a>3.6.1进程创建和撤销</h3><h3 id="3-6-2进程阻塞和唤醒"><a href="#3-6-2进程阻塞和唤醒" class="headerlink" title="3.6.2进程阻塞和唤醒"></a>3.6.2进程阻塞和唤醒</h3><h3 id="3-6-3进程的挂起和激活"><a href="#3-6-3进程的挂起和激活" class="headerlink" title="3.6.3进程的挂起和激活"></a>3.6.3进程的挂起和激活</h3><h2 id="3-7-进程互斥和同步"><a href="#3-7-进程互斥和同步" class="headerlink" title="3.7  进程互斥和同步"></a>3.7  进程互斥和同步</h2><h3 id="3-7-1临界区和临界资源"><a href="#3-7-1临界区和临界资源" class="headerlink" title="3.7.1临界区和临界资源"></a>3.7.1临界区和临界资源</h3><p>临界资源是一次仅允许一个进程使用的共享资源。</p><p>临界区是每个进程访问临界资源的那段代码。</p><h3 id="3-7-2信号量和PV原语"><a href="#3-7-2信号量和PV原语" class="headerlink" title="3.7.2信号量和PV原语"></a>3.7.2信号量和PV原语</h3><p>信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。</p><p>信号量的数值仅能由P、V原语操作改变。</p><h3 id="3-7-3互斥的概念"><a href="#3-7-3互斥的概念" class="headerlink" title="3.7.3互斥的概念"></a>3.7.3互斥的概念</h3><p><strong>定义：</strong>不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。</p><h3 id="3-7-4同步的概念"><a href="#3-7-4同步的概念" class="headerlink" title="3.7.4同步的概念"></a>3.7.4同步的概念</h3><p><strong>定义：</strong>对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。</p><h2 id="3-8-进程通信"><a href="#3-8-进程通信" class="headerlink" title="3.8  进程通信"></a>3.8  进程通信</h2><p>Todo</p><h2 id="3-9-死锁问题"><a href="#3-9-死锁问题" class="headerlink" title="3.9  死锁问题"></a>3.9  死锁问题</h2><h3 id="3-9-1死锁的概念"><a href="#3-9-1死锁的概念" class="headerlink" title="3.9.1死锁的概念"></a>3.9.1死锁的概念</h3><p><strong>定义：</strong> 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。</p><p><strong>起因：</strong>并发进程的资源竞争</p><p><strong>条件：</strong>同时具备互斥条件、不剥夺条件、部分分配、环路条件。</p><h3 id="3-9-2死锁的解决方案"><a href="#3-9-2死锁的解决方案" class="headerlink" title="3.9.2死锁的解决方案"></a>3.9.2死锁的解决方案</h3><h4 id="3-9-2-1-死锁预防"><a href="#3-9-2-1-死锁预防" class="headerlink" title="3.9.2.1    死锁预防"></a>3.9.2.1    死锁预防</h4><h4 id="3-9-2-2-死锁避免"><a href="#3-9-2-2-死锁避免" class="headerlink" title="3.9.2.2    死锁避免"></a>3.9.2.2    死锁避免</h4><p>最具代表性的避免算法-银行家算法</p><h4 id="3-9-2-3-死锁的检测和恢复"><a href="#3-9-2-3-死锁的检测和恢复" class="headerlink" title="3.9.2.3    死锁的检测和恢复"></a>3.9.2.3    死锁的检测和恢复</h4><h2 id="3-10-线程"><a href="#3-10-线程" class="headerlink" title="3.10    线程"></a>3.10    线程</h2><h3 id="3-10-1-线程的基本概念"><a href="#3-10-1-线程的基本概念" class="headerlink" title="3.10.1 线程的基本概念"></a>3.10.1 线程的基本概念</h3><p>定义：引入线程后，线程是操作系统调度和分配的基本单位。</p><p>组成：线程=？+线程控制块(TCB)</p><h3 id="3-10-2-线程状态和线程控制块-TCB"><a href="#3-10-2-线程状态和线程控制块-TCB" class="headerlink" title="3.10.2 线程状态和线程控制块(TCB)"></a>3.10.2 线程状态和线程控制块(TCB)</h3><p>线程状态：执行状态、就绪状态、阻塞(等待)状态</p><p>线程控制块数据结构包括：</p><p>a)     线程标识符</p><p>b)     一组寄存器</p><p>c)     线程执行状态</p><p>d)     优先级</p><p>e)     线程专有存储区</p><p>f)     信号屏蔽</p><p>g)    堆栈指针</p><h3 id="3-10-3-线程和进程的区别"><a href="#3-10-3-线程和进程的区别" class="headerlink" title="3.10.3 线程和进程的区别"></a>3.10.3 线程和进程的区别</h3><p>从以下六点讨论</p><p>a)     调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。</p><p>b)     并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。</p><p>c)     拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。</p><p>d)     独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。</p><p>e)     系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。</p><p>f)     支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。</p><h1 id="4-处理机调度"><a href="#4-处理机调度" class="headerlink" title="4   处理机调度"></a>4   处理机调度</h1><h2 id="4-1-调度层级"><a href="#4-1-调度层级" class="headerlink" title="4.1  调度层级"></a>4.1  调度层级</h2><p>一个作业提交后，往往会经历三种层级（加线程四种）</p><h3 id="4-1-1作业调度"><a href="#4-1-1作业调度" class="headerlink" title="4.1.1作业调度"></a>4.1.1作业调度</h3><p>又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。</p><h4 id="4-1-1-1-周转时间相关"><a href="#4-1-1-1-周转时间相关" class="headerlink" title="4.1.1.1    周转时间相关"></a>4.1.1.1    周转时间相关</h4><p>周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间</p><p>平均周转时间=所有作业周转时间之和/总作业数</p><p>带权周转时间=作业周转时间/作业执行时间</p><p>平均带权周转时间=所有带权作业周转时间之和/总作业数</p><h4 id="4-1-1-2-响应时间，截止时间和系统吞吐量"><a href="#4-1-1-2-响应时间，截止时间和系统吞吐量" class="headerlink" title="4.1.1.2     响应时间，截止时间和系统吞吐量"></a>4.1.1.2     响应时间，截止时间和系统吞吐量</h4><p>响应时间是提交请求和返回该请求的响应之间使用的时间<br>截止时间是某任务必须开始执行或者必须完成的最迟时间<br>吞吐量是对单位时间内完成的工作量的量度</p><h3 id="4-1-2交换调度"><a href="#4-1-2交换调度" class="headerlink" title="4.1.2交换调度"></a>4.1.2交换调度</h3><p>又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存</p><h3 id="4-1-3进程调度"><a href="#4-1-3进程调度" class="headerlink" title="4.1.3进程调度"></a>4.1.3进程调度</h3><p>又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式</p><h4 id="4-1-3-1-非抢占方式"><a href="#4-1-3-1-非抢占方式" class="headerlink" title="4.1.3.1    非抢占方式"></a>4.1.3.1    非抢占方式</h4><p>一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。</p><h4 id="4-1-3-2-抢占方式"><a href="#4-1-3-2-抢占方式" class="headerlink" title="4.1.3.2     抢占方式"></a>4.1.3.2     抢占方式</h4><p>系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程</p><p>a)     优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU</p><p>b)     短作业优先原则：就绪的短进程有权抢占长进程的CPU</p><p>c)     时间片原则：一个时间片用完后，系统重新进行进程调度</p><h3 id="4-1-4线程调度"><a href="#4-1-4线程调度" class="headerlink" title="4.1.4线程调度"></a>4.1.4线程调度</h3><p>Todo</p><h2 id="4-2-作业和进程的关系"><a href="#4-2-作业和进程的关系" class="headerlink" title="4.2  作业和进程的关系"></a>4.2  作业和进程的关系</h2><p>系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。</p><h2 id="4-3-调度算法"><a href="#4-3-调度算法" class="headerlink" title="4.3  调度算法"></a>4.3  调度算法</h2><p>宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。</p><p>​    微观调度：轮转法、优先级法、多级反馈轮转法。</p><h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5   存储管理"></a>5   存储管理</h1><h2 id="5-1-存储器结构"><a href="#5-1-存储器结构" class="headerlink" title="5.1  存储器结构"></a>5.1  存储器结构</h2><p>由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。</p><h3 id="5-1-1寄存器"><a href="#5-1-1寄存器" class="headerlink" title="5.1.1寄存器"></a>5.1.1寄存器</h3><p>寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。</p><h3 id="5-1-2高速缓存"><a href="#5-1-2高速缓存" class="headerlink" title="5.1.2高速缓存"></a>5.1.2高速缓存</h3><p>它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。</p><h3 id="5-1-3主存输器"><a href="#5-1-3主存输器" class="headerlink" title="5.1.3主存输器"></a>5.1.3主存输器</h3><p>简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。</p><h3 id="5-1-4磁盘缓存"><a href="#5-1-4磁盘缓存" class="headerlink" title="5.1.4磁盘缓存"></a>5.1.4磁盘缓存</h3><p>目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。</p><h2 id="5-2-程序的处理阶段"><a href="#5-2-程序的处理阶段" class="headerlink" title="5.2  程序的处理阶段"></a>5.2  程序的处理阶段</h2><p>主要有编译，链接，装入，下面主要讲链接和装入。</p><h3 id="5-2-1程序的链接"><a href="#5-2-1程序的链接" class="headerlink" title="5.2.1程序的链接"></a>5.2.1程序的链接</h3><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。<br>链接又可分为静态链接，装入时动态链接，运行时动态链接。</p><h3 id="5-2-2程序的装入"><a href="#5-2-2程序的装入" class="headerlink" title="5.2.2程序的装入"></a>5.2.2程序的装入</h3><p>分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。</p><h2 id="5-3-地址变换"><a href="#5-3-地址变换" class="headerlink" title="5.3  地址变换"></a>5.3  地址变换</h2><h3 id="5-3-1静态地址重定向"><a href="#5-3-1静态地址重定向" class="headerlink" title="5.3.1静态地址重定向"></a>5.3.1静态地址重定向</h3><p><strong>原理：</strong>Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。</p><h3 id="5-3-2动态地址重定位"><a href="#5-3-2动态地址重定位" class="headerlink" title="5.3.2动态地址重定位"></a>5.3.2动态地址重定位</h3><p><strong>关系：</strong>MA(物理地址)=BR(基址地址)+VR(虚拟地址)。</p><p>原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。</p><h2 id="5-4-分区存储管理"><a href="#5-4-分区存储管理" class="headerlink" title="5.4  分区存储管理"></a>5.4  分区存储管理</h2><p>分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。</p><h3 id="5-4-1固态分区法"><a href="#5-4-1固态分区法" class="headerlink" title="5.4.1固态分区法"></a>5.4.1固态分区法</h3><p>原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。</p><p>优点:易于实现，开销小。</p><p>缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。</p><h3 id="5-4-2动态分区法"><a href="#5-4-2动态分区法" class="headerlink" title="5.4.2动态分区法"></a>5.4.2动态分区法</h3><p><strong>原理：</strong>动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。</p><p><strong>优点：</strong>没有内碎片；</p><p><strong>缺点：</strong>有外碎片；</p><p><strong>算法：</strong>根据情况有以下俩种，着重介绍三种</p><p>a)     基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法</p><p>b)     基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法</p><h4 id="5-4-2-2-最先适应法"><a href="#5-4-2-2-最先适应法" class="headerlink" title="5.4.2.2     最先适应法"></a>5.4.2.2     最先适应法</h4><h4 id="5-4-2-3-最佳适应法"><a href="#5-4-2-3-最佳适应法" class="headerlink" title="5.4.2.3     最佳适应法"></a>5.4.2.3     最佳适应法</h4><h4 id="5-4-2-4-最坏适应法"><a href="#5-4-2-4-最坏适应法" class="headerlink" title="5.4.2.4     最坏适应法"></a>5.4.2.4     最坏适应法</h4><h3 id="5-4-3页式管理（离散分配）"><a href="#5-4-3页式管理（离散分配）" class="headerlink" title="5.4.3页式管理（离散分配）"></a>5.4.3页式管理（离散分配）</h3><p>基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。</p><h4 id="5-4-3-1-静态页式管理"><a href="#5-4-3-1-静态页式管理" class="headerlink" title="5.4.3.1    静态页式管理"></a>5.4.3.1    静态页式管理</h4><p>原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。</p><h4 id="5-4-3-2-动态页式管理"><a href="#5-4-3-2-动态页式管理" class="headerlink" title="5.4.3.2    动态页式管理"></a>5.4.3.2    动态页式管理</h4><h3 id="5-4-4段式和段页式管理"><a href="#5-4-4段式和段页式管理" class="headerlink" title="5.4.4段式和段页式管理"></a>5.4.4段式和段页式管理</h3><p>基本思想：todo</p><h4 id="5-4-4-1-段式管理"><a href="#5-4-4-1-段式管理" class="headerlink" title="5.4.4.1     段式管理"></a>5.4.4.1     段式管理</h4><p>原理：todo</p><h4 id="5-4-4-2-段页式管理"><a href="#5-4-4-2-段页式管理" class="headerlink" title="5.4.4.2     段页式管理"></a>5.4.4.2     段页式管理</h4><p>原理：todo</p><h3 id="5-4-5覆盖和交换技术"><a href="#5-4-5覆盖和交换技术" class="headerlink" title="5.4.5覆盖和交换技术"></a>5.4.5覆盖和交换技术</h3><h2 id="5-5-虚拟存输器"><a href="#5-5-虚拟存输器" class="headerlink" title="5.5  虚拟存输器"></a>5.5  虚拟存输器</h2><h3 id="5-5-1虚拟存储的实现方式"><a href="#5-5-1虚拟存储的实现方式" class="headerlink" title="5.5.1虚拟存储的实现方式"></a>5.5.1虚拟存储的实现方式</h3><p>虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式：</p><h4 id="5-5-1-1-分页请求系统"><a href="#5-5-1-1-分页请求系统" class="headerlink" title="5.5.1.1     分页请求系统"></a>5.5.1.1     分页请求系统</h4><p>在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。<br>  硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上</p><h4 id="5-5-1-2-请求分段系统"><a href="#5-5-1-2-请求分段系统" class="headerlink" title="5.5.1.2     请求分段系统"></a>5.5.1.2     请求分段系统</h4><p>在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页”</p><h3 id="5-5-2页面置换算法"><a href="#5-5-2页面置换算法" class="headerlink" title="5.5.2页面置换算法"></a>5.5.2页面置换算法</h3><h4 id="5-5-2-1-随机淘汰算法"><a href="#5-5-2-1-随机淘汰算法" class="headerlink" title="5.5.2.1     随机淘汰算法"></a>5.5.2.1     随机淘汰算法</h4><p>随机地选择某个用户地页面并将其换出。</p><h4 id="5-5-2-2-最佳置换算法（理想型淘汰算法OPT）"><a href="#5-5-2-2-最佳置换算法（理想型淘汰算法OPT）" class="headerlink" title="5.5.2.2     最佳置换算法（理想型淘汰算法OPT）"></a>5.5.2.2     最佳置换算法（理想型淘汰算法OPT）</h4><p>其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。</p><h4 id="5-5-2-3-先进先出置换算法（FIFO）"><a href="#5-5-2-3-先进先出置换算法（FIFO）" class="headerlink" title="5.5.2.3     先进先出置换算法（FIFO）"></a>5.5.2.3     先进先出置换算法（FIFO）</h4><p>总是先淘汰最先进入内存的页面。</p><h4 id="5-5-2-4-最近最久未使用算法（LRU）"><a href="#5-5-2-4-最近最久未使用算法（LRU）" class="headerlink" title="5.5.2.4     最近最久未使用算法（LRU）"></a>5.5.2.4     最近最久未使用算法（LRU）</h4><p>选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。</p><h4 id="5-5-2-5-最少使用置换算法（LFU）"><a href="#5-5-2-5-最少使用置换算法（LFU）" class="headerlink" title="5.5.2.5     最少使用置换算法（LFU）"></a>5.5.2.5     最少使用置换算法（LFU）</h4><p>在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。</p><h4 id="5-5-2-6-Clock置换算法"><a href="#5-5-2-6-Clock置换算法" class="headerlink" title="5.5.2.6     Clock置换算法"></a>5.5.2.6     Clock置换算法</h4><p>是一种LRU算法<br>每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；<br>当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；<br>再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面；</p><h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6   文件系统"></a>6   文件系统</h1><h2 id="6-1-文件系统基本概念"><a href="#6-1-文件系统基本概念" class="headerlink" title="6.1  文件系统基本概念"></a>6.1  文件系统基本概念</h2><p><strong>目的：</strong>文件系统地出现是为了更好地管理软件资源</p><p><strong>文件系统的定义：</strong>操作系统中与管理文件有关的软件和数据称为文件系统</p><p><strong>文件的定义：</strong>文件时一段程序和数据的集合</p><p><strong>文件的分类：</strong>按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。</p><h2 id="6-2-文件的逻辑结构和存取方式"><a href="#6-2-文件的逻辑结构和存取方式" class="headerlink" title="6.2  文件的逻辑结构和存取方式"></a>6.2  文件的逻辑结构和存取方式</h2><h3 id="6-2-1逻辑结构"><a href="#6-2-1逻辑结构" class="headerlink" title="6.2.1逻辑结构"></a>6.2.1逻辑结构</h3><p><strong>字符流的无结构文件：</strong>管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。</p><p><strong>记录式的有结构文件：</strong>把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。</p><h4 id="6-2-1-1-连续结构"><a href="#6-2-1-1-连续结构" class="headerlink" title="6.2.1.1     连续结构"></a>6.2.1.1     连续结构</h4><h4 id="6-2-1-2-多重结构"><a href="#6-2-1-2-多重结构" class="headerlink" title="6.2.1.2     多重结构"></a>6.2.1.2     多重结构</h4><h4 id="6-2-1-3-转置结构"><a href="#6-2-1-3-转置结构" class="headerlink" title="6.2.1.3     转置结构"></a>6.2.1.3     转置结构</h4><h4 id="6-2-1-4-顺序结构"><a href="#6-2-1-4-顺序结构" class="headerlink" title="6.2.1.4     顺序结构"></a>6.2.1.4     顺序结构</h4><h3 id="6-2-2逻辑存储方法"><a href="#6-2-2逻辑存储方法" class="headerlink" title="6.2.2逻辑存储方法"></a>6.2.2逻辑存储方法</h3><h4 id="6-2-2-1-顺序存输方法"><a href="#6-2-2-1-顺序存输方法" class="headerlink" title="6.2.2.1     顺序存输方法"></a>6.2.2.1     顺序存输方法</h4><h4 id="6-2-2-2-随机存输方法"><a href="#6-2-2-2-随机存输方法" class="headerlink" title="6.2.2.2     随机存输方法"></a>6.2.2.2     随机存输方法</h4><h4 id="6-2-2-3-按关键字存输方法"><a href="#6-2-2-3-按关键字存输方法" class="headerlink" title="6.2.2.3    按关键字存输方法"></a>6.2.2.3    按关键字存输方法</h4><p>多用于复杂文件系统。</p><h3 id="6-2-3逻辑搜索方式"><a href="#6-2-3逻辑搜索方式" class="headerlink" title="6.2.3逻辑搜索方式"></a>6.2.3逻辑搜索方式</h3><p>文件的获取是要找到文件内容所在的逻辑地址</p><h4 id="6-2-3-1-线性搜索法"><a href="#6-2-3-1-线性搜索法" class="headerlink" title="6.2.3.1     线性搜索法"></a>6.2.3.1     线性搜索法</h4><h4 id="6-2-3-2-散列法"><a href="#6-2-3-2-散列法" class="headerlink" title="6.2.3.2     散列法"></a>6.2.3.2     散列法</h4><h4 id="6-2-3-3-二分搜索法"><a href="#6-2-3-3-二分搜索法" class="headerlink" title="6.2.3.3     二分搜索法"></a>6.2.3.3     二分搜索法</h4><h2 id="6-3-文件的物理结构和存储设备"><a href="#6-3-文件的物理结构和存储设备" class="headerlink" title="6.3  文件的物理结构和存储设备"></a>6.3  文件的物理结构和存储设备</h2><h3 id="6-3-1文件物理结构"><a href="#6-3-1文件物理结构" class="headerlink" title="6.3.1文件物理结构"></a>6.3.1文件物理结构</h3><h4 id="6-3-1-1-连续文件"><a href="#6-3-1-1-连续文件" class="headerlink" title="6.3.1.1    连续文件"></a>6.3.1.1    连续文件</h4><p>连续文件采用连续分配方式：</p><p><strong>特点：</strong>为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。<br><strong>优点：</strong>顺序访问容易; 顺序访问速度快;<br><strong>缺点：</strong>要求有连续的存储空间; 必须事先知道文件的长度;</p><h4 id="6-3-1-2-串联文件"><a href="#6-3-1-2-串联文件" class="headerlink" title="6.3.1.2    串联文件"></a>6.3.1.2    串联文件</h4><p>串联文件采用链接分配</p><p><strong>特点：</strong>文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；<br><strong>优点：</strong>没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间;</p><h4 id="6-3-1-3-索引文件"><a href="#6-3-1-3-索引文件" class="headerlink" title="6.3.1.3    索引文件"></a>6.3.1.3    索引文件</h4><p>索引文件采用索引分配</p><p><strong>特点：</strong>每个文件都有自己的索引块，这是一个磁盘块地址的数组。</p><h3 id="6-3-2文件存储设备"><a href="#6-3-2文件存储设备" class="headerlink" title="6.3.2文件存储设备"></a>6.3.2文件存储设备</h3><p>存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。</p><h4 id="6-3-2-1-顺序存取存储设备—磁带"><a href="#6-3-2-1-顺序存取存储设备—磁带" class="headerlink" title="6.3.2.1    顺序存取存储设备—磁带"></a>6.3.2.1    顺序存取存储设备—磁带</h4><p><strong>特点：</strong>只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。</p><p><strong>影响因素：</strong>信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。</p><h4 id="6-3-2-2-直接存取存储设备—磁盘"><a href="#6-3-2-2-直接存取存储设备—磁盘" class="headerlink" title="6.3.2.2     直接存取存储设备—磁盘"></a>6.3.2.2     直接存取存储设备—磁盘</h4><h2 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4  文件存储空间管理"></a>6.4  文件存储空间管理</h2><p>文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。</p><h3 id="6-4-1空闲目录管理"><a href="#6-4-1空闲目录管理" class="headerlink" title="6.4.1空闲目录管理"></a>6.4.1空闲目录管理</h3><h3 id="6-4-2空闲链块法"><a href="#6-4-2空闲链块法" class="headerlink" title="6.4.2空闲链块法"></a>6.4.2空闲链块法</h3><h3 id="6-4-3位示图"><a href="#6-4-3位示图" class="headerlink" title="6.4.3位示图"></a>6.4.3位示图</h3><h2 id="6-5-文件目录管理"><a href="#6-5-文件目录管理" class="headerlink" title="6.5  文件目录管理"></a>6.5  文件目录管理</h2><p>从文件管理角度看，一个文件包括文件说明和文件体。</p><h3 id="6-5-1文件目录的种类"><a href="#6-5-1文件目录的种类" class="headerlink" title="6.5.1文件目录的种类"></a>6.5.1文件目录的种类</h3><h4 id="6-5-1-1-单级文件目录"><a href="#6-5-1-1-单级文件目录" class="headerlink" title="6.5.1.1     单级文件目录"></a>6.5.1.1     单级文件目录</h4><p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。</p><h4 id="6-5-1-2-两级文件目录"><a href="#6-5-1-2-两级文件目录" class="headerlink" title="6.5.1.2     两级文件目录"></a>6.5.1.2     两级文件目录</h4><p>目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB；</p><h4 id="6-5-1-3-树形结构目录"><a href="#6-5-1-3-树形结构目录" class="headerlink" title="6.5.1.3     树形结构目录"></a>6.5.1.3     树形结构目录</h4><p>多级目录结构又称为树型目录结构；<br>主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点；</p><h3 id="6-5-2文件目录的共享"><a href="#6-5-2文件目录的共享" class="headerlink" title="6.5.2文件目录的共享"></a>6.5.2文件目录的共享</h3><p>从系统管理的方式来看，有三种方法可以实现文件共享</p><h4 id="6-5-2-1-绕道法"><a href="#6-5-2-1-绕道法" class="headerlink" title="6.5.2.1     绕道法"></a>6.5.2.1     绕道法</h4><h4 id="6-5-2-2-链接法"><a href="#6-5-2-2-链接法" class="headerlink" title="6.5.2.2     链接法"></a>6.5.2.2     链接法</h4><h4 id="6-5-2-3-基本文件目录表（BFD）"><a href="#6-5-2-3-基本文件目录表（BFD）" class="headerlink" title="6.5.2.3    基本文件目录表（BFD）"></a>6.5.2.3    基本文件目录表（BFD）</h4><h3 id="6-5-3目录管理"><a href="#6-5-3目录管理" class="headerlink" title="6.5.3目录管理"></a>6.5.3目录管理</h3><p>文件目录管理应该存放在磁盘，其他的没理解todo</p><h2 id="6-6-文件存取控制"><a href="#6-6-文件存取控制" class="headerlink" title="6.6  文件存取控制"></a>6.6  文件存取控制</h2><p>用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。</p><h3 id="6-6-1存取控制矩阵"><a href="#6-6-1存取控制矩阵" class="headerlink" title="6.6.1存取控制矩阵"></a>6.6.1存取控制矩阵</h3><h3 id="6-6-2存取控制表"><a href="#6-6-2存取控制表" class="headerlink" title="6.6.2存取控制表"></a>6.6.2存取控制表</h3><h3 id="6-6-3口令方式"><a href="#6-6-3口令方式" class="headerlink" title="6.6.3口令方式"></a>6.6.3口令方式</h3><h3 id="6-6-4密码方式"><a href="#6-6-4密码方式" class="headerlink" title="6.6.4密码方式"></a>6.6.4密码方式</h3><p>密码方式是保密性最好的验证方式。</p><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7    设备管理"></a>7    设备管理</h1><h2 id="7-1-设备的分类"><a href="#7-1-设备的分类" class="headerlink" title="7.1  设备的分类"></a>7.1  设备的分类</h2><p>在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。</p><h2 id="7-2-数据传输控制方式"><a href="#7-2-数据传输控制方式" class="headerlink" title="7.2  数据传输控制方式"></a>7.2  数据传输控制方式</h2><p>设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。</p><h3 id="7-2-1程序直接控制方式"><a href="#7-2-1程序直接控制方式" class="headerlink" title="7.2.1程序直接控制方式"></a>7.2.1程序直接控制方式</h3><p>由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。</p><h3 id="7-2-2中断方式"><a href="#7-2-2中断方式" class="headerlink" title="7.2.2中断方式"></a>7.2.2中断方式</h3><p>I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。</p><h3 id="7-2-3DMA方式"><a href="#7-2-3DMA方式" class="headerlink" title="7.2.3DMA方式"></a>7.2.3DMA方式</h3><p>在外围设备和内存之间开辟直接的数据交换通道。</p><h3 id="7-2-4通道控制方式"><a href="#7-2-4通道控制方式" class="headerlink" title="7.2.4通道控制方式"></a>7.2.4通道控制方式</h3><p>以内存为中心，实现设备和内存直接交换数据的控制的方式。</p><h2 id="7-3-中断技术"><a href="#7-3-中断技术" class="headerlink" title="7.3  中断技术"></a>7.3  中断技术</h2><p><strong>原理：</strong>中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。</p><p><strong>过程：</strong>判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点</p><h3 id="7-3-1中断技术的分类"><a href="#7-3-1中断技术的分类" class="headerlink" title="7.3.1中断技术的分类"></a>7.3.1中断技术的分类</h3><p>中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。</p><h4 id="7-3-1-1-外中断"><a href="#7-3-1-1-外中断" class="headerlink" title="7.3.1.1    外中断"></a>7.3.1.1    外中断</h4><p>一般是来自处理机和内存外部的中断</p><h4 id="7-3-1-2-内中断（陷阱）"><a href="#7-3-1-2-内中断（陷阱）" class="headerlink" title="7.3.1.2    内中断（陷阱）"></a>7.3.1.2    内中断（陷阱）</h4><p>一般是来自处理机和内存内部的中断</p><h4 id="7-3-1-3-软中断"><a href="#7-3-1-3-软中断" class="headerlink" title="7.3.1.3    软中断"></a>7.3.1.3    软中断</h4><p>是通信进程之间模拟硬中断的一种信号通信方式</p><h2 id="7-4-缓冲技术"><a href="#7-4-缓冲技术" class="headerlink" title="7.4  缓冲技术"></a>7.4  缓冲技术</h2><p><strong>目的：</strong>缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。</p><p><strong>分类：</strong>缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。</p><h3 id="7-4-1缓冲池的结构"><a href="#7-4-1缓冲池的结构" class="headerlink" title="7.4.1缓冲池的结构"></a>7.4.1缓冲池的结构</h3><p>缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。</p><h3 id="7-4-2缓冲池管理"><a href="#7-4-2缓冲池管理" class="headerlink" title="7.4.2缓冲池管理"></a>7.4.2缓冲池管理</h3><p>Todo</p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相关_FairyGUI</title>
      <link href="/posts/1542.html"/>
      <url>/posts/1542.html</url>
      
        <content type="html"><![CDATA[<h1 id="FairyGUI概叙"><a href="#FairyGUI概叙" class="headerlink" title="FairyGUI概叙"></a>FairyGUI概叙</h1><h1 id="FairyGUI基础"><a href="#FairyGUI基础" class="headerlink" title="FairyGUI基础"></a>FairyGUI基础</h1><h1 id="FairyGUI基本元件"><a href="#FairyGUI基本元件" class="headerlink" title="FairyGUI基本元件"></a>FairyGUI基本元件</h1><h1 id="FairyGUI控件"><a href="#FairyGUI控件" class="headerlink" title="FairyGUI控件"></a>FairyGUI控件</h1><h2 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h2><h2 id="字体处理"><a href="#字体处理" class="headerlink" title="字体处理"></a>字体处理</h2><h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><h2 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h2><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h2 id="关联系统"><a href="#关联系统" class="headerlink" title="关联系统"></a>关联系统</h2><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="单选和多选框"><a href="#单选和多选框" class="headerlink" title="单选和多选框"></a>单选和多选框</h2><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><h2 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h2><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><h2 id="滚动容器"><a href="#滚动容器" class="headerlink" title="滚动容器"></a>滚动容器</h2><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h2 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h2><h1 id="Unity中的使用必备"><a href="#Unity中的使用必备" class="headerlink" title="Unity中的使用必备"></a>Unity中的使用必备</h1><h2 id="组件拓展类"><a href="#组件拓展类" class="headerlink" title="组件拓展类"></a>组件拓展类</h2><h2 id="分辨率自适应"><a href="#分辨率自适应" class="headerlink" title="分辨率自适应"></a>分辨率自适应</h2><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><h2 id="输入处理"><a href="#输入处理" class="headerlink" title="输入处理"></a>输入处理</h2><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><h2 id="拖拽相关"><a href="#拖拽相关" class="headerlink" title="拖拽相关"></a>拖拽相关</h2><h2 id="插入其他对象"><a href="#插入其他对象" class="headerlink" title="插入其他对象"></a>插入其他对象</h2><h2 id="DrawCall优化"><a href="#DrawCall优化" class="headerlink" title="DrawCall优化"></a>DrawCall优化</h2><h1 id="FairyGUI进阶"><a href="#FairyGUI进阶" class="headerlink" title="FairyGUI进阶"></a>FairyGUI进阶</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="多国语言"><a href="#多国语言" class="headerlink" title="多国语言"></a>多国语言</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h2 id="弹出功能"><a href="#弹出功能" class="headerlink" title="弹出功能"></a>弹出功能</h2><h2 id="曲面UI"><a href="#曲面UI" class="headerlink" title="曲面UI"></a>曲面UI</h2><h2 id="动效"><a href="#动效" class="headerlink" title="动效"></a>动效</h2><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> GUI解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> GUI解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相关_基于Lua的热更新解决方案</title>
      <link href="/posts/03008.html"/>
      <url>/posts/03008.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> 热更新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Lua </tag>
            
            <tag> AssetBundle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法格式（.md后缀-使用typora）</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法格式"><a href="#Markdown语法格式" class="headerlink" title="Markdown语法格式"></a>Markdown语法格式</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#标题1 （大）</span><span class="token comment">##标题2</span><span class="token comment">###标题3</span><span class="token comment">####标题4 （小）</span>以此类推 最高标题6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">​```代码块名称<span class="token punctuation">(</span>可以输入各种语言java、c++、html等<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//加粗**加粗**//代码高亮显示<span class="token operator">==</span>高亮<span class="token operator">==</span>//删除线~~删除线~~//斜体  *斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//引用语法<span class="token operator">&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>作者：泽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//分割线---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="图片插入："><a href="#图片插入：" class="headerlink" title="图片插入："></a>图片插入：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//在线图片与本地图片<span class="token operator">!</span><span class="token punctuation">[</span>照片名子<span class="token punctuation">]</span>（/image/me.png）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//超链接语法<span class="token punctuation">[</span>超链接名字<span class="token punctuation">]</span>（https://gihub.com/yerenping）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//无需列表- 目录1  -后加空格- 目录2- 目录3//有序列表  <span class="token number">1</span>+. +名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右键》插入》表格用代码过于复杂不推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnityEditor</title>
      <link href="/posts/1550.html"/>
      <url>/posts/1550.html</url>
      
        <content type="html"><![CDATA[<h1 id="待写"><a href="#待写" class="headerlink" title="待写"></a>待写</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> UnityEditor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UnityEditor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/posts/514.html"/>
      <url>/posts/514.html</url>
      
        <content type="html"><![CDATA[<p>列举一些常用的排序算法</p><p>#冒泡排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void BubbleSort(int[] array, int count){    //设置标识符，如果为false意为当前数组为有序，不需要再排序了    bool shouldSorted = true;    for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++)    {        shouldSorted = false;        for (int j = count - 1; j &gt; i; j--)        {            if (array[j - 1] &gt; array[j])            {                shouldSorted = true;                Utilities.Swap(ref array[j - 1], ref array[j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#选择排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void SelectSort(int[] array, int count){    int min;    for (int i = 0; i &lt; count - 1; i++)    {        min = i;        for (int j = i + 1; j &lt; count; j++)        {            if (array[min] &gt; array[j])            {                min = j;            }        }        if (min != i)        {            Utilities.Swap(ref array[min], ref array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#插入排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void InserSort(int[] array, int count){    int guard; //哨兵，用于暂存需要交换的值    for (int i = 0; i &lt; count - 1; i++)    {        if (array[i] &gt; array[i + 1])        {            guard = array[i + 1];            int j;            for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--)            {                array[j + 1] = array[j]; //赋值操作（依次后移）            }            array[j + 1] = guard;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#希尔排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 希尔排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void ShellSort(int[] array, int count){    int i, j, guard;    int increment = count;    do    {        increment = increment / 3 + 1; //增量序列        for (i = increment + 1; i &lt; count; i++)        {            if (array[i] &lt; array[i - increment])            {                guard = array[i]; //暂存在哨兵处                for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment)                {                    array[j + increment] = array[j]; //记录后移，查找插入位置                }                array[j + increment] = guard; //插入            }        }    } while (increment &gt; 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#堆排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 堆排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void HeapSort(int[] array, int count){    for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆    {        HeapAdjust(array, i, count - 1);    }    for (int i = count - 1; i &gt; 0; i--)    {        Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换        HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆    }}/// &lt;summary&gt;/// 堆排序_构造大顶堆函数/// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义/// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="startIndex"&gt;起始位置&lt;/param&gt;/// &lt;param name="endIndex"&gt;结束位置&lt;/param&gt;public static void HeapAdjust(int[] array, int startIndex, int endIndex){    int temp;    temp = array[startIndex];    for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选    {        if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1])        {            ++i; //i为关键字中较大记录的下标        }        if (temp &gt; array[i])        {            break; //rc应插入在位置s上        }        array[startIndex] = array[i];        startIndex = i;    }    array[startIndex] = temp; //插入}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#归并排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 归并排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void MergeSort(int[] array, int count){    int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果    int k = 1;    while (k &lt; count)    {        MergePass(array, tempArray, k, count); //array归并到tempArray        k = 2 * k; //子序列长度加倍        MergePass(tempArray, array, k, count); //tempArray归并到array        k = 2 * k; //子序列长度加倍    }}/// &lt;summary&gt;/// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="srChildLength"&gt;SR中子序列长度&lt;/param&gt;/// &lt;param name="arrayLength"&gt;原数组长度&lt;/param&gt;public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength){    int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数    while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2,            hasMergeCount + 2 * srChildLength - 2); //两两归并        hasMergeCount += 2 * srChildLength;    }    if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1);    }    else //若最后只剩下单个子序列    {        for (int j = hasMergeCount - 1; j &lt; arrayLength; j++)        {            tr[j] = sr[j];        }    }}/// &lt;summary&gt;/// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="sr1StartIndex"&gt;SR数组子序列1起始位置&lt;/param&gt;/// &lt;param name="sr1EndIndex"&gt;SR数组子序列1结束位置&lt;/param&gt;/// &lt;param name="sr2EndIndex"&gt;SR数组子序列2结束位置&lt;/param&gt;private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex){    int sr2StartIndex, currentProcess; //currentProcess为当前进度    for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex;        sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex;        currentProcess++) //两个SR有一个被榨干后就要退出循环    {        if (sr[sr1StartIndex] &lt; sr[sr2StartIndex])        {            tr[currentProcess] = sr[sr1StartIndex++];        }        else        {            tr[currentProcess] = sr[sr2StartIndex++];        }    }    if (sr1StartIndex &lt;= sr1EndIndex)    {        for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++)        {            tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR        }    }    if (sr2StartIndex &lt;= sr2EndIndex)    {        for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++)        {            tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#快速排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 快速排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void QuickSort(int[] array, int count){    QSort(array, 0, count - 1);}/// &lt;summary&gt;/// 快速排序_递归调用/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;private static void QSort(int[] array, int low, int high){    int pivot;    while (low &lt; high)    {        pivot = Partition(array, low, high);        QSort(array, low, pivot - 1);        //尾递归，可以减少一次递归堆栈深度        low = pivot + 1;    }}/// &lt;summary&gt;/// 获取枢轴数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static int Partition(int[] array, int low, int high){    int pivotkey;    int m = low + (high - low) / 2;    //下面是三数取中优化    //交换左端与右端数据，保证左端较小    if (array[low] &gt; array[high])    {        Utilities.Swap(ref array[low],ref array[high]);    }    //交换中间与右端数据，保证中间较小    if (array[m] &gt; array[high])    {        Utilities.Swap(ref array[m],ref array[high]);    }    //交换中间与左端数据，保证左端较小    if (array[m] &gt; array[low])    {        Utilities.Swap(ref array[low],ref array[m]);    }    //默认选取当前数组的第一个值作为枢轴值    pivotkey = array[low];    //枢轴备份    int pivotkeyback = pivotkey;    while (low &lt; high)    {        while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey)        {            high--;        }        array[low] = array[high];        while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey)        {            low++;        }        array[high] = array[low];    }    //将枢轴数值替换回array[low]    array[low] = pivotkeyback;    //返回当前枢轴下标    return low;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#各种排序时空复杂度<br><img src="img/01002-0001.png" alt="排序复杂图"><br>n: 数据规模<br>k: “桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏MVC系列框架</title>
      <link href="/posts/2051.html"/>
      <url>/posts/2051.html</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑;</p><p>流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据;</p><p>总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架；</p><p>不使用MVC的逻辑：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevPanel : MonoBehaviour{      public Button btnLevUp;      public Button btnClose;            //展示UI面板      public static void ShowMe()    {    //todo    }        //隐藏UI面板    public static void HideMe()    {    //todo    }        void Start()    {        //2.监听事件        btnClose.onClick.AddListener(ClickClose);        btnLevUp.onClick.AddListener(ClickLevUp);    }        public void ClickClose()    {        Debug.Log("关闭");        HideMe();    }        public void ClickLevUp()    {        Debug.Log("升级");        //存储数据        //同步更新面板上的数据        UpdateInfo();        //更新主面板的内容        MainPanel.Panel.UpdateInfo();    }            //3.更新面板    public void UpdateInfo()    {    //更新数据    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发；</p><p>使用MVC：<br>Model层：负责增删查改获取界面上需要的数据</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevModel{    //定义数据    private int lev;    //外界只能获取字段    public int Lev    {        get        {            return lev;        }    }        //通知外部更新的事件    //通过它和外部建立联系 而不是直接获取外部的面板    private event UnityAction&lt;PlayerLevModel&gt; updateEvent;        //在外部第一次获取这个数据 如何获取    //通过单例模式 来达到数据的唯一性 和数据的获取    private static PlayerLevModel data = null;    public static PlayerLevModel Data    {        get        {            if( data == null )            {                data = new PlayerLevModel();                data.Init();            }            return data;        }    }        //数据相关的操作    // 初始化    public void Init()    {        lev = PlayerPrefs.GetInt("PlayerLev", 1);    }}    public void LevUp()    {        //升级 改变内容        lev += 1;        //改变过后保存        SaveData();    }            public void SaveData()    {        //把这些数据内容 存储到本地        PlayerPrefs.SetInt("PlayerLev", lev);        UpdateInfo();    }            public void AddEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent += function;    }    public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function)    {        updateEvent -= function;    }    //通知外部更新外部数据的方法    private void UpdateInfo()    {        //找到对应的 使用数据的脚本 去更新数据        updateEvent?Invoke(this);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>视图层：负责获取控件，更新控件信息</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevView : MonoBehaviour{      //1.找控件    public Button btnClose;    public Button btnLevUp;    //2.提供面板更新的相关方法给外部    public void UpdateInfo(PlayerModel data)    {        txtLev.text = "LV." + data.Lev;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新）</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PlayerLevController : MonoBehaviour{    //视图实例，这里视图和控制在一个物体上    private PlayerLevView roleView;    private static PlayerLevController controller = null;    //控制层单例    public static PlayerLevController Controller    {        get        {            return controller;        }    }            public static void ShowMe()    {        if (controller == null)        {            //实例化面板对象            //设置它的父对象 为Canvas        }        //如果是隐藏的形式hide 在这要显示        controller.gameObject.SetActive(true);    }    public static void HideMe()    {        if (controller != null)        {            //方式一 直接删            //方式二 设置可见为隐藏        }    }            void Start()    {    //这里视图和控制在一个物体上        roleView = this.GetComponent&lt;RoleView&gt;();        //第一次更新面板        roleView.UpdateInfo(PlayerLevModel.Data);        roleView.btnClose.onClick.AddListener(ClickCloseBtn);        roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn);        //告知数据模块 当更新时 通知哪个函数做处理        PlayerModel.Data.AddEventListener(UpdateInfo);    }            private void ClickCloseBtn()    {        HideMe();    }    private void ClickLevUpBtn()    {        //通过数据模块 进行升级 达到数据改变        PlayerLevModel.Data.LevUp();    }    private void UpdateInfo( PlayerModel data )    {        if( roleView != null )        {            roleView.UpdateInfo(data);        }    }    private void OnDestroy()    {              PlayerLevModel.Data.RemoveEventListener(UpdateInfo);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好处：<br>1.各司其职，互不干涉 —— 编程思路更清晰<br>2.有利开发中的分工 —— 多人协同开发时，同步并行<br>3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率<br>缺点：<br>1.增加了程序文件的体量 —— 脚本由一变三<br>2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好<br>2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大）</p><h1 id="MV-的概念"><a href="#MV-的概念" class="headerlink" title="MV*的概念"></a>MV*的概念</h1><p>MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变；<br>  所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。</p><p><img src="https://s4.ax1x.com/2022/02/05/Hm6yN9.png" alt="相关的变种"></p><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>  切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部.</p><p>Model层:不变</p><p>View层:不能直接传入Model模型来更新</p><p>Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入；</p><h1 id="MVVM（MP）"><a href="#MVVM（MP）" class="headerlink" title="MVVM（MP）"></a>MVVM（MP）</h1><p>  MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细；</p><p>了解的话可以看看这些第三方MVVM框架：<br>loxodon-Framework:<a href="https://github.com/vovgou/loxodon-framework">vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)</a><br>uMVVM:<a href="https://github.com/MEyes/uMVVM">MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com)</a></p><p>所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心；</p><h1 id="MVE"><a href="#MVE" class="headerlink" title="MVE"></a>MVE</h1><p>  E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可；</p><h1 id="商业框架PureMVC"><a href="#商业框架PureMVC" class="headerlink" title="商业框架PureMVC"></a>商业框架PureMVC</h1><p>官网：<a href="http://puremvc.org/">PureMVC 框架</a><br>PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；<br>Model（数据模型）：关联Proxy(代理)对象，负责处理数据；<br>View（界面）：关联Mediator(中介)对象，负责处理界面；<br>Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；<br>Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；<br>Notification：通知，负责传递信息；</p>]]></content>
      
      
      <categories>
          
          <category> Game-Play </category>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏框架 </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏程序基础框架</title>
      <link href="/posts/2050.html"/>
      <url>/posts/2050.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例管理者基类"><a href="#单例管理者基类" class="headerlink" title="单例管理者基类"></a>单例管理者基类</h1><h2 id="不继承自Mono"><a href="#不继承自Mono" class="headerlink" title="不继承自Mono"></a>不继承自Mono</h2><p>1.利用单例模式和泛形去实现模块管理者基类；</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">public class SingletonBase&lt;T&gt; where T:new(){    private static T instance;    public static T GetInstance()    {        if (instance == null) instance = new T();        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承自Mono"><a href="#继承自Mono" class="headerlink" title="继承自Mono"></a>继承自Mono</h2><p>1.直接实例化通过生成游戏对象并且附加脚本；<br>2.Awake实例化的话要保证单例的唯一性；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour{    private static T instance;    public static T GetInstance()    {        if (instance == null)        {            GameObject go = new GameObject            {                name = typeof(T).Name,            };            instance = go.AddComponent&lt;T&gt;();            DontDestroyOnLoad(go);        }        return instance;    }    protected virtual void Awake()    {        if (instance == null)        {            instance = this as T;            DontDestroyOnLoad(gameObject);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="事件管理者"><a href="#事件管理者" class="headerlink" title="事件管理者"></a>事件管理者</h1><p>1.观察者模式，利用了泛形和委托（事件）<br>2.这里的事件字典只能对付小游戏，大型游戏仍是不够</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public interface IEventInfo { } public class EventInfo : IEventInfo{    public event UnityAction actions;    public EventInfo(UnityAction action)    {        actions += action;    }    public void EventTrigger()    {        actions?.Invoke();    }}public class EventInfo&lt;T&gt; : IEventInfo{    public event UnityAction&lt;T&gt; actions;    public EventInfo(UnityAction&lt;T&gt; action)    {        actions += action;    }    public void EventTrigger(T Info)    {        actions?.Invoke(Info);    }}public class EventMgr : SingletonBase&lt;EventMgr&gt;{    //暂时只定义一个字典进行储存，小游戏够用了    private Dictionary&lt;string, IEventInfo&gt; eventDic = new Dictionary&lt;string, IEventInfo&gt;();     public void AddListenter(string name,UnityAction action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions += action;        else eventDic.Add(name,new EventInfo(action));    }    public void AddListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions += action;        else eventDic.Add(name, new EventInfo&lt;T&gt;(action));    }    public void RemoveListenter(string name, UnityAction action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions -= action;    }    public void RemoveListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions -= action;    }    public void EventTrigger(string name)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).EventTrigger();    }    public void EventTrigger&lt;T&gt;(string name,T info)    {        if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).EventTrigger(info);    }    public void Clear()    {        eventDic.Clear();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Mono根节点"><a href="#Mono根节点" class="headerlink" title="Mono根节点"></a>Mono根节点</h1><p>1.可以创建一个全局唯一的Mono节点使用<br>2.实现游戏入口继承自该节点即可，但是实现Awake单例</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class MonoRoot : SingletonMono&lt;MonoRoot&gt;{    private event UnityAction updateActions;    protected override void Awake()    {        base.Awake();    }    protected virtual void Update()    {        updateActions?.Invoke();    }    public void AddUpdateListenter(UnityAction updateAction)    {        updateActions += updateAction;    }    public void RemoveUpdateListenter(UnityAction updateAction)    {        updateActions -= updateAction;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="资源加载管理者"><a href="#资源加载管理者" class="headerlink" title="资源加载管理者"></a>资源加载管理者</h1><p>1.资源加载有同步加载和异步加载，异步加载用协程实现<br>2.资源加载管理者包括场景切换，以及配置文件加载</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class ResMgr : SingletonBase&lt;ResMgr&gt;{    #region 资源加载    private Dictionary&lt;string,Object&gt; ObjCacheDic=new Dictionary&lt;string, Object&gt;();    public T LoadObj&lt;T&gt;(string path , bool isIns=true , bool isCache= true ) where T : Object    {        T obj;        if (ObjCacheDic.TryGetValue(path, out Object cacheObj)) obj = cacheObj as T;        else         {            obj = Resources.Load&lt;T&gt;(path);            if (isCache) ObjCacheDic.Add(path, obj);        };        if (obj is GameObject &amp;&amp; isIns) return GameObject.Instantiate(obj);        else return obj;    }    public void LoadObjAsyn&lt;T&gt;(string path,UnityAction&lt;T&gt; callback, bool isIns = true, bool isCache = true) where T : Object    {        if (ObjCacheDic.TryGetValue(path, out Object obj))        {            if (obj is GameObject &amp;&amp; isIns)                callback(GameObject.Instantiate(obj) as T);            else                callback(obj as T);        }        else MonoRoot.GetInstance().StartCoroutine(ReallyLoadObjAsyn(path, callback, isIns, isCache));    }    public IEnumerator ReallyLoadObjAsyn&lt;T&gt;(string path, UnityAction&lt;T&gt; callback, bool isIns, bool isCache) where T : Object    {        ResourceRequest r = Resources.LoadAsync&lt;T&gt;(path);        yield return r;        if(isCache) ObjCacheDic.Add(path, r.asset);        if (r.asset is GameObject &amp;&amp; isIns)            callback(GameObject.Instantiate(r.asset) as T);        else            callback(r.asset as T);    }    #endregion        #region 场景切换    public void LoadScene(string name, UnityAction fun)    {        //场景同步加载        SceneManager.LoadScene(name);        //加载完成过后 才会去执行fun        fun();    }    public void LoadSceneAsyn(string name, UnityAction fun)    {        MonoRoot.GetInstance().StartCoroutine(ReallyLoadSceneAsyn(name, fun));    }    public IEnumerator ReallyLoadSceneAsyn(string name, UnityAction fun)    {        AsyncOperation op = SceneManager.LoadSceneAsync(name);        while (!op.isDone)        {            //这里可以去做一些事情，例如更新进度条            //EventMgr.GetInstance().EventTrigger("更新进度条", op.progress);            yield return op.progress;        }        //加载完成过后 才会去执行fun        fun();    }     #endregion}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="缓存池管理者"><a href="#缓存池管理者" class="headerlink" title="缓存池管理者"></a>缓存池管理者</h1><p>1.用一个类类型去包装缓存队列，这个类里面应该封装了获取和设置缓存对象的方法<br>2.缓存池目前只支持预制物的缓存</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class PoolMgr :SingletonBase&lt;PoolMgr&gt; {    private Dictionary&lt;string, PoolData&gt; poolDic=new Dictionary&lt;string, PoolData&gt;();    private GameObject poolRoot;    public void GetObj(string name, UnityAction&lt;GameObject&gt; callBack)    {        if(poolDic.TryGetValue(name, out PoolData poolData) &amp;&amp; poolData.Count &gt; 0)        {            callBack(poolData.GetObj());        }        else        {            //创建资源应使用资源路径            ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(name, (go) =&gt;{                go.name = name;                callBack(go);            });        }    }    public void PushObj(string name,GameObject obj)    {        if(poolRoot=null)poolRoot=new GameObject("PoolRoot");        if(poolDic.TryGetValue(name,out PoolData poolData)) poolData.PushObj(obj);        else poolDic.Add(name, new PoolData(obj,poolRoot));    }    public void  Clear()    {        poolDic.Clear();        poolRoot = null;    }}public class PoolData{    private GameObject parentRoot;    private Queue&lt;GameObject&gt; objQue;    public PoolData(GameObject obj,GameObject poolObj)    {        parentRoot = new GameObject($"{obj.name}Root");        parentRoot.transform.parent = poolObj.transform;        objQue = new Queue&lt;GameObject&gt;();    }    public int Count    {        get { return objQue.Count; }    }    public void PushObj(GameObject obj)    {        //存起来        objQue.Enqueue(obj);        //失活 让其隐藏        obj.SetActive(false);        //设置父对象        obj.transform.parent = parentRoot.transform;    }    public GameObject GetObj()    {        //取出第一个        GameObject obj = objQue.Dequeue();        //激活 让其显示        obj.SetActive(true);        //断开了父子关系        obj.transform.parent = null;        return obj;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="输入管理者"><a href="#输入管理者" class="headerlink" title="输入管理者"></a>输入管理者</h1><p>1.输入管理者耦合事件监听和Mono根节点</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class InputMgr : SingletonBase&lt;InputMgr&gt;{    private bool isStart = false;    public InputMgr()    {        MonoMgr.GetInstance().AddUpdateListener(UpdateIpt);    }    public void StartOrEndCheck(bool isOpen)    {        isStart = isOpen;    }    private void CheckKeyCode(KeyCode key)    {        //事件中心模块 分发按下抬起事件        if (Input.GetKeyDown(key))            EventCenter.GetInstance().EventTrigger("某键按下", key);        //事件中心模块 分发按下抬起事件        if (Input.GetKeyUp(key))            EventCenter.GetInstance().EventTrigger("某键抬起", key);    }    private void UpdateIpt()    {        //没有开启输入检测 就不去检测 直接return        if (!isStart)            return;        CheckKeyCode(KeyCode.W);        CheckKeyCode(KeyCode.S);        CheckKeyCode(KeyCode.A);        CheckKeyCode(KeyCode.D);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="音效管理者"><a href="#音效管理者" class="headerlink" title="音效管理者"></a>音效管理者</h1><p>1.一般音效资源应该做缓存池处理</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class MusicMgr : MonoBehaviour{    private bool isMute = false;    //背景音乐源    private AudioSource bkSource;    //背景音乐大小    private float bkValue = 1;    //一般音乐列表    private List&lt;AudioSource&gt; sourceLst = new List&lt;AudioSource&gt;();    //背景音乐大小    private float soundValue = 1;    //音乐源节点    private GameObject musicRoot;    public MusicMgr()    {        MonoMgr.GetInstance().AddUpdateListener(UpdateMsc);    }    //音乐播放完就回收    private void UpdateMsc()    {        for (int i = sourceLst.Count - 1; i &gt;= 0; --i)        {            if (!sourceLst[i].isPlaying)            {                GameObject.Destroy(sourceLst[i]);                sourceLst.RemoveAt(i);            }        }    }    public void PlayBkMusic(string name)    {        if(!musicRoot) musicRoot=new GameObject("MusicRoot");        if (bkSource) bkSource = musicRoot.AddComponent&lt;AudioSource&gt;();        //异步加载背景音乐 加载完成后 播放        ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;("Music/BK/" + name, (clip) =&gt;        {            bkSource.clip = clip;            bkSource.loop = true;            bkSource.volume = bkValue;            bkSource.Play();        });    }    public void PauseBKMusic()    {        bkSource?.Pause();    }    public void StopBKMusic()    {        bkSource?.Stop();    }    public void ChangeBKValue(float v)    {        bkValue = v;        if (bkSource == null) bkSource.volume = bkValue;    }    public void PlaySound(string name, bool isLoop=false, GameObject parent=null, UnityAction&lt;AudioSource&gt; callBack = null)    {        if (!musicRoot) musicRoot = new GameObject("MusicRoot");        //当音效资源异步加载结束后 再添加一个音效        ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;("Music/Sound/" + name, (clip) =&gt;        {            AudioSource source;            if (parent) source=parent.AddComponent&lt;AudioSource&gt;();            else source = musicRoot.AddComponent&lt;AudioSource&gt;();            source.clip = clip;            source.loop = isLoop;            source.volume = soundValue;            source.Play();            sourceLst.Add(source);            if (callBack != null)                callBack(source);        });    }    public void ChangeSoundValue(float value)    {        soundValue = value;        for (int i = 0; i &lt; sourceLst.Count; ++i)            sourceLst[i].volume = value;    }    public void StopSound(AudioSource source)    {        if (sourceLst.Contains(source))        {            sourceLst.Remove(source);            source.Stop();            GameObject.Destroy(source);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="UI管理者和UI面板基类"><a href="#UI管理者和UI面板基类" class="headerlink" title="UI管理者和UI面板基类"></a>UI管理者和UI面板基类</h1><h2 id="面板基类"><a href="#面板基类" class="headerlink" title="面板基类"></a>面板基类</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class BasePanel : MonoBehaviour{    //通过里式转换原则 来存储所有的控件    private Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt; controlDic = new Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt;();    protected virtual void Awake()    {        FindChildrenControl&lt;Button&gt;();        FindChildrenControl&lt;Image&gt;();        FindChildrenControl&lt;Text&gt;();        FindChildrenControl&lt;Toggle&gt;();        FindChildrenControl&lt;Slider&gt;();        FindChildrenControl&lt;ScrollRect&gt;();        FindChildrenControl&lt;InputField&gt;();    }    public virtual void ShowMe()    {    }    public virtual void HideMe()    {    }    protected virtual void OnClick(string btnName)    {    }    protected virtual void OnValueChanged(string toggleName, bool value)    {    }    protected T GetControl&lt;T&gt;(string controlName) where T : UIBehaviour    {        if (controlDic.ContainsKey(controlName))        {            for (int i = 0; i &lt; controlDic[controlName].Count; ++i)            {                if (controlDic[controlName][i] is T)                    return controlDic[controlName][i] as T;            }        }        return null;    }    private void FindChildrenControl&lt;T&gt;() where T : UIBehaviour    {        T[] controls = this.GetComponentsInChildren&lt;T&gt;();        for (int i = 0; i &lt; controls.Length; ++i)        {            string objName = controls[i].gameObject.name;            if (controlDic.ContainsKey(objName))                controlDic[objName].Add(controls[i]);            else                controlDic.Add(objName, new List&lt;UIBehaviour&gt;() { controls[i] });            //如果是按钮控件            if (controls[i] is Button)            {                (controls[i] as Button).onClick.AddListener(() =&gt;                {                    OnClick(objName);                });            }            //如果是单选框或者多选框            else if (controls[i] is Toggle)            {                (controls[i] as Toggle).onValueChanged.AddListener((value) =&gt;                {                    OnValueChanged(objName, value);                });            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="UI管理者"><a href="#UI管理者" class="headerlink" title="UI管理者"></a>UI管理者</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class UIMgr : SingletonBase&lt;UIMgr&gt;{    public Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;();    private Transform bot;    private Transform mid;    private Transform top;    private Transform system;    //记录我们UI的Canvas父对象 方便以后外部可能会使用它    public RectTransform canvas;    public UIMgr()    {        //创建Canvas 让其过场景的时候 不被移除        GameObject obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;("UI/Canvas");        canvas = obj.transform as RectTransform;        GameObject.DontDestroyOnLoad(obj);        //找到各层        bot = canvas.Find("Bot");        mid = canvas.Find("Mid");        top = canvas.Find("Top");        system = canvas.Find("System");        //创建EventSystem 让其过场景的时候 不被移除        obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;("UI/EventSystem");        GameObject.DontDestroyOnLoad(obj);    }    /// &lt;summary&gt;    /// 通过层级枚举 得到对应层级的父对象    /// &lt;/summary&gt;    /// &lt;param name="layer"&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public Transform GetLayerFather(EUIayer layer)    {        switch (layer)        {            case EUIayer.Bot:                return this.bot;            case EUIayer.Mid:                return this.mid;            case EUIayer.Top:                return this.top;            case EUIayer.System:                return this.system;        }        return null;    }    /// &lt;summary&gt;    /// 显示面板    /// &lt;/summary&gt;    /// &lt;typeparam name="T"&gt;面板脚本类型&lt;/typeparam&gt;    /// &lt;param name="panelName"&gt;面板名&lt;/param&gt;    /// &lt;param name="layer"&gt;显示在哪一层&lt;/param&gt;    /// &lt;param name="callBack"&gt;当面板预设体创建成功后 你想做的事&lt;/param&gt;    public void ShowPanel&lt;T&gt;(string panelName, EUIayer layer = EUIayer.Mid, UnityAction&lt;T&gt; callBack = null) where T : BasePanel    {        if (panelDic.ContainsKey(panelName))        {            panelDic[panelName].ShowMe();            // 处理面板创建完成后的逻辑            if (callBack != null)                callBack(panelDic[panelName] as T);            //避免面板重复加载 如果存在该面板 即直接显示 调用回调函数后  直接return 不再处理后面的异步加载逻辑            return;        }        ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;("UI/" + panelName, (obj) =&gt;        {            //把他作为 Canvas的子对象            //并且 要设置它的相对位置            //找到父对象 你到底显示在哪一层            Transform father = bot;            switch (layer)            {                case EUIayer.Mid:                    father = mid;                    break;                case EUIayer.Top:                    father = top;                    break;                case EUIayer.System:                    father = system;                    break;            }            //设置父对象  设置相对位置和大小            obj.transform.SetParent(father);            obj.transform.localPosition = Vector3.zero;            obj.transform.localScale = Vector3.one;            (obj.transform as RectTransform).offsetMax = Vector2.zero;            (obj.transform as RectTransform).offsetMin = Vector2.zero;            //得到预设体身上的面板脚本            T panel = obj.GetComponent&lt;T&gt;();            // 处理面板创建完成后的逻辑            if (callBack != null)                callBack(panel);            panel.ShowMe();            //把面板存起来            panelDic.Add(panelName, panel);        });    }    /// &lt;summary&gt;    /// 隐藏面板    /// &lt;/summary&gt;    /// &lt;param name="panelName"&gt;&lt;/param&gt;    public void HidePanel(string panelName)    {        if (panelDic.ContainsKey(panelName))        {            panelDic[panelName].HideMe();            GameObject.Destroy(panelDic[panelName].gameObject);            panelDic.Remove(panelName);        }    }    /// &lt;summary&gt;    /// 得到某一个已经显示的面板 方便外部使用    /// &lt;/summary&gt;    public T GetPanel&lt;T&gt;(string name) where T : BasePanel    {        if (panelDic.ContainsKey(name))            return panelDic[name] as T;        return null;    }    /// &lt;summary&gt;    /// 给控件添加自定义事件监听    /// &lt;/summary&gt;    /// &lt;param name="control"&gt;控件对象&lt;/param&gt;    /// &lt;param name="type"&gt;事件类型&lt;/param&gt;    /// &lt;param name="callBack"&gt;事件的响应函数&lt;/param&gt;    public static void AddCustomEventListener(UIBehaviour control, EventTriggerType type, UnityAction&lt;BaseEventData&gt; callBack)    {        EventTrigger trigger = control.GetComponent&lt;EventTrigger&gt;();        if (trigger == null)            trigger = control.gameObject.AddComponent&lt;EventTrigger&gt;();        EventTrigger.Entry entry = new EventTrigger.Entry();        entry.eventID = type;        entry.callback.AddListener(callBack);        trigger.triggers.Add(entry);    }}/// &lt;summary&gt;/// UI层级/// &lt;/summary&gt;public enum EUIayer{    Bot,    Mid,    Top,    System,}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Game-Play </category>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相关_数据持久化</title>
      <link href="/posts/1543.html"/>
      <url>/posts/1543.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> 数据持久化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 数据持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相关_UGUI</title>
      <link href="/posts/1541.html"/>
      <url>/posts/1541.html</url>
      
        <content type="html"><![CDATA[<h1 id="六大基础组件"><a href="#六大基础组件" class="headerlink" title="六大基础组件"></a>六大基础组件</h1><p>1.Canvas对象上依附的：<br>Canvas：画布组件，主要用于渲染UI控件<br>Canvas Scaler：画布分辨率自适应组件，主要用于分辨率自适应<br>Graphic Raycaster：射线事件交互组件，主要用于控制射线响应相关<br>RectTransform：UI对象位置锚点控制组件，主要用于控制位置和对其方式</p><p>2.EventSystem对象上依附的：<br>EventSystem和Standalone Input Module：<br>玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作</p><h2 id="Canvas画布组件"><a href="#Canvas画布组件" class="headerlink" title="Canvas画布组件"></a>Canvas画布组件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Screen Space - Overlay：屏幕空间，覆盖模式，UI始终在前；    Pixel Perfect：是否开启无锯齿精确渲染（性能换效果）    SortOrder：排序层编号（用于控制多个Canvas时的渲染先后顺序）    TargetDisplay：目标设备（在哪个显示设备上显示）    Additional Shader Channels：其他着色器通道，决定着色器可以读取哪些数据<span class="token number">2</span>.Screen Space - Camera<span class="token punctuation">(</span>不推荐设置成主摄像机<span class="token punctuation">)</span>：屏幕空间，摄像机模式，3D物体可以显示在UI之前；    RenderCamera：用于渲染UI的摄像机（如果不设置将类似于覆盖模式）    Plane Distance：UI平面在摄像机前方的距离，类似整体Z轴的感觉    Sorting Layer：所在排序层    Order <span class="token keyword">in</span> Layer：排序层的序号    <span class="token number">3</span>.World Space：世界空间，3D模式；    Event Camera：用于处理UI事件的摄像机（如果不设置，不能正常注册UI事件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Canvas.html">画布 - Unity 手册 (unity3d.com)</a></p><h2 id="CanvasScaler画布缩放控制器组件"><a href="#CanvasScaler画布缩放控制器组件" class="headerlink" title="CanvasScaler画布缩放控制器组件"></a>CanvasScaler画布缩放控制器组件</h2><p>  CanvasScaler意思是画布缩放控制器，它是用于分辨率自适应的组件，它主要负责在不同分辨率下UI控件大小自适应，它并不负责位置，位置由之后的RectTransform组件负责；</p><p>1.屏幕分辨率（UI画布宽高*缩放系数 = 屏幕分辨率）：当前设备的分辨率，编辑器下Game窗口中可以查看到；<br>2.参考分辨率：在其中一种适配模式中出现的关键参数，参与分辨率自适应的计算；<br>3.画布宽高和缩放系数：分辨率自适应会改变的参数，通过屏幕分辨率和参考分辨率计算而来；<br>4.分辨率大小自适应：通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数，该结果会影响所有UI控件的缩放大小；</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-CanvasScaler.html">画布缩放器 (Canvas Scaler) - Unity 手册 (unity3d.com)</a></p><h3 id="缩放模式"><a href="#缩放模式" class="headerlink" title="缩放模式"></a>缩放模式</h3><p>  根据屏幕尺寸进行缩放，随着屏幕尺寸变化来放大缩小（游戏开发中常用）；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Reference Resolution：参考分辨率（美术同学出图的标准分辨率）；缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算；<span class="token number">2</span>.Screen Match Mode：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式；    Expand：水平或垂直拓展画布区域，会根据宽高比的变化来放大缩小画布，可能有黑边<span class="token punctuation">(</span>缩放系数 <span class="token operator">=</span> Mathf.Min<span class="token punctuation">(</span>屏幕宽/参考分辨率宽，屏幕高/参考分辨率高<span class="token punctuation">))</span><span class="token punctuation">;</span>    Shrink：水平或垂直裁剪画布区域，会根据宽高比的变化来放大缩小画布，可能会裁剪<span class="token punctuation">(</span>缩放系数 <span class="token operator">=</span> Mathf.Max<span class="token punctuation">(</span>屏幕宽/参考分辨率宽，屏幕高/参考分辨率高<span class="token punctuation">))</span><span class="token punctuation">;</span>    Match Width Or Height：以宽高或者二者的平均值作为参考来缩放画布区<span class="token punctuation">(</span>在取平均值之前，我们先取相对宽度和高度的对数,float logWidth <span class="token operator">=</span> Mathf.Log<span class="token punctuation">(</span>屏幕宽 / 参考分辨率宽, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>float logHeight <span class="token operator">=</span> Mathf.Log<span class="token punctuation">(</span>屏幕高 / 参考分辨率高, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>,在对数空间中变换是为了获得更好的性能以及更准确的结果,float logWeightedAverage <span class="token operator">=</span> Mathf.Lerp<span class="token punctuation">(</span>logWidth, logHeight, m_MatchWidthOrHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>scaleFactor <span class="token operator">=</span> Mathf.Pow<span class="token punctuation">(</span><span class="token number">2</span>, logWeightedAverage<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恒定像素模式"><a href="#恒定像素模式" class="headerlink" title="恒定像素模式"></a>恒定像素模式</h3><p>  无论屏幕大小如何，UI始终保持相同像素大小。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Scale Factor：缩放系数，按此系数缩放画布中的所有UI元素；<span class="token number">2</span>.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素），图片设置中的Pixels Per Unit设置，会和该参数一起参与计算；计算公式：UI原始尺寸 <span class="token operator">=</span> 图片大小（像素）/ <span class="token punctuation">(</span>Pixels Per Unit / Reference Pixels Per Unit）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恒定物理模式"><a href="#恒定物理模式" class="headerlink" title="恒定物理模式"></a>恒定物理模式</h3><p>  无论屏幕大小和分辨率如何，UI元素始终保持相同物理大小（DPI：（Dots Per Inch，每英寸点数）图像每英寸长度内的像素点数）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Physical Unit：物理单位，使用的物理单位种类<span class="token number">2</span>.Fallback Screen DPI：备用DPI，当找不到设备DPI时，使用此值<span class="token number">3</span>.Default Sprite DPI：默认图片DP单位种类 与1英寸的关系：Centimeters（厘米cm） <span class="token number">2.54</span>Millimeters（毫米mm） <span class="token number">25.4</span>Inches（英寸） <span class="token number">1</span>Points（点） <span class="token number">72</span>Picas（皮卡） 计算公式：根据DPI算出新的Reference Pixels Per Unit （单位参考像素）新单位参考像素 <span class="token operator">=</span>单位参考像素 * Physical Unit / Default Sprite DPI再使用模式一：恒定像素模式的公式进行计算原始尺寸 <span class="token operator">=</span>图片大小（像素）/ <span class="token punctuation">(</span>Pixels Per Unit / 新单位参考像素<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##3D模式<br>  当Canvas的渲染模式设置为，世界空间3D渲染模式时，这时Canvas Scaler 的缩放模式会强制变为，World 3D世界模式；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Dynamic Pixels Per Unit：UI中动态创建的位图（例如文本）中，单位像素数（类似密度）<span class="token number">2</span>.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Graphic-Raycaster图像射线投射器"><a href="#Graphic-Raycaster图像射线投射器" class="headerlink" title="Graphic Raycaster图像射线投射器"></a>Graphic Raycaster图像射线投射器</h2><p>  Graphic Raycaster意思是图形射线投射器,它是用于检测UI输入事件的射线发射器,它主要负责通过射线检测玩家和UI元素的交互,判断是否点击到了UI元素;</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Ignore Reversed Graphics：是否忽略反转图形<span class="token number">2</span>.Blocking Objects：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效）<span class="token number">3</span>.Blocking Mask：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-GraphicRaycaster.html">图形射线投射器 - Unity 手册 (unity3d.com)</a></p><h2 id="RectTransform"><a href="#RectTransform" class="headerlink" title="RectTransform"></a>RectTransform</h2><p>  RectTransform意思是矩形变换，它继承于Transform，是专门用于处理UI元素位置大小相关的组件，Transform组件只处理位置、角度、缩放，RectTransform在此基础上加入了矩形相关，将UI元素当做一个矩形来处理，加入了中心点、锚点、长宽等属性，其目的是更加方便的控制其大小以及分辨率自适应中的位置适应；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Pivot：轴心<span class="token punctuation">(</span>中心<span class="token punctuation">)</span>点，取值范围0~1<span class="token number">2</span>.Anchors<span class="token punctuation">(</span>相对父矩形锚点<span class="token punctuation">)</span>：<span class="token number">3</span>.Min是矩形锚点范围X和Y的最小值<span class="token number">4</span>.Max是矩形锚点范围X和Y的最大值取值范围都是0~1<span class="token number">5</span>.Pos<span class="token punctuation">(</span>X,Y,Z<span class="token punctuation">)</span>：轴心点<span class="token punctuation">(</span>中心点<span class="token punctuation">)</span>相对锚点的位置<span class="token number">6</span>.Width/Height：矩形的宽高<span class="token number">7</span>.Left/Top/Right/Bottom：矩形边缘相对于锚点的位置；当锚点分离时会出现这些内容<span class="token number">8</span>.Rotation：围绕轴心点旋转的角度<span class="token number">9</span>.Scale：缩放大小<span class="token number">10</span>.Blueprint Mode（蓝图模式）:启用后，编辑旋转和缩放不会影响矩形，只会影响显示内容<span class="token number">11</span>.Raw Edit Mode（原始编辑模式）:启用后，改变轴心和锚点值不会改变矩形位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-RectTransform.html">矩形变换 - Unity 手册 (unity3d.com)</a></p><h2 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h2><p>  Event System意思是事件系统，它是用于管理玩家的输入事件并分发给各UI控件，它是事件逻辑处理模块，所有的UI事件都通过EventSystem组件中轮询检测并做相应的执行，它类似一个中转站，和许多模块一起共同协作，如果没有它，所有点击、拖曳等等行为都不会被响应；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.First Selected：首先选择的游戏对象，可以设置游戏一开始的默认选择<span class="token number">2</span>.Send Navigation Events：是否允许导航事件（移动/按下/取消）<span class="token number">3</span>.Drag Threshold：拖拽操作的阈值（移动多少像素算拖拽）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-EventSystem.html">事件系统管理器 - Unity 手册 (unity3d.com)</a></p><h2 id="Standalone-Input-Module"><a href="#Standalone-Input-Module" class="headerlink" title="Standalone Input Module"></a>Standalone Input Module</h2><p>  Standalone Input Module意思是独立输入模块，它主要针对处理鼠标/键盘/控制器/触屏（新版Unity）的输入，输入的事件通过EventSystem进行分发，它依赖于EventSystem组件，他们两缺一不可；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Horizontal Axis：水平轴按钮对应的热键名（该名字对应Input管理器）<span class="token number">2</span>.Vertical Axis：垂直轴按钮对应的热键名（该名字对应Input管理器）<span class="token number">3</span>.Submit Button：提交（确定）按钮对应的热建名（该名字对应Input管理器）<span class="token number">4</span>.Cancel Button：取消按钮对应的热建名（该名字对应Input管理器）<span class="token number">5</span>.Input Actions Per Second：每秒允许键盘/控制器输入的数量<span class="token number">6</span>.Repeat Delay：每秒输入操作重复率生效前的延迟时间<span class="token number">7</span>.ForceModule Active：是否强制模块处于激活状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-StandaloneInputModule.html">独立输入模块 - Unity 手册 (unity3d.com)</a></p><h1 id="三大基础控件"><a href="#三大基础控件" class="headerlink" title="三大基础控件"></a>三大基础控件</h1><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>  是UGUI中用于显示文本的关键组件，可以加OutLine组件和Shadow组件配合。</p><p>Text参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Text：文本显示内容Font：字体FontStyle：字体样式Normal：普通Bold：加粗Italic：斜体Bold And Italic：加粗 + 斜体Font Size：字体大小Line Spacing：行之间的垂直间距Rich Text：是否开启富文本Alignment：对其方式Align By Geometry：使用字形集合形状范围进行水平对其，而不是字形指标Horizontal Overflow：处理文本太宽无法放入矩形范围内时的处理方式Wrap：包裹模式-字体始终在矩形范围内，会自动换行Overflow：溢出模式-字体可以溢出矩形框Vertical Overflow：处理文本太高无法放入矩形范围内时的处理方式Truncate：截断模式-字体始终在矩形范围内，超出部分裁剪Overflow：溢出模式-字体可以溢出矩形框Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整字体大小MinSize：最小多小MaxSize：最大多大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>富文本:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">加粗<span class="token operator">&lt;</span>b<span class="token operator">&gt;</span>文本内容<span class="token operator">&lt;</span>/b<span class="token operator">&gt;</span>斜体<span class="token operator">&lt;</span>i<span class="token operator">&gt;</span>文本内容<span class="token operator">&lt;</span>/i<span class="token operator">&gt;</span>大小<span class="token operator">&lt;</span>size<span class="token operator">=</span><span class="token number">5</span><span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span>文本内容<span class="token operator">&lt;</span>/size<span class="token operator">&gt;</span>颜色:<span class="token operator">&lt;</span>color<span class="token operator">=</span><span class="token comment">#ff0000ff&gt;文本内容&lt;/size&gt;</span><span class="token operator">&lt;</span>color<span class="token operator">=</span>red<span class="token operator">&gt;</span>文本内容<span class="token operator">&lt;</span>/size<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Text.html">文本 (Text) - Unity 手册 (unity3d.com)</a></p><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>  是UGUI中用于显示精灵图片的关键组件，除了背景图等大图，一般都使用Image来显示UI中的图片元素。<br>Image参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Source Image：图片来源（图片类型必须是”精灵“类型）Color：图像的颜色Material：图像的材质（一般不修改，会使用UI的默认材质）Raycast Target：是否作为射线检测的目标（如果不勾选将不会响应射线检测）Maskable：是否能被遮罩（之后结合遮罩相关知识点进行讲解）Image Type：图片类型Simple-普通模式，均匀缩放整个图片Sliced-切片模式，9宫格拉伸，只拉伸中央十字区域Pixels Per UnitMultiplier：每单位像素乘数Fill Center：中心填充Tiled-平铺模式，重复平铺中央部分Filled-填充模式Fill Method：填充方式Fill Origin：填充原点Fill Amount：填充量Clockwise：顺时针方向Use Sprite Mesh：使用精灵网格，勾选的话Unity会帮我们生成图片网格Preserve Aspect：确保图像保持其现有尺寸Set Native Size：设置为图片资源的原始大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Image.html">图像 (Image) - Unity 手册 (unity3d.com)</a></p><h2 id="RawImage"><a href="#RawImage" class="headerlink" title="RawImage"></a>RawImage</h2><p>  它和Image的区别是 一般RawImage用于显示大图(背景图，不需要打入图集的图片，网络下载的图等等)。</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-RawImage.html">原始图像 (Raw Image) - Unity 手册 (unity3d.com)</a></p><h1 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h1><h2 id="Button按钮控件"><a href="#Button按钮控件" class="headerlink" title="Button按钮控件"></a>Button按钮控件</h2><p>  是UGUI中用于处理玩家按钮相关交互的关键组件。<br>参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果None：没有状态变化效果ColorTint：用颜色表示不同状态的变化TargetGraphic：控制的目标图形Normal Color：正常状态颜色Highlighted Color：鼠标进入时显示高亮颜色Pressed Color：按下颜色Selected Color：选中的颜色Disabled Color：禁用时的颜色Color Multiplier：颜色倍增器，过渡颜色乘以该值FadeDuration：衰减持续时间，从一个状态进入另一个状态时需要的时间Sprite Swap：用图片表示不同状态的变化Highlighted Sprite：鼠标进入时图片Pressed Sprite：按下时图片Selected Color：选中时的颜色Disabled Sprite：禁用时显示的图片Animation：用动画表示不同状态的变化Normal Trigger：正常动画触发器Highlighted Trigger：鼠标进入状态时触发器Pressed Trigger：按下时触发器Selected Trigger：选中时触发器Disabled Trigger：禁用时触发器Navigation：导航模式，可以设置UI元素如何在播放模式中控制导航None：无键盘导航Horizontal：水平导航Verticval：垂直导航Automatic：自动导航Explicit：指定周边控件进行导航Visualize:可以在场景窗口看到导航连线OnClick：单击（按下再抬起）执行的函数列表<span class="token punctuation">(</span>btn.onClick.AddListenter<span class="token punctuation">(</span>事件<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Button.html">按钮 (Button) - Unity 手册 (unity3d.com)</a></p><h2 id="Toggle开关控件"><a href="#Toggle开关控件" class="headerlink" title="Toggle开关控件"></a>Toggle开关控件</h2><p>  是UGUI中用于处理玩家单选框多选框相关交互的关键组件，可以通过配合ToggleGroup组件制作为单选框，默认创建的Toggle由4个对象组成，父对象——Toggle组件依附，子对象——背景图（必备）、选中图（必备）、说明文字（可选）。</p><p>Toggle参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>IsOn：当前是否处于打开状态Toggle Transition：在开关值变化时的过渡方式None：无任何过渡，直接显示隐藏Fade：淡入淡出Graphic：用于表示选中状态的图片Group：单选框分组<span class="token punctuation">(</span>需要挂载Toggle Group组件<span class="token punctuation">)</span>Allow Switch Off：是否允许不选中任何一个单选框（注意：单选框分组组件可以挂载在任何对象上，只需要将其和一组的单选框关联即可）OnValueChanged：开关状态变化时执行的函数列表（ tog.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span><span class="token punctuation">;</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Toggle.html">开关 (Toggle) - Unity 手册 (unity3d.com)</a></p><h2 id="InputField文本输入控件"><a href="#InputField文本输入控件" class="headerlink" title="InputField文本输入控件"></a>InputField文本输入控件</h2><p>  是UGUI中用于处理玩家文本输入相关交互的关键组件，默认创建的InputField由3个对象组成，父对象——InputField组件依附对象 以及 同时在其上挂载了一个Image作为背景图，子对象——文本显示组件（必备）、默认显示文本组件（必备）。<br> InputField参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>TextComponent：用于关联显示输入内容的文本组件Text：输入框的起始默认值Character Limit：可以输入字符长度的最大值（0默认无限）Content Type：输入的字符类型限制Standard：标准模式；可以输入任何字符Autocorrected：自动更正模式；跟踪未知单词，向用户建议合适的替换候选词Integer Number：整数模式；用户只能输入整数Decimal Number：十进制数模式；用于只能输入数字包括小数Alphanumeric：字母数字模式；只能输入字母和数字Name：名字模式；自动将每个单子首字母大写Email Address：邮箱地址模式；允许最多输入一个@符号组成的字符和数字字符串Password：密码模式；用星号隐藏输入的字符，允许使用字符Pin：别针模式；用星号隐藏输入的字符，只允许输入整数Custom：自定义模式；允许自定义行类型，输入类型，键盘类型和字符验证Line Type：行类型，定义文本格式Single Line：只允许单行显示Multi Line Submit：允许使用多行。仅在需要时使用新的一行Multi Line NewLine：允许使用多行。用户可以按回车键空行Placeholder：关联用于显示初始内容文本控件Caret Blink Rate：光标闪烁速率Caret Width：光标宽Custom Caret Color：自定义光标颜色Selection Color：批量选中的背景颜色Hide Mobile Input：隐藏移动设备屏幕上键盘，仅适用于IOSRead Only：只读，不能改OnValueChanged：滑动条值改变时执行的函数列表input.onValueChanged.AddListener<span class="token punctuation">(</span>事件）input.onEndEdit.AddListener<span class="token punctuation">(</span>事件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-InputField.html">输入字段 (Input Field) - Unity 手册 (unity3d.com)</a></p><h2 id="Slider滑动条控件"><a href="#Slider滑动条控件" class="headerlink" title="Slider滑动条控件"></a>Slider滑动条控件</h2><p>  Slider是滑动条组件，默认创建的Slider由4组对象组成，父对象——Slider组件依附的对象，子对象——背景图、进度图、滑动块三组对象。</p><p>Slider参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>FillRect：用于填充的进度条图形Handle Rect：用于滑动的滑动块图形Direction：滑动条值增加的方向Left To Right：从左到右Right To Left：从右到左Bottom To Top：从下到上Top To Bottom：从上到下Min Value 和 Max Value：最小值和最大值，滑动滚动条时值从最小到最大之间变化（左右、上下极值）Whole Numbers：是否约束为整数值变化Value：当前滑动条代表的数值OnValueChanged：滑动条值改变时执行的函数列表（ s.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Slider.html">滑动条 (Slider) - Unity 手册 (unity3d.com)</a></p><h2 id="ScrollBar滚动条控件"><a href="#ScrollBar滚动条控件" class="headerlink" title="ScrollBar滚动条控件"></a>ScrollBar滚动条控件</h2><p>  是UGUI中用于处理滚动条相关交互的关键组件，默认创建的Scrollbar由2组对象组成，父对象——Scrollbar组件依附的对象，子对象——滚动块对象，一般情况下我们不会单独使用滚动条 ，都是配合ScrollView滚动视图来使用。</p><p>ScrollBar参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Handle Rect：关联滚动块图形对象Direction：滑动条值增加的方向Left To Right：从左到右Right To Left：从右到左Bottom To Top：从下到上Top To Bottom：从上到下Value：滚动条初始位置值（0~1）Value：滚动块在条中的比例大小（0~1）Number Of Steps：允许可以滚动多少次（不同滚动位置的数量）OnValueChanged：滚动条值改变时执行的函数列表（   sb.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Scrollbar.html">滚动条 (Scrollbar) - Unity 手册 (unity3d.com)</a></p><h2 id="ScrollView滚动视图控件"><a href="#ScrollView滚动视图控件" class="headerlink" title="ScrollView滚动视图控件"></a>ScrollView滚动视图控件</h2><p>  是UGUI中用于处理滚动视图相关交互的关键组件，默认创建的ScrollRect由4组对象组成，父对象——ScrollRect组件依附的对象 还有一个Image组件 最为背景图，子对象——Viewport控制滚动视图可视范围和内容显示、Scrollbar Horizontal 水平滚动条、Scrollbar Vertical 垂直滚动条。</p><p>ScrollRect参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Content：控制滚动视图显示内容的父对象，它的尺寸有多大<span class="token punctuation">(</span>滚动视图就能拖多远<span class="token punctuation">)</span>Horizontal：启用水平滚动Vertical：启用垂直滚动Movement Type：滚动视图元素的运动类型。主要控制拖动时的反馈效果Unrestricted（一般不使用）：不受限制，随便拖动Elastic（常用）：回弹效果，当滚出边缘后，会弹回边界Elasticity：回弹系数，控制回弹效果。值越大回弹越慢Clamped：夹紧效果，始终限制在范围内，没有回弹效果Inertia：移动惯性，如果开启，松开鼠标后会有一定的移动惯性Deceleration Rate：减速率（0~1），0没有惯性，1不会停止Scroll Sensitivity：滚轮（鼠标中间）和触摸板（笔记本）的滚动事件敏感性Viewport：关联滚动视图内容视口对象Horizontal Scrollbar：关联水平滚动条Visibility：是否在不需要时自动隐藏等模式Permanent：一直显示滚动条Auto Hide：自动隐藏滚动条Auto Hide And Expand Viewport：自动隐藏滚动条并且自动拓展内容视口Spacing：滚动条和视口之间的间隔空间OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dropdow下拉列表控件"><a href="#Dropdow下拉列表控件" class="headerlink" title="Dropdow下拉列表控件"></a>Dropdow下拉列表控件</h2><p>  是UGUI中用于处理下拉列表相关交互的关键组件，默认创建的DropDown由4组对象组成，父对象——DropDown组件依附的对象 还有一个Image组件 作为背景图，子对象——Label是当前选项描Arrow右侧小箭头、Template下拉列表选单。</p><p>Dropdow参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Interactable：是否接受输入Transition：响应用户输入的过渡效果<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航<span class="token punctuation">(</span>同Button<span class="token punctuation">)</span>Template：关联下拉列表对象Caption Text：关联显示当前选择内容的文本组件Caption Image：关联显示当前选择内容的图片组件Item Text：关联下拉列表选项用的文本控件Item Image：关联下拉列表选项用的图片控件Value：当前所选选项的索引值Alpha Fada Speed：下拉列表窗口淡入淡出的速度Options：存在的选项列表OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener<span class="token punctuation">(</span>事件<span class="token punctuation">)</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/script-Dropdown.html">下拉选单 (Dropdown) - Unity 手册 (unity3d.com)</a></p><h1 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h1><h2 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h2><p>  打图集注意的是在游戏场景插入同图集的图会打断批处理，即使在同一个图集也不行，所以要额外注意UI元素的排列顺序。</p><h2 id="事件监听接口"><a href="#事件监听接口" class="headerlink" title="事件监听接口"></a>事件监听接口</h2><h2 id="EventTrigger事件触发器"><a href="#EventTrigger事件触发器" class="headerlink" title="EventTrigger事件触发器"></a>EventTrigger事件触发器</h2><h2 id="屏幕坐标转UI相对坐标"><a href="#屏幕坐标转UI相对坐标" class="headerlink" title="屏幕坐标转UI相对坐标"></a>屏幕坐标转UI相对坐标</h2><h2 id="遮罩Mask"><a href="#遮罩Mask" class="headerlink" title="遮罩Mask"></a>遮罩Mask</h2><h2 id="模型和粒子显示在UI之前"><a href="#模型和粒子显示在UI之前" class="headerlink" title="模型和粒子显示在UI之前"></a>模型和粒子显示在UI之前</h2><h2 id="异形按钮"><a href="#异形按钮" class="headerlink" title="异形按钮"></a>异形按钮</h2><h2 id="自动布局组件"><a href="#自动布局组件" class="headerlink" title="自动布局组件"></a>自动布局组件</h2><h2 id="画布组Canvas-Group"><a href="#画布组Canvas-Group" class="headerlink" title="画布组Canvas Group"></a>画布组Canvas Group</h2>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> GUI解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> GUI解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相关_GUI</title>
      <link href="/posts/1540.html"/>
      <url>/posts/1540.html</url>
      
        <content type="html"><![CDATA[<h1 id="GUI概叙"><a href="#GUI概叙" class="headerlink" title="GUI概叙"></a>GUI概叙</h1><h1 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h1><h2 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h2><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h2><h2 id="多选框"><a href="#多选框" class="headerlink" title="多选框"></a>多选框</h2><h2 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h2><h2 id="拖动条"><a href="#拖动条" class="headerlink" title="拖动条"></a>拖动条</h2><h2 id="图像绘制和框"><a href="#图像绘制和框" class="headerlink" title="图像绘制和框"></a>图像绘制和框</h2><h1 id="复合控件"><a href="#复合控件" class="headerlink" title="复合控件"></a>复合控件</h1><h2 id="工具栏和选择网格"><a href="#工具栏和选择网格" class="headerlink" title="工具栏和选择网格"></a>工具栏和选择网格</h2><h2 id="滚动视图和分组"><a href="#滚动视图和分组" class="headerlink" title="滚动视图和分组"></a>滚动视图和分组</h2><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h1 id="自定义整体样式"><a href="#自定义整体样式" class="headerlink" title="自定义整体样式"></a>自定义整体样式</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
          <category> GUI解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> GUI解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity进阶</title>
      <link href="/posts/03009.html"/>
      <url>/posts/03009.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity核心</title>
      <link href="/posts/1539.html"/>
      <url>/posts/1539.html</url>
      
        <content type="html"><![CDATA[<h1 id="2D相关"><a href="#2D相关" class="headerlink" title="2D相关"></a>2D相关</h1><h2 id="图片导入设置"><a href="#图片导入设置" class="headerlink" title="图片导入设置"></a>图片导入设置</h2><h3 id="Unity支持的图片格式"><a href="#Unity支持的图片格式" class="headerlink" title="Unity支持的图片格式"></a>Unity支持的图片格式</h3><p>BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大;</p><p>TIF:基本不损失图片信息的图片格式，缺点是体积大;</p><p>JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道;</p><p>PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道;</p><p>TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道;</p><p>PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面;</p><p>其它:还支持,EXR、GIF、HDR、IFF、PICT等等,其中Unity最常用的图片格式是JPG、PNG、TGA三种格式;</p><h3 id="纹理类型设置（Texture-Type）"><a href="#纹理类型设置（Texture-Type）" class="headerlink" title="纹理类型设置（Texture Type）"></a>纹理类型设置（Texture Type）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Default-默认纹理，大部分导入的模型贴图都是该类型sRGB<span class="token punctuation">(</span>Color Texture<span class="token punctuation">)</span>：启用可以将纹理存储在伽马空间<span class="token punctuation">(</span>见下图一<span class="token punctuation">)</span>中（对每一个像素做一次幂函数运算）Alpha Source：指定如何生成纹理的Alpha通道None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道Input Texture Alpha：输入纹理中的AlphaFrom Gray Scale：从输入纹理RGB值的平均值生成AlphaAlpha Is Transparency：启用可以避免边缘上的过滤瑕疵<span class="token number">2</span>.Normal map-法线贴图格式：法线贴图说明：就是在原物体的凹凸表面的每个点上均作法线法线就是垂直于某个点的切线的方向向量Create From Grayscale：启用此属性可以从灰度高度贴图创建法线贴图Bumpiness：控制凹凸程度，值越大凹凸感越强Filtering：如何计算凹凸值Smooth：使用标准算法生成法线贴图Sharp：生成比标准模式更锐利的法线贴图<span class="token number">3</span>.Editor GUI and Legacy GUI：一般在编辑器中或者GUI上使用的纹理<span class="token number">4</span>.Sprite（2D and UI）：2D游戏或者UGUI中使用的格式Sprite Mode：图像中提取精灵图形的方式Single：按原样使用精灵图像Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片Polygon：网格精灵模式Pixels Per Unit：世界空间中的一个距离单位对应多少像素MeshType：网格类型；只有Single和Multiple模式才支持Full Rect：创建四边形，将精灵显示在四边形上Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状；任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是；Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小Pivot：精灵图片的轴心点，Single模式才有此选项，对应九宫格布局的九个点，还可以自定义Generate Physics Shape：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状，只有Single 和Multiple模式才可使用Sprite Editor：编辑Sprite，需要安装2D Sprite包，之后单独讲解<span class="token number">5</span>.Cursor：自定义光标<span class="token number">6</span>.Cookie：光源剪影格式Light Type：应用的光源类型，一般点光源的剪影需要设置为立方体纹理，方向光和聚光灯的剪影设置为2D纹理；Spotlight：聚光灯类型，需要边缘纯黑色纹理Directional：方向光，平铺纹理Point：点光源，需要设置为立方体形状<span class="token number">7</span>.Lightmap：光照贴图格式<span class="token number">8</span>.Single Channel：纹理只需要单通道的格式Channel：希望将纹理处理为Alpha还是Red通道Alpha：使用Alpha通道，不允许进行压缩Red：使用红色通道<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图一：线性和伽马颜色空间说明<br><img src="https://s4.ax1x.com/2022/01/28/7x84ij.png" alt="线性和伽马颜色空间说明"></p><h3 id="纹理形状（Texture-Shape）"><a href="#纹理形状（Texture-Shape）" class="headerlink" title="纹理形状（Texture Shape）"></a>纹理形状（Texture Shape）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.2D：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上<span class="token punctuation">;</span><span class="token number">2</span>.Cube：立方体贴图，主要用于天空盒和反射探针Mapping：如何将纹理投影到游戏对象上Auto：根据纹理信息创建布局<span class="token number">6</span> Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像Latitude-Longitude Layout：将纹理映射到2D维度/经度Mirrored Ball：将纹理映射到类似球体的立方体贴图上Convolution Type：纹理的过滤类型None：无过滤Specular：将立方体作为反射探针Diffuse：将纹理进行过滤表示辐照度，可作为光照探针Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理高级设置"><a href="#纹理高级设置" class="headerlink" title="纹理高级设置"></a>纹理高级设置</h3><p>  高级设置主要是纹理的一些尺寸规则、读写规则、以及MipMap相关设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Non-Power of <span class="token number">2</span>：如果纹理尺寸非2的幂如何处理<span class="token punctuation">(</span>为什么纹理要设置为2的N次方：因为图形学规则，纹理必须是2的幂尺寸<span class="token punctuation">)</span>None：纹理尺寸大小保持不变To nearest：将纹理缩放到最接近2的幂的大小（注意：PVRTC格式要求纹理为正方形）To larger：将纹理缩放到最大尺寸大小值的2的幂的大小To smaller：将纹理缩放到最小尺寸大小值的2的幂的大小<span class="token number">2</span>.Read/Write Enabled：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启）<span class="token number">3</span>.Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap<span class="token number">4</span>.Generate Mip Maps：允许生成MipMap<span class="token punctuation">(</span>开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片,在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率<span class="token punctuation">)</span><span class="token punctuation">;</span>Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘Mip Map Filtering：优化图像质量的过滤方法Box：随着尺寸减小，级别更加平滑Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率Alpha Cutoff Value：覆盖率参考值Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理平铺拉伸设置"><a href="#纹理平铺拉伸设置" class="headerlink" title="纹理平铺拉伸设置"></a>纹理平铺拉伸设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Wrap Mode：平铺纹理时的方式Repeat：在区块中重复纹理Clamp：拉伸纹理的边缘Mirror：在每个整数边界上镜像纹理以创建重复图案Mirror Once：镜像纹理一次，然后将拉伸边缘纹理Per-axis：单独控制如何在U轴和V轴上包裹纹理Filter Mode：纹理在通过3D变化拉伸时如何进行过度Point：纹理在靠近时变为块状Bilinear：纹理在靠近时变得模糊Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="纹理平台打包设置（非常重要）"><a href="#纹理平台打包设置（非常重要）" class="headerlink" title="纹理平台打包设置（非常重要）"></a>纹理平台打包设置（非常重要）</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Max Size：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内<span class="token number">2</span>.Resize Algorithm：当纹理尺寸大于指定的Max Size时，使用的缩小算法Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多Format：纹理格式（各平台支持的格式有所不同，如果选择Automatic，会根据平台使用默认设置）都支持的格式:下图一移动端和网页端特有格式：下图二不同平台单独进行设置：IOS：选择默认的纹理压缩设置 <span class="token punctuation">(</span>PVRTC<span class="token punctuation">)</span> 可获得更大的兼容性。如果您的应用程序不包含 OpenGL ES <span class="token number">2</span> 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。Andorid：推荐如下图三由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包；构建一个以 OpenGL ES <span class="token number">3</span> 为目标的 APK，访问 Android 的 Player Settings，菜单：Edit <span class="token operator">&gt;</span> Project Settings <span class="token operator">&gt;</span>Player Settings，然后选择 Android 类别），向下滚动到 Graphics APIs 部分，确保 OpenGL ES <span class="token number">2</span> 不在列表中，构建 APK，（菜单：File <span class="token operator">&gt;</span> Build Settings，然后单击 Build）；构建一个以 OpenGL ES <span class="token number">2</span> 为目标的单独 APK，访问 Android Player Settings，向下滚动到 Graphics APIs 部分，在列表中添加 OpenGL ES <span class="token number">2</span>，并删除 OpenGL ES <span class="token number">3</span> 和 Vulkan，构建 APK。<span class="token number">3</span>.Compression：选择纹理的压缩类型，帮助Unity正确选择压缩格式，会根据平台和压缩格式的可用性进行压缩；None：不压缩纹理Low Quality：以低质量格式压缩纹理Normal Quality：以标准格式压缩纹理High Quality：以高质量格式压缩纹理<span class="token number">4</span>.Use Crunch Compression：启用后，使用Crunch压缩，Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快；Compressor Quality:压缩质量条，质量越高意味着纹理越大，压缩事件越长。<span class="token number">5</span>.Split Alpha Channel：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。<span class="token number">6</span>.Override ETC2 fallback：不支持ETC2压缩的设备上，使用的格式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图一：都支持的格式<br><img src="https://s4.ax1x.com/2022/01/28/7xag9e.png" alt="都支持的格式"><br>图二：移动端和网页端特有格式<br><img src="https://s4.ax1x.com/2022/01/28/7xaoAf.png" alt="移动端和网页端特有格式"><br>图三：移动端和网页端特有格式<br><img src="https://s4.ax1x.com/2022/01/28/7xdi34.png" alt="移动端和网页端特有格式"></p><h2 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h2><h3 id="Sprite-Editor"><a href="#Sprite-Editor" class="headerlink" title="Sprite Editor"></a>Sprite Editor</h3><p>1.Single图片编辑：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右下角设置窗口：Name：名字Position：在图片中的偏移位置和宽高Border：边框，用于设置九宫格的4条边Pivot：轴心（中心）点位置Pivot Unit Mode：轴心点单位模式Normalized：标准化模式，0~1Pixels：像素模式Custom Pivot：自定义轴心点（OutLine）自定义边缘线和<span class="token punctuation">(</span>Physics<span class="token punctuation">)</span>自定义物理形状：Snap：将控制点贴近在最近的像素Outline Tolerance：轮廓点的复杂性和准确性，0~1值越大轮廓点越多，越准确Generate：生成网格轮廓        //1.Sprite Editor        //  基础图片设置（右下角窗口）        //  主要用于设置单张图片的基础属性        //2.Custom Outline（决定渲染区域）        //  自定义边缘线设置，可以自定义精灵网格的轮廓形状        //  默认情况下不修改都是在矩形网格上渲染,边缘外部透明区域会被渲染，浪费性能        //  使用自定义轮廓，可以调小透明区域，提高性能        //3.Custom Physics Shape（决定碰撞判断区域）        //  自定义精灵图片的物理形状，主要用于设置需要物理碰撞判断的2D图形        //  它决定了之后产生碰撞检测的区域        //4.Secondary Textures<span class="token punctuation">(</span>为图片添加特殊效果<span class="token punctuation">)</span>        //  次要纹理设置，可以将其它纹理和该精灵图片关联        //  着色器可以得到这些辅助纹理然后用于做一些效果处理        //  让精灵应用其它效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.Multiple图集元素分割：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">自动分割<span class="token punctuation">(</span>Automatic<span class="token punctuation">)</span>：Pivot：单张图片轴心点位置Custom Pivot：自定义轴心点Method：如何处理现有对象Delete Existing：替换掉已经选择的任何矩形Smart：尝试创建新矩形同时保留或调整现有矩形Safe：添加新矩形而不更改任何已经存在的矩形按单元格大小分割<span class="token punctuation">(</span>Grid By Cell Size<span class="token punctuation">)</span>：Pixel Size：单元格宽高Offset：偏移位置Padding：和边缘的偏移位置Keep Empty Rects：是否保留空矩形按单元格大小分割<span class="token punctuation">(</span>Grid By Cell Count<span class="token punctuation">)</span>增加参数Column <span class="token operator">&amp;</span> Row：行列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.Polygon多边形编辑：</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/SpriteEditor.html">Sprite Editor - Unity 手册 (unity3d.com)</a></p><h3 id="Sprite-Renderer"><a href="#Sprite-Renderer" class="headerlink" title="Sprite Renderer"></a>Sprite Renderer</h3><p>  所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的。</p><p>参数讲解:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Sprite：渲染的精灵图片<span class="token number">2</span>.Color：定义着色，一般没有特殊需求不会修改<span class="token number">3</span>.Filp：水平或竖直翻转精灵图片<span class="token number">4</span>.Draw Mode：绘制模式，当尺寸变化时的缩放方式Simple：简单模式，缩放时整个图像一起缩放Sliced：切片模式，9宫格切片模式，十字区域缩放，4个角不变化,一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect）Tiled：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect）Continuous：当尺寸变化时，中间部分将均匀平铺Adaptive：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺<span class="token number">5</span>.Mask Interaction：与精灵遮罩交互时的方式None：不与场景中任何精灵遮罩交互Visible inside Mask：精灵遮罩覆盖的地方可见，而遮罩外部不可见Visible Outside Mask：精灵遮罩外部的地方可见，而遮罩覆盖处不可见<span class="token number">6</span>.Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改<span class="token number">7</span>.Material：材质，可以使用一些自定义材质来显示一些特殊效果,一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse<span class="token number">8</span>.Additional Settings：高级设置Sorting Layer：排序层选择Order <span class="token keyword">in</span> Layer：层级序列号，数值越大约会显示在前面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteRenderer.html">Sprite Renderer - Unity 手册 (unity3d.com)</a></p><p>API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 代码设置        GameObject obj = new GameObject();        SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;();        //动态的改变图片        sr.sprite = Resources.Load&lt;Sprite&gt;("dead1");        //动态的加载 图集中的图        Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;("RobotBoyIdleSprite");        sr.sprite = sprs[10];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/SpriteRenderer.html">UnityEngine.SpriteRenderer - Unity 脚本 API (unity3d.com)</a></p><h3 id="Sprite-Creator"><a href="#Sprite-Creator" class="headerlink" title="Sprite Creator"></a>Sprite Creator</h3><p>  我们可以利用Sprite Editor的多边形工具创造出各种多边形,Unity也为我们提供了现成的一些多边形,它的主要作用是2D游戏的替代资源,在等待美术出资源时我们可以用他们作为替代品,有点类似Unity提供的自带几何体(在Project窗口右键创建各种形状的Sprite精灵图片).</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/SpriteCreator.html">Sprite Creator - Unity 手册 (unity3d.com)</a></p><h3 id="Sprite-Mask"><a href="#Sprite-Mask" class="headerlink" title="Sprite Mask"></a>Sprite Mask</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Sprite：遮罩图片<span class="token punctuation">;</span><span class="token number">2</span>.Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）<span class="token punctuation">;</span><span class="token number">3</span>.Custom Range：自定义遮罩范围,开启后可以设置遮罩的范围，按照排序层来划分<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/SpriteMask.html">UnityEngine.SpriteMask - Unity 脚本 API (unity3d.com)</a></p><h3 id="Sorting-Group"><a href="#Sorting-Group" class="headerlink" title="Sorting Group"></a>Sorting Group</h3><p>  顾名思义，SortingGroup是排序分组的意思,它的主要作用就是对多个精灵图片进行分组排序,Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样,主要作用是对于需要分层的2D游戏用于整体排序。</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SortingGroup.html">排序组 - Unity 手册 (unity3d.com)</a></p><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Rendering.SortingGroup.html">Rendering.SortingGroup - Unity 脚本 API (unity3d.com)</a></p><h3 id="Sprite-Atlas精灵图集制作"><a href="#Sprite-Atlas精灵图集制作" class="headerlink" title="Sprite Atlas精灵图集制作"></a>Sprite Atlas精灵图集制作</h3><p>  在工程设置面板中打开功能:Edit——&gt;Project Setting——&gt;Editor（Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)）；<br>Disabled：默认设置，不会打包图集；<br>Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包；<br>Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集；</p><p>1.打图集面板参数相关</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Type：图集类型Master：主图集Include <span class="token keyword">in</span> Build：选中可以在当前构建中包含图集Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度Padding：图集中各图片的间隔像素Variant：变体类型的图集Master Atlas：关联的主图集（图集类型必须是Master）Include <span class="token keyword">in</span> Build：选中可以在当前构建中包含图集Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果<span class="token punctuation">(</span>变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include <span class="token keyword">in</span> build选项，而主图集禁用此选项即可<span class="token punctuation">)</span><span class="token number">2</span>.Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它<span class="token number">3</span>.Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启<span class="token number">4</span>.SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。<span class="token number">5</span>.Filter Mode：纹理在3D变化拉伸时如何进行过滤Point：纹理靠近时变为块状Bilinear：纹理靠近时变得模糊Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊<span class="token number">6</span>.Objects <span class="token keyword">for</span> Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片<span class="token number">7</span>.Default:Max Texture Size：纹理的最大尺寸，像素为单位Format：指定纹理的内部表示，在不同平台上会有不同的参数Compression：纹理压缩类型<span class="token punctuation">(</span>质量越高占用内存越多，不压缩质量最好<span class="token punctuation">)</span>不压缩、低质量、普通质量、高质量；Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快Compressor Quality：压缩质量，质量越高纹理越大，耗时越长<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteAtlas.html">精灵图集 - Unity 手册 (unity3d.com)</a></p><p>2.API使用</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 代码控制        GameObject obj = new GameObject();        SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;();        //加载图集资源        SpriteAtlas spriteAtlas = Resources.Load&lt;SpriteAtlas&gt;("MyAtlas");        //加载图集资源中的某一张小图        sr.sprite = spriteAtlas.GetSprite("dead1");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/U2D.SpriteAtlas.html">U2D.SpriteAtlas - Unity 脚本 API (unity3d.com)</a></p><h2 id="2D物理系统"><a href="#2D物理系统" class="headerlink" title="2D物理系统"></a>2D物理系统</h2><h3 id="刚体"><a href="#刚体" class="headerlink" title="刚体"></a>刚体</h3><p>1.刚体类型参数说明:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Dynamic：动态类型（受重力和力的影响移动和旋转）Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质，如果不设置，将使用在Physics 2D窗口中设置的默认材质物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项；Use Auto Mass：是否使用自动质量Mass：质量Linear Dray：影响位置移动的阻力系数Angular Drag：影响旋转移动的阻力系数Gravity Scale：受重力影响的程度Collision Detection：碰撞检测算法Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况Sleeping Mode：对象处于静止状态时进入睡眠模式Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大Start Awake：最初处于唤醒状态Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒Interpolate：物理更新间隔之间的插值运算None：不应用移动平滑Interpolate：根据前一帧进行平滑处理Extrapolate：根据后一帧位置进行平滑处理Constraints：约束限制，可以让某一个轴不受力影响位移或者旋转<span class="token number">2</span>.Kinematic：运动学类型，不受力的影响，只能通过代码让其动起来，能和Dynamic 2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数，因此它没有了质量莫摩擦系数等属性，因此它的性能能消耗较低，主要会通过代码来处理其移动旋转；Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞，如果Use FullKinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞；Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它，如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞<span class="token number">3</span>.Static：静态类型完全不动的需要检测碰撞的对象，相当于是无限质量不可移动的对象，它的性能消耗最小，它只能和Dynamic 2D刚体碰撞（和只加碰撞体的区别），和它类似的有只加碰撞器而不加刚体的物体，它们会和刚体物体产生碰撞，但是自己不会动；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Rigidbody2D.html">2D 刚体 - Unity 手册 (unity3d.com)</a></p><p>2.刚体API说明:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 刚体API(参考刚体3D)        //加力        Rigidbody2D rigid = this.GetComponent&lt;Rigidbody2D&gt;();        rigid.AddForce(new Vector2(0, 100));        //速度        rigid.velocity = new Vector2(1, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Rigidbody2D.html">UnityEngine.Rigidbody2D - Unity 脚本 API (unity3d.com)</a></p><h3 id="碰撞体"><a href="#碰撞体" class="headerlink" title="碰撞体"></a>碰撞体</h3><p>1.碰撞体参数相关:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.圆形碰撞器（Circle）:Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性Is Trigger：是否是触发器Used By Effector：是否被附加的2D效应器使用Offset：圆心偏移位置Radius：圆形的半径<span class="token number">2</span>.盒状碰撞器<span class="token punctuation">(</span>Box<span class="token punctuation">)</span>:`Used by Composite：如果勾选，则该碰撞器将附加到2D复合碰撞器使用（勾选后一些属性只能在复合碰撞器中配置）Auto Tiling：如果渲染器组件的Draw Mode设置为Tiled模式，勾选该选项，当改变精灵大小时将自动更新碰撞器尺寸；Size：矩形的宽高Edge Radius：使四个顶点为圆角<span class="token number">3</span>.多边形碰撞器<span class="token punctuation">(</span>Polygon<span class="token punctuation">)</span>Points：多边形顶点虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了，都通过Edit Collider编辑，或者让Unity自动识别创建<span class="token number">4</span>.边界碰撞器<span class="token punctuation">(</span>Edge地形<span class="token punctuation">)</span>：边界碰撞器的编辑主要还是通过Edit Collider一般不会手动去通过数值加点<span class="token number">5</span>.<span class="token number">5</span>.胶囊碰撞器<span class="token punctuation">(</span>Capsule<span class="token punctuation">)</span>Size：胶囊的宽高Direction：是竖直胶囊还是水平胶囊<span class="token number">6</span>.复合碰撞器<span class="token punctuation">(</span>Composite必须配合刚体使用<span class="token punctuation">)</span>Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型Outlines：空心轮廓，类似边界碰撞器Polygons：实心多边形，类似多边形碰撞器Generation Type：生成类型，复合碰撞器在何时生成新几何体Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/Collider2D.html">2D 碰撞体 - Unity 手册 (unity3d.com)</a></p><p>2.碰撞器API：碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 碰撞检测函数    private void OnCollisionEnter2D(Collision2D collision)    private void OnCollisionExit2D(Collision2D collision)    private void OnCollisionStay2D(Collision2D collision)    private void OnTriggerEnter2D(Collider2D collision)    private void OnTriggerExit2D(Collider2D collision)    private void OnTriggerStay2D(Collider2D collision)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h3><p>物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质<br>物理材质参数相关：<br>    Friction：摩擦系数，为0表示没有摩擦力<br>    Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹）</p><h3 id="恒定力（了解即可）"><a href="#恒定力（了解即可）" class="headerlink" title="恒定力（了解即可）"></a>恒定力（了解即可）</h3><p>恒定力（Constant Force）参数说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Force：物理更新时施加于2D刚体上的线性力Relative Force：物理更新时施加的线性力（相对刚体对象坐标系）Torque：物理更新时施加于2D刚体的扭矩力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="效应器-Effector"><a href="#效应器-Effector" class="headerlink" title="效应器(Effector)"></a>效应器(Effector)</h3><p>效应器参数相关:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.区域效应器（Area）：在一个区域内让游戏对象受到力和扭矩力的作用<span class="token punctuation">(</span>作浮力和电梯传送带<span class="token punctuation">)</span>Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度Force Angle：施加力的角度Force Magnitude：施加力的大小Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化ForceTarget：效应器在目标对象上施加力的作用点Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转）Rigidbody：以刚体的当前质心（不会产生扭矩力）Drag：阻力Angular Drag：扭矩阻力<span class="token number">2</span>.浮力效应器（Buoyancy）：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮，密度和流体相同的碰撞体会浮在流体中Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移Linear Drag：影响对象在水中移动的阻力系数Angular Drag：影响对象在水中旋转的阻力系数Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小Flow Variation：随机改变流体力的值<span class="token number">3</span>.点效应器：模拟磁铁 吸引或者排斥的效果Force Magnitude：施加力的大小Force Variation：施加力的大小变化Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放Force Source：力源来自哪个位置，从该点计算距离。Collider：碰撞器的位置Rigidbody：刚体的位置Force Target：作用力目标位置，用改点计算位置Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力Rigidbody：刚体的位置，不会产生扭矩力Force Mode：计算力的模式Constant：忽略源和目标之间相隔的距离Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力<span class="token number">4</span>.平台效应器（Platform）：2D游戏当中的平台或可往上跳跃的墙壁Rotational Offset：旋转偏移量，控制平台角度偏移Use One Way：是否使用单向碰撞行为Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞Use Side Friction：是否应该在平台两侧使用摩擦Use Side Bounce：是否应该在平台两侧使用弹性Side Arc：用于定义左右两侧平台的响应弧度<span class="token number">5</span>.表面效应器（Surface）：模拟传送带Speed：表面保持的速度Speed Variation：速度的随机增加值Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转Use Friction：是否使用摩擦力Use Bounce：是否使用弹力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/Effectors2D.html">2D 效应器 - Unity 手册 (unity3d.com)</a></p><h2 id="SpriteShape"><a href="#SpriteShape" class="headerlink" title="SpriteShape"></a>SpriteShape</h2><p>  SpriteShape是精灵形状的意思（在Package Manager中导入相关工具），它主要是方便我们以节约美术资源为前提，制作2D游戏场景地形或者背景的。<br>类型：开放不封闭的图形、封闭的图形；</p><h3 id="Sprite-Shape-Profile精灵形状概述文件"><a href="#Sprite-Shape-Profile精灵形状概述文件" class="headerlink" title="Sprite Shape Profile精灵形状概述文件"></a>Sprite Shape Profile精灵形状概述文件</h3><p>Sprite Shape Profile精灵形状概述文件配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式）Offset：纹理偏移量Angle Ranges：角度范围（这里的设置主要用于封闭图形在不同角度范围内使用的图片不同，可以达到一个封闭效果）Start：起始角度End：结束角度Order：Sprite相交时的优先级，优先级高的显示在前面Sprites：指定角度范围内的精灵列表，在该角度范围内，可以选择使用的图片资源Corners：指定角显示的精灵图片，主要用于封闭图形，外部四个角用的图片，内部四个角用的图片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sprite-Shape-Renderer和Sprite-Shape-Controller精灵形状渲染器和控制器"><a href="#Sprite-Shape-Renderer和Sprite-Shape-Controller精灵形状渲染器和控制器" class="headerlink" title="Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器"></a>Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器</h3><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-SpriteShapeRenderer.html">Sprite Shape Renderer - Unity 手册 (unity3d.com)</a></p><p>参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Sprite Shape Renderer精灵形状渲染器：该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息Color：颜色Mask Interaction：遮罩相互作用规则设置Fill Material和Edge Material：填充材质和边缘材质Sorting Layer和Order <span class="token keyword">in</span> Layer：排序相关<span class="token number">2</span>.Sprite Shape Controller精灵形状控制器：Profile：使用的精灵形状概述文件Detail：精灵形状的质量（高中低三种质量）Is Open Ended：是否是开放的，不封闭的Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸，开启后只有宽度够才会平铺，如果宽度不够会拉伸，不开启始终平铺，但是可能会出现裁剪效果，一般根据你的实际效果进行选择；Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量Enable Tangents：是否启用切线计算功能（如果你的着色器中需要切线信息参与计算，则勾选）Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小Worldspace UV：根据世界控件的UV填充纹理启用编辑状态后：Tangent Mode ：切线模式（从左至右依次是）顶点模式-点两侧不构成曲线切线模式-点两侧构成曲线，并且可以控制切线弧度左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度Position：选中点的局部坐标位置Height：控制点左右两侧精灵图片的高度Corner：是否使用角度图片Disabled：不使用角度图片Automatic：自动Sprite Variant：选择使用的精灵图片Snapping：是否开启捕捉设置控制点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Tilemap-过后再来学"><a href="#Tilemap-过后再来学" class="headerlink" title="Tilemap(过后再来学)"></a>Tilemap(过后再来学)</h2><h1 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a>动画基础</h1><h2 id="Animation动画窗口"><a href="#Animation动画窗口" class="headerlink" title="Animation动画窗口"></a>Animation动画窗口</h2><p>面板左侧（说明）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">顶部从左至右：<span class="token number">1</span>.预览模式（开关）<span class="token number">2</span>.录制模式（开关）打开后预览模式默认开启<span class="token number">3</span>.回到动画开头<span class="token number">4</span>.上一关键帧（快捷键：键盘逗号）<span class="token number">5</span>.播放动画（快捷键：键盘Alt+逗号）<span class="token number">6</span>.下一关键帧（快捷键：键盘句号）<span class="token number">7</span>.回到动画结尾（快捷键：键盘Alt+句号）<span class="token number">8</span>.当前处于第几帧底部Dopesheet：关键帧模式底部Curves：曲线模式中部从左至右：按选择筛选添加关键帧添加事件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>面板左侧（操作）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">多出一个可以选择当前动画的下拉列表：可以在这里创建新动画和切换动画多出一个可以添加变化属性的按钮：在这里你可以任意添加你想要在动画中变化的脚本变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>面板右侧（说明）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">动画时间轴面板：当编辑动画时，会在该面板上编辑关键帧等信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>右侧面板（操控）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">时间轴可以拖动（注意）：时间轴上的单位为n秒n帧，一格代表一帧（并不是秒）选择关键帧右键：Add Key：添加关键帧Delete Key：删除关键帧Clamped Auto：切线模式，自动设置切线Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画Free Smooth：自由设置切线Flat：切线设置为水平Broken：单独控制左右曲线切线Free：自由设置Linear：直线Constant：常量切换Weighted：权重切换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/animeditor-UsingAnimationEditor.html">使用 Animation 视图 - Unity 手册 (unity3d.com)</a></p><h2 id="Animation老动画组件"><a href="#Animation老动画组件" class="headerlink" title="Animation老动画组件"></a>Animation老动画组件</h2><p>  在创建动画之前为对象添加Animation组件之后再制作动画，这时制作出的动画和之前的动画格式是有区别的。<br>Animation组件参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Animation组件：默认播放的动画Animations：该动画组件可以控制的所有动画Play AutoMatically：是否一开始就自动播放默认动画Animate Physics：动画是否与物理交互Culling Type：决定什么时候不播放动画Always Animate：始终播放Based On Renderers：基于默认动画姿势剔除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老动画Animation文件参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Default：读取设置得更高的默认重复模式Once：播放一次就停止Loop：从头到尾不停循环播放PingPong：从头到尾从尾到头不停播放ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>老Animation组件API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 代码控制播放        //1.播放动画        animation.Play("1");        //2.淡入播放,自动产生过渡效果        //当你要播放的动画的开始状态 和当前的状态 不一样时         //就会产生过渡效果        animation.CrossFade("3");        //3.前一个播完再播放下一个        animation.PlayQueued("2");        animation.CrossFadeQueued("2");                //4.停止播放所有动画        animation.Stop();        //5.是否在播放某个动画        if( animation.IsPlaying("1") )        //6.播放模式设置        animation.wrapMode = WrapMode.Loop;        //7.其它（了解即可，新动画系统中会详细讲解）        //层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果）        //设置层级        animation["1"].layer = 1;        //设置权重        animation["1"].weight = 1;        //混合模式 叠加还是混合        animation["1"].blendMode = AnimationBlendMode.Additive;        //设置混组相关骨骼信息        animation[""].AddMixingTransform();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Animation.html">UnityEngine.Animation - Unity 脚本 API (unity3d.com)</a></p><h2 id="Animator动画控制器面板"><a href="#Animator动画控制器面板" class="headerlink" title="Animator动画控制器面板"></a>Animator动画控制器面板</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.左侧面板Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的Parameters：参数页签，为动画状态机添加控制状态切换的参数眼睛图标：显隐左侧面板<span class="token number">2</span>.右侧面板：网格化布局区域（主要用于编辑状态之前的切换关系）；1.窗口中的每一个矩形表示一个状态；2.窗口中的每一个箭头表示一个切换条件；矩形说明：默认三大矩形：绿色Entry矩形：进入状态机流程红色Exit矩形：退出状态机流程Any State：任意状态，代表状态机中的任意状态人为添加矩形：橙色矩形：一开始的默认状态动画，和Entry相连，表示一开始播放的动画灰色矩形：自己添加的某一种动作状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AnimatorController.html">Animator Controller - Unity 手册 (unity3d.com)</a></p><h2 id="Animator新动画组件"><a href="#Animator新动画组件" class="headerlink" title="Animator新动画组件"></a>Animator新动画组件</h2><p>Animator组件参数相关：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Controller：对应的动画控制器（状态机）Avatar：对应的替身配置信息（之后讲解3D模型时详细讲解）Apply Root Motion：是否启用动画位移更新UpdateMode：更新模式（一般不修改它）:Normal：正常更新Animate Physics：物理更新Unscaled Time：不受时间缩放影响；Culling Mode：裁剪剔除模式：Always Animate：始终播放动画，即使在屏幕外也不剔除；Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入；Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新动画文件(.ani)界面参数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Loop Time：是否是循环动画（在动画结尾时重新开始）Loop Pose：无缝循环运动Cycle Offset：循环动画在其他时间开始时的周期偏移<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Animator组件API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 Animator中的API        //我们用代码控制状态机切换主要使用的就是Animator提供给我们的API        //我们知道一共有四种切换条件 int float bool trigger        //所以对应的API也是和这四种类型有关系的        animator = this.GetComponent&lt;Animator&gt;();        //1.通过状态机条件切换动画        animator.SetFloat("条件名", 1.2f);        animator.SetInteger("条件名", 5);        animator.SetBool("条件名", true);        animator.SetTrigger("条件名");        animator.GetFloat("条件名");        animator.GetInteger("条件名");        animator.GetBool("条件名");        //2.直接切换动画 除非特殊情况 不然一般不使用        animator.Play("状态名");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Animator.html">UnityEngine.Animator - Unity 脚本 API (unity3d.com)</a></p><h1 id="2D动画"><a href="#2D动画" class="headerlink" title="2D动画"></a>2D动画</h1><h2 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h2><h2 id="骨骼动画-2DAnimation"><a href="#骨骼动画-2DAnimation" class="headerlink" title="骨骼动画-2DAnimation"></a>骨骼动画-2DAnimation</h2><h2 id="骨骼动画-Spine"><a href="#骨骼动画-Spine" class="headerlink" title="骨骼动画-Spine"></a>骨骼动画-Spine</h2><h1 id="3D模型导入相关"><a href="#3D模型导入相关" class="headerlink" title="3D模型导入相关"></a>3D模型导入相关</h1><p>模型导出：<a href="https://docs.unity.cn/cn/2019.4/Manual/CreatingDCCAssets.html">在 Unity 外部创建资源（模型导出） - Unity 手册</a></p><h2 id="Model模型页签"><a href="#Model模型页签" class="headerlink" title="Model模型页签"></a>Model模型页签</h2><p>Model模型页签说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Scene场景相关设置：*Scale Factor：当模型中的比例不符合项目中的预期比例时，可以修改此值来改变该模型的全局比例Unity的物理系统希望游戏世界中的1米在导入模型文件中为1个单位；*Convert Units：启用可将模型文件中定义的模型比例转换为Unity的比例，不同的格式的比例如下，.fbx .max .jas <span class="token operator">=</span> <span class="token number">0.01</span>，.3ds <span class="token operator">=</span> <span class="token number">0.1</span>，.mb .ma .lxo .dxf .blend .dae <span class="token operator">=</span> <span class="token number">1</span>；Import BlendShapes：是否允许Unity随网格一起导入混合形状，当导入包含混合形状的网格时，将使用Skinned MeshRenderer组件（注意：1.导入混合形状发现需要在FBX文件中具有平滑组；2.如果想要导入具有法线的混合形状；把下方的Blend Shape Normals属性设置为Import，将使用FBX文件的发现，或者把下方的Blend Shape Normals属性设置为Calculate，Unity使用相同的逻辑来计算网格和混合形状上的法线）；Import Visibility：是否导入可见性，开启后可以从FBX文件中读取可见性属性。，比如模型动作里 有些动作是要隐藏模型形象的，开启后才会生效，一些3D建模软件对可见性属性不支持或者有限制，比如Maya和Blender就对可见性有限制，所以一般这个选项要根据你使用的建模软件决定（一般可以不勾选）；Import Cameras：是否导入摄像机；*Preserve Hierarchy：始终创建一个显示预制体根，通常在导入的时候，FBX会将模型中的空根节点进行优化去掉它，但是如果多个FBX文件中包含同一层级的空跟对象，可以勾选它来保留他们；主要作用是：比如有两个fbx文件，1包含骨骼和网格，2只包含骨骼动画。如果不启用它导入2，那么Unity将剥离根节点，会让层级不匹配让动画不能正常播放；Sort Hierarchy By Name：在层级窗口中根据名字排序子物体，如果不启用，会保留FBX文件中定义的层级顺序；<span class="token number">2</span>.Meshes网格相关设置：*Mesh Compression-网格压缩，设置压缩比级减小网格的文件大小，提高压缩比会降低网格的精度，调整该参数可以优化游戏包的大小：Off：不使用压缩Low：低压缩比Medium：中等压缩比High：高压缩比*Read/Write Enabled：是否开启读写网格信息，如果开启，Unity将网格数据传给GPU后，在CPU中还会保留可寻址内存，意味着我们可以通过代码访问网格数据进行处理，如果不开启，Unity将网格数据传个GPU后，会将CPU中的可寻址内存中网格数据删除，我们无法再得到网格数据，开启时，会增加内存占用，关闭时，可以节约运行时内存使用量（何时开启？；1.需要在代码中读取或写入网格数据；2.需要运行时合并网格；3.需要使用网格碰撞器时；4.需要运行时使用NavMesh构建组件来烘焙NavMesh时）；Optimize Mesh-确定三角形在网格中列出的顺序以提高GPU性能：Nothing：无优化Everything：对顶点以及多边形顶点索引进行重新排序Polygon Order：仅对多边形重新排序Vertex Order：仅对顶点重新排序*Generate Colliders：生成碰撞器，启用后会自动附加网格碰撞器的情况下导入你的网格，建议不移动的环境几何体可以开启它，但是需要移动的几何体建议不要开启它；<span class="token number">3</span>.Geometry几何体相关设置：*Keep Quads：保留四边形，启用后，Unity不会将4个顶点的多边形转为三角形，当使用曲面细分着色器时可能需要启用此选项，因为四边形的曲面周色漆比多边形的效率更高；*Weld Vertices：合并在空间中共享相同位置的顶点，前提是这些顶点总体上共享相同的属性（UV，法线，切线等等）（开启后相当于会通过减少网格的总数量来优化网格的顶点计数）；一般都开启，除非你想有意保留这些重复顶点，之后想通过代码去获取他们来进行处理；Index Format：网格索引缓冲区的大小（一般都选择16bits，Auto可以会默认选择16bits，只有在必要时使用32bit，16bits即通用又节约内存）；Legacy Blend Shape Normals：启用后会基于Smoothing Angle值来计算法线；Normals-定义如何计算法线：Import：从文件中导入法线，如果文件中不包含发现信息，将使用Calculate模式计算法线Calculate：根据Normals Mode、Smoothness Source和Smoothing Angle属性来计算发现None：不计算法线Blend Shape Normal：定义如何为混合形状计算法线，只有当Legacy Blend Shape Normals禁用时出现Normals Mode：计算法线的模式，只有当上方的Normals设置为Import和Calculate才会出现Unweighted Legacy：2017.1版本之前计算法线的方式，如果是在该版本之前导入的所有FBX模型，默认设置为该模式Unweighted：法线不加权重Area Weighted：法线按照图面面积加权重Angle Weighted：法线按照每个图面上的顶角加权重Area And Angle Weighted：法线按照每个图面上的图面面积和顶角加权重，这是默认选项Smoothness Source-如何确定平滑，哪些边应该平滑，哪些应该粗糙，只有当Legacy Blend Shape Normals 禁用时出现：Prefer Smoothing Groups：尽可能使用模型文件中的平滑组From Smoothing Groups：仅使用模型文件中的平滑组From Angle：使用Smoothing Angle值来确定哪些边应该是平滑的None：不拆分硬边的任何顶点Smoothing Angle：控制是否为硬边拆分顶点，通常，值越大，产生的顶点越少，仅当Normals设置为Calculate时才可用（注意：此设置仅用于非常光滑的或者非常复杂的模型，否则，最好在3D建模软件中手动平滑然后导入，始终建议建模的时候就做好，更加准确）；Tangents-定义如何导入或计算顶点切线，仅当Normals设置为Calculate或Import时，此属性才可用：Import：如果Normals设置为Import，则从FBX文件中导入顶点切线，如果网格没有切线，那么将无法使用法线贴图着色器Calculate Legacy：使用旧版算法计算切线Calculate Legacy With Split Tangents：使用旧版算法计算切线，并在UV图表上进行拆分。如果网格上的接缝碰坏了法线贴图光照，请使用此属性Calculate Mikktspace：使用米克特空间计算切线None：不导入顶点切线，网格没有切线，则无法使用法线贴图着色器Swap UVs：在网格中交换UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项Generate Lightmap UVs：为光照贴图创建第二个UV通道<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/FBXImporter-Model.html">Model 选项卡 - Unity 手册 (unity3d.com)</a></p><h2 id="Rig操纵骨骼页签"><a href="#Rig操纵骨骼页签" class="headerlink" title="Rig操纵骨骼页签"></a>Rig操纵骨骼页签</h2><p>Animation Type-动画类型说明:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.None-不存在动画:主要用于一些环境静态模型<span class="token number">2</span>.Humanoid-人形模型,一般情况下，有头和四肢（一个头两条腿两只手）为人形,人形模型需要使用Avatar化身系统,绑定人主要关节的映射关系:Avatar Definition：选择获取Avatar定义的位置No Avatar：没有化身系统信息Create From This Model：根据此模型创建Avatar化身信息Copy from Other Avatar：指向另一个模型上设置的Avatar化身信息Source：复制另一个具有相同骨架的Avatar化身信息以导入其动画剪辑,使用Copy From Other Avatar时才有Configure<span class="token punctuation">..</span>.：打开Avatar化身配置,使用Create From This Model时才有Skin Weights：设置影响单个顶点的最大骨骼数量Standard（4 Bones）：使用最多4个骨骼来产生影响。默认值，处于对性能考虑，建议使用此设Custom：设置自定义的最大骨骼数，选择后会出现下方的两个选项Max Bones/Vertex：定义每个顶点的最大估个数，值越大性能消耗越大Max Bone Weight：设置考虑骨骼权重的最低阈值，权重计算时将忽略小于此值的内容Optimize Game Objects：在Avatar化身系统和Animator动画组件中删除和存储所导入角色的游戏对象骨骼层级信息。如果启用会出现下方的Extra Transforms to Expose选项。角色将使用Unity动画系统的内部骨架，可以提高动画角色的性能Extra Transforms to Expose：要公开的骨骼层级，在下方打钩将公开该骨骼层级信息放大镜：通过名称搜索对应骨骼信息Toggle All：全选或者反选Collapse All：全部折叠Expand All：全部展开<span class="token number">3</span>.Generic-通用模型，非人形模型,不是标准的人形模型，可以是任意形状，可能有8只腿两个头等等,这种模型主要需要设置骨骼根节点:Root Node：选择用于此Avatar的根节点的骨骼（仅当选择Create From This Model才会出现）<span class="token number">4</span>.Legacy-旧版动画类型与Unity3.x及更早版本导入和使用动画一般不使用:Generation：动画导入方法Don't Import：不导入动画第2~4个选项：已禁用，勿使用Store <span class="token keyword">in</span> Root（New）：导入动画将其存储在模型的根节点中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Avatar设置说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Mapping设置-我们需要在这个页签对模型关节进行映射设置，因为人物动画无非就是改变这些关节的角度：部位设置：身体，头部，左右手，关节映射信息设置Mapping选项：Clear：清空映射AutoMap：自动映射Load：从文件中读取Save：保存映射信息Pose选项：Reset：重置姿势Sample Bind-Pose：绑定姿势示例Enforce T-Pose：强制T姿势<span class="token number">2</span>.Muscles<span class="token operator">&amp;</span>Settings设置：Muscle Group Preview-肌肉群预览：可以在这里预览在不同姿势的旋转变化，用来观察之前的关联映射关系是否合理，主要起到预览作用；Per-Muscle Settings-肌肉设置：，用于设置各骨骼在旋转时的范围限制，因为如果不设置限制，在一些极限角度时会非常奇怪，我们可以在这里单独设置限制范围；Additional Settings-高级设置：可以设置手脚的扭转和伸展值，一般不会修改他们，其中Translation DoF比较重要，如果启用，将启用人形角色的移动动画，如果禁用，Unity仅使用旋转对骨骼进行动画化，但是启用后，会提升性能消耗，因为动画需要执行额外步骤来重定向人形动画，除非动画包含角色某些骨骼的动画式移动才会启用，一般情况下禁用即可；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/FBXImporter-Rig.html">Rig 选项卡 - Unity 手册 (unity3d.com)</a></p><h2 id="Animation动画页签"><a href="#Animation动画页签" class="headerlink" title="Animation动画页签"></a>Animation动画页签</h2><p>1.如何导入外部创建的模型资源：<a href="https://docs.unity.cn/cn/2019.4/Manual/CreatingDCCAssets.html">在 Unity 外部创建资源 - Unity 手册</a></p><p>2.使用多个模型文件来导入动画：<a href="https://docs.unity.cn/cn/2019.4/Manual/Splittinganimations.html">提取动画剪辑 - Unity 手册</a></p><h3 id="动画基础信息设置"><a href="#动画基础信息设置" class="headerlink" title="动画基础信息设置"></a>动画基础信息设置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Import Constraints-从此资源导入约束：启用后，Unity会自动添加相应的约束组件将其关联到正确的游戏对象Import Animation-从此资源导入动画：如果禁用，下面的都没有，并且不会导入任何动画；Bake Animations：通过反向动力学（IK）或模拟创建的动画以便推进运动关键帧，仅用于Maya、3Dmax和Cinema4D文件Anim.Compression：导入动画时使用的压缩类型Off：禁用动画压缩，在导入时Unity不会减少关键帧数量，效果最好性能较低，文件较大，运行时内存占用也大。通常不建议使用Keyframe Reduction：减少冗余关键帧，仅适用于Generic通用动画类型Keyframe Reduction and Compression：减少关键帧并在文件中存储动画时压缩关键帧，会影响文件大小，但是内存大小和Keyframe Reduction相同，仅适用于Legacy旧版动画类型Optimal：让Unity决定如何压缩，仅适用Generic通用和Humanoid人形动画类型Rotation Error：设置旋转曲线压缩容错度（百分比），原始旋转值和减小值之间的最小角度Position Error：设置位置曲线压缩容错度（百分比）Scale Error：设置缩放曲线压缩容错度（百分比）（如果原始值和消减值之间的差小于原始值乘以容错百分比，会删除关键帧）这些内容仅在Keyframe Reduction或Optimal压缩时可用；Animated Custom Properties：导入你指定为自定义用户属性的任何FBX属性动画剪辑选择列表：在这里我们可以看到所有的动画剪辑可以通过+或-来新增剪辑或者删除所选的剪辑，在这里选择一个动画剪辑后，我们可以在下方编辑具体的相关属性信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动画剪辑属性基本设置"><a href="#动画剪辑属性基本设置" class="headerlink" title="动画剪辑属性基本设置"></a>动画剪辑属性基本设置</h3><p>动画剪辑属性:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.动画剪辑名称:可编辑修改<span class="token number">2</span>.时间轴:Start动画剪辑的开始帧,End动画剪辑的结束帧,我们可以在时间轴中定义每个动画剪辑的帧范围<span class="token punctuation">;</span><span class="token number">3</span>.动画重要信心设置:Loop Time：播放动画剪辑时是否循环播放，到结尾时重新开始Loop Pose：无缝循环运动Loop Match：循环匹配Cycle Offset：循环动画在其他时间开始时的周期偏移Root Transform Rotation：根位置的角度相关Bake Into Pose：将根旋转烘焙到骨骼移动，禁用此选项将存储为根运动Based Upon：根旋转的基础Original：保持源文件中的原始旋转Root Node Rotation：使用根节点的旋转（仅适用Generic通用动画类型）Body Orientation：保持上半身朝前（仅适用于Humanoid人形动画类型）Offset：根旋转偏移（单位：度）Root Transform Position（Y）：根垂直位置（Y轴方向）Bake Into Pose：将垂直根运动烘焙到骨骼移动。禁用此选项将会存储为根运动Based Upon（at Start）：垂直方向根位置的基础Original：保持源文件中的垂直位置Root Node Position：使用垂直根位置（仅适用Generic通用动画类型）Center Of Mass：保持质心与根位置对其（仅适用Humanoid人形动画类型）Feet（推荐）：保持双脚与根变换位置对齐（仅适用Humanoid人形动画类型）Offset：垂直根位置偏移Root Transform Position（XZ）：根水平位置（XZ平面）Bake Into Pose：将水平根运动烘焙到骨骼移动。禁用此选项将会存储为根运动Based Upon：水平根位置的基础Original：保持源文件中的水平位置Root Node Position：使用水平根位置（仅适用Generic通用动画类型）Center Of Mass：保持与根位置对其（仅适用Humanoid人形动画类型）Mirror：在此剪辑中进行左右镜像（仅Humanoid人形动画类型才显示）Additive Reference Pose：启用后可以设置附加动画层基础参考姿势的帧。在时间轴中可以看到蓝色标记，附加动画层：在动画控制器（状态机）中可以添加新的动画层：Pose Frame：当启用参考姿势帧时，该项就是选择的具体是哪一帧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="动画剪辑属性其它设置"><a href="#动画剪辑属性其它设置" class="headerlink" title="动画剪辑属性其它设置"></a>动画剪辑属性其它设置</h3><p>其它设置说明:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.Curves:曲线可以配合Animator作为参数，通过加入曲线值可以利用他标记重要的点,可以修改曲线的名字，名字就类似参数名,可以通过加减来添加或删除曲线信息<span class="token punctuation">;</span><span class="token punctuation">(</span>曲线中的值X轴代表标准化时（0~1）代表动画的开始和结尾<span class="token punctuation">;</span>Y轴的值可以根据需求自己设置也可以使用下方提供的预设曲线<span class="token punctuation">)</span><span class="token number">2</span>.Events动画事件<span class="token punctuation">(</span>不推荐延迟严重<span class="token punctuation">)</span>:类似之前我们学习的Animation窗口中的动画事件可以在这里为动画剪辑添加一个事件，当动画播放到事件处时会自动找对象脚本中的同名函数,当我们希望在动画某一时刻进行逻辑处理时非常常用,比如某一时刻进行伤害判断<span class="token number">3</span>.Mask动画遮罩:主要作用是当播放该动画时，可以指定哪一部分或者哪些骨骼排除在外不受动作影响,Humanoid（人形动画的快捷设置）,我们分别可以控制,头、左右臂、左右手、左右腿、根等,点击他们让他们变成红色，就代表做该动作时不影响该部位,Transform（明确指定哪些骨骼关节点不受影响）<span class="token number">4</span>.Motion:当导入的动画剪辑包含根运动时,我们可以在这里手动设置特定骨骼关节点作为我们的根运动节点,展开后看到的都是骨骼关节节点<span class="token number">5</span>.Inport Messages:当我们导入动画出现问题，看到黄色的警告符号时,你可以将 Generate Retargeting Quality Report 选中,Unity会帮我们生成更多的有关重定向问题的具体信息,我们便可以看到具体的一些问题<span class="token punctuation">(</span>只有看到警告动画不正确时才启用，可以帮助我们排查问题<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AnimationClip.html">Animation 选项卡 - Unity 手册 (unity3d.com)</a></p><h2 id="Materials材质纹理页签"><a href="#Materials材质纹理页签" class="headerlink" title="Materials材质纹理页签"></a>Materials材质纹理页签</h2><p>材质纹理页签说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Material Creation Mode-定义希望Unity如何为模型生成或导入材质：None：不使用此模型中嵌入的任何材质，改用Unity的默认漫反射材质Standard：导入时，Unity使用默认规则来生成材质Import via MaterialDescription（Experimental）：导入时，Unity使用FBX文件中嵌入的材质描述来生成材质；（与Standard相比，该方法结果更准确，并且支持更广泛的材质类型。）sRGB Albedo Colors：是否在伽马空间中使用反射率颜色，对于使用线性颜色控件的项目，禁用此选项；Location：定义如何访问材质和纹理Use Embedded Materials：将导入的材质保持在导入的资源中Use External Materials（Legacy）：将导入的材质提取为外部资源。旧版材质处理方式，适用于2017.1或更早的Unity版本创建的项目Extract Textures/Materials：当选择Use Embedded Materials后会出现的内容。这两个按钮可以提取导入的资源中嵌入的所有材质和纹理。Naming：定义材质的命名规则By Base Texture Name：使用导入材质的漫反射纹理名称来命名材质。如果未将漫反射纹理分配给材质，Unity将使用导入材质的名称From Model<span class="token string">'s Material：使用导入材质的名称来命名材质Model Name + Model'</span>s Material：使用模型文件的名称与导入材质的名称相结合来命名材质Search：定义在使用Naming选项定义的名称时查找现有材质的位置规则Local Materials Folder：在本地Materials材质子文件夹（模型文件所在的同一文件夹）中查找现有材质Recursive-Up：在所有父文件夹（一直向上追溯到Assets文件夹）中所有Materials子文件夹中查找现有材质Project-Wide：在所有Unity项目文件夹中查找现有材质重新映射的材质:如果找到了，Unity会自动关联,如果没有找到，我们可以手动进行关联<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/FBXImporter-Materials.html">Materials 选项卡 - Unity 手册 (unity3d.com)</a></p><h1 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h1><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AnimatorController.html">Animator Controller - Unity 手册 (unity3d.com)</a></p><h2 id="3D动画使用"><a href="#3D动画使用" class="headerlink" title="3D动画使用"></a>3D动画使用</h2><h3 id="状态参数"><a href="#状态参数" class="headerlink" title="状态参数"></a>状态参数</h3><p>状态参数说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Motion：分配给此状态的动画剪辑Speed：动画的默认速度Multiplier：控制速度的乘数，如果要使用需要勾选的Parameter选中配合的参数float类型Motion Time：运动的时间，如果要使用需要勾选的Parameter选中配合的参数float类型Mirror：是否为状态生成镜像，仅适用于人形动画，如果要配合参数使用选中旁边的Parameter关联参数，参数是bool类型Cycle Offset：循环偏移时间，如果要配合参数使用选中旁边的Parameter关联参数，参数是float类型Foot IK：是否遵循Foot IK，适用于人形人形动画Write Defaults：AnimatorStates 是否为其运动执行未动画化的属性写回默认值。Solo：仅播放该过渡Mute：禁用过渡Solo和Mute如果一起选择，Mute优先执行Add Behaviour：添加状态机行为脚本，之后会专门讲解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连线参数"><a href="#连线参数" class="headerlink" title="连线参数"></a>连线参数</h3><p>连线参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">改名框：可以在这里为动画过渡改名，如果不改，对应的名字就是，<span class="token string">"某一状态名"</span>-<span class="token operator">&gt;</span><span class="token string">"某一状态名"</span>；Has Exit Time：是否有退出时间，如果勾选，当切换动画时，动画一定是播放到下方的Exit Time（百分比）的时间时才过渡到下一个动画Exit Time：退出时间，当选择上方的Has Exit Time时，该值决定了过渡生效的确切时间。该值可以大于1，如果小于1，比如0.85，表示当动画播放到了85%的动画时，就会过渡。如果大于1，比如4.5，那么动画将循环4.5次后过渡到下一个动画Fixed Duration：选中后，下方的Trnaition Duration过渡持续时间将以秒为单位解读过渡时间，如果不选中，则以百分比解读过渡时间Transition Duration<span class="token punctuation">(</span>s/%<span class="token punctuation">)</span>：过渡持续时间，相当于从该状态切换到下一状态的过渡动画持续的时间，对应下方两个蓝色箭头包裹区域Transition Offset：过渡到目标状态的起始播放的时间偏移。如果是0则从目标状态开头开始播放，如果是0.5则从目标状态的一半开始播放，你可以理解为切入下一个状态的切入点；Interruption Source：该过渡中断的情况None：不在添加任何过渡Current State：将当前状态过渡排队Next State：使下一个状态的过渡进行排队Current State Then Next State：将当前状态的过渡和下一个状态的过渡都依次排队Next State Thne Current State：将下一状态的过渡和当前状态的过渡依次排队Ordered Interruption：当前过渡是否可在不考虑顺序的情况下被其它过渡中断选中时，找到有效过渡或当前过渡时，会中断不选中时，找到有效过渡，会中断Conditions：过渡条件（如果没有过渡条件，只会考虑Exit Time）AnyState和动作之间连线Can Transition To self：是否可以过渡到自己Preview <span class="token builtin class-name">source</span> state：预览各种过渡状态，可以查看从任意状态切换到当前状态的过渡效果；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画分层和遮罩"><a href="#动画分层和遮罩" class="headerlink" title="动画分层和遮罩"></a>动画分层和遮罩</h2><p>动画分层设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Weight：权重，当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例Mask：动画遮罩，该层动画全部都会受该遮罩的影响Blending：混合方式Override：覆盖方式，播放该层动画时忽略其他层信息Additive：叠加方式，会和其它层动画叠加播放Sync：是否同步其它层，主要用于直接从另一个层复制状态过来，在该层中进行修改，适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑（选择后会多一个Source Layer表示你要复制哪一层的状态）Timing：当选中Sync同步其它层时，该参数激活，选中，会采用折中方案调整同步层上的动画时长（基于权重计算），不选中，动画时长将使用原始层做为母版IK Pass：反向动力学，之后讲解IK的时候再讲解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画混合"><a href="#动画混合" class="headerlink" title="动画混合"></a>动画混合</h2><p>1.2D Simple Directional     2D简单定向模式  运动表示不同方向时使用 比如向前、后、左、右走；<br>2.2D Freeform Directional   2D自由形式定向模式   同上 运动表示不同方向时使用 但是可以在同一方向上有多个运动 比如向前跑和走；<br>3.2D Freeform Cartesian     2D自由形式笛卡尔坐标模式  运动不表示不同方向时使用 比如向前走不拐弯 向前跑不拐弯 向前走右转 向前跑右转；<br>4.Direct直接模式   自由控制每个节点权重，一般做表情动作等；<br>5.1D混合是用一个参数控制动画的混合，之所以叫1D是因为一个参数可以看做是1维线性的；</p><h2 id="动画IK控制"><a href="#动画IK控制" class="headerlink" title="动画IK控制"></a>动画IK控制</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 什么是IK？        //在骨骼动画中，构建骨骼的方法被称为正向动力学        //它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变        //用我们人体举例子        //当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子        //而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思        //它和正向动力学恰恰相反        //它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转        //用我们人体举例子        //当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动        //用父子骨骼理解的话就是子带动了父知识点二 如何进行IK控制        //1.在状态机的层级设置中 开启 IK 通道        //2.继承MonoBehavior的类中        //  Unity定义了一个IK回调函数:OnAnimatorIK        //  我们可以在该函数中调用Unity提供的IK相关API来控制IK        //3.Animator中的IK相关API        //头部IK相关        //weight:LookAt全局权重0~1        //bodyWeight:LookAt时身体的权重0~1        //headWeight:LookAt时头部的权重0~1        //eyesWeight:LookAt时眼镜的权重0~1        //clampWeight:0表示角色运动时不受限制，1表示角色完全固定无法执行LookAt，0.5表示只能够移动范围的一半        SetLookAtWeight     设置头部IK权重        SetLookAtPosition   设置头部IK看向位置        SetIKPositionWeight 设置IK位置权重        SetIKRotationWeight 设置IK旋转权重        SetIKPosition       设置IK对应的位置        SetIKRotation       设置IK对应的角度        AvatarIKGoal枚举    四肢末端IK枚举知识点三 关于OnAnimatorIK和OnAnimatorMove两个函数的理解        //我们可以简单理解这两个函数是两个和动画相关的特殊生命周期函数        //他们在Update之后LateUpdate之前调用        //他们会在每帧的状态机和动画处理完后调用        OnAnimatorIK在OnAnimatorMove之前调用        OnAnimatorIK中主要处理 IK运动相关逻辑        OnAnimatorMove主要处理 动画移动以修改根运动的回调逻辑        //他们存在的目的只是多了一个调用时机，当每帧的动画和状态机逻辑处理完后再调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动画目标匹配"><a href="#动画目标匹配" class="headerlink" title="动画目标匹配"></a>动画目标匹配</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 什么是动画目标匹配        //动画目标匹配主要指的是        //当游戏中角色要以某种动作移动，该动作播放完毕后，人物的手或者脚必须落在某一个地方        //比如：角色需要跳过踏脚石或者跳跃并抓住房梁        //那么这时我们就需要动作目标匹配来达到想要的效果       知识点二 如何实现动画目标匹配        //Unity中的Animator提供了对应的函数来完成该功能        //使用步骤是        //1.找到动作关键点位置信息（比如起跳点，落地点，简单理解就是真正可能产生位移的动画表现部分）        //2.将关键信息传入MatchTargetAPI中//参数一：目标位置        //参数二：目标角度        //参数三：匹配的骨骼位置        //参数四：位置角度权重        //参数五：开始位移动作的百分比        //参数六：结束位移动作的百分比        animator.MatchTarget(targetPos.position, targetPos.rotation, AvatarTarget.RightFoot, new MatchTargetWeightMask(Vector3.one, 1), 0.4f, 0.64f);知识点三 注意        //调用匹配动画的时机有一些限制        //1.必须保证动画已经切换到了目标动画上        //2.必须保证调用时动画并不是处于过度阶段而真正在播放目标动画        //如果发现匹配不正确，往往都是这两个原因造成的        //3.需要开启Apply Root Motion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="状态机行为脚本"><a href="#状态机行为脚本" class="headerlink" title="状态机行为脚本"></a>状态机行为脚本</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">识点一 状态机行为脚本是什么？        //状态机行为脚本时一类特殊的脚本,继承指定的基类        //它主要用于关联到状态机中的状态矩形上        //我们可以按照一定规则编写脚本        //当进入、退出、保持在某一个特定状态时我们可以进行一些逻辑处理        //简单解释就是为Animator Controller状态机窗口中的某一个状态添加一个脚本        //利用这个脚本我们可以做一些特殊功能        //比如        //1.进入或退出某一状态时播放声音        //2.仅在某些状态下检测一些逻辑，比如是否接触地面等等        //3.激活和控制某些状态相关的特效知识点二 如何使用状态机脚本        //1.新建一个脚本继承StateMachineBehaviour基类        //2.实现其中的特定方法进行状态行为监听        //  OnStateEnter    进入状态时，第一个Update中调用        //  OnStateExit     退出状态时，最后一个Update中调用        //  OnStateIK       OnAnimatorIK后调用        //  OnStateMove     OnAnimatorMove后调用        //  OnStateUpdate   除第一帧和最后一帧，每个Update上调用        //  OnStateMachineEnter     子状态机进入时调用，第一个Update中调用        //  OnStateMachineExit      子状态机退出时调用，最后一个Update中调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="角色控制器"><a href="#角色控制器" class="headerlink" title="角色控制器"></a>角色控制器</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一· 角色控制器的使用        //关键参数        //是否接触了地面        if ( cc.isGrounded )        //关键方法        //受重力作用的移动        cc.SimpleMove(Vector3.forward * 10 * Time.deltaTime);        //不受重力作用的移动        cc.Move(Vector3.forward * 10 * Time.deltaTime);    //当角色控制器想要判断和别的碰撞器产生碰撞时 使用该函数    private void OnControllerColliderHit(ControllerColliderHit hit)    {        print(hit.collider.gameObject.name);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/CharacterController.html">UnityEngine.CharacterController - Unity 脚本 API (unity3d.com)</a></p><h1 id="导航寻路"><a href="#导航寻路" class="headerlink" title="导航寻路"></a>导航寻路</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity基础</title>
      <link href="/posts/1538.html"/>
      <url>/posts/1538.html</url>
      
        <content type="html"><![CDATA[<h1 id="3D数学"><a href="#3D数学" class="headerlink" title="3D数学"></a>3D数学</h1><h2 id="数学计算Mathf公共类"><a href="#数学计算Mathf公共类" class="headerlink" title="数学计算Mathf公共类"></a>数学计算Mathf公共类</h2><p>Math：是C#中封装好的用于数学计算的工具)类) —— 位于System命名空间中；<br>Mathf：是Unity中封装好的用于数学计算的工具)结构体) —— 位于UnityEngine命名空间中，Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法，使用Mathf中的方法用于Unity游戏开发中的数学计算即可；</p><p>API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点三 Mathf中的常用方法——一般计算一次//1.π - PIprint(Mathf.PI);//2.取绝对值 - Absprint(Mathf.Abs(-10));print(Mathf.Abs(-20));print(Mathf.Abs(1));//3.向上取整 - CeilToIntfloat f = 1.3f;int i = (int)f;print(i);print(Mathf.CeilToInt(f));print(Mathf.CeilToInt(1.00001f));//4.向下取整 - FloorToIntprint(Mathf.FloorToInt(9.6f));//5.钳制函数 - Clampprint(Mathf.Clamp(10, 11, 20));print(Mathf.Clamp(21, 11, 20));print(Mathf.Clamp(15, 11, 20));//6.获取最大值 - Maxprint(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8));print(Mathf.Max(1, 2));//7.获取最小值 - Minprint(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));print(Mathf.Min(1.1f, 0.4f));//8.一个数的n次幂 - Powprint("一个数的n次方" + Mathf.Pow(4, 2));print("一个数的n次方" + Mathf.Pow(2, 3));//9.四舍五入 - RoundToIntprint("四舍五入" + Mathf.RoundToInt(1.3f));print("四舍五入" + Mathf.RoundToInt(1.5f));//10.返回一个数的平方根 - Sqrtprint("返回一个数的平方根" + Mathf.Sqrt(4));print("返回一个数的平方根" + Mathf.Sqrt(16));print("返回一个数的平方根" + Mathf.Sqrt(64));//11.判断一个数是否是2的n次方 - IsPowerOfTwoprint("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(4));print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(8));print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(3));print("判断一个数是否是2的n次方" + Mathf.IsPowerOfTwo(1));//12.判断正负数 - Signprint("判断正负数" + Mathf.Sign(0));print("判断正负数" + Mathf.Sign(10));print("判断正负数" + Mathf.Sign(-10));print("判断正负数" + Mathf.Sign(3));print("判断正负数" + Mathf.Sign(-2));知识点四 Mathf中的常用方法——一般不停计算//插值运算 - Lerp//Lerp函数公式result = Mathf.Lerp(start, end, t);//t为插值系数，取值范围为 0~1result = start + (end - start)*t//插值运算用法一//每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置start = Mathf.Lerp(start, 10, Time.deltaTime);//插值运算用法二//每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果time += Time.deltaTime;result = Mathf.Lerp(start, 10, time);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Mathf.html">UnityEngine.Mathf - Unity 脚本 API (unity3d.com)</a></p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>1.角度和弧度都是度量角的单位：<br>角度：1°<br>弧度：1 radian<br>圆一周的角度：360°<br>圆一周的弧度：2π radian</p><p>2.角度和弧度的转换关系：<br>π rad = 180°<br>1 rad = (180 / π)°=&gt; 1 rad = 180 / 3.14 ≈ 57.3°；<br>1°= (π / 180) rad =&gt; 1°= 3.14 / 180 ≈ 0.01745 rad；<br>由此可以得出<br>弧度 * 57.3 = 对应角度<br>角度 * 0.01745 = 对应弧</p><p>3.角度弧度相关API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 弧度、角度相互转化//弧度转角度float rad = 1;float anger = rad * Mathf.Rad2Deg;//角度转弧度anger = 1;rad = anger * Mathf.Deg2Rad;知识点二 三角函数)可以让物体做曲线运动)//注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5知识点三 反三角函数//注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度rad = Mathf.Asin(0.5f);print(rad * Mathf.Rad2Deg);rad = Mathf.Acos(0.5f);print(rad * Mathf.Rad2Deg);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="坐标系说明"><a href="#坐标系说明" class="headerlink" title="坐标系说明"></a>坐标系说明</h2><p>1.世界坐标系：<br>原点：世界的中心点<br>轴向：世界坐标系的三个轴向是固定的</p><p>2.物体坐标系：<br>原点：物体的中心点)建模时决定)<br>轴向：<br>物体右方为x轴正方向<br>物体上方为y轴正方向<br>物体前方为z轴正方向</p><p>3.屏幕坐标系：<br>原点：屏幕左下角<br>轴向：<br>向右为x轴正方向<br>向上为y轴正方向<br>最大宽高：<br>Screen.width<br>Screen.height</p><p>4.视口坐标系：<br>原点：屏幕左下角<br>轴向：<br>向右为x轴正方向<br>向上为y轴正方向<br>特点：<br>左下角为)0,0)<br>右上角为)1,1)<br>和屏幕坐标类似，将坐标单位化</p><p>汇总</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 世界坐标系//目前学习的和世界坐标系相关的//this.transform.position;//this.transform.rotation;//this.transform.eulerAngles;//this.transform.lossyScale(全局缩放大小，只能得);//修改他们 会是相对世界坐标系的变化知识点二 物体坐标系//相对父对象的物体坐标系的位置 本地坐标 相对坐标//this.transform.localPosition;//this.transform.localEulerAngles;//this.transform.localRotation;//this.transform.localScale;//修改他们 会是相对父对象物体坐标系的变化知识点三 屏幕坐标系//Input.mousePosition//Screen.width;//Screen.height;知识点四 视口坐标系//摄像机上的 视口范围坐标转换相关//世界转本地//this.transform.InverseTransformDirection//this.transform.InverseTransformPoint//this.transform.InverseTransformVector//本地转世界//this.transform.TransformDirection//this.transform.TransformPoint  //this.transform.TransformVector//世界转屏幕//Camera.main.WorldToScreenPoint//屏幕转世界//Camera.main.ScreenToWorldPoint//世界转视口//Camera.main.WorldToViewportPoint//视口转世界//Camera.main.ViewportToWorldPoint//视口转屏幕//Camera.main.ViewportToScreenPoint//屏幕转视口//Camera.main.ScreenToViewportPoint;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Vector3向量"><a href="#Vector3向量" class="headerlink" title="Vector3向量"></a>Vector3向量</h2><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Vector3.html">UnityEngine.Vector3 - Unity 脚本 API (unity3d.com)</a></p><h3 id="向量模长和单位向量"><a href="#向量模长和单位向量" class="headerlink" title="向量模长和单位向量"></a>向量模长和单位向量</h3><p>1.标量：<br>有数值大小，没有方向</p><p>2.向量：<br>有数值大小，有方向的矢量</p><p>3.两点决定一向量：<br>A点：(Xa,Ya,Za)<br>B点：(Xb,Yb,Zb)<br>从A指向B的向量为AB向量<br>B-A = (Xb-Xa, Yb-Ya, Zb-Za)<br>从B指向A的向量为BA向量<br>A-B = (Xa-Xb, Ya-Yb, Za-Zb)<br>口诀：终点减起点</p><p>4.零向量和负向量：<br>零向量<br>(0,0,0)<br>零向量是唯一一个大小为0的向量<br>负向量<br>(x,y,z)的负向量为(-x,-y,-z)<br>负向量和原向量大小相等<br>负向量和原向量方向相反</p><p>5.向量的模长：<br>向量的模长就是向量的长度<br>向量是由两个点算出，所以向量的模长就是两个点的距离<br>模长公式：<br>A向量(x,y,z)<br>模长 = √x² + y² + z²</p><p>6.单位向量：<br>模长为1的向量为单位向量<br>任意一个向量经过归一化就是单位向量<br>只需要方向，不想让模长影响计算结果时使用单位向量<br>归一化公式：<br>A向量(x,y,z)<br>模长 = √x² + y² + z²<br>单位向量 = (x/模长, y/模长, z/模长)</p><p>7.向量模长和单位向量相关API：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 向量//三维向量 - Vector3//Vector3有两种几何意义//1.位置 —— 代表一个点print(this.transform.position);//2.方向 —— 代表一个方向print(this.transform.forward);print(this.transform.up);Vector3 v = new Vector3(1, 2, 3);Vector2 v2 = new Vector2(1, 2);知识点二 两点决定一向量//A和B此时 几何意义 是两个点Vector3 A = new Vector3(1, 2, 3);Vector3 B = new Vector3(5, 1, 5);//求向量//此时 AB和 BA 他们的几何意义 是两个向量Vector3 AB = B - A;Vector3 BA = A - B;知识点三 零向量和负向量print(Vector3.zero);print(Vector3.forward);print(-Vector3.forward);知识点四 向量的模长//Vector3中提供了获取向量模长的成员属性//magnitudeprint(AB.magnitude);Vector3 C = new Vector3(5, 6, 7);print(C.magnitude);print(Vector3.Distance(A, B));知识点五 单位向量//Vector3中提供了获取单位向量的成员属性//normalizedprint(AB.normalized);print(AB / AB.magnitude);总结//模长相当于可以得到 两点之间的距离  单位向量 主要是用来进行移动计算的 它不会影响我们想要的移动效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向量加减乘除"><a href="#向量加减乘除" class="headerlink" title="向量加减乘除"></a>向量加减乘除</h3><p>1.向量加法：向量A + 向量B = (Xa + Xb, Ya + Yb)；<br>位置+位置：两个位置相加没有任何几何意义<br>向量+向量：两个向量相加得到一个新向量；向量 + 向量 = 向量)向量相加，首尾相连)<br><img src="https://s4.ax1x.com/2022/01/27/7XBRTf.png" alt="向量+向量"><br>位置+向量：位置加向量得到一个新位置；位置 + 向量 = 位置；向量 + 位置 = 位置)位置和向量相加=平移位置)<br><img src="https://s4.ax1x.com/2022/01/27/7XB7Xn.png" alt="位置+向量"></p><p>2.向量减法<br>向量A - 向量B = (Xa - Xb, Ya - Yb, Za);<br>位置-位置：两个位置相减得到一个新向量；位置 - 位置 = 向量)两点决定一向量，终点 - 起点)；<br><img src="https://s4.ax1x.com/2022/01/27/7XDEtO.png" alt="位置-位置"><br>向量-向量：两个向量相减得到一个新向量；向量 - 向量 = 向量)向量相减，头连头，尾指尾，A - B = B头指A头)；<br><img src="https://s4.ax1x.com/2022/01/27/7XDujA.png" alt="向量-向量"><br>位置-向量：位置减向量相当于 加负向量；位置 + (-向量)=位置)位置减向量 = 平移位置)；<br><img src="https://s4.ax1x.com/2022/01/27/7XDY9g.png" alt="位置-向量"><br>向量-位置：向量减位置没有任何几何意义</p><p>3.向量乘除<br>向量只会和标量进行乘除法运算<br>向量A<em>标量a = (x</em>a, y<em>a, z</em>a);<br>向量A/标量a = (x/a, y/a, z/a);<br>向量 *or/ 标量 = 向量;<br>向量 *or/ 正数，方向不变，放大缩小模长;<br>向量 *or/ 负数，方向相反，放大缩小模长;<br>向量 * 0，得到零向量;</p><p>4.知识点：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 向量加法        //this.transform.position += new Vector3(1, 2, 3);        this.transform.Translate(Vector3.forward * 5);知识点二 向量减法        //this.transform.position -= new Vector3(1, 2, 3);        this.transform.Translate(-Vector3.forward * 5);知识点三 向量乘除标量        this.transform.localScale *= 2;        this.transform.localScale /= 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h3><p>1.点乘计算公式：<br>向量A·向量B = Xa<em>Xb + Ya</em>Yb + Za*Zb=标量；<br>点乘可以得到一个向量：在自己向量上投影的长度)我们可以用这个规律判断敌方的大致方位)；<br>点乘结果 &gt; 0 两个向量夹角为锐角；<br>点乘结果 = 0 两个向量夹角为直角；<br>点乘结果 &lt; 0 两个向量夹角为钝；</p><p>2.公式推导：<br>Cosβ = 直角边 / 单位向量B模长<br>直角边 = Cosβ * 单位向量B模长)直角边 = 单位向量A · 单位向量B);<br>↓<br>Cosβ * 单位向量B模长 = 单位向量A · 单位向量B;<br>↓<br>Cosβ = 单位向量A · 单位向量B;<br>↓<br>推出结果：β = Acos(单位向量A · 单位向量B);<br><img src="https://s4.ax1x.com/2022/01/27/7XyMu9.png" alt="公式推导"></p><p>3.点乘API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 通过点乘判断对象方位)判断前后)        //Vector3 提供了计算点乘的方法        Debug.DrawRay(this.transform.position, this.transform.forward, Color.red);        Debug.DrawRay(this.transform.position, target.position - this.transform.position, Color.red);        //得到两个向量的点乘结果        //向量 a 点乘 AB 的结果        float dotResult = Vector3.Dot(this.transform.forward, target.position - this.transform.position);        if( dotResult &gt;= 0 )        {            print("它在我前方");        }        else        {            print("它在我后方");        }知识点二 通过点乘推导公式算出夹角)判断夹角，但是夹角为0-180之间，不能判断左右)        //步骤        //1.用单位向量算出点乘结果        dotResult = Vector3.Dot(this.transform.forward, (target.position - this.transform.position).normalized);        //2.用反三角函数得出角度        print("角度-" + Mathf.Acos(dotResult) * Mathf.Rad2Deg);        //Vector3中提供了 得到两个向量之间夹角的方法         print("角度2-" + Vector3.Angle(this.transform.forward, target.position - this.transform.position));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向量叉乘"><a href="#向量叉乘" class="headerlink" title="向量叉乘"></a>向量叉乘</h3><p>1.叉乘计算公式：<br>向量A x 向量B = (YaZb - ZaYb,ZaXb - XaZb,XaYb - YaX)=向量；</p><p>2.几何意义<br>A x B 得到的向量同时垂直A和B；<br>A x B 向量垂直于A和B组成的平面；<br>A x B = -(B x A)；</p><p>3.叉乘API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 叉乘计算        print(Vector3.Cross(A.position, B.position));        知识点二 叉乘几何意义        //假设向量 A和B 都在 XZ平面上        //向量A 叉乘 向量 B        //y大于0 证明 B在A右侧        //y小于0 证明 B在A左侧        Vector3 C = Vector3.Cross(A.position, B.position);        if( C.y &gt; 0)        {            print("B在A的右侧");        }        else        {            print("B在A的左侧");        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向量插值运算"><a href="#向量插值运算" class="headerlink" title="向量插值运算"></a>向量插值运算</h3><p>插值API:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 线性插值        //公式result = start + (end - start) * t        //1.先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置        A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime);        //2.匀速 每帧改变时间  当t&gt;=1时 得到结果        //这种匀速移动 当time&gt;=1时  我改变了 目标位置后  它会直接瞬移到我们的目标位置        //应该相当于Vector3.MoveToWards()        if(nowTarget != target.position)        {            nowTarget = target.position;            time = 0;            startPos = B.position;        }        time += Time.deltaTime;        B.position = Vector3.Lerp(startPos, nowTarget, time);知识点二 球形插值//做弧线运动，可以做弓箭射击，太阳东升西落        C.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up*0.1f, time*0.01f);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Quaternion四元数"><a href="#Quaternion四元数" class="headerlink" title="Quaternion四元数"></a>Quaternion四元数</h2><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Quaternion.html">UnityEngine.Quaternion - Unity 脚本 API (unity3d.com)</a></p><h3 id="为什么使用四元数"><a href="#为什么使用四元数" class="headerlink" title="为什么使用四元数"></a>为什么使用四元数</h3><p>1.欧拉角)transform.eulerAngles)：由三个角度(x,y,z)组成，遵守heading-pitch-bank旋转序列约定)heading:物体绕自身的对象坐标系的Y轴，旋转的角度；pitch:物体绕自身的对象坐标系的X轴，旋转的角度；bank:物体绕自身的对象坐标系的Z轴，旋转的角度)；<br>1.1.优点：直观、易理解；存储空间小)三个数表示)；可以进行从一个方向到另一个方向旋转大于180度的角度；<br>1.2缺点：同一旋转的表示不唯一；万向节死锁；</p><p>2.万向节死锁：当某个特定轴达到某个特殊值时，绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度；Unity中X轴达到90度时，会产生万向节死锁；</p><h3 id="四元数是什么"><a href="#四元数是什么" class="headerlink" title="四元数是什么"></a>四元数是什么</h3><p>1.轴-角对：在3D空间中，任意旋转都可以表示，绕着某个轴旋转一个旋转角得到；</p><p>2.四元数：对于给定旋转，假设为绕着n轴，旋转β度，n轴为(x,y,z)；四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z]；</p><p>3.四元数基本API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 四元数 Quaternion        //四元数Q = [cos(β/2),  sin(β/2)x, sin(β/2)y, sin(β/2)z]        //计算原理        //Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad));        //提供的轴角对 初始化 四元数的方法        Quaternion q = Quaternion.AngleAxis(60, Vector3.right);        知识点二 四元数和欧拉角转换        //1.欧拉角转四元数        Quaternion q2 = Quaternion.Euler(60, 0, 0);        GameObject obj2 = GameObject.CreatePrimitive(PrimitiveType.Cube);        obj2.transform.rotation = q2;        //2.四元数转欧拉角        print(q2.eulerAngles);知识点三 四元数弥补的欧拉角缺点        //1.同一旋转的表示不唯一  四元数旋转后 转换后的欧拉角 始终是 -180~180度        //2.万向节死锁 通过四元数旋转对象可以避免万向节死锁        //必备知识点：四元数相乘代表旋转四元数 this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四元数常用方法"><a href="#四元数常用方法" class="headerlink" title="四元数常用方法"></a>四元数常用方法</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 单位四元数        print(Quaternion.identity);        //testObj.rotation = Quaternion.identity;        Instantiate(testObj, Vector3.zero, Quaternion.identity);知识点二 插值运算        //在四元数中Lerp和Slerp只有一些细微差别        //由于算法不同,Slerp的效果会好一些        //Lerp的效果相比Slerp更快但是如果旋转范围较大效果较差,所以建议使用Slerp进行插值运算        //无限接近 先快后慢        A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);        //匀速变化 time&gt;=1到达目标        time += Time.deltaTime;        B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);识点三 LookRotation        //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);        //lookA.rotation = q;        lookA.MyLookAt(lookB);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四元数计算"><a href="#四元数计算" class="headerlink" title="四元数计算"></a>四元数计算</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 四元数相乘        //两个四元数相乘得到一个新的四元数,代表两个旋转量的叠加,相当于旋转(旋转相对的坐标系 是物体自身坐标系)        Quaternion q = Quaternion.AngleAxis(20, Vector3.up);        this.transform.rotation *= q;知识点二 四元数乘向量        //四元数乘向量返回一个新向量,可以将指定向量旋转对应四元数的旋转量,相当于直接旋转向量        Vector3 v = Vector3.forward;        v = Quaternion.AngleAxis(45, Vector3.up) * v;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Mono重要内容"><a href="#Mono重要内容" class="headerlink" title="Mono重要内容"></a>Mono重要内容</h1><h2 id="延迟-延时-函数"><a href="#延迟-延时-函数" class="headerlink" title="延迟(延时)函数"></a>延迟(延时)函数</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 什么是延迟函数        //延迟函数顾名思义        //就是会延时执行的函数        //我们可以自己设定延时要执行的函数和具体延时的时间        //是MonoBehaviour基类中实现好的方法知识点二 延迟函数的使用1.延迟函数        //Invoke        //参数一：函数名 字符串        //参数二：延迟时间 秒为单位        Invoke("DelayDoSomething", 1);        //注意：        //1-1.延时函数第一个参数传入的是函数名字符串        //1-2.延时函数没办法传入参数 只有包裹一层        //1-3.函数名必须是该脚本上申明的函数2.延迟重复执行函数        //InvokeRepeating        //参数一：函数名字符串        //参数二：第一次执行的延迟时间        //参数三：之后每次执行的间隔时间        InvokeRepeating("DelayRe", 5, 1);//注意：        //它的注意事项和延时函数一致3.取消延迟函数        //3-1取消该脚本上的所有延时函数执行        CancelInvoke();        //3-2指定函数名取消        //只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消        CancelInvoke("DelayDoSomething");4.判断是否有延迟函数        if( IsInvoking())        {            print("存在延迟函数");        }        if( IsInvoking("DelayDoSomething") )        {            print("存在延迟函数DelayDoSomething");        }知识点三 延迟函数受对象失活销毁影响        //脚本依附对象失活 或者 脚本自己失活        //延迟函数可以继续执行 不会受到影响的        //脚本依附对象销毁或者脚本移除        //延迟函数无法继续执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h2><p>1.Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容(注意：Unity中的多线程 要记住关闭);<br>2.协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿,继承MonoBehavior的类都可以使用协程;<br>3.协程只有当组件单独失活时不受影响，其它情况协程会停止<br>4.API</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 协程的使用        //继承MonoBehavior的类 都可以开启 协程函数        //第一步：申明协程函数        //  协程函数2个关键点        //  1-1返回值为IEnumerator类型及其子类        //  1-2函数中通过 yield return 返回值; 进行返回        //第二步：开启协程函数        //协程函数 是不能够 直接这样去执行的！！！！！！！        //这样执行没有任何效果        //MyCoroutine(1, "123");        //常用开启方式        //IEnumerator ie = MyCoroutine(1, "123");        //StartCoroutine(ie);        Coroutine c1 = StartCoroutine( MyCoroutine(1, "123") );        Coroutine c2 = StartCoroutine( MyCoroutine(1, "123"));        Coroutine c3 = StartCoroutine( MyCoroutine(1, "123"));        //第三步：关闭协程        //关闭所有协程        //StopAllCoroutines();        //关闭指定协程        //StopCoroutine(c1);知识点二 yield return 不同内容的含义        //1.下一帧执行        //yield return 数字;        //yield return null;        //在Update和LateUpdate之间执行        //2.等待指定秒后执行        //yield return new WaitForSeconds(秒);        //在Update和LateUpdate之间执行        //3.等待下一个固定物理帧更新时执行        //yield return new WaitForFixedUpdate();        //在FixedUpdate和碰撞检测相关函数之后执行        //4.等待摄像机和GUI渲染完成后执行        //yield return new WaitForEndOfFrame();        //在LateUpdate之后的渲染相关处理完毕后之后        //5.一些特殊类型的对象 比如异步加载相关函数返回的对象        //之后讲解 异步加载资源 异步加载场景 网络加载时再讲解        //一般在Update和LateUpdate之间执行        //6.跳出协程        //yield break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="协同程序原理"><a href="#协同程序原理" class="headerlink" title="协同程序原理"></a>协同程序原理</h2><p>1.协程的本质 就是利用 C#的迭代器函数”分步执行”的特点+协程调度逻辑 实现的一套分时执行函数的规则;</p><p>2.代码实现：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 协程的本质        //协程可以分成两部分        //1.协程函数本体        //2.协程调度器        //协程本体就是一个能够中间暂停返回的函数        //协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数        //Unity只实现了协程调度部分        //协程的本体本质上就是一个 C#的迭代器方法        知识点二 协程本体是迭代器方法的体现        //1.协程函数本体        //如果我们不通过 开启协程方法执行协程         //Unity的协程调度器是不会帮助我们管理协程函数的        IEnumerator ie = Test();        //但是我们可以自己执行迭代器函数内容        ie.MoveNext();//会执行函数中内容遇到 yield return为止的逻辑        print(ie.Current);//得到 yield return 返回的内容        //ie.MoveNext();        //print(ie.Current);        //ie.MoveNext();        //print(ie.Current);        //ie.MoveNext();        //TestClass tc = ie.Current as TestClass;        //print(tc.time);        //MoveNext 返回值 代表着 是否到了结尾)这个迭代器函数 是否执行完毕)                //2.协程调度器        //继承MonoBehavior后 开启协程        //相当于是把一个协程函数)迭代器)放入Unity的协程调度器中帮助我们管理进行执行        //具体的yield return 后面的规则 也是Unity定义的一些规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#Resources资源动态加载</p><h2 id="Unity中的特殊文件夹"><a href="#Unity中的特殊文件夹" class="headerlink" title="Unity中的特殊文件夹"></a>Unity中的特殊文件夹</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 工程路径获取        //注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用        //我们不会在实际发布游戏后 还使用该路径        //游戏发布过后 该路径就不存在了         print(Application.dataPath);知识点二 Resources 资源文件夹        //路径获取：        //一般不获取        //只能使用Resources相关API进行加载        //如果硬要获取 可以用工程路径拼接        print(Application.dataPath + "/Resources");        //注意：        //需要我们自己将创建        //作用：        //资源文件夹        //1-1.需要通过Resources相关API动态加载的资源需要放在其中        //1-2.该文件夹下所有文件都会被打包出去        //1-3.打包时Unity会对其压缩加密        //1-4.该文件夹打包后只读 只能通过Resources相关API加载知识点三 StreamingAssets 流动资源文件夹        //路径获取：        print(Application.streamingAssetsPath);        //注意：        //需要我们自己将创建        //作用：        //流文件夹        //2-1.打包出去不会被压缩加密，可以任由我们摆布        //2-2.移动平台只读，PC平台可读可写        //2-3.可以放入一些需要自定义动态加载的初始资源知识点四 persistentDataPath 持久数据文件夹        //路径获取：        print(Application.persistentDataPath);        //注意：        //不需要我们自己将创建        //作用：        //固定数据文件夹        //3-1.所有平台都可读可写        //3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中知识点五 Plugins 插件文件夹        //路径获取：        //一般不获取        //注意：        //需要我们自己将创建        //作用：        //插件文件夹        //不同平台的插件相关文件放在其中        //比如IOS和Android平台知识点六 Editor 编辑器文件夹        //路径获取：        //一般不获取        //如果硬要获取 可以用工程路径拼接        print(Application.dataPath + "/Editor");        //注意：        //需要我们自己将创建        //作用：        //编辑器文件夹        //5-1.开发Unity编辑器时，编辑器相关脚本放在该文件夹中        //5-2.该文件夹中内容不会被打包出去知识点七 默认资源文件夹 Standard Assets        //路劲过去：        //一般不获取        //注意：        //需要我们自己将创建        //作用：        //默认资源文件夹        //一般Unity自带资源都放在这个文件夹下        //代码和资源优先被编译<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Application.html">UnityEngine.Application - Unity 脚本 API (unity3d.com)</a></p><h2 id="Resources同步加载"><a href="#Resources同步加载" class="headerlink" title="Resources同步加载"></a>Resources同步加载</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 常用资源类型        //1.预设体对象——GameObject)要实例化)        //2.音效文件——AudioClip        //3.文本文件——TextAsset        //4.图片文件——Texture        //5.其它类型——需要什么用什么类型知识点二 资源同步加载 普通方法        //在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源        //打包时 Resources文件夹 里的内容 都会打包在一起        //1.预设体对象 想要创建在场景上 记住实例化        // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中)        Object obj = Resources.Load("Cube");        //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化        Instantiate(obj);        // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中)        Object obj2 = Resources.Load("Sphere");        //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化        Instantiate(obj2);        //2.音效资源        //第一步：就是加载数据        Object obj3 = Resources.Load("Music/BKMusic");        //第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可        audioS.clip = obj3 as AudioClip;        audioS.Play();        //3.文本资源        //文本资源支持的格式        //.txt        //.xml        //.bytes        //.json        //.html        //.csv        //.....        TextAsset ta = Resources.Load("Txt/Test") as TextAsset;        //文本内容        print(ta.text);        //字节数据组        //print(ta.bytes);        //4.图片        tex = Resources.Load("Tex/TestJPG") as Texture;        GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);)(画出图片)        //5.其它类型 需要什么类型 就用什么类型就行        //6.问题：资源同名怎么办        //Resources.Load加载同名资源时 无法准确加载出你想要的内容        //可以使用另外的API        //6-1加载指定类型的资源        //tex = Resources.Load("Tex/TestJPG", typeof(Texture)) as Texture;        ta = Resources.Load("Tex/TestJPG", typeof(TextAsset)) as TextAsset;        //print(ta.text);        //6-2加载指定名字的所有资源        Object[] objs = Resources.LoadAll("Tex/TestJPG"); 知识点三 资源同步加载 泛型方法        TextAsset ta2 = Resources.Load&lt;TextAsset&gt;("Tex/TestJPG");        print(ta2.text);        tex = Resources.Load&lt;Texture&gt;("Tex/TestJPG");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Resources异步加载"><a href="#Resources异步加载" class="headerlink" title="Resources异步加载"></a>Resources异步加载</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 Resources异步加载方法        //注意：        //异步加载 不能马上得到加载的资源 至少要等一帧        //1.通过异步加载中的完成事件监听 使用加载的资源        //这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载        //ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;("Tex/TestJPG");        //马上进行一个 资源下载结束 的一个事件函数监听        //rq.completed += LoadOver;        print(Time.frameCount);        //这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的         //一定要等加载结束过后 才能使用        //rq.asset ××××××××××××        //2.通过协程 使用加载的资源        StartCoroutine(Load());            IEnumerator Load()    {        //迭代器函数 当遇到yield return时  就会 停止执行之后的代码        //然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时        ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;("Tex/TestJPG");        print(Time.frameCount);        //第一部分        //Unity 自己知道 该返回值 意味着你在异步加载资源         //yield return rq;        //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码        print(Time.frameCount);                //判断资源是否加载结束        while(!rq.isDone)        {            //打印当前的 加载进度 (0-1浮点型值)            print(rq.progress);            yield return null;        }        tex = rq.asset as Texture;    }总结：        //1.完成事件监听异步加载        //好处：写法简单        //坏处：只能在资源加载结束后 进行处理        //“线性加载”        //2.协程异步加载        //好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新        //坏处：写法稍麻烦        //“并行加载”        //注意：        //理解为什么异步加载不能马上加载结束，为什么至少要等1帧        //理解协程异步加载的原理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Resources卸载资源"><a href="#Resources卸载资源" class="headerlink" title="Resources卸载资源"></a>Resources卸载资源</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 Resources重复加载资源会浪费内存吗？        //其实Resources加载一次资源过后        //该资源就一直存放在内存中作为缓存        //第二次加载时发现缓存中存在该资源        //会直接取出来进行使用        //所以 多次重复加载不会浪费内存        //但是 会浪费性能)每次加载都会去查找取出，始终伴随一些性能消耗)        知识点二 如何手动释放掉缓存中的资源        //1.卸载指定资源        //Resources.UnloadAsset 方法        //注意：        //该方法 不能释放 GameObject对象 因为它会用于实例化对象        //它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等        //一般情况下 我们很少单独使用它        //GameObject obj = Resources.Load&lt;GameObject&gt;("Cube");        //即使是没有实例化的 GameObject对象也不能进行卸载        //Resources.UnloadAsset(obj);        //2.卸载未使用的资源        //注意：        //一般在过场景时和GC一起使用        Resources.UnloadUnusedAssets();        GC.Collect();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Resources.html">UnityEngine.Resources - Unity 脚本 API (unity3d.com)</a></p><h1 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h1><p>  需要把要加载的场景Build Settings中。</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 场景同步切换        //在切换场景时        //Unity会删除当前场景上所有对象        //并且去加载下一个场景的相关信息        //如果当前场景 对象过多或者下一个场景对象过多        //这个过程会非常的耗时 会让玩家感受到卡顿        SceneManager.LoadScene("Lesson20Test");知识点二 场景异步切换        //场景异步加载和资源异步加载 几乎一致 有两种方式        //1.通过事件回调函数 异步加载        //AsyncOperation ao = SceneManager.LoadSceneAsync("Lesson20Test");        //当场景异步加载结束后 就会自动调用该事件函数 我们如果希望在加载结束后 做一些事情 那么久可以在该函数中        //写处理逻辑        //ao.completed += (a) =&gt;        //{        //    print("加载结束");        //};        //ao.completed += LoadOver;        //2.通过协程异步加载        //需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了        //所以 协程中的部分逻辑 可能是执行不了的         //解决思路        //让处理场景加载的脚本依附的对象 过场景时 不被移除        //该脚本依附的对象 过场景时 不会被 移除        DontDestroyOnLoad(this.gameObject);       StartCoroutine(LoadScene("Lesson20Test"));        IEnumerator LoadScene(string name)    {        //第一步        //异步加载场景        AsyncOperation ao = SceneManager.LoadSceneAsync(name);        //Unity内部的 协程协调器 发现是异步加载类型的返回对象 那么就会等待        //等待异步加载结束后 才会继续执行 迭代器函数中后面的步骤        print("异步加载过程中 打印的信息");        //协程的好处 是异步加载场景时 我可以在加载的同时 做一些别的逻辑        //yield return ao;        //第二步        print("异步加载结束后 打印的信息");        //比如 我们可以在异步加载过程中 去更新进度条        //第一种 就是利用 场景异步加载 的进度 去更新 但是 不是特别准确 一般也不会直接用        //while(!ao.isDone)        //{        //    print(ao.progress);        //    yield return null;        //}        //离开循环后 就会认为场景加载结束        //可以把进度条顶满 然后 隐藏进度条        //第二种 就是根据你游戏的规则 自己定义 进度条变化的条件        yield return ao;        //场景加载结束 更新20%进度        //接着去加载场景中 的其它信息        //比如        //动态加载怪物        //这时 进度条 再更新20%        //动态加载 场景模型        //这时 就认为 加载结束了 进度条顶满         //隐藏进度条    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/SceneManagement.SceneManager.html">SceneManagement.SceneManager - Unity 脚本 API (unity3d.com)</a></p><h1 id="画线功能Linerenderer组件"><a href="#画线功能Linerenderer组件" class="headerlink" title="画线功能Linerenderer组件"></a>画线功能Linerenderer组件</h1><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 LineRenderer是什么        //LineRenderer是Unity提供的一个用于画线的组件        //使用它我们可以在场景中绘制线段        //一般可以用于        //1绘制攻击范围        //2武器红外线        //3辅助功能        //4其它画线功能        知识点二ineRender代码相关        //动态添加一个线段        GameObject line = new GameObject();        line.name = "Line";        LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;();        //首尾相连        lineRenderer.loop = true;        //开始结束宽        lineRenderer.startWidth = 0.02f;        lineRenderer.endWidth = 0.02f;        //开始结束颜色        lineRenderer.startColor = Color.white;        lineRenderer.endColor = Color.red;        //设置材质        m = Resources.Load&lt;Material&gt;("M");        lineRenderer.material = m;        //设置点        //一定注意 设置点 要 先设置点的个数        lineRenderer.positionCount = 4;        //接着就设置 对应每个点的位置        lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0),                                                  new Vector3(0,0,5),                                                  new Vector3(5,0,5)});        lineRenderer.SetPosition(3, new Vector3(5, 0, 0));        //是否使用世界坐标系        //决定了 是否随对象移动而移动        lineRenderer.useWorldSpace = false;        //让线段受光影响 会接受光数据 进行着色器计算        lineRenderer.generateLightingData = true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/LineRenderer.html">UnityEngine.LineRenderer - Unity 脚本 API (unity3d.com)</a></p><p><img src="https://s4.ax1x.com/2022/01/27/7jWrk9.png" alt="面板参数一"><br><img src="https://s4.ax1x.com/2022/01/27/7jW26K.png" alt="面板参数二"><br><img src="https://s4.ax1x.com/2022/01/27/7jWfmD.png" alt="面板参数三"><br><img src="https://s4.ax1x.com/2022/01/27/7jWIkd.png" alt="面板参数四"></p><h1 id="核心系统"><a href="#核心系统" class="headerlink" title="核心系统"></a>核心系统</h1><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Physics.html">UnityEngine.Physics - Unity 脚本 API (unity3d.com)</a></p><h2 id="物理系统之范围检测"><a href="#物理系统之范围检测" class="headerlink" title="物理系统之范围检测"></a>物理系统之范围检测</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点二 如何进行范围检测        //必备条件：想要被范围检测到的对象 必须具备碰撞器        //注意点：        //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的        //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已        //范围检测API        //1.盒状范围检测        //参数一：立方体中心点        //参数二：立方体三边大小        //参数三：立方体角度        //参数四：检测指定层级)不填检测所有层)        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal        //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息)        print(LayerMask.NameToLayer("UI"));        Collider[] colliders = Physics.OverlapBox( Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up),                             1 &lt;&lt; LayerMask.NameToLayer("UI") |                            1 &lt;&lt; LayerMask.NameToLayer("Default"), QueryTriggerInteraction.UseGlobal);        //0000 0001        //0010 0000        //重要知识点：        //关于层级        //通过名字得到层级编号 LayerMask.NameToLayer        //我们需要通过编号左移构建二进制数        //这样每一个编号的层级 都是 对应位为1的2进制数        //我们通过 位运算 可以选择想要检测层级        //好处 一个int 就可以表示所有想要检测的层级信息        //层级编号是 0~31 刚好32位        //是一个int数        //每一个编号 代表的 都是二进制的一位        //0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1        //1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2        //2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4        //3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8        //4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16        //5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32        //另一个API         //返回值：碰撞到的碰撞器数量        //参数：传入一个数组进行存储        //Physics.OverlapBoxNonAlloc()                if(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0)        //2.球形范围检测        //参数一：中心点        //参数二：球半径        //参数三：检测指定层级)不填检测所有层)        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal        //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息)        colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer("Default"));        //另一个API         //返回值：碰撞到的碰撞器数量        //参数：传入一个数组进行存储        //Physics.OverlapSphereNonAlloc        if( Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0 )        //3.胶囊范围检测        //参数一：半圆一中心点        //参数二：半圆二中心点        //参数三：半圆半径        //参数四：检测指定层级)不填检测所有层)        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal        //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息)        colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer("UI"), QueryTriggerInteraction.UseGlobal);        //另一个API         //返回值：碰撞到的碰撞器数量        //参数：传入一个数组进行存储        //Physics.OverlapCapsuleNonAlloc        if ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders ) != 0 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="物理系统之射线检测"><a href="#物理系统之射线检测" class="headerlink" title="物理系统之射线检测"></a>物理系统之射线检测</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 射线对象        //1.3D世界中的射线        //假设有一条        //起点为坐标(1,0,0)        //方向为世界坐标Z轴正方向的射线        //注意：        //理解参数含义        //参数一：起点        //参数二：方向)一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量)                //目前只是申明了一个射线对象 对于我们来说 没有任何的用处        Ray r = new Ray(Vector3.right, Vector3.forward);        //Ray中的参数        print(r.origin);//起点        print(r.direction);//方向        //2.摄像机发射出的射线        // 得到一条从屏幕位置作为起点        // 摄像机视口方向为 方向的射线        Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);        知识点三 碰撞检测函数        //Physics类中提供了很多进行射线检测的静态函数        //他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了        //注意：        //射线检测也是瞬时的        //执行代码时进行一次射线检测        //1.最原始的射线检测        // 准备一条射线        Ray r3 = new Ray(Vector3.zero, Vector3.forward);        // 进行射线检测 如果碰撞到对象 返回true        //参数一：射线        //参数二: 检测的最大距离 超出这个距离不检测        //参数三：检测指定层级)不填检测所有层)        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal        //返回值：bool 当碰撞到对象时 返回 true 没有 返回false        if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断        //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向        if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))        //2.获取相交的单个物体信息        //物体信息类 RaycastHit        RaycastHit hitInfo;        //参数一：射线        //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中        //参数三：距离        //参数四：检测指定层级)不填检测所有层)        //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal        if( Physics.Raycast(r3, out hitInfo, 1000, 1&lt;&lt;LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal) )        {            //碰撞器信息            print("碰撞到物体的名字" + hitInfo.collider.gameObject.name);            //碰撞到的点            print(hitInfo.point);            //法线信息            print(hitInfo.normal);            //得到碰撞到对象的位置            print(hitInfo.transform.position);            //得到碰撞到对象 离自己的距离            print(hitInfo.distance);            //RaycastHit 该类 对于我们的意义            //它不仅可以得到我们碰撞到的对象信息            //还可以得到一些 碰撞的点 距离 法线等等的信息        }        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断        if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))        //3.获取相交的多个物体        //可以得到碰撞到的多个对象        //如果没有 就是容量为0的数组        //参数一：射线        //参数二：距离        //参数三：检测指定层级)不填检测所有层)        //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal        RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal);        //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断        //之前的参数一射线 通过两个点传入        hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal);        //还有一种函数 返回的碰撞的数量 通过out得到数据        if(Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal) &gt; 0 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Ray.html">UnityEngine.Ray - Unity 脚本 API (unity3d.com)</a></p><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/RaycastHit.html">UnityEngine.RaycastHit - Unity 脚本 API (unity3d.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity入门</title>
      <link href="/posts/1537.html"/>
      <url>/posts/1537.html</url>
      
        <content type="html"><![CDATA[<p>将之前的笔记整理下来</p><h1 id="Unity概叙"><a href="#Unity概叙" class="headerlink" title="Unity概叙"></a>Unity概叙</h1><p>  Unity是一个游戏开发的集成工具，降低了游戏开发的门槛，提高了开发效率。</p><h2 id="工程文件夹"><a href="#工程文件夹" class="headerlink" title="工程文件夹"></a>工程文件夹</h2><p>Assets：工程资源文件夹(美术资源脚本)<br>Library:库文件夹<br>Logs:日志文件夹<br>obj:编译中间文件<br>Packages:包配置信息<br>ProjectSettings:工程设置信息</p><h1 id="Unity界面基础"><a href="#Unity界面基础" class="headerlink" title="Unity界面基础"></a>Unity界面基础</h1><p>Inspector检查窗口：用于设置游戏对象具体信息<br>Console控制台窗口：用于显示调试信息，报错、警告、打印信息等<br>Scene场景窗口：所有游戏对象所在地<br>Hierarchy层级窗口：所有游戏的对象名单<br>Game游戏窗口：玩家看到的游戏画面<br>Project工程窗口：所有游戏资源和脚本内容</p><h2 id="Scence场景和Hierarchy层级窗口"><a href="#Scence场景和Hierarchy层级窗口" class="headerlink" title="Scence场景和Hierarchy层级窗口"></a>Scence场景和Hierarchy层级窗口</h2><h3 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h3><p>  我们可以在Hierarchy窗口中创建或拖入各种游戏对象。<br>Hierarchy层级窗口快捷键：<br>F2：对象改名<br>Ctrl+C：复制<br>Ctrl+V：粘贴<br>Ctrl+D：克隆一个<br>Delete：删除</p><h3 id="Scence"><a href="#Scence" class="headerlink" title="Scence"></a>Scence</h3><p>  我们可以在Scene窗口中查看所有游戏对象设置所有游戏对象。<br>窗口上方工具条内容：<br>1.渲染模式<br>2.2D、3D视图切换<br>3.光源、音效、特效显示开启<br>4.辅助线显示<br>5.辅助功能，控制场景上提示图标等<br>6.搜索<br>7.场景轴向</p><p>关于Unity中的3D世界坐标轴：<br>红色为X轴正向<br>绿色为Y轴正向<br>蓝色为Z轴正向</p><p>以屏幕为参照物：<br>垂直屏幕向内为Z正方向<br>平行屏幕向右为X正方向<br>平行屏幕向上为Y正方向</p><p>场景中的操作：<br>左键相关：<br>  鼠标单击：选中单个物体<br>  鼠标框选：选中多个物体<br>  Ctrl+鼠标单击：多选物体<br>  长按ALT键+鼠标左键+移动鼠标：相对观察视口中心点旋转</p><p>选中物体之后，按F键：居中显示物体(或者在层级窗口中双击对象)</p><p>右键相关：<br>  鼠标右键按下+移动鼠标：旋转视口<br>  鼠标右键按下+WASD：漫游场景<br>  鼠标右键按下+WASD+Shift：快速漫游场景<br>长按ALT键+鼠标右键+移动鼠标：相对屏幕中心点拉近拉远</p><p>中键相关：<br>滚动鼠标中间：相对屏幕中心点拉近拉远<br>鼠标中间按下+移动鼠标：平移观察视口<br>长按ALT键+滚动鼠标中间：鼠标指哪就朝哪拉近拉</p><h2 id="Game游戏和Project工程"><a href="#Game游戏和Project工程" class="headerlink" title="Game游戏和Project工程"></a>Game游戏和Project工程</h2><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h3><p>  游戏画面窗口，玩家能看到的画面内容.</p><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>  工程资源窗口，所有的工程资源都会在该窗口<br>中显示，显示的内容为Assets文件夹中的所有内容.</p><p>Project工程窗口关键功能:<br>1.窗口设置<br>2.创建相关资源文件<br>3.查找<br>4.按资源类型查找<br>5.按名字查找</p><p>资源类型:<br>图片格式：jpg、png、tga<br>模型格式：fbx、max、maya<br>音效：wav、mp3、ogg<br>文本：txt、json、bytes<br>视频：mp4</p><h2 id="Inspector检查和Console控制台"><a href="#Inspector检查和Console控制台" class="headerlink" title="Inspector检查和Console控制台"></a>Inspector检查和Console控制台</h2><h3 id="Inspector"><a href="#Inspector" class="headerlink" title="Inspector"></a>Inspector</h3><p>  查看场景中游戏对象关联的C#脚本信息.</p><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p>  用于查看调试信息的窗口报错、警告、测试打印都可以显示在其中,默认未开启可以在Window——&gt;General中开启或者使用快捷键：Ctrl+Shift+C，该窗口将显示代码编译过程中或者游戏运行过程中的报错、警告、测试信息主要用于查错和调试用。</p><p>Console控制台窗口：<br>1.清空控制台<br>2.相同内容折叠显示<br>3.运行时清空<br>4.构建时清空<br>5.报错暂停运行<br>6.是否显示错误信息<br>7.是否显示警告信息<br>8.是否显示打印信息</p><h2 id="工具栏和父子关系"><a href="#工具栏和父子关系" class="headerlink" title="工具栏和父子关系"></a>工具栏和父子关系</h2><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>从左到右：<br>1.文件操作：新建工程，新建场景，工程打包等等<br>2.编辑操作：对象编辑操作相关，工程设置，引擎设置相关<br>3.资源操作：基本等同于Project窗口中右键相关功能<br>4.对象操作：基本等同于Hierarchy窗口中右键相关功能<br>5.脚本操作：Unity自带的脚本，可以添加各系统中的脚本<br>7.窗口：可以打开Unity各核心系统的窗口<br>9.帮助：检查更新，查看版本等等功能</p><p>File中的重要选项：BuildSetting(工程发布打包)<br>Edit中的重要选项：Project Setting(工程各系统设置)、Preferences(首选项，可以设置编程软件)、GameObject中的重要选项：MoveToView、Align With View、Align View to Selected(几种快捷设置位置的功能)</p><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><p>  对象之间产生父子关系后，如何相互影响？爸爸干嘛，儿子干嘛；儿子干嘛，爸爸不管。<br>Scene上方作用：<br>pivot：以本身为中心点；<br>center：以整体为中心点；<br>local：以本身旋转为朝向；<br>global：以世界坐标为朝向；</p><h1 id="Unity工作原理"><a href="#Unity工作原理" class="headerlink" title="Unity工作原理"></a>Unity工作原理</h1><p>  使用它时是处于运行中的，我们是在一个运行中的软件里制作游戏的，Unity开发的本质就是在Unity引擎的基础上,利用反射和引擎提供的各种功能进行的拓展开发。</p><h2 id="反射机制和游戏场景"><a href="#反射机制和游戏场景" class="headerlink" title="反射机制和游戏场景"></a>反射机制和游戏场景</h2><p>反射机制的体现：除了Transform这个表示位置的标配剧本外，我们可以为这个演员(GameObject)关联各种剧本(C#脚本)，让它按照我们剧本中(代码逻辑中)的命令来处理事情，而为演员添加剧本的这个过程，就是在利用反射new一个新的剧本对，象和演员(GameObject)对象进行关联，让其按我们的命令做事；</p><p>利用反射举例体现：<br>1.修改Inspector面板中Transform的内容：已知对象，类名，变量名，通过反射为该对象设置变量值；<br>2.新建一个脚本后，添加给一个指定的GameObject对象：已知类名，可以获取所有公共成员，故可以在Inspector<br>面板上创建各公共字段信息</p><p>游戏场景的本质：游戏场景文件后缀为.unity，它的本质就是一个配置文件，Unity有一套自己识别处理它的机制，但是本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象；</p><h2 id="预设物和资源包的导入导出"><a href="#预设物和资源包的导入导出" class="headerlink" title="预设物和资源包的导入导出"></a>预设物和资源包的导入导出</h2><p>后缀名：.prefab，Prefabs放该类型文件;<br>预制物删除变红处理：点击预制物右键Unpack Prefab;<br>Project右键：导入导出包(.unitypackage);</p><h1 id="Unity脚本基础"><a href="#Unity脚本基础" class="headerlink" title="Unity脚本基础"></a>Unity脚本基础</h1><p>默认脚本内容：Editor\Data\Resources\ScriptTemplates</p><h2 id="脚本基本规则"><a href="#脚本基本规则" class="headerlink" title="脚本基本规则"></a>脚本基本规则</h2><p>1.创建规则：<br>    1.不在VS中创建脚本了<br>    2.可以放在Assets文件夹下的任何位置(建议同一文件夹管理)<br>    3.类名和文件名必须一致,不然不能挂载(因为反射机制创建对象，会通过文件名去找Type)<br>    4.建议不要使用中文名命名<br>    5.没有特殊需求 不用管命名空间<br>    6.创建的脚本默认继承MonoBehavior</p><p>2.MonoBehavior基类：<br>    1.创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上<br>    2.继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！<br>    3.继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义<br>    4.继承了MonoBehavior的脚本可以在一个对象上挂多个(如果没有加DisallowMultipleComponent特性)<br>    5.继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则</p><p>3.不继承MonoBehavior的类<br>    1.不继承Mono的类 不能挂载在GameObject上<br>    2.不继承Mono的类 想怎么写怎么写 如果要使用需要自己new<br>    3.不继承Mono的类 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据)<br>    4.不继承Mono的类 不用保留默认出现的几个函数</p><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>总结：这些生命周期函数 如果你不打算在其中写逻辑 那就不要使用这些命周期函数。<br>我们要知道，虽然建议大家不在继承MonoBehavior的类中写构造函数；<br>但是不意味着我们不能写，当我们在继承MonoBehavior的类中写无参构造函数时，你会发现在编辑模式下或者运行后，只要该脚本挂载在场景中，那么该无参构造函数是会被自动执行的。<br>因为Unity的工作原理中提到的反射机制，Unity实际上通过反射帮助我们实例化了该脚本对象，既然要实例化那么肯定是需要new的，只不过Unity中不需要我们自己new继承了MonoBehavior的类，只要挂载后Unity帮助我们做了这件事。<br>那么为什么不建议大家写构造函数呢？<br>1.Unity的规则就是，继承MonoBehavior的脚本不能new只能挂载<br>2.生命周期函数的Awake是类似构造函数的存在，当对象出生就会自动调用<br>3.写构造函数反而在结构上会破坏Unity设计上的规范</p><p><img src="https://s4.ax1x.com/2022/01/26/7LPvwj.png" alt="帧的概率"><br><img src="https://s4.ax1x.com/2022/01/26/7LkYWt.png" alt="生命周期"></p><p>打印方式：<br>普通：Debug.Log(“123”);<br>报错：Debug.LogError(“出错了！！！！！”);<br>警告：Debug.LogWarning(“警告！！！”);</p><h2 id="Inspector窗口可编辑变量"><a href="#Inspector窗口可编辑变量" class="headerlink" title="Inspector窗口可编辑变量"></a>Inspector窗口可编辑变量</h2><p>知识点一: 私有和保护无法显示编辑，公共的可以显示编辑；<br>知识点二 ：[SerializeField]让私有的和保护的也可以被显示；<br>知识点三：[HideInInspector]公共的也不让其显示编辑；<br>知识点四：[System.Serializable] 让自定义类型可以被访问；//加在类前，而字典怎么都不行<br>知识点七： 辅助特性<br>1.[Header(“分组说明”)] ：分组说明特性，为成员分组；<br>2.[Tooltip(“说明内容”)] //悬停注释，为变量添加说明；<br>3.[Space()]：间隔特性，让两个字段间出现间隔<br>4.[Range(最小值, 最大值)] //修饰数值的滑条范围；<br>5.[TextArea(3, 4)] ：滚动条显示字符串，默认不写参数就是超过3行显示滚动条；<br>6.[ContextMenuItem(“显示按钮名”, “方法名”)] ：为变量添加快捷方法，参数1 显示按钮名，参数2 方法名 不能有参数；<br>7.[Multiline(4)] ：多行显示字符串 默认不写参数显示3行<br>8.[ContextMenu(“测试函数”)] ：方法添加特性能够在Inspector中执行</p><h2 id="继承自MonoBehavior重要内容"><a href="#继承自MonoBehavior重要内容" class="headerlink" title="继承自MonoBehavior重要内容"></a>继承自MonoBehavior重要内容</h2><h3 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h3><p>1.获取依附的GameObject：this.gameObject;<br>2.获取依附的GameObject的位置信息：<br>-print(this.transform.position);//位置<br>-print(this.transform.eulerAngles);//角度<br>-print(this.transform.lossyScale);//缩放大小<br>3.获取脚本是否激活： this.enabled；</p><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>1:得到依附对象上挂载的其它脚本</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.得到自己挂载的单个脚本,获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空this.GetComponent("脚本名");//2.得到自己挂载的多个脚本this.GetComponents&lt;泛形类型&gt;();//3.得到子对象挂载的脚本(它默认也会找自己身上是否挂载该脚本)//函数是有一个参数的 默认不传 是false 意思就是 如果子对象失活 是不会去找这个对象上是否有某个脚本的//如果传true 及时 失活 也会找//得子对象 挂载脚本 单个this.GetComponentInChildren&lt;泛形类型&gt;(true);this.GetComponentsInChildren&lt;泛形类型&gt;(true);//4.得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本)this.GetComponentInParent&lt;泛形类型&gt;();this.GetComponentsInParent&lt;泛形类型&gt;();//5.尝试获取脚本//提供了一个更加安全的 获取单个脚本的方法 如果得到了 会返回true//然后在来进行逻辑处理即可this.TryGetComponent&lt;泛形类型&gt;(out 赋值变量)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Unity重要组件和API"><a href="#Unity重要组件和API" class="headerlink" title="Unity重要组件和API"></a>Unity重要组件和API</h1><h2 id="GameObject最小单位"><a href="#GameObject最小单位" class="headerlink" title="GameObject最小单位"></a>GameObject最小单位</h2><p>直接实例化：new GameObject(“实体名”，typeof(要添加的组件名)…….) ；</p><p>注意事项：<br>1.建议使用Destroy方法，它是异步的，不会马上删除对象，只是给对象加一个标识，一般情况下下一帧才会把对象从内存一处。；<br>2.如果继承自mono，可以省略GameObject字段；<br>3.对象失活也是可以用一些方式获取的；<br>4.广播方法效率很低，不建议使用；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 GameObject中的成员变量//名字print(this.gameObject.name);this.gameObject.name = "Lesson4唐老狮改名";print(this.gameObject.name);//是否激活print(this.gameObject.activeSelf);//是否是静态print(this.gameObject.isStatic);//层级print(this.gameObject.layer);//标签print(this.gameObject.tag);transformthis.transform 上一节课讲解的 通过Mono去得到的依附对象的GameObject的位置信息//他们得到的信息是一样 都是依附的GameObject的位置信息print(this.gameObject.transform.position);知识点二 GameObject中的静态方法//创建自带几何体//只要得到了一个GameObject对象 我就可以得到它身上挂在的任何脚本信息//通过obj.GetComponent来得去GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);obj.name = "唐老狮创建的立方体";//查找对象相关的知识//两种找单个对象的共同点://1.无法找到失活的对象的 //  只能找到 激活的对象//2.如果场景中 存在多个满足条件的对象//  我们无法准确确定找到的是谁 //1查找单个对象//通过对象名查找//这个查找效率比较低下  因为他会在场景中的所有对象去查找//没有找到 就会返回nullGameObject obj2 = GameObject.Find("唐老狮");//通过tag来查找对象GameObject obj3 = GameObject.FindWithTag("Player");//和上面的方法一样，名字不一样而已GameObject obj3 = GameObject.FindGameObjectWithTag("Player");//得到某一个单个对象 目前有2种方式了//1.是public从外部面板拖 进行关联//2.通过API去找//2查找多个对象//找多个对象的API 只能是通过tag去找多个 通过名字 是没有找多个的方法的//通过tag找到多个对象//它也是 只能找到 激活对象 无法找到失活对象GameObject obj3 = GameObject.FindGameObjectsWithTag("Player");//还有几个查找对象相关是用的比较少的方法 是GameObject父类 Object提供的方法//引出额外知识点 Unity中的Object和C#中的万物之父的区别//Unity里面的Object 不是指的万物之父object//Unity里的Object 命名空间在UnityEngine中的 Object类 也是集成万物之父的一个自定义类//C#中的Object 命名空间是在System中的 //它可以找到场景中挂载的某一个脚本对象//效率更低 上面的GameObject.Find 和通过FindWithTag找 只是遍历对象//这个方法 不仅要遍历对象 还要遍历对象上挂载的脚本 Lesson4 o = GameObject.FindObjectOfType&lt;Lesson4&gt;();print(o.gameObject.name);//实例化对象(克隆对象)的方法//实例化(克隆)对象 它的作用 是根据一个GameObject对象 创建出一个和它一模一样的对象GameObject obj5 = GameObject.Instantiate(myObj);//以后学了更多知识点 就可以在这操作obj5//如果你继承了 MonoBehavior 其实可以不用写GameObject一样可以使用//因为 这个方法时Unity里面的 Object基类提供给我们的 所以可以直接用Instantiate(myObj);//删除对象的方法GameObject.Destroy(myObj2);//第二个参数 代表延迟几秒钟删除GameObject.Destroy(obj5, 5);Destroy不仅可以删除对象 还可以删除脚本GameObject.Destroy(this);//删除对象有两种作用//1.是删除指定的一个游戏对象//2.是删除一个指定的脚本对象//注意：这个Destroy方法 不会马上移除对象 只是给这个对象加了一个移除标识 //     一般情况下 它会在下一帧时把这个对象移除并从内存中移除//如果没有特殊需求 就是一定要马上移除一个对象的话 //建议使用上面的 Destroy方法 因为 是异步的 降低卡顿的几率//下面这个方法 就是立即把对象 从内存中移除了 GameObject.DestroyImmediate(myObj);//如果是继承MonoBehavior的类 不用写GameObjectDestroy(myObj2);DestroyImmediate(myObj);//过场景不移除 //默认情况 在切换场景时 场景中对象都会被自动删除掉//如果你希望某个对象 过场景不被移除 //下面这句代码 就是不想谁过场景被移除 就传谁 //一般都是传 依附的GameObject对象//比如下面这句代码的意思 就是自己依附的GameObject对象 过场景不被删除GameObject.DontDestroyOnLoad(this.gameObject);//如果继承MOnoBehavior也可以直接写DontDestroyOnLoad(this.gameObject);知识点三 GameObject中的成员方法//创建空物体//new一个GameObject就是在创建一个空物体GameObject obj6 = new GameObject();GameObject obj7 = new GameObject("唐老狮创建的空物体");GameObject obj8 = new GameObject("顺便加脚本的空物体", typeof(Lesson2),typeof(Lesson1));//为对象添加脚本//继承MOnoBehavior的脚本 是不能够去new //如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上//直接使用GameObject提供的方法即可Lesson1 les1 = obj6.AddComponent(typeof(Lesson1)) as Lesson1;//用泛型更方便Lesson2 les2 = obj6.AddComponent&lt;Lesson2&gt;();//通过返回值 可以得到加入的脚本信息//来进行一些处理//得到脚本的成员方 和继承Mono的类得到脚本的方法 一模一样  //标签比较//下面两种比较的方法 是一样的if(this.gameObject.CompareTag("Player")){    print("对象的标签 是 Player");}if(this.gameObject.tag == "Player"){    print("对象的标签 是 Player");}//设置激活失活//false 失活true 激活obj6.SetActive(false);obj7.SetActive(false);obj8.SetActive(false);//次要的成员方法 了解即可 不建议使用//强调//下面讲的方法 都不建议大家使用 效率比较低//通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法//通知自己 执行什么行为//命令自己 去执行这个TestFun这个函数 会在自己身上挂在的所有脚本去找这个名字的函数//它会去找到 自己身上所有的脚本 有这个名字的函数去执行this.gameObject.SendMessage("TestFun");this.gameObject.SendMessage("TestFun2", 199);//广播行为 让自己和自己的子对象执行this.gameObject.BroadcastMessage("函数名");//向父对象和自己发送消息 并执行this.gameObject.SendMessageUpwards("函数名");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/GameObject.html">UnityEngine.GameObject - Unity 脚本 API (unity3d.com)</a></p><h2 id="Time时间相关"><a href="#Time时间相关" class="headerlink" title="Time时间相关"></a>Time时间相关</h2><p>作用：主要 用于游戏中参与位移、记时、时间暂停等；<br>重要内容:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一 时间缩放比例//时间停止Time.timeScale = 0;//回复正常Time.timeScale = 1;//2倍速Time.timeScale = 2;//知识点二 帧间隔时间//帧间隔时间 主要是用来计算位移//路程 = 时间*速度//根据需求 选择参与计算的间隔时间//如果希望 游戏暂停时就不动的 那就使用Time.deltaTime;//如果希望 不受暂停影响 Time.unscaledDeltaTime;//帧间隔时间：最近的一帧 用了多长时间(秒)//受scale影响print("帧间隔时间" + Time.deltaTime);//不受scale影响的帧间隔时间print("不受scale影响的帧间隔时间" + Time.unscaledDeltaTime);知识点三 游戏开始到现在的时间//它主要用来计时 单机游戏中计时//受scale影响print("游戏开始到现在的时间:" + Time.time);//不受scale影响print("不受scale影响的游戏开始到现在的时间:" + Time.unscaledTime);知识点四 物理帧间隔时间 FixedUpdate//受scale影响Time.fixedDeltaTime;//不受scale影响Time.fixedUnscaledDeltaTime;知识点五 帧数//从开始到现在游戏跑了多少帧(次循环)print(Time.frameCount);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Time.html">UnityEngine.Time - Unity 脚本 API (unity3d.com)</a></p><h2 id="Transform-位置和位移"><a href="#Transform-位置和位移" class="headerlink" title="Transform-位置和位移"></a>Transform-位置和位移</h2><h3 id="Vector3"><a href="#Vector3" class="headerlink" title="Vector3"></a>Vector3</h3><p>常用：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//常用变量print(Vector3.zero);//000print(Vector3.right);//100print(Vector3.left);//-100print(Vector3.forward);//001print(Vector3.back);//00-1print(Vector3.up);//010print(Vector3.down);//0-10//常用方法 (后续加)//计算两个点之间的距离的方法print(Vector3.Distance(v1, v12));//返回float 两个向量之间的角度(以度为单位)Vector3.Angle();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Vector3.html">UnityEngine.Vector3 - Unity 脚本 API (unity3d.com)</a></p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>(注意：位置的赋值不能直接改变x，y，z 只能整体改变)<br>位移方式：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一：位置//相对世界坐标系this.gameObject.transform；//相对父对象this.transform.localPosition；//世界正朝向Vector3.forwad;//本身正朝向transform.forward；//知识点二 位移//坐标系下的位移计算公式：路程 = 方向 * 速度 * 时间//方式一 自己计算//想要变化的 就是 position//用当前的位置 + 我要动多长距离  得出最终所在的位置this.transform.position = this.transform.position + this.transform.up * 1 * Time.deltaTime;//因为我用的是 this.transform.forward 所以它始终会朝向相对于自己的面朝向去动this.transform.position += this.transform.forward * 1 * Time.deltaTime;//方向非常重要 因为 它决定了你的前进方向this.transform.position += Vector3.forward * 1 * Time.deltaTime;//方式二 API//参数一：表示位移多少  路程 = 方向 * 速度 * 时间//参数二：表示 相对坐标系   默认 该参数 是相对于自己坐标系的//1相对于世界坐标系的 Z轴 动  始终是朝 世界坐标系 的 Z轴正方向移动this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World);//2相对于世界坐标的 自己的面朝向去动   始终朝自己的面朝向移动this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World);//3相对于自己的坐标系 下的 自己的面朝向向量移动 (一定不会这样让物体移动) XXXXXXXthis.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.Self);//4相对于自己的坐标系 下的 Z轴正方向移动  始终朝自己的面朝向移动this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Transform.html">UnityEngine.Transform - Unity 脚本 API (unity3d.com)</a></p><h2 id="Tramsfrom-角度和旋转"><a href="#Tramsfrom-角度和旋转" class="headerlink" title="Tramsfrom-角度和旋转"></a>Tramsfrom-角度和旋转</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 角度相关相对世界坐标角度：transform.eulerAngles；相对父对象角度：transform.localEulerAngles；知识点二 旋转相关//自己计算(省略 和位置一样 不停改变角度即可)//API计算//自转//每个轴 具体转多少度//第一个参数 相当于 是旋转的角度 每一帧 //第二个参数 默认不填 就是相对于自己坐标系 进行的旋转this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime);this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World);//相对于某个轴 转多少度//参数一：是相对哪个轴进行转动//参数二：是转动的 角度 是多少//参数三：默认不填 就是相对于自己的坐标系 进行旋转//       如果填  可以填写相对于 世界坐标系进行旋转this.transform.Rotate(Vector3.right, 10 * Time.deltaTime);this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World);//相对于某一个点转//参数一：相当于哪一个点 转圈圈//参数二：相对于那一个点的 哪一个轴转圈圈//参数三：转的度数  旋转速度 * 时间this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Transfrom-缩放和看向"><a href="#Transfrom-缩放和看向" class="headerlink" title="Transfrom-缩放和看向"></a>Transfrom-缩放和看向</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 缩放//相对世界坐标系print(this.transform.lossyScale);//相对本地坐标系(父对象)print(this.transform.localScale);//注意：//1.同样缩放不能只改xyz 只能一起改(相对于世界坐标系的缩放大小只能得 不能改)//所以 我们一般要修改缩放大小 都是改的 相对于父对象的 缩放大小 localScalethis.transform.localScale = new Vector3(3, 3, 3);//2.Unity没有提供关于缩放的API//之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有//如果你想要 让 缩放 发生变化 只能自己去写(自己算)this.transform.localScale += Vector3.one * Time.deltaTime;知识点二 看向//让一个对象的面朝向 可以一直看向某一个点或者某一个对象//看向一个点 相对于世界坐标系的this.transform.LookAt(Vector3.zero);//看向一个对象 就传入一个对象的  Transform信息this.transform.LookAt(lookAtObj);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Transfrom-父子关系"><a href="#Transfrom-父子关系" class="headerlink" title="Transfrom-父子关系"></a>Transfrom-父子关系</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 获取和设置父对象//获取父对象print(this.transform.parent.name);//设置父对象 断绝父子关系this.transform.parent = null;//设置父对象 认爸爸this.transform.parent = GameObject.Find("Father2").transform;//通过API来进行父子关系的设置this.transform.SetParent(null);//断绝父子关系this.transform.SetParent(GameObject.Find("Father2").transform);//认爸爸//参数一：我的父亲//参数二：是否保留世界坐标的 位置 角度 缩放 信息//       true  会保留 世界坐标下的状态  和 父对象 进行计算 得到本地坐标系的信息//       false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 this.transform.SetParent(GameObject.Find("Father3").transform, false);知识点二 抛妻弃子//就是和自己的所有儿子 断绝关系 没有父子关系了this.transform.DetachChildren();知识点三 获取子对象//按名字查找儿子//找到儿子的 transform信息//Find方法 是能够找到 失活的对象的 ！！！！！ GameObject相关的 查找 是不能找到失活对象的print(this.transform.Find("Cube (1)").name);//他只能找到自己的儿子 找不到自己的孙子 ！！！！！！print(this.transform.Find("GameObject").name);//虽然它的效率 比GameObject.Find相关 要高一些 但是 前提是你必须知道父亲是谁 才能找//遍历儿子//如何得到有多少个儿子//1.失活的儿子也会算数量//2.找不到孙子 所以孙子不会算数量print(this.transform.childCount);//通过索引号 去得到自己对应的儿子//如果编号 超出了儿子数量的范围 那会直接报错的 //返回值 是 transform 可以得到对应儿子的 位置相关信息this.transform.GetChild(0);知识点四 儿子的操作//判断自己的爸爸是谁//一个对象 判断自己是不是另一个对象的儿子if(son.IsChildOf(this.transform)){    print("是我的儿子");}//得到自己作为儿子的编号print(son.GetSiblingIndex());//把自己设置为第一个儿子son.SetAsFirstSibling();//把自己设置为最后一个儿子son.SetAsLastSibling();//把自己设置为指定个儿子//就算你填的数量 超出了范围(负数或者更大的数) 不会报错 会直接设置成最后一个编号son.SetSiblingIndex(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Transfrom-坐标转换"><a href="#Transfrom-坐标转换" class="headerlink" title="Transfrom-坐标转换"></a>Transfrom-坐标转换</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 世界坐标转本地坐标print(Vector3.forward);//世界坐标系 转本地坐标系 可以帮助我们大概判断一个相对位置//世界坐标系的点 转换 为相对本地坐标系的点  //受到缩放影响print("转换后的点 " + this.transform.InverseTransformPoint(Vector3.forward));//世界坐标系的方向 转换 为相对本地坐标系的方向 //不受缩放影响print("转换后的方向" + this.transform.InverseTransformDirection(Vector3.forward));//受缩放影响print("转换后的方向(受缩放影响)" + this.transform.InverseTransformVector(Vector3.forward));知识点二 本地坐标转世界坐标//本地坐标系的点 转换 为相对世界坐标系的点 受到缩放影响print("本地 转 世界 点" + this.transform.TransformPoint(Vector3.forward));//本地坐标系的方向 转换 为相对世界坐标系的方向 //不受缩放影响print("本地 转 世界 方向" + this.transform.TransformDirection(Vector3.forward));//受缩放影响print("本地 转 世界 方向" + this.transform.TransformVector(Vector3.forward));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Input输入相关"><a href="#Input输入相关" class="headerlink" title="Input输入相关"></a>Input输入相关</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一 鼠标在屏幕位置Input.mousePosition//知识点二 检测鼠标输入//鼠标按下一瞬间 进入//0左键 1右键 2中键Input.GetMouseButtonDown(0)//中键滚动//返回值的 y -1往下滚  0没有滚  1往上滚//它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值print(Input.mouseScrollDelta);//知识点三 检测键盘输入//传入字符串的重载//这里传入的 字符串 不能是大写的 不然会报错//只能传入小写字符串Input.GetKeyDown("q")//推荐枚举型 Input.GetKey(KeyCode.W)  //知识点四 检测默认轴输入 //我们学习鼠标 键盘输入 主要是用来//控制玩家 比如 旋转 位移等等//所以Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转//键盘AD按下时 返回 -1到1之间的变换//相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转float h = Input.GetAxis("Horizontal");//键盘SW按下时 返回 -1到1之间的变换//得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转print(Input.GetAxis("Vertical"));//鼠标横向移动时 -1 到 1 左 右print(Input.GetAxis("Mouse X"));//鼠标竖向移动时  -1 到 1 下 上print(Input.GetAxis("Mouse Y"));//我们默认的 GetAxis方法 是有渐变的 会总 -1~0~1之间 渐变 会出现小数//GetAxisRaw方法 和 GetAxis使用方式相同//只不过 它的返回值 只会是 -1 0 1 不会有中间值//知识点三 其它的监听//是否有任意键或鼠标长按if(Input.anyKey)//是否有任意键或鼠标按下if(Input.anyKeyDown)//这一帧的键盘输入print(Input.inputString);//手柄输入相关//得到连接的手柄的所有按钮名字string[] strs = Input.GetJoystickNames();//某一个手柄键按下if( Input.GetButtonDown("Jump") )//某一个手柄键抬起if (Input.GetButtonUp("Jump"))//某一个手柄键长按if (Input.GetButton("Jump"))//移动设备触摸相关if(Input.touchCount &gt; 0){    Touch t1 = Input.touches[0];    //位置    print(t1.position);    //相对上次位置的变化    print(t1.deltaPosition);}//是否启用多点触控Input.multiTouchEnabled = false;//陀螺仪(重力感应)//是否开启陀螺仪 必须开启 才能正常使用Input.gyro.enabled = true;//重力加速度向量print(Input.gyro.gravity);//旋转速度print(Input.gyro.rotationRate);//陀螺仪 当前的旋转四元数 //比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响//手机怎么动 它怎么动print(Input.gyro.attitude);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Input.html">UnityEngine.Input - Unity 脚本 API (unity3d.com)</a></p><h2 id="Screen屏幕相关"><a href="#Screen屏幕相关" class="headerlink" title="Screen屏幕相关"></a>Screen屏幕相关</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一 静态属性//常用//当前屏幕分辨率Resolution r = Screen.currentResolution;print("当前屏幕分辨率的宽" + r.width + "高" + r.height);//屏幕窗口当前宽高//这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高//一般写代码 要用窗口宽高 做计算时 就用他们print(Screen.width);print(Screen.height);//屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep;//不常用//运行时是否全屏模式Screen.fullScreen = true;//窗口模式//独占全屏FullScreenMode.ExclusiveFullScreen//全屏窗口FullScreenMode.FullScreenWindow//最大化窗口FullScreenMode.MaximizedWindow//窗口模式FullScreenMode.WindowedScreen.fullScreenMode = FullScreenMode.Windowed;//移动设备屏幕转向相关//允许自动旋转为左横向 Home键在左Screen.autorotateToLandscapeLeft = true;//允许自动旋转为右横向 Home键在右Screen.autorotateToLandscapeRight = true;//允许自动旋转到纵向 Home键在下Screen.autorotateToPortrait = true;//允许自动旋转到纵向倒着看 Home键在上Screen.autorotateToPortraitUpsideDown = true;//指定屏幕显示方向Screen.orientation = ScreenOrientation.Landscape;知识点二 静态方法//设置分辨率 一般移动设备不使用Screen.SetResolution(1920, 1080, false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Screen.html">UnityEngine.Screen - Unity 脚本 API (unity3d.com)</a></p><h2 id="Camera摄像机相关"><a href="#Camera摄像机相关" class="headerlink" title="Camera摄像机相关"></a>Camera摄像机相关</h2><p>1.*Clear Flags：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">如何清除背景：skybox天空盒<span class="token punctuation">(</span>3D<span class="token punctuation">)</span>Solid Color颜色填充<span class="token punctuation">(</span>2D<span class="token punctuation">)</span>Depth only 只画该层，背景透明<span class="token punctuation">(</span>叠加渲染<span class="token punctuation">)</span>Don't Clear 不移除，覆盖渲染<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.*Culling Mask</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">选择性渲染部分层级：可以指定只渲染对应层级的对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.*Projection</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">2</span>.1Perspective 透视模式FOV Axis：视场角 轴-决定了光学仪器的视野范围Field of view：视口大小Physical Camera：物理摄像机、勾选后可以模拟真实世界中、摄像机、焦距、传感器尺寸、透镜移位等等Focal Length：焦距Sensor Type：传感器类型Sensor Size：传感器尺寸Lens Shift：透镜移位Gate Fit：闸门配合<span class="token number">2</span>.2orthographic 正交摄像机<span class="token punctuation">(</span>一般用于2D游戏制作<span class="token punctuation">)</span>Size：摄制范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.*Clipping Planes：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">裁剪平面距离<span class="token punctuation">(</span>近和远<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.Viewport Rect：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">视口范围屏幕上将绘制该摄像机视图的位置：主要用于双摄像机游戏<span class="token number">0</span>~1 相当于宽高百分比<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>6.*Depth:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">渲染顺序上的深度<span class="token punctuation">(</span>多个摄像机，越小的越先渲染，大的覆盖小的<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7.Redering path:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">渲染路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8.*Target Texture:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">渲染纹理:可以把摄像机画面渲染到一张图上:主要用于制作小地图<span class="token punctuation">(</span>摄像机渲染到这张图上<span class="token punctuation">)</span>在Project右键创建 Render Texture<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>9.*Occlusion Culling:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">是否启用剔除遮挡<span class="token punctuation">(</span>性能优化<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>10.Allow HDR:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">是否允许高动态范围渲染<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>11.Allow MSAA:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">是否允许抗锯齿<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>12.Allow Dynamic Resolution:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">是否允许动态分辨率呈现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>13.Target Display:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">用于哪个显示器:主要用来开发有多个屏幕的平台游戏<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Camera.html">摄像机 - Unity 手册 (unity3d.com)</a></p><p>代码相关：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 重要静态成员//1.获取摄像机//如果用之前的知识 来获取摄像机//主摄像机的获取//如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机print(Camera.main.name);//获取摄像机的数量print(Camera.allCamerasCount);//得到所有摄像机Camera[] allCamera = Camera.allCameras;print(allCamera.Length);//2.渲染相关委托//摄像机剔除前处理的委托函数Camera.onPreCull += (c) =&gt;{};//摄像机 渲染前处理的委托Camera.onPreRender += (c) =&gt;{};//摄像机 渲染后 处理的委托Camera.onPostRender += (c) =&gt;{};知识点二 重要成员//1.界面上的参数 都可以在Camera中获取到//比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置Camera.main.depth = 10;//2.世界坐标转屏幕坐标//转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远//我们会用这个来做的功能 最多的 就是头顶血条相关的功能Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position);print(v);//3.屏幕坐标转世界坐标//只所以改变Z轴 是因为 如果不改 Z默认为0//转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点//如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点Vector3 v = Input.mousePosition;v.z = 5;obj.position = Camera.main.ScreenToWorldPoint(v);//print(Camera.main.ScreenToWorldPoint(v));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Camera.html">UnityEngine.Camera - Unity 脚本 API (unity3d.com)</a></p><h1 id="核心系统"><a href="#核心系统" class="headerlink" title="核心系统"></a>核心系统</h1><h2 id="光源系统基础"><a href="#光源系统基础" class="headerlink" title="光源系统基础"></a>光源系统基础</h2><h3 id="Light组件"><a href="#Light组件" class="headerlink" title="Light组件"></a>Light组件</h3><p>1.*Type:光源类型</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Spot:聚光灯Range:发光范围距离Spot Angle:光锥角度Directional:方向光<span class="token punctuation">(</span>环境光<span class="token punctuation">)</span>Point:点光源Area:面光源<span class="token punctuation">(</span>烘焙下用<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.*Color:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">颜色<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.*Mode:光源模式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Realtime:实时光源每帧实时计算，效果好，性能消耗大Baked:烘焙光源事先计算好，无法动态变化Mixed:混合光源预先计算+实时运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.*Intensity:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">光源亮度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.Indirect Multiplier:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">改变间接光的强度低于1，每次反弹会使光更暗大于1，每次反弹会使光更亮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>6.*Shadow Type:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">NoShadows:关闭阴影HardShadows:生硬阴影SoftShadows:柔和阴影<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>7.RealtimeShadows</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Strength:阴影暗度 <span class="token number">0</span>~1之间，越大越黑Resolution:阴影贴图渲染分辨率，越高越逼真，消耗越高Bias:阴影推离光源的距离Normal Bias:阴影投射面沿法线收缩距离Near Panel:渲染阴影的近裁剪面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.*Cookie:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">投影遮罩<span class="token punctuation">(</span>用图制作光照的样子<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9.Cookie Size：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">大小设置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>10.Draw Halo:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">球形光环开关<span class="token punctuation">(</span>光晕<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>11.*Flare:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">耀斑<span class="token punctuation">(</span>工程文件可以自己右键创建该类型文件，想再Game显示，摄像机添加Flare Layer脚本<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>12.Render Mode:渲染模式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Auto:运行时确定Important:以像素质量为单位进行渲染，效果逼真，消耗大Not Important:以快速模式进行渲染<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>13.*Culling Mask:剔除遮罩层，决定哪些层的对象受到该光源影响</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Light.html">光源 - Unity 手册 (unity3d.com)</a></p><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Light.html">UnityEngine.Light - Unity 脚本 API (unity3d.com)</a></p><h3 id="光窗口"><a href="#光窗口" class="headerlink" title="光窗口"></a>光窗口</h3><p>1.Environment-环境相关设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Skybox Material-天空盒材质：可以改变天空盒<span class="token punctuation">(</span>创建天空盒创建一个材质球将种类设置为skybox<span class="token punctuation">)</span>Sun Source-太阳来源：不设置会默认使用场景中最亮的方向光代表太阳Environment Lighting-环境光设置：Source-环境光光源颜色：Skybox：天空和材质作为环境光颜色Gradient：可以为天空、地平线、地面单独选择颜色和他们之间混合Intensity Multiplier-环境光亮度；Ambient Mode-全局光照模式只有启用了实时全局和全局烘焙时才有用：Realtime<span class="token punctuation">(</span>已弃用<span class="token punctuation">)</span>Baked<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.OtherSettings-其它设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Fog-雾开关<span class="token punctuation">(</span>性能消耗<span class="token punctuation">)</span>：Color-雾颜色：Mode-雾计算模式：Linear-随距离线性增加：Start：离摄像机多远开始有雾End：离摄像机多远完全遮挡Exponential-随距离指数增加：-Density-强度；Exponential Qquare-随距离比指数更快的增加-Density：强度；Halo Texture：光源周围挥着光环的纹理Halo Strength：光环可见性Flare Fade Speed：耀斑淡出时间最初出现之后淡出的时间；Flare Strength：耀斑可见性Spot Cookie：聚光灯默认剪影纹理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/lighting-window.html">Lighting 窗口 - Unity 手册 (unity3d.com)</a></p><h2 id="物理系统之碰撞检测"><a href="#物理系统之碰撞检测" class="headerlink" title="物理系统之碰撞检测"></a>物理系统之碰撞检测</h2><h3 id="Rigidbody组件"><a href="#Rigidbody组件" class="headerlink" title="Rigidbody组件"></a>Rigidbody组件</h3><p>重点：碰撞产生的必要条件，两个物体都有碰撞器，至少一个物体有刚体。</p><p>1.RigidBody组件信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Mass：质量<span class="token punctuation">(</span>默认为千克<span class="token punctuation">)</span>质量越大惯性越大；Drag：空气阻力根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力；Angular Drag：根据扭矩旋转对象时影响对象的空气阻力大小。0 表示没有空气阻力；Use Gravity：是否受重力影响Is Kinematic：如果启用此选项，则对象将不会被物理引擎驱动，只能通过 <span class="token punctuation">(</span>Transform<span class="token punctuation">)</span> 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用；Interpolate-<span class="token punctuation">(</span>物理帧时间长时使用<span class="token punctuation">)</span>插值运算，让刚体物体移动更平滑：None：不应用插值运算；Interpolate：根据前一帧的变换来平滑变换；Extrapolate：差值运算，根据下一帧的估计变换来平滑变换；Constraints-约束，对刚体运动的限制：Freeze Position：有选择地停止刚体沿世界 X、Y 和 Z 轴的移动；Freeze Rotation：有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转；Collision Detection<span class="token punctuation">(</span>碰撞检测模式<span class="token punctuation">)</span>-用于防止快速移动的对象穿过其它对象而不检测碰撞：Discrete<span class="token punctuation">(</span>离散检测<span class="token punctuation">)</span>：对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞<span class="token punctuation">(</span>这是默认值<span class="token punctuation">)</span>；Continuous<span class="token punctuation">(</span>连续检测<span class="token punctuation">)</span>：对动态碰撞体<span class="token punctuation">(</span>具有刚体<span class="token punctuation">)</span>使用离散碰撞检测，并对静态碰撞体<span class="token punctuation">(</span>没有刚体<span class="token punctuation">)</span>使用连续碰撞检测；设置为连续动态 <span class="token punctuation">(</span>Continuous Dynamic<span class="token punctuation">)</span> 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。<span class="token punctuation">(</span>此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置<span class="token punctuation">)</span>，其他刚体将使用离散碰撞检测。Continuous Speculative<span class="token punctuation">(</span>连续推测检测<span class="token punctuation">)</span>：对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s4.ax1x.com/2022/01/26/7OieIA.png" alt="碰撞检测模式对比图"></p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-Rigidbody.html">刚体 - Unity 手册 (unity3d.com)</a></p><p>API:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一 刚体自带添加力的方法//给刚体加力的目标就是 //让其有一个速度 朝向某一个方向移动//1.首先应该获取刚体组件rigidBody = this.GetComponent&lt;Rigidbody&gt;();//2.添加力//相对世界坐标//世界坐标系 Z轴正方向加了一个里//加力过后 对象是否停止移动 是由阻力决定的//如果阻力为0 那给了一个力过后 始终 是不会停止运动rigidBody.AddForce(Vector3.forward * 10);//如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动rigidBody.AddForce(this.transform.forward * 10);//相对本地坐标rigidBody.AddRelativeForce(Vector3.forward * 10);//3.添加扭矩力，让其旋转//相对世界坐标rigidBody.AddTorque(Vector3.up * 10);//相对本地坐标rigidBody.AddRelativeTorque(Vector3.up * 10);//4.直接改变速度//这个速度方向 是相对于 世界坐标系的 //如果要直接通过改变速度 来让其移动 一定要注意这一点rigidBody.velocity = Vector3.forward * 5;//5.模拟爆炸效果//模拟爆炸的力 一定是 所有希望产生爆炸效果影响的对象 //都需要得到他们的刚体 来执行这个方法 才能都有效果rigidBody.AddExplosionForce(100, Vector3.zero, 10);//知识点二 力的几种模式//第二个参数 力的模式 主要的作用 就是 计算方式不同而已 //由于4中计算方式的不同 最终的移动速度就会不同rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration);//动量定理//Ft = mv// v = Ft/m;//F:力//t：时间//m:质量//v:速度//1.Acceleration //给物体增加一个持续的加速度，忽略其质量//v = Ft/m//F:(0,0,10)//t:0.02s//m:默认为1//v = 10*0.02/ 1 = 0.2m/s//每物理帧移动0.2m/s*0.02 = 0.004m//2.Force//给物体添加一个持续的力，与物体的质量有关//v = Ft/m//F:(0,0,10)//t:0.02s//m:2kg//v = 10*0.02/ 2 = 0.1m/s//每物理帧移动0.1m/s*0.02 = 0.002m//3.Impulse//给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1//v = Ft/m//F:(0,0,10)//t:默认为1//m:2kg//v = 10*1/ 2 = 5m/s//每物理帧移动5m/s*0.02 = 0.1m//4.VelocityChange//给物体添加一个瞬时速度，忽略质量，忽略时间//v = Ft/m//F:(0,0,10)//t:默认为1//m:默认为1//v = 10*1/ 1 = 10m/s//每物理帧移动10m/s*0.02 = 0.2m//知识点三 力场脚本(Unity封装好了的组件)ConstantForce组件//补充 刚体的休眠//获取刚体是否处于休眠状态 如果是 if (rigidBody.IsSleeping()){    //就唤醒它    rigidBody.WakeUp();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Rigidbody.html">UnityEngine.Rigidbody - Unity 脚本 API (unity3d.com)</a></p><h3 id="碰撞器"><a href="#碰撞器" class="headerlink" title="碰撞器"></a>碰撞器</h3><p>碰撞器面板说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.3D碰撞器种类<span class="token number">1</span>.盒状<span class="token number">2</span>.球状<span class="token number">3</span>.胶囊<span class="token number">4</span>.网格<span class="token number">5</span>.轮胎<span class="token number">6</span>.地形<span class="token number">2</span>.共同参数：Is Trigger：是否是触发器，如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略，主要用于进行没有物理效果的碰撞检测；Material：物理材质<span class="token punctuation">(</span>工程右键可以创建一个物理材质.material文件<span class="token punctuation">)</span>，可以确定碰撞体和其它对象碰撞时的交互<span class="token punctuation">(</span>表现<span class="token punctuation">)</span>方式。Center：碰撞体在对象局部空间中的中心点位置<span class="token number">3</span>.常用碰撞器：BoxCollider-盒状碰撞器-Size：碰撞体在X、Y、Z方向上的大小；Sphere Collider-球状碰撞器-Radius：球形碰撞体的半径大小；Capsule Collider-胶囊碰撞器：Radius：胶囊体的半径Height：胶囊体的高度Direction：胶囊体在对象局部空间中的轴向<span class="token number">4</span>.异形物体使用多种碰撞器组合：刚体对象的子对象碰撞器信息参与碰撞检测；<span class="token number">5</span>.不常用碰撞器：Mesh Collider-网格碰撞器：Convex：勾选此复选框可启用 Convex。如果启用此属性，该 Mesh Collider 将与其他 Mesh Collider 发生碰撞。Convex Mesh Collider 最多 <span class="token number">255</span> 个三角形。Cooking Options-启用或禁用影响物理引擎对网格处理方式的网格烹制选项：-None：禁用下方列出的所有 Cooking Options-Everything：启用下方列出的所有 Cooking Options。-Cook <span class="token keyword">for</span> Faster Simulation：使物理引擎烹制网格以加快模拟速度。启用此设置后，这会运行一些额外步骤，以保证生成的网格对于运行时性能是最佳的。这会影响物理查询和接触生成的性能。禁用此设置后，物理引擎会使用更快的烹制速度，并尽可能快速生成结果。因此，烹制的 Mesh Collider 可能不是最佳的。-Enable Mesh Cleaning：使物理引擎清理网格。启用此设置后，烹制过程会尝试消除网格的退化三角形以及其他几何瑕疵。此过程生成的网格更适合于在碰撞检测中使用，往往可生成更准确的击中点。-Weld Colocated Vertices：使物理引擎在网格中删除相等的顶点。启用此设置后，物理引擎将合并具有相同位置的顶点。这对于运行时发生的碰撞反馈十分重要。Mesh：引用需要用于碰撞的网格。Wheel Collider-环状 碰撞器：Mass：车轮的质量Radius：车轮的半径Wheel Damping Rate：这是应用于车轮的阻尼值Suspension Distance：车轮悬架的最大延伸距离<span class="token punctuation">(</span>在局部空间中测量<span class="token punctuation">)</span>。悬架始终向下延伸穿过局部 Y 轴。Force App Point Distance：此参数定义车轮上的受力点。此距离应该是距车轮底部静止位置的距离<span class="token punctuation">(</span>沿悬架行程方向<span class="token punctuation">)</span>，以米为单位。当 forceAppPointDistance <span class="token operator">=</span> <span class="token number">0</span> 时，受力点位于静止的车轮底部。较好的车辆会使受力点略低于车辆质心。Suspension Spring：悬架尝试通过增加弹簧力和阻尼力来到达目标位置 <span class="token punctuation">(</span>Target Position<span class="token punctuation">)</span>-Spring：弹簧力尝试到达目标位置。值越大，悬架达到目标位置就越快-Damper：抑制悬架速度。值越大，悬架弹簧移动就越慢-Target Position：悬架沿悬架距离 <span class="token punctuation">(</span>Suspension Distance<span class="token punctuation">)</span> 的静止距离。1 对应于完全展开的悬架，0 对应于完全压缩的悬架。默认值为 <span class="token number">0.5</span>，与常规汽车的悬架行为匹配。Forward Friction-车轮向前滚动时轮胎摩擦的特性；Sideways Friction车轮侧向滚动时轮胎摩擦的特性—：-Extremum Slip：曲线的极值点。-Extremum Value：曲线的极值点。-Asymptote Slip：曲线的渐近点。-Asymptote Value：曲线的渐近点。-Stiffness：Extremum Value 和 Asymptote Value 的乘数<span class="token punctuation">(</span>默认值为 <span class="token number">1</span><span class="token punctuation">)</span>。改变摩擦力的刚度。将此值设置为零将完全禁用车轮的所有摩擦力。通常在运行时修改刚度以使用脚本来模拟各种地面材质。注意事项：不必通过转动或滚动 WheelCollider 对象来控制汽车；附加了 WheelCollider 的对象应始终相对于汽车本身固定；Terrain Collider-地形碰撞器Terrain Data：地形数据Enable Tree Colliders：选中此属性时，将启用树碰撞体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/CollidersOverview.html">碰撞体 - Unity 手册 (unity3d.com)</a></p><h3 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h3><p>物理材质参数说明</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Dynamic Friction：已在移动时使用的摩擦力。通常为 <span class="token number">0</span> 到 <span class="token number">1</span> 之间的值。值为零就像冰一样，值为 <span class="token number">1</span> 将使对象迅速静止<span class="token punctuation">(</span>除非用很大的力或重力推动对象<span class="token punctuation">)</span>Static Friction：当对象静止在表面上时使用的摩擦力。通常为 <span class="token number">0</span> 到 <span class="token number">1</span> 之间的值。值为零就像冰一样，值为 <span class="token number">1</span> 将导致很难让对象移动。Bounciness：表面的弹性如何？值为 <span class="token number">0</span> 将不会反弹。值为 <span class="token number">1</span> 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。Friction Combine-两个碰撞对象的摩擦力的组合方式：-Average：对两个摩擦值求平均值。-Minimum：使用两个值中的最小值。-Maximum：使用两个值中的最大值。-Multiply：两个摩擦值相乘。unce Combine：两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="碰撞检测函数"><a href="#碰撞检测函数" class="headerlink" title="碰撞检测函数"></a>碰撞检测函数</h3><p>注意：碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用.</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一 物理碰撞检测响应函数    //碰撞触发接触时会 自动执行这个函数    private void OnCollisionEnter(Collision collision)    {//Collision类型的 参数 包含了 碰到自己的对象的相关信息//关键参数//1.碰撞到的对象碰撞器的信息//collision.collider//2.碰撞对象的依附对象(GameObject)//collision.gameObject//3.碰撞对象的依附对象的位置信息//collision.transform//4.触碰点数相关//collision.contactCount//接触点 具体的坐标//ContactPoint[] pos = collision.contacts;//只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息print(this.name + "被" + collision.gameObject.name + "撞到了");    }    //碰撞结束分离时  会自动执行的函数    private void OnCollisionExit(Collision collision)    {print(this.name + "被" + collision.gameObject.name + "结束碰撞了");    }    //两个物体相互接触摩擦时 会不停的调用该函数    private void OnCollisionStay(Collision collision)    {print(this.name + "一直在和" + collision.gameObject.name + "接触");    }//知识点二 触发器检测响应函数    //触发开始的函数 当第一次接触时 会自动调用    protected virtual void OnTriggerEnter(Collider other)    {print(this.name + "被" + other.gameObject.name + "触发了");    }    //触发结束的函数 当水乳相融的状态结束时 会调用一次    private void OnTriggerExit(Collider other)    {print(this.name + "被" + other.gameObject.name + "结束水乳相融的状态了");    }    //当两个对象 水乳相融的时候 会不停调用    private void OnTriggerStay(Collider other)    {print(this.name + "和" + other.gameObject.name + "正在水乳相融");    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="音效系统"><a href="#音效系统" class="headerlink" title="音效系统"></a>音效系统</h2><h3 id="音频文件导入"><a href="#音频文件导入" class="headerlink" title="音频文件导入"></a>音频文件导入</h3><p>1.导入参数设置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">常用格式：wav、mp3、ogg、aiff；音频文件属性设置Force To Mono：多声道转单声道；Normalize：强制为单声道时，混合过程中被标准化；Load In Background：在后台加载，不阻塞主线程；Ambisonic：立体混响声 ，非常适合 <span class="token number">360</span> 度视频和 XR 应用程序，如果音频文件包含立体混响声编码的音频，请启用此选项；LoadType-加载类型：Decompress On Load：不压缩形式存在内存，加载块，但是内存占用高<span class="token punctuation">(</span>适用于小音效文件<span class="token punctuation">)</span>；Compress <span class="token keyword">in</span> memory：压缩形式存在内存，加载慢，内存小<span class="token punctuation">(</span>仅适用于较大音效文件<span class="token punctuation">)</span>Streaming：以流形式存在，使用时解码。内存占用最小，cpu消耗高<span class="token punctuation">(</span>性能换内存<span class="token punctuation">)</span>Preload Audio Data：预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载Compression Format-压缩方式：PCM：音频以最高质量存储Vorbis：相对PCM压缩的更小，根据质量决定ADPCM：包含噪音，会被多次播放的声音，如碰撞声Quality：音频质量，确定要应用于压缩剪辑的压缩量。<span class="token punctuation">(</span>不适用于 PCM/ADPCM/HEVAG 格式<span class="token punctuation">)</span>Sample Rate Setting-PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率：Preserve Sample Rate：此设置可保持采样率不变<span class="token punctuation">(</span>默认值<span class="token punctuation">)</span>；Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率；Override Sample Rate：此设置允许手动覆盖采样率，因此可有效地将其用于丢弃频率内容；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="音频源和音频监听组件"><a href="#音频源和音频监听组件" class="headerlink" title="音频源和音频监听组件"></a>音频源和音频监听组件</h3><p>组件面板说明：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">AudioSource-音频源：AudioClip：声音剪辑文件<span class="token punctuation">(</span>音频文件<span class="token punctuation">)</span>Output：默认将直接输出到场景中的音频监听器，可以更改为输出到混音器<span class="token punctuation">(</span>音乐游戏可能会用<span class="token punctuation">)</span>；Mute：静音开关；Bypass Effect：开关滤波器效果；Bypass Listener Effects：快速开关所有监听器；Bypass Reverb Zones：快速开关所有混响区Play On Awake：对象创建时就播放音乐，也就是开关启动游戏就播放；Loop：循环Priority：优先级<span class="token punctuation">(</span>越大越不容易被其他音效覆盖<span class="token punctuation">)</span>Volume：音量大小Pitch：音高Stereo Pan：2D声音立体声位置。相当于左右声道Spatial Blend：音频受3D空间的影响程度<span class="token punctuation">(</span>设置是2d游戏还是3d音效<span class="token punctuation">)</span>Reverb Zone Mix：到混响区的输出信号量3D Sound Settings-和Spatial Blend参数成正比应用：Doppler Level：多普勒效果等级Spread：扩散角度设置为3D立体声还是多声道Volume Rolloff-声音衰减速度：Logarithmic Rolloff：靠近音频源时，声音很大，但离开对象时，声音降低得非常快。Linear Rolloff：与音频源的距离越远，听到的声音越小。Custom Rolloff：音频源的音频效果是根据曲线图的设置变化的。Min/Max Distance：最小距离内，声音保持最大响度；最大距离外，声音开始减弱；AudioListener-音频监听脚本；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/class-AudioSource.html">音频源 - Unity 手册 (unity3d.com)</a></p><h3 id="音频源代码控制"><a href="#音频源代码控制" class="headerlink" title="音频源代码控制"></a>音频源代码控制</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//知识点一 代码控制播放停止//播放音效audioSource.Play();//延迟播放 填写的是秒数audioSource.PlayDelayed(5);//停止音效audioSource.Stop();//暂停audioSource.Pause();//停止暂停 和暂停后 Play效果是一样的 都会继续播放现在的音效audioSource.UnPause();知识点二 如何检测音效播放完毕//如果你希望某一个音效播放完毕后 想要做什么事情//那就可以在Update生命周期函数中 不停的去检测 它的 该属性//如果是false就代表播放完毕了audioSource.isPlaying知识点三 如何动态控制音效播放//1.直接在要播放音效的对象上挂载脚本 控制播放//2.实例化挂载了音效源脚本的对象//这种方法 其实用的比较少//Instantiate(obj);//3.用一个AudioSource来控制播放不同的音效//AudioSource aus = this.gameObject.AddComponent&lt;AudioSource&gt;();//aus.clip = clip;//aus.Play();//潜在知识点 //一个GameObject可以挂载多个 音效源脚本AudioSource//使用时要注意 如果要挂载多个 那一定要自己管理他们 控制他们的播放 停止 不然 我们没有办法准确的获取//谁是谁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/AudioClip.html">UnityEngine.AudioClip - Unity 脚本 API (unity3d.com)</a></p><h3 id="麦克风输入相关"><a href="#麦克风输入相关" class="headerlink" title="麦克风输入相关"></a>麦克风输入相关</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">知识点一 获取设备麦克风信息string[] strs = Microphone.devices;知识点二 开始录制//参数一：设备名 传空使用默认设备//参数二：超过录制长度后 是否重头录制//参数三：录制时长//参数四：采样率clip = Microphone.Start(null, false, 10, 44100);知识点三 结束录制Microphone.End(null);知识点四 获取音频数据用于存储或者传输//规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度float[] f = new float[clip.channels * clip.samples];clip.GetData(f, 0);print(f.Length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.unity3d.com/cn/2020.3/ScriptReference/Microphone.html">UnityEngine.Microphone - Unity 脚本 API (unity3d.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#进阶</title>
      <link href="/posts/1028.html"/>
      <url>/posts/1028.html</url>
      
        <content type="html"><![CDATA[<h1 id="CLR中简单数据结构类"><a href="#CLR中简单数据结构类" class="headerlink" title="CLR中简单数据结构类"></a>CLR中简单数据结构类</h1><p>命名空间：System.Collections；</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>语法:new ArrayList();<br>建议：本质是一个自动扩容的object数值，存在装箱拆箱，尽量少用；<br><a href="https://www.runoob.com/csharp/csharp-arraylist.html">C# 动态数组(ArrayList) |菜鸟教程 (runoob.com)</a></p><h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack(栈)"></a>Stack(栈)</h2><p>语法：new Stack();<br>建议：存在装箱拆箱；<br><a href="https://www.runoob.com/csharp/csharp-stack.html">C# 堆栈(Stack) | 菜鸟教程 (runoob.com)</a></p><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h2><p>语法：new Queue();<br>建议：存在装箱拆箱；<br><a href="https://www.runoob.com/csharp/csharp-queue.html">C# 队列(队列) |菜鸟教程 (runoob.com)</a></p><h2 id="Hashtable-哈希表"><a href="#Hashtable-哈希表" class="headerlink" title="Hashtable(哈希表)"></a>Hashtable(哈希表)</h2><p>定义：又叫散列表，是基于键的哈希代码组织起来的键值对，主要用来提高数据查询效率；<br>语法：new Hashtable();<br>迭代器遍历法:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">IDictionaryEnumerator me=哈希表对象名.GetEnumerator();while(me.MoveNext()){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>建议：存在装箱拆箱；<br><a href="https://www.runoob.com/csharp/csharp-hashtable.html">C# 哈希表(Hashtable) |菜鸟教程 (runoob.com)</a></p><h1 id="CLR中的泛形"><a href="#CLR中的泛形" class="headerlink" title="CLR中的泛形"></a>CLR中的泛形</h1><p>命名空间：System.Collections.Generic</p><h2 id="泛形"><a href="#泛形" class="headerlink" title="泛形"></a>泛形</h2><p>定义：通过类型参数来实现代码操作多种类型；<br>原理：相当于占位符，定义类或者方法是用替代符代替变量类型，当真正使用时再指定具体类型；</p><h2 id="泛形约束"><a href="#泛形约束" class="headerlink" title="泛形约束"></a>泛形约束</h2><p>关键字：where，可以多个使用;<br>种类：6种如下：<br>1.值类型  where 泛形字母:struct；<br>2.引用类型 where 泛形字母:class；<br>3.存在无参公共构造函数 where 泛形字母:new()；<br>4.某个类本身或者派生类 where 泛形字母:类名；<br>5.每个接口的派生 where 泛形字母:接口名；<br>6.另一个泛形类型或者派生类型 where 泛形字母:另一个泛形字母；</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>定义：表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。<br>语法：new List&lt;&gt;();<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1?view=net-6.0">List 类 (System.Collections.Generic) | Microsoft Docs</a></p><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>定义：表示键和值的集合。<br>语法：new Dictionart&lt;键,值&gt;();<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0">Dictionary 类 (System.Collections.Generic) | Microsoft Docs</a></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>定义：表示双重链接列表。<br>语法：new LinkedList&lt;&gt;();<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.linkedlist-1?view=net-6.0">LinkedList 类 (System.Collections.Generic) | Microsoft Docs</a></p><h2 id="泛形队列"><a href="#泛形队列" class="headerlink" title="泛形队列"></a>泛形队列</h2><p>定义：表示对象的先进先出泛形集合。<br>语法：new Queue&lt;&gt;();<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.queue-1?view=net-6.0">Queue 类 (System.Collections.Generic) | Microsoft Docs</a></p><h2 id="泛形栈"><a href="#泛形栈" class="headerlink" title="泛形栈"></a>泛形栈</h2><p>定义：表示相同指定类型的实例可变大小的后进先出 (LIFO) 集合。<br>语法：new Stack&lt;&gt;();<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.stack-1?view=net-6.0">Stack 类 (System.Collections.Generic) | Microsoft Docs</a></p><h1 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>定义：C# 中的委托(Delegate)类似于 C 或 C++ 中函数的指针,本质时一个类。委托(Delegate) 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变，专门用来装载函数的容器。<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//定义访问修饰符 delegate 返回值类型 委托名&lt;泛形类型&gt;(参数列表)//实例化委托名 变量名=new 委托名();//赋值,参数要一致变量名[+或-]=方法名()//使用委托变量名(对应参数):<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>系统自带的委托：Action&lt;泛形类型,……泛形类型&gt;和Func&lt;泛形类型,…..返回值&gt;;(d都支持16个泛形类型)</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>定义:让委托使用更加安全，事件是一种特殊的变量类型<br>语法：访问修饰符 event 委托类型 事件名<br>和委托区别：不能再类外部赋值(可以加减)，不能在类外部调用，只能在类内部封装调用；</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>定义：没有名字的函数，要配合委托和事件使用；<br>缺点：没有名字，无法通过+-移除；<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Action a=delegate(参数列表){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Lambad表达式"><a href="#Lambad表达式" class="headerlink" title="Lambad表达式"></a>Lambad表达式</h2><p>定义：可以理解成是匿名函数的简写；</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">(参数列表)=&gt;{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="多线程和任务"><a href="#多线程和任务" class="headerlink" title="多线程和任务"></a>多线程和任务</h1><p>前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程<br>后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程<br>线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存</p><h2 id="多线程-Thread"><a href="#多线程-Thread" class="headerlink" title="多线程(Thread)"></a>多线程(Thread)</h2><p>命名空间：using System.Threading<br>语法:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//启动线程，将要执行的代码逻辑封装到一个函数语句块中Thread 线程名=new Thread(委托方法);//启动线程线程名.start();//设置为后台线程,当进程结束后台线程结束线程名.IsBackground=true;//关闭释放一个死循环进程，有俩中方法  //为线程死循环加一个标志变量  //通过线程提供的方法(在.net core版本会无法中止报错),可以加异常捕捉  线程名.Abort();//线程休眠线程名.Sleep(时间/ms);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.runoob.com/csharp/csharp-multithreading.html">C# 多线程 | 菜鸟教程 (runoob.com)</a></p><p>共享数据问题：多线程操作同一内存区域可能出现问题，可以通过加锁的形式避免问题</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">lock(同一引用类型变量){  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="线程池-ThreadPoll"><a href="#线程池-ThreadPoll" class="headerlink" title="线程池(ThreadPoll)"></a>线程池(ThreadPoll)</h2><p>命名空间：using System.Threading<br>定义:ThreadPoll是线程池(享元设计模式)，其目的是为了减少开启新线程消耗的资源(使用线程池中的空闲线程，不必在开启新线程，以及统一管理线程(线程池中的线程执行完毕后，回归到线程池里，等待新任务).<br>优缺点：ThreadPoll性能优于Thread，但是Thread和ThreadPoll对线程的控制都不是很好，例如线程等待(线程执行一段时间无响应后，直接停止线程，释放资源 等 都没有直接的API来控制 只能通过硬编码来实现，同时ThreadPool使用的是线程池全局队列，全局队列中的线程依旧会存在竞争共享资源的情况，从而影响性能。<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//快速启动ThreadPool.QueueUserWorkItem(委托方法);//获取线程池中辅助线程的最大数量(workerThreadsMax)和线程池中异步I/O线程的最大数量(completionPortThreadsMax)ThreadPool.GetMaxThreads(out int workerThreadsMax, out int completionPortThreadsMax);//获取线程池中辅助线程的最小数量(workerThreadsMin)和线程池中异步I/O线程的最小数量(completionPortThreadsMin)ThreadPool.GetMinThreads(out int workerThreadsMin, out int completionPortThreadsMin);//设置最大线程数量 和 设置最小线程数量，在进程内是全局的。在一个地方设置了，后面所有的请求中都是这个数量了//委托异步调用、Task、Parallel、async/await 都使用的是线程池的线程； new Thread()不受限制，但是会占用线程池的数量。ThreadPool.SetMaxThreads(12, 12);//不能低于当前电脑的线程数；比如四核八线程，就不能低于8，否则无效ThreadPool.SetMinThreads(1, 1); //线程等待，需要使用ManualResetEvent来完成ManualResetEvent mre = new ManualResetEvent(false);ThreadPool.QueueUserWorkItem((obj) =&gt; {    DoSomething("");    mre.Set();} );mre.WaitOne()；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="任务-Task"><a href="#任务-Task" class="headerlink" title="任务(Task)"></a>任务(Task)</h2><p>命名空间：using System.Threading.Tasks<br>特点：Task是基于任务的异步编程模型,Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。<br>建议：使用Task的时候应该尽量结合async和await关键字来使用。避免使用.Result 和 .Wait()来阻塞等待;.Result 和 .Wait()会占用线程资源，直到任务完成；而await的基于异步回调的，不会浪费CPU资源；async和await是语法糖，本质上其实是ContinueWith()。<br>基本语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//Task使用方式1Task task1 = new Task(() =&gt; { DoSomething("张三"); });task1.Start(); //Task使用方式2var taskFactory = Task.Factory;Task&lt;int&gt; t1 = taskFactory.StartNew&lt;int&gt;(() =&gt; { DoSomething("王五"); return 1; });Task t2 = taskFactory.StartNew(() =&gt; { DoSomething("赵六"); }); Task t3 = taskFactory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =&gt; {     Console.WriteLine("所有线程都完成了，就会调用这个函数， 不会阻塞主线程"); });Task t4 = taskFactory.ContinueWhenAny(new Task[] { t1, t2 }, (t) =&gt;{    Console.WriteLine("任意一个线程完成了，就会调用这个函数， 不会阻塞主线程");}); //Task使用方式3Task&lt;int&gt; task = Task.Run&lt;int&gt;(() =&gt; { DoSomething("李四"); return 1; }); int temp = task.Result; //阻塞执行完毕并获取结果，不建议使用这种方式task.Wait(); //阻塞，直到子线程执行完毕，不建议使用这种方式await task; //阻塞，直到子线程执行完毕。 但是主线程(调用方)将继续往下执行，await task后面的代码等同于封装在ContinueWith()里面  //Task其它使用方式 //Task.Delay(2000)不阻塞当前线程，一般配合ContinueWith使用，在ContinueWith里面的子线程将等待2秒之后执行 //Thread.Sleep(2000)是阻塞当前线程 Task task3 = Task.Delay(2000).ContinueWith((t) =&gt;{});//等待所有线程完成Task.WaitAll(new Task[] { task1, t1 });//等待任意一个线程完成Task.WaitAny(new Task[] { task1, t1 });//线程回调task1.ContinueWith((o) =&gt;{     Console.WriteLine("线程回调，task1执行完毕之后执行这里。");}//Task取消任务CancellationTokenSource tokenSource = new CancellationTokenSource();CancellationToken token = tokenSource.Token;ManualResetEvent resetEvent = new ManualResetEvent(true);//定义任务Task task = new Task(async () =&gt; {    while (true) {          if (token.IsCancellationRequested) {            return;        }                // 初始化为true时执行WaitOne不阻塞        resetEvent.WaitOne();        // Doing something.......                // 模拟等待100ms        await Task.Delay(100);    }}, token);//任务开始task.Start();//任务暂停resetEvent.Reset();//任务继续resetEvent.Set();//取消TasktokenSource.Cancel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>async/await语法使用案例：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">static void Main(string[] args){    string content = GetContentAsync(Environment.CurrentDirectory + @"/test.txt").Result;    //调用同步方法    //string content = GetContent(Environment.CurrentDirectory + @"/test.txt");    Console.WriteLine(content);    Console.ReadKey();}//异步读取文件内容async static Task&lt;string&gt; GetContentAsync(string filename){        FileStream fs = new FileStream(filename, FileMode.Open);    var bytes = new byte[fs.Length];    //ReadAync方法异步读取内容，不阻塞线程    Console.WriteLine("开始读取文件");    int len = await fs.ReadAsync(bytes, 0, bytes.Length);    string result = Encoding.UTF8.GetString(bytes);    return result;}//同步读取文件内容static string GetContent(string filename){    FileStream fs = new FileStream(filename, FileMode.Open);    var bytes = new byte[fs.Length];    //Read方法同步读取内容，阻塞线程    int len =  fs.Read(bytes, 0, bytes.Length);    string result = Encoding.UTF8.GetString(bytes);    return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><h2 id="什么是编译器"><a href="#什么是编译器" class="headerlink" title="什么是编译器"></a>什么是编译器</h2><p>源语言程序：某种程序设计语言写的，像c#、c、c++、java等；<br>目标语言程序：计算机可以识别的二进制数程序；<br>编译器：是一种翻译程序(编译原理 )，将源语言程序翻译成目标语言程序；</p><h2 id="什么是预处理器指令"><a href="#什么是预处理器指令" class="headerlink" title="什么是预处理器指令"></a>什么是预处理器指令</h2><p>定义：指导编译器，在实际编译开始时对信息进行预处理，都是以#开始，不是指令，所以不以；结束；</p><h2 id="常见的预处理器指令"><a href="#常见的预处理器指令" class="headerlink" title="常见的预处理器指令"></a>常见的预处理器指令</h2><p>//写在脚本最前面，配合if指令或特性使用<br>1.#define：定义一个符号，类似一个没有值的变量<br>2.#undef：取消define定义的符号<br>3.#if、#elif、#else、#endif：和if语法规则一样，用于告诉编译器进行编译代码的流程控制；<br>4.#warning、#error：告诉编译器是报警告还是报错；</p><h1 id="反射和特性"><a href="#反射和特性" class="headerlink" title="反射和特性"></a>反射和特性</h1><p>程序集：由编译器编译(.exe或者.dll)，供编译执行的中间产物；<br>元数据：数据的数据；</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>概念：程序正在运行时可以查看其他程序集或者自己的元数据这就叫反射；<br>type定义：类的信息类，是访问元数据的主要方式，反射的技术；<br>语法：获取的type指向的内存都是一样的</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.通过object.GetType()获取对象的TypeType t1=object.GetType();//2.通过typeof关键字获取类的TypeType t2=typeof(int);//3.通过类名获取，但是必须有命名空间Type p3=Type.GetType("System.Int32");//程序集获取t1.Assembly;//获取类的所有公共成员MemberInfo[] infos=t1.GetMembers();//获取类所有构造函数并调用ConstructorInfo[] ctors=t1.GetConstructors();//获取构造函数传入 Type数组 数组中按顺序是参数类型，执行构造函数传入 object数组 表示按顺序传入的参数；//得到无参构造ConstructorInfo info =t1.GetConstructor(new Type[]);info.Invoke(null) as 类名;//得到有参构造ConstructorInfo info =t1.GetConstructor(new Type[]{typeof(int)});info.Invoke(new object[]{2}) as 类名;//得到所有成员变量FieldInfo[] fieldINfos=t1.GetFields();//得到指定名称的公共成员变量FieldInfo infoj=t1.GetField("变量名")；//通过反射获取变量值infoj.GetValue(类实例);//通过反射设置变量值infoj.SetValue(类实例,要赋的值)；//获得类的公共成员方法MethodInfo[] methods=t1.GetMethods();//获取指定方法MethodInfo method=t1.GetMethod("方法名"，new Type[]{反射参数类型同上});method.Invoke(参数)；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>定义：本质是个类，可以利用特性类为元数据添加额外信息，之后可以用反射获取这些额外信息，类、变量、函数前都可以添加；<br>自定义特性：继承特性基类 Attribute(使用自定义特性时类名后面会省略Attribute这几个字);<br>语法</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.定义特性class 特性类名：Attribute{}//2.特性使用[特性名(参数列表)]//类、函数、变量上一行//3.判断是否使用了某个特性//参数一：特性的类型   参数二：是否搜索继承链(属性和时间忽略)if(类type类型.IsDefind(typeof(特性类型)，false)){}//4.获取Type元数据中的所有特性t.GetCustomAttributes(ture);//5.为特性类加特性，限制自定义特性//参数一：AttributeTargets--特性可以用在哪里//参数二：AllowMultiple--是否允许多个特性在同一个目标上//参数三：Inherited--特性是否能被派生类和重写成员继承[AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple=true,Inherited=true)]//6.系统自带特性//6.1过时特性[Obsolete("过时特性，后面是ture直接报错，否则警告"，false)]//6.2调用者信息特性用处不大，省略，用工具就可以了//6.3条件编译特性//和#define配套使用，必须有该参数名的预指令符号才会执行修饰成员using System.Runtime.CompilerServices[Conditional("Fun")]//6.4外部Dll包函数特性//用来标记非.Net的函数，表明在一个外部的DLL中定义，用来调用c或者c++得DLL包写好的方法using System.Runtime.InteropServices[DllImport("程序集全名")]public static extern int 外部DLL元数据函数名()  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><h2 id="lock和using语句块"><a href="#lock和using语句块" class="headerlink" title="lock和using语句块"></a>lock和using语句块</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>定义：确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。<br>注意：<br>1.lock不能锁定空值，但Null是不需要被释放的。<br>2.lock不能锁定string类型，虽然它也是引用类型的。因为字符串类型被CLR“暂留”。即整个程序中任何给定字符串都只有一个实例，具有相同内容的字符串都代表着同一个实例。因此，只要在应用程序进程中的任何位置处具有相同内容的字符串上放置了锁，就将锁定应用程序中与该字符串具有相同内容的字符串。因此，最好锁定不会被暂留的私有或受保护成员。</p><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><p>作用：<br>1.自动释放，避免缓存，内存溢出<br>2.简化try catch 得到在此定义域内自动释放所新建的对象，以简化代码；</p><h2 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h2><p>协变：out<br>逆变：in<br>作用一：用out修饰的泛形只能作为返回值，用in修饰的泛形只能作为参数<br>作用二：用out和in修饰的泛形委托可以i互相装载(有父子关系的委托)</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//结合里氏替换原则理解//协变 父类总是能被子类替代TestOut&lt;Son&gt; os=()=&gt;{  }TestOut&lt;Father&gt; of=os;//参数必须声明outof();//实际上os装的函数返回的是Son的//逆变 子类装父类委托TestIn&lt;Father&gt; of=()=&gt;{  }TestIn&lt;Son&gt; os=of;//参数必须声明inos();//实际上os装的函数返回的是Father的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h2><p>概念：又称为光标(cursor)，是程序设计的软件设计模式，是可以在遍历访问的接口，设计人员无需关心容器的内存细节，能用foreach遍历的类，都实现了迭代器；<br>关键接口：IEnumerator(迭代器实现),IEnumerable(foreach实现，有方法即可);<br>命名空间：using System.Collections;<br>yield return：是c#提供的语法糖(糖衣语法)，可以将复杂逻辑简单化，增加程序可读性，yield关键字可以理解为暂时返回，保留当前状态；</p><h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><h2 id="隐藏类型var"><a href="#隐藏类型var" class="headerlink" title="# 隐藏类型var"></a># 隐藏类型var</h2><p>  可以用来表示任何类型的变量，一般用来临时变量，但是不能再更改类型。</p><h2 id="设置对象初始值"><a href="#设置对象初始值" class="headerlink" title="# 设置对象初始值"></a># 设置对象初始值</h2><p>  可以直接通过大括号来进行赋值。</p><h2 id="设置集合初始值"><a href="#设置集合初始值" class="headerlink" title="# 设置集合初始值"></a># 设置集合初始值</h2><p>  可以直接通过大括号来进行赋值。</p><h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="# 匿名类型"></a># 匿名类型</h2><p>  var变量可声明为自定义的匿名类型，但是只能有变量。<br>语法</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">var v=new {age=10,name="小明};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="# 可空类型"></a># 可空类型</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//1.数值类型使用，声明时再值类型后面加？可以赋值为空int? lue=null; //又如int[] os=null;int? x=os?[0];//2.引用类型使用，相当于一种语法糖，自动判断是否为空,例如判断委托是否为不为空才执行o?Invoke();//3.判断值类型是否为空值变量名.HasValue；//4.安全获取值类型默认值(可以指定默认值)值变量名.GetValueOrDefault(默认值);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="空和并操作符"><a href="#空和并操作符" class="headerlink" title="# 空和并操作符"></a># 空和并操作符</h2><p>定义：左边值？？右边值，左边为null返回右边值，否则左边；</p><h2 id="内插字符串"><a href="#内插字符串" class="headerlink" title="# 内插字符串"></a># 内插字符串</h2><p>  用关键字$，类似于Format拼接字符串。<br>语法</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.WriteLine($"你好，{name}”);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="单句逻辑简略写法"><a href="#单句逻辑简略写法" class="headerlink" title="# 单句逻辑简略写法"></a># 单句逻辑简略写法</h2><p>  逻辑语句只有一句代码的话可以省略{}，而属性只有一句getset可以写成get=&gt;返回值;set=&gt;变量名=要赋的值，方法同理。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#核心</title>
      <link href="/posts/1027.html"/>
      <url>/posts/1027.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h1><p>其他编程方式：面向过程编程；<br>三大特征：封装+继承+多态；<br>七大原则：<br>1.单一原则：一个类只处理自己应该处理的。应该各司其职，例如把每个移动技能都尽量写出一个类，方便修改。<br>2.开闭原则：新功能尽量是加处理而不是改代码。继承就是最明显的开闭原则，不要修改模板的内容，例如定义属性要用方法定义， getset，方便修改，修改类时或者改别人的方法，不清楚逻辑的就再写一个类。<br>3.依赖倒置原则：不依赖于具体实现，要依赖抽象(接口)。要依赖于抽象，不要依赖于具体实现，可以先了解需求，再画图，最后变成代码。<br>4.接口隔离原则：一个接口一个行为。接口里的单一原则，需要分的事件要分清楚。<br>5.里氏替换原则：用父类容器装载子类，任何地方子类都能替换父类。不要修改别人的代码，可以继承他的代码去重写(注：多态：父类的指针指向子类，而调用子类的方法)<br>6.合成复用原则：尽量用组合复用的形式。继承关系中，父类要可以解决子类共同的问题，子类时解决特与的问题，能用现有的类，就别再自己创建类。<br>7.迪米特法则：一个类尽量减少对别的类引用。又叫最少知识原则，减少耦合性，类自己能解决的，尽量不要牵扯别的类，比如A类引用B类的方法，但是B类方法参数改了，A类也要改。</p><h1 id="面向对象三特征-封装"><a href="#面向对象三特征-封装" class="headerlink" title="面向对象三特征-封装"></a>面向对象三特征-封装</h1><p>一般类定义：</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class 类名{  类名 对象名=new 类名; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="类一般成员和封装"><a href="#类一般成员和封装" class="headerlink" title="类一般成员和封装"></a>类一般成员和封装</h2><p>成员变量：成员变量是声明在类中的变量，可以是任意类型；<br>成员方法(函数)：类的成员函数是一个在类定义中有它的定义或原型的函数;<br>访问修饰符种类：public(接口成员、命名空间、枚举默认)、private(类成员)、protected、internal(类、结构、接口、委托默认)；</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数：类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行，构造函数的名称与类的名称完全相同，它没有任何返回类型默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，以下是它的特殊写法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public 类名(参数1，参数2):this(参数1){  //默认会先调用无参构造(this)或者父类构造函数(换成base)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>##析构函数<br>析构函数：类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行，析构函数的名称是在类的名称前加上一个波浪形(~)作为前缀，它不返回值，也不带任何参数，析构函数用于在结束程序(比如关闭文件、释放内存等)之前释放资源，就是当引用类型的堆被回收时被调用，析构函数不能继承或重载。</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>定义:简称GC，当堆(Heap)中的变量没有被任何对象引用时，就会被自动回收；<br>算法：引用计数、标记清除、标记整理、复制集合；<br>注意事项：GC只负责堆的垃圾回收,而栈(stack)的内存时系统自动管理的，值类型有自己的生命周期，会自动分配和释放；<br>原理：C#会把堆中的内存分为0代内存、1代内存、2代内存(代是分代算法，代系数越大速度越慢，内存越大)，新分配的对象会配置在0代内存，每次分配都可能会进行垃圾回收释放内存(0代内存或者1代内存满时)，垃圾回收机制确认堆中的垃圾，首先会标记对象，发现是否有引用，标记后可达对象，未标记未不可达对象(垃圾)，然后就将对象压缩堆(挂起执行托管代码线程)释放垃圾，搬迁可达对象地址到下一代内存(到第二代内存不会在搬迁)，大对象(83kb以上)总认为是第二代内存。<br>手动触发代码：GC.Collect();一般Loading过场景调用</p><h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><p>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 属性类型 属性名{  访问修饰符 get{}//自动属性可以省略{}  访问修饰符 set{}//自动属性可以省略{}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>概念:让对象可以像数组一样通过索引访问元素，索引器可以重载；<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 返回值 this[参数1、参数2]{  get{}  set{}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态类和静态成员static"><a href="#静态类和静态成员static" class="headerlink" title="静态类和静态成员static"></a>静态类和静态成员static</h2><p>静态类：不能被实例化，只能有静态成员；<br>静态变量：当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本；<br>静态函数：这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在；<br>静态构造函数：不能使用访问修饰符，不能有参数，使用静态类或者普通类的成员时会自动且仅调用一次；</p><h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><p>特点：一定是写在静态类，一定是静态函数，第一个参数为拓展目标，第一个参数用this修饰；<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数1，参数2){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>概念：使用operator关键字让自定义类和结构体可以使用运算符；<br>特点：一定是公告静态方法，返回值在operator前(条件运算要成对出现，一个符号可以多个重载，不能使用ref和out);<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static 返回类型 operator 运算符(参数列表){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不可重载的运算符:逻辑与&amp;&amp; 、逻辑非||、索引符[]、强转符号()、点.、三目运算符?:、赋值符号=；</p><h2 id="内部类和分部类"><a href="#内部类和分部类" class="headerlink" title="内部类和分部类"></a>内部类和分部类</h2><p>内部类定义:在一个类中再声明一个类，使用时要外部类点出自己；<br>分部类：用partial把类分成几部分,注意访问修饰符要一样;<br>分部方法:用partial将方法声明和实现分离，强制私有，只能在分部类声明，不能有返回值，不能用out关键字；</p><h1 id="面向对象三特征-继承"><a href="#面向对象三特征-继承" class="headerlink" title="面向对象三特征-继承"></a>面向对象三特征-继承</h1><h2 id="继承基本规则"><a href="#继承基本规则" class="headerlink" title="继承基本规则"></a>继承基本规则</h2><p>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class 类名 ：被继承的类{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>概念:任何父类出现的地方，子类都可以替代<br>语法:</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">父类 变量名=new 子类()；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>###is关键字<br>定义:判断一个对象是否为指定类对象，返回bool值<br>语法:对象 is 类名</p><p>###as关键字<br>定义:将一个对象转换为指定类对象，没有返回null<br>语法:对象 as 类名</p><h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p>特点:实例化时先执行父类构造函数,再执行子类构造函数；</p><h2 id="万物之父和装箱拆箱"><a href="#万物之父和装箱拆箱" class="headerlink" title="万物之父和装箱拆箱"></a>万物之父和装箱拆箱</h2><p>万物之父关键字:object<br>装箱:例如object存储值类型发生，把值类型从栈中迁移到堆中，变成引用类型；<br>拆箱:例如把object转为值类型发生，把引用类型从堆中迁移到栈中，变成值类型；</p><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>概念:使用sealed关键字使类无法再被继承；</p><h1 id="面向对象三特征-多态"><a href="#面向对象三特征-多态" class="headerlink" title="面向对象三特征-多态"></a>面向对象三特征-多态</h1><h2 id="vob"><a href="#vob" class="headerlink" title="vob"></a>vob</h2><p>关键字：virtual(虚函数)和override(重写);</p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>关键字：abstract(抽象函数)；<br>特点：抽象类不能被实例化，但是遵守里氏替换原则，抽象方法没有方法体；</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>关键字:interface；<br>特点：不包含成员变量，只有抽象方法、属性、索引器、事件，成员不能被实现，不能是私有成员，类可以继承多个接口，接口也遵守里氏替换原则；<br>作用：不作为实体基类,但是可以作为一个行为基类;<br>命名规则:帕斯卡命名法前面加I;</p><p>###显示实现接口<br>作用：当实现俩个接口后，其中有相同方法时；<br>语法：用接口名点出方法名;</p><h2 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h2><p>关键字:sealed修饰不能再被重写；</p><h1 id="面向对象相关知识点"><a href="#面向对象相关知识点" class="headerlink" title="面向对象相关知识点"></a>面向对象相关知识点</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>特点：命名空间可以包裹命名空间;<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace 命名空间名{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="万物之父中的方法"><a href="#万物之父中的方法" class="headerlink" title="万物之父中的方法"></a>万物之父中的方法</h2><p>静态方法Equals:判断俩个对象是否相等,值类型比较数值，引用类型比较地址;<br>静态方法RefereceEquals：判断俩个对象引用是否相等，主要用于应用类型，值类型返回始终false;<br>普通方法GetType():获取对象运行时的类型(反射相关);<br>普通方法MemberwiseClone：拷贝对象,引用对象指向相同地址;<br>虚方法Equals:相当于RefereceEquals,但是在种类中ValueType中重写了,可以用来比较值相等；<br>虚方法GetHashCode：获取对象哈希值(对象唯一编码，但是也可能u不同对象哈希码一样)；<br>虚方法ToString：返回对象代表的字符串;</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>注意事项：string大部分方法需要赋值再使用，因为会实例化一个新的字符串；<br>字符串名[]：字符串索引器;<br>(静态)string.Format()：字符串拼接(替代);<br>字符串名.IndexOf()：正向查找字符位置;<br>字符串名.LastIndexOf()：反向查找字符位置;<br>字符串名.Remove()：移除指定位置的字符;<br>字符串名.Replace()：替换指定字符串;<br>字符串名.ToUpper()：字符串全部大写；<br>字符串名.ToLower()：字符串全部小写;<br>字符串名.Substring()：字符串截取；<br>字符串名.Split()：字符串切割；</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>作用：修改字符串而不创建新的对象<br>字符串.Capacity:获取容量；<br>字符串.Append:增；<br>字符串.AppendFormat():拼接；<br>字符串.Insert():插入；<br>字符串.Remove():删；<br>字符串.Clear():清空；<br>索引-字符串[]:用来查和改；<br>str.Replace():替换；</p><h2 id="字符串拼接的方式"><a href="#字符串拼接的方式" class="headerlink" title="字符串拼接的方式"></a>字符串拼接的方式</h2><h3 id="直接通过-拼接"><a href="#直接通过-拼接" class="headerlink" title="直接通过+拼接"></a>直接通过+拼接</h3><p>  会有性能问题，字符串少还好，越多GC越严重。</p><h3 id="通过StringBuilder拼接字符串"><a href="#通过StringBuilder拼接字符串" class="headerlink" title="通过StringBuilder拼接字符串"></a>通过StringBuilder拼接字符串</h3><p>  字符串数量越多性能相对直接+拼接方法越高。</p><h3 id="通过StringBuffer拼接字符串"><a href="#通过StringBuffer拼接字符串" class="headerlink" title="通过StringBuffer拼接字符串"></a>通过StringBuffer拼接字符串</h3><p>  区别：线程安全版的StringBuilder，但是性能不如StringBuilder;</p><h3 id="string-Format"><a href="#string-Format" class="headerlink" title="string.Format"></a>string.Format</h3><p>原理：其底层本质还是StringBuilder来实现的；</p><h3 id="方式拼接字符串"><a href="#方式拼接字符串" class="headerlink" title="$方式拼接字符串"></a>$方式拼接字符串</h3><p>原理：是string.Format简化版，C#6.0新增操作；<br>语法：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str = $"my name is{name}, I'm {age} years old";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h1><h2 id="多脚本文件"><a href="#多脚本文件" class="headerlink" title="多脚本文件"></a>多脚本文件</h2><p>.cs：源码文件<br>.sln：解决方案入口文件<br>.dll：编译文件</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>定义：统一建模语言，是面向对象设计的建模语言；<br>理解：可以通过一些UML可视化软件(visio)就可以生成代码；</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础</title>
      <link href="/posts/1026.html"/>
      <url>/posts/1026.html</url>
      
        <content type="html"><![CDATA[<p>将之前的笔记记录在博客上</p><h1 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h1><p>特点：数据(变量)集合、自定义；</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>  枚举是一个被命名的整形常量集合,可以声明再命名空间、类和结构体中。</p><h3 id="枚举声明"><a href="#枚举声明" class="headerlink" title="枚举声明"></a>枚举声明</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">enum 变量名{  名1,//枚举中默认是0下面累加  名2=4,//可以赋值,下面数值接着从此开始  名3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举的类型转换"><a href="#枚举的类型转换" class="headerlink" title="枚举的类型转换"></a>枚举的类型转换</h3><p>1.枚举和int互转后是数值的转换<br>2.枚举转换成string是枚举名<br>3.string转换成枚举,必须有这个字符串名的枚举名,实例如下：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Enum.Parse(typeof(声明枚举类型名),"Other");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>  数组是储存一组相同的数值集合,下标从0开始。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1,2,3,4……(第数组长度-1个) }；<br>获取长度：数组名.length;</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>声明：变量类型【,】 二维数组名=new 变量类型【行,列】{ { 1,1,1… },{ 1,1,1…. },{ 1,1,1…. }… };<br>获取长度:数组名.length(维度);</p><h3 id="交叉数组"><a href="#交叉数组" class="headerlink" title="交叉数组"></a>交叉数组</h3><p>  即数组的数组。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct 结构体名{  变量类型 变量名    构造函数(可选)    函数}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体和类相同点：<br>1.两者都拥有成员,包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。<br>2.两者的成员都有其各自的存取范围。例如,可以将某一个成员声明为Public,而将另一个成员声明为Private。<br>3.两者都可以实现接口。<br>4.两者都可以公开一个默认属性,然而前提是这个属性至少要取得一个自变量。<br>5.两者都可以声明和触发事件,而且两者都可以声明委托(Delegate)。<br>6.两者都是container类型,这表示它们可以包含其他数据类型作为成员。</p><p>区别：<br>1.结构是实值类型(Value Types),而类则是引用类型(Reference Types)。<br>2.结构使用栈存储(Stack Allocation),而类使用堆存储(Heap Allocation)。<br>3.所有结构成员默认都是Public,而类的变量和常量数则默认位Private,不过其他类成员默认都是Public。<br>4.结构成员不能被声明位Protected,而类成员可以。<br>5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化,但是类变量声明可以。<br>6.结构不能声明默认的构造函数,也就是不拥有参数的非共享构造函数,但是类则无此限制。<br>7.二者都可以拥有共享构造函数,结构的共享构造函数不能带有参数,但是类的共享构造函数则可以带或者不带参数。<br>8.结构不允许声明析构函数(Destructor),类则无此限制。<br>9.结构的实例(Instance)声明,不允许对包含的变量进行初始化设定,类则可以在声明类的实例时,同时进行变量初始化。<br>1.结构是隐式继承自ValueType类,而且不能继承任何其他类型,类则可以继续自ValueType以外的任何类。<br>11.结构是无法被继承的,类则可以。<br>12.结构永远不会终止,因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止,当内存回收进程检测到没有任何作用的类时,它就会调用类的Finalize方法。<br>13.结构不需要构造函数,类则需要构造函数。<br>14.结构只能在一种情况下使用非共享构造函数,那就是非共享构造函数会接受参数。但是类则无此限制,它可以使用带参数或不带参数的非共享构造函数。<br>15.每一个结构都具有无参数的隐含公共构造函数,此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上,由于结构是数值类型的,因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的,而且对象变量可引用不同的类实例,在此方面的区别,会对使用将结构和类造成如下的影响：<br>16.结构变量会隐式的使用结构的无参数构造函数来初始化成员,这就意味语句 Struct S = new Struct()。<br>17.当您将一个结构变量赋值给另一个,或者将结构实例传递到程序变量时,所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个,或者将对象变量传递给程序时,则只是复制指针。<br>18.您可以将Null值赋值给结构变量,但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化,但是您还是可以调用变量的方法并访问其数据成员。相反的,如果您将对象变量设定为Null,您就会中断它与任何类型实例的关联,而且除非您再将另一个实例赋值给它,否则无法通过变量访问任何成员。<br>19.您可以在不同时间将不同的类的实例赋值给同一个对象变量,而且在同一时间可有好几个对象变量引用相同的类实例,如果您对类成员值做了改变,则其他指向相同实例的对象变量也会发生改变。然而,结构成员则会封装在他们自己的实例中,变更结构成员值并不会对其他任何结构变量的成员造成影响,甚至也不会影响相同结构声明的其他实例。<br>20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。</p><p>如何选择结构还是类:<br>1.堆栈的空间有限,对于大量的逻辑的对象,创建类要比创建结构好一些<br>2.结构表示如点、矩形和颜色这样的轻量对象,例如,如果声明一个含有 1000 个点对象的数组,则将为引用每个对象分配附加的内存。在此情况下,结构的成本较低。<br>3.在表现抽象和多级别的对象层次时,类是最好的选择。<br>4.大多数情况下该类型只是一些数据时,结构时最佳的选择。</p><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>  其他类型、结构体；<br>存储位置：栈空间–系统分配,自动回收,小而快<br>特点：在赋值时,把内容拷贝给对方,它变我不变,内存地址不变。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>  string、数组、类<br>存储位置：手动申请和释放,大而慢<br>特点：在赋值时,让俩者指向一个值,它变我也变,指向堆中相同内存地址。</p><h2 id="特殊引用类型string"><a href="#特殊引用类型string" class="headerlink" title="特殊引用类型string"></a>特殊引用类型string</h2><p>  string在赋值时也会再分配一个内存空间。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>  函数可以写在类中和结构体中。</p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>基本语法：static 返回类型 函数名(参数类型 参数名1….){ 代码逻辑；return 返回值  }</p><h2 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h2><p>  在函数内部传入,里面变了,外面也变了。<br>声明：函数参数的修饰符；<br>区别：ref传入的参数必须初始化,out传入的变量必须在内部赋值；</p><h2 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h2><p>变长参数声明：params 变量类型[] 变量名；<br>参数默认值：可选参数,在方法声明时就进行赋值,可选参数必须写在普通参数后面；</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>定义：重载和返回值无关,和参数类型、个数、顺序有关；</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>定义：就是让函数自己调用自己,但是需要留出出口,否则就是死循环</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#入门</title>
      <link href="/posts/1025.html"/>
      <url>/posts/1025.html</url>
      
        <content type="html"><![CDATA[<p>将之前的笔记记录在博客上</p><h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C#基础知识"></a>C#基础知识</h1><h2 id="主流语言的应用领域"><a href="#主流语言的应用领域" class="headerlink" title="主流语言的应用领域"></a>主流语言的应用领域</h2><p>C: 嵌入式硬件开发<br>C++: 游戏客户端、服务器、软件<br>C#: 游戏客户端、服务器、软件、网站</p><p>Java: 安卓、服务器、软件、网站<br>JavaScript: H5游戏、网站、服务器<br>PHP: 网站、服务器<br>Python: 网站、服务器、辅助开发</p><p>SQL: 数据库<br>Go: 服务器<br>Objective-C: 苹果(mac、ios)相关<br>Swift: 苹果(mac、ios)相关</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="IDE是什么"><a href="#IDE是什么" class="headerlink" title="IDE是什么"></a>IDE是什么</h3><p>IDE(Integrated Development Environment )<br>集成开发环境<br>它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调<br>试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。<br>它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代<br>码命令，听从你的指令和你进行交流。</p><h3 id="常用的IDE-集成开发环境-软件"><a href="#常用的IDE-集成开发环境-软件" class="headerlink" title="常用的IDE(集成开发环境)软件"></a>常用的IDE(集成开发环境)软件</h3><p>Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;<br>Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;<br>Android Studio: 谷歌推出，主要用于开发安卓应用;<br>Xcode:苹果推出，主要用于开发苹果应用;</p><h1 id="第一个应用程序"><a href="#第一个应用程序" class="headerlink" title="第一个应用程序"></a>第一个应用程序</h1><h2 id="理解写代码这件事"><a href="#理解写代码这件事" class="headerlink" title="理解写代码这件事"></a>理解写代码这件事</h2><p>通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算<br>机通过这些命令来执行一些行为，从而实现一些特定的需求。<br>比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能<br>够动起来</p><h2 id="注释的三种方式"><a href="#注释的三种方式" class="headerlink" title="注释的三种方式"></a>注释的三种方式</h2><p>1.两杠注释:用于注释一行信息<br>2.星号注释:用于注释多行信息<br>3.三杠注释:用于注释类、命名空间等</p><h2 id="快捷注释的方法"><a href="#快捷注释的方法" class="headerlink" title="快捷注释的方法"></a>快捷注释的方法</h2><p>1.上方工具栏<br>2.快捷键<br>CTRL + K + C 注释<br>CTRL + K + U 取消注释</p><h2 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h2><p>由#region #endregion配对出现</p><h2 id="控制台输入打印语句"><a href="#控制台输入打印语句" class="headerlink" title="控制台输入打印语句"></a>控制台输入打印语句</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.Write():输出Console.WriteLine:换行输出Console.ReadKey:检测用户按下Console.ReadLine:用户输入回车<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="有符号的整形变量"><a href="#有符号的整形变量" class="headerlink" title="有符号的整形变量"></a>有符号的整形变量</h3><p>sbyte: -128-127(字节占1);<br>short:  -32768-32767(字节占2);<br>int: -21亿-21亿多(字节占4);<br>long: -9百万兆-9百万兆(字节占8);</p><h3 id="无符号的整数变量"><a href="#无符号的整数变量" class="headerlink" title="无符号的整数变量"></a>无符号的整数变量</h3><p>byte:0-255(字节占1);<br>ushort: 0-65535(字节占2);<br>uint: 0-42亿多(字节占4);<br>ulong: 0-18百万兆(字节占8);</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;<br>double:(字节占8) 存储15-17位有效数字;<br>decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; </p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><p>bool:非真即假(字节占1);<br>char:存储单个字符(字节占2);<br>string:存储多个字符，没有上限(长度可变);</p><h2 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h2><p>  数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000<br>通过sizeof获取变量占用的内存空间(例如:sizeof(int);;<br>1byte=8bit;<br>1kb=1024byte;<br>1mb=1024kb;<br>1gb=1024mb;<br>1tb=1024gb;</p><h3 id="进制转换-整数，左侧第一位表示符号"><a href="#进制转换-整数，左侧第一位表示符号" class="headerlink" title="进制转换(整数，左侧第一位表示符号)"></a>进制转换(整数，左侧第一位表示符号)</h3><p>十进制转二进制:不停除2;<br>二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0);</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>1.不能重名;<br>2.不能以数字开头;<br>3.不能是关键字;<br>4.不能有特殊符号(下划线除外);</p><p>驼峰命名法(变量)、帕斯卡命名法(函数、类)</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>关键字const，必须初始化，不能被修改。</p><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>  是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行</p><h2 id="固定写法"><a href="#固定写法" class="headerlink" title="固定写法"></a>固定写法</h2><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>':单引号;<br>":双引号<br>\n:换行<br>\:斜杠</p><h3 id="不常用的转义字符"><a href="#不常用的转义字符" class="headerlink" title="不常用的转义字符"></a>不常用的转义字符</h3><p>\t:制表符(空一个tab键)<br>\b:光标退格<br>\0:空字符<br>\a:警告音</p><h3 id="取消转义字符"><a href="#取消转义字符" class="headerlink" title="取消转义字符"></a>取消转义字符</h3><p>  在字符串前面加一个@(例如@”\你好")</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>  不同变量类型之间的相互转换</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>  不同类型之间的自动转换，大范围转小范围</p><h3 id="相同大类型之间的转换"><a href="#相同大类型之间的转换" class="headerlink" title="相同大类型之间的转换"></a>相同大类型之间的转换</h3><p>  特殊类型不存在隐式转换</p><h3 id="不同大类型之间的转换"><a href="#不同大类型之间的转换" class="headerlink" title="不同大类型之间的转换"></a>不同大类型之间的转换</h3><h4 id="无符号和有符号之间"><a href="#无符号和有符号之间" class="headerlink" title="无符号和有符号之间"></a>无符号和有符号之间</h4><p>  有符号的变量不能隐式转换无符号的;<br>  无符号的变量隐式转换有符号的前提是范围一定是涵盖的;</p><h4 id="浮点数和整数之间"><a href="#浮点数和整数之间" class="headerlink" title="浮点数和整数之间"></a>浮点数和整数之间</h4><p>  浮点数可以转任何类型整数;<br>  整数不能转换浮点型(不能存小数);</p><h4 id="特殊类型和其他类型"><a href="#特殊类型和其他类型" class="headerlink" title="特殊类型和其他类型"></a>特殊类型和其他类型</h4><p>  char类型可以隐式转换成整数和浮点型(ASCII码);<br>  bool和string不能和其他类型互相转换;</p><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><p>  手动转换。</p><h3 id="括号强转"><a href="#括号强转" class="headerlink" title="括号强转"></a>括号强转</h3><p>  小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。</p><h3 id="Parse法"><a href="#Parse法" class="headerlink" title="Parse法"></a>Parse法</h3><p>  把字符串类型转换成对应类型，前提能转换，否则报错。<br>语法:变量类型.Parse(“字符串”)</p><h3 id="Convert法"><a href="#Convert法" class="headerlink" title="Convert法"></a>Convert法</h3><p>  更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。<br>语法:Convert.To目标类型(变量或者常量)</p><h3 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h3><p>作用:拼接打印;<br>语法:变量.ToString();</p><h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><p>  避免程序报错造成卡死</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">try{  }catch{  }finally{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>赋值运算符:=<br>算数运算符:+ - * / %<br>复合运算符:+= -+ *= /= %=<br>自增运算符:a++(先用再加)  ++a(先加再用)</p><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>1.乘除大于加减;<br>2.括号优先;</p><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>方法一:+号拼接;<br>方法二:string.Format(“{0}”，18);<br>控制台打印拼接:支持类似方法二;</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>  只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。<br>条件运算符:&gt; &lt; == != &gt;= &lt;=;</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符:&amp;&amp; || !</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>  ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)<br>位或:|(有1则1)<br>异或:^(对位运算，相同为0，不同为1)<br>位取反:~(0变1，1变0，反码补码问题)<br>左右移:&lt;&lt;(左移几位，右边加几个0)   &gt;&gt;(右移几位，右边去几个数)</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>语法:空位(bool类型)？空位:空位;</p><h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">if(){  }else if(){  }else{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">switch(){  case 变量:  break;  default:  break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">while(循环跳出条件){  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">do{  }while();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">for(int i=1;i&lt;条件;i++){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">foreach(var i in 集合需要继承自一个接口){  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><h2 id="控制台相关"><a href="#控制台相关" class="headerlink" title="控制台相关"></a>控制台相关</h2><p>1.Console.Readkey().Keycahr-可以保存输入的字符;<br>2.Console.Clear()-清空控制台;<br>3.Console.SetWindowSize(宽，高);<br>4.Console.SetBufferSize(宽，高)-缓冲区大小;<br>5.Console.SetCursorPosition(x，y)-设置光标的位置<br>6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色<br>7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear<br>8.Console.CursorVisiable=false-设置光标显隐<br>9.Environment.Exit(0)-关闭控制台</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>语法:Random 变量名=new Random();<br>生成非负数:变量名.Next(最小到最大，范围不包括最大);</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
