<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机操作系统原理笔记</title>
      <link href="/posts/513.html"/>
      <url>/posts/513.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-操作系统绪论"><a href="#1-操作系统绪论" class="headerlink" title="1   操作系统绪论"></a>1   操作系统绪论</h1><h2 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1  操作系统概念"></a>1.1  操作系统概念</h2><p>定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。</p><p><strong>特征：</strong>并发、共享、虚拟、异步。</p><h2 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2  操作系统发展历程"></a>1.2  操作系统发展历程</h2><p>手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。</p><h3 id="1-2-1单道批处理"><a href="#1-2-1单道批处理" class="headerlink" title="1.2.1单道批处理"></a>1.2.1单道批处理</h3><p><strong>原理：</strong>计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。</p><p><strong>特征：</strong>内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。</p><h3 id="1-2-2多道批处理"><a href="#1-2-2多道批处理" class="headerlink" title="1.2.2多道批处理"></a>1.2.2多道批处理</h3><p>原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。</p><p>特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。</p><h3 id="1-2-3分时系统"><a href="#1-2-3分时系统" class="headerlink" title="1.2.3分时系统"></a>1.2.3分时系统</h3><p>特征：多路性、独立性、及时性、交互性。</p><h3 id="1-2-4实时系统"><a href="#1-2-4实时系统" class="headerlink" title="1.2.4实时系统"></a>1.2.4实时系统</h3><p><strong>特征：</strong>多路性、独立性、及时性、交互性、可靠性。</p><h1 id="2-操作系统用户界面"><a href="#2-操作系统用户界面" class="headerlink" title="2   操作系统用户界面"></a>2   操作系统用户界面</h1><h2 id="2-1-作业"><a href="#2-1-作业" class="headerlink" title="2.1  作业"></a>2.1  作业</h2><p><strong>定义：</strong>分用户和系统角度去理解</p><p>a)     用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业；</p><p>b)     系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL)</p><h2 id="2-2-一般用户输入输出方式"><a href="#2-2-一般用户输入输出方式" class="headerlink" title="2.2  一般用户输入输出方式"></a>2.2  一般用户输入输出方式</h2><h3 id="2-2-1联机输入输出方式"><a href="#2-2-1联机输入输出方式" class="headerlink" title="2.2.1联机输入输出方式"></a>2.2.1联机输入输出方式</h3><h3 id="2-2-2脱机输入输出方式"><a href="#2-2-2脱机输入输出方式" class="headerlink" title="2.2.2脱机输入输出方式"></a>2.2.2脱机输入输出方式</h3><h3 id="2-2-3直接耦合方式"><a href="#2-2-3直接耦合方式" class="headerlink" title="2.2.3直接耦合方式"></a>2.2.3直接耦合方式</h3><h3 id="2-2-4Spooling系统"><a href="#2-2-4Spooling系统" class="headerlink" title="2.2.4Spooling系统"></a>2.2.4Spooling系统</h3><p><strong>原理：</strong>todo。</p><p><strong>特点：</strong>系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。</p><h3 id="2-2-5网络联机方式"><a href="#2-2-5网络联机方式" class="headerlink" title="2.2.5网络联机方式"></a>2.2.5网络联机方式</h3><h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3  系统调用"></a>2.3  系统调用</h2><p><strong>定义：</strong>系统调用是操作系统留给编程人员的唯一接口。</p><p><strong>原理：</strong>todo</p><h3 id="2-3-1系统调用指令"><a href="#2-3-1系统调用指令" class="headerlink" title="2.3.1系统调用指令"></a>2.3.1系统调用指令</h3><p>int和trap指令进行系统调用。</p><p>call和jmp指令进入普通过程调用(子调用)。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3   进程管理"></a>3   进程管理</h1><h2 id="3-1-进程的概念"><a href="#3-1-进程的概念" class="headerlink" title="3.1  进程的概念"></a>3.1  进程的概念</h2><p><strong>组成：</strong>进程=程序+数据+进程控制块(进程状态信息PCB)</p><p><strong>定义：</strong>进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p><strong>目的：</strong>对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性；</p><p><strong>优缺点：</strong>引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。</p><h2 id="3-2-进程和程序的区别"><a href="#3-2-进程和程序的区别" class="headerlink" title="3.2  进程和程序的区别"></a>3.2  进程和程序的区别</h2><p>a)     进程是动态的，程序是静态的；</p><p>b)     进程是暂时的，程序是永久的；</p><p>c)     组成不同，进程的组成包括程序；</p><p>d)    对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序；</p><p>e)    进程可以并行，具有独立性、异步性。</p><p>f)    进程是竞争计算机资源的基本单位。</p><h2 id="3-3-进程控制块-PCB"><a href="#3-3-进程控制块-PCB" class="headerlink" title="3.3  进程控制块(PCB)"></a>3.3  进程控制块(PCB)</h2><p>进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。</p><h3 id="3-3-1描述信息"><a href="#3-3-1描述信息" class="headerlink" title="3.3.1描述信息"></a>3.3.1描述信息</h3><h3 id="3-3-2控制信息"><a href="#3-3-2控制信息" class="headerlink" title="3.3.2控制信息"></a>3.3.2控制信息</h3><h3 id="3-3-3资源管理信息"><a href="#3-3-3资源管理信息" class="headerlink" title="3.3.3资源管理信息"></a>3.3.3资源管理信息</h3><h3 id="3-3-4CPU保护现场结构"><a href="#3-3-4CPU保护现场结构" class="headerlink" title="3.3.4CPU保护现场结构"></a>3.3.4CPU保护现场结构</h3><h2 id="3-4-进程上下文切换"><a href="#3-4-进程上下文切换" class="headerlink" title="3.4  进程上下文切换"></a>3.4  进程上下文切换</h2><p><strong>原因：</strong>进程中断、超时、进程调用。</p><p><strong>步骤：</strong></p><p>a)    保存被切换进程的正文部分到有关存储区。</p><p>b)    进程有关调度和资源分配程序执行，选取新的进程。</p><p>c)    新进程正文部分从存储区取出，激活选中进程执行。</p><h2 id="3-5-进程的状态和进程转换"><a href="#3-5-进程的状态和进程转换" class="headerlink" title="3.5  进程的状态和进程转换"></a>3.5  进程的状态和进程转换</h2><h3 id="3-5-1进程状态"><a href="#3-5-1进程状态" class="headerlink" title="3.5.1进程状态"></a>3.5.1进程状态</h3><p>初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止))</p><h3 id="3-5-2进程状态转换"><a href="#3-5-2进程状态转换" class="headerlink" title="3.5.2进程状态转换"></a>3.5.2进程状态转换</h3><h2 id="3-6-进程控制"><a href="#3-6-进程控制" class="headerlink" title="3.6  进程控制"></a>3.6  进程控制</h2><h3 id="3-6-1进程创建和撤销"><a href="#3-6-1进程创建和撤销" class="headerlink" title="3.6.1进程创建和撤销"></a>3.6.1进程创建和撤销</h3><h3 id="3-6-2进程阻塞和唤醒"><a href="#3-6-2进程阻塞和唤醒" class="headerlink" title="3.6.2进程阻塞和唤醒"></a>3.6.2进程阻塞和唤醒</h3><h3 id="3-6-3进程的挂起和激活"><a href="#3-6-3进程的挂起和激活" class="headerlink" title="3.6.3进程的挂起和激活"></a>3.6.3进程的挂起和激活</h3><h2 id="3-7-进程互斥和同步"><a href="#3-7-进程互斥和同步" class="headerlink" title="3.7  进程互斥和同步"></a>3.7  进程互斥和同步</h2><h3 id="3-7-1临界区和临界资源"><a href="#3-7-1临界区和临界资源" class="headerlink" title="3.7.1临界区和临界资源"></a>3.7.1临界区和临界资源</h3><p>临界资源是一次仅允许一个进程使用的共享资源。</p><p>临界区是每个进程访问临界资源的那段代码。</p><h3 id="3-7-2信号量和PV原语"><a href="#3-7-2信号量和PV原语" class="headerlink" title="3.7.2信号量和PV原语"></a>3.7.2信号量和PV原语</h3><p>信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。</p><p>信号量的数值仅能由P、V原语操作改变。</p><h3 id="3-7-3互斥的概念"><a href="#3-7-3互斥的概念" class="headerlink" title="3.7.3互斥的概念"></a>3.7.3互斥的概念</h3><p><strong>定义：</strong>不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。</p><h3 id="3-7-4同步的概念"><a href="#3-7-4同步的概念" class="headerlink" title="3.7.4同步的概念"></a>3.7.4同步的概念</h3><p><strong>定义：</strong>对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。</p><h2 id="3-8-进程通信"><a href="#3-8-进程通信" class="headerlink" title="3.8  进程通信"></a>3.8  进程通信</h2><p>Todo</p><h2 id="3-9-死锁问题"><a href="#3-9-死锁问题" class="headerlink" title="3.9  死锁问题"></a>3.9  死锁问题</h2><h3 id="3-9-1死锁的概念"><a href="#3-9-1死锁的概念" class="headerlink" title="3.9.1死锁的概念"></a>3.9.1死锁的概念</h3><p><strong>定义：</strong> 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。</p><p><strong>起因：</strong>并发进程的资源竞争</p><p><strong>条件：</strong>同时具备互斥条件、不剥夺条件、部分分配、环路条件。</p><h3 id="3-9-2死锁的解决方案"><a href="#3-9-2死锁的解决方案" class="headerlink" title="3.9.2死锁的解决方案"></a>3.9.2死锁的解决方案</h3><h4 id="3-9-2-1-死锁预防"><a href="#3-9-2-1-死锁预防" class="headerlink" title="3.9.2.1    死锁预防"></a>3.9.2.1    死锁预防</h4><h4 id="3-9-2-2-死锁避免"><a href="#3-9-2-2-死锁避免" class="headerlink" title="3.9.2.2    死锁避免"></a>3.9.2.2    死锁避免</h4><p>最具代表性的避免算法-银行家算法</p><h4 id="3-9-2-3-死锁的检测和恢复"><a href="#3-9-2-3-死锁的检测和恢复" class="headerlink" title="3.9.2.3    死锁的检测和恢复"></a>3.9.2.3    死锁的检测和恢复</h4><h2 id="3-10-线程"><a href="#3-10-线程" class="headerlink" title="3.10    线程"></a>3.10    线程</h2><h3 id="3-10-1-线程的基本概念"><a href="#3-10-1-线程的基本概念" class="headerlink" title="3.10.1 线程的基本概念"></a>3.10.1 线程的基本概念</h3><p>定义：引入线程后，线程是操作系统调度和分配的基本单位。</p><p>组成：线程=？+线程控制块(TCB)</p><h3 id="3-10-2-线程状态和线程控制块-TCB"><a href="#3-10-2-线程状态和线程控制块-TCB" class="headerlink" title="3.10.2 线程状态和线程控制块(TCB)"></a>3.10.2 线程状态和线程控制块(TCB)</h3><p>线程状态：执行状态、就绪状态、阻塞(等待)状态</p><p>线程控制块数据结构包括：</p><p>a)     线程标识符</p><p>b)     一组寄存器</p><p>c)     线程执行状态</p><p>d)     优先级</p><p>e)     线程专有存储区</p><p>f)     信号屏蔽</p><p>g)    堆栈指针</p><h3 id="3-10-3-线程和进程的区别"><a href="#3-10-3-线程和进程的区别" class="headerlink" title="3.10.3 线程和进程的区别"></a>3.10.3 线程和进程的区别</h3><p>从以下六点讨论</p><p>a)     调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。</p><p>b)     并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。</p><p>c)     拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。</p><p>d)     独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。</p><p>e)     系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。</p><p>f)     支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。</p><h1 id="4-处理机调度"><a href="#4-处理机调度" class="headerlink" title="4   处理机调度"></a>4   处理机调度</h1><h2 id="4-1-调度层级"><a href="#4-1-调度层级" class="headerlink" title="4.1  调度层级"></a>4.1  调度层级</h2><p>一个作业提交后，往往会经历三种层级（加线程四种）</p><h3 id="4-1-1作业调度"><a href="#4-1-1作业调度" class="headerlink" title="4.1.1作业调度"></a>4.1.1作业调度</h3><p>又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。</p><h4 id="4-1-1-1-周转时间相关"><a href="#4-1-1-1-周转时间相关" class="headerlink" title="4.1.1.1    周转时间相关"></a>4.1.1.1    周转时间相关</h4><p>周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间</p><p>平均周转时间=所有作业周转时间之和/总作业数</p><p>带权周转时间=作业周转时间/作业执行时间</p><p>平均带权周转时间=所有带权作业周转时间之和/总作业数</p><h4 id="4-1-1-2-响应时间，截止时间和系统吞吐量"><a href="#4-1-1-2-响应时间，截止时间和系统吞吐量" class="headerlink" title="4.1.1.2     响应时间，截止时间和系统吞吐量"></a>4.1.1.2     响应时间，截止时间和系统吞吐量</h4><p>响应时间是提交请求和返回该请求的响应之间使用的时间<br>截止时间是某任务必须开始执行或者必须完成的最迟时间<br>吞吐量是对单位时间内完成的工作量的量度</p><h3 id="4-1-2交换调度"><a href="#4-1-2交换调度" class="headerlink" title="4.1.2交换调度"></a>4.1.2交换调度</h3><p>又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存</p><h3 id="4-1-3进程调度"><a href="#4-1-3进程调度" class="headerlink" title="4.1.3进程调度"></a>4.1.3进程调度</h3><p>又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式</p><h4 id="4-1-3-1-非抢占方式"><a href="#4-1-3-1-非抢占方式" class="headerlink" title="4.1.3.1    非抢占方式"></a>4.1.3.1    非抢占方式</h4><p>一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。</p><h4 id="4-1-3-2-抢占方式"><a href="#4-1-3-2-抢占方式" class="headerlink" title="4.1.3.2     抢占方式"></a>4.1.3.2     抢占方式</h4><p>系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程</p><p>a)     优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU</p><p>b)     短作业优先原则：就绪的短进程有权抢占长进程的CPU</p><p>c)     时间片原则：一个时间片用完后，系统重新进行进程调度</p><h3 id="4-1-4线程调度"><a href="#4-1-4线程调度" class="headerlink" title="4.1.4线程调度"></a>4.1.4线程调度</h3><p>Todo</p><h2 id="4-2-作业和进程的关系"><a href="#4-2-作业和进程的关系" class="headerlink" title="4.2  作业和进程的关系"></a>4.2  作业和进程的关系</h2><p>系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。</p><h2 id="4-3-调度算法"><a href="#4-3-调度算法" class="headerlink" title="4.3  调度算法"></a>4.3  调度算法</h2><p>宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。</p><p>​    微观调度：轮转法、优先级法、多级反馈轮转法。</p><h1 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5   存储管理"></a>5   存储管理</h1><h2 id="5-1-存储器结构"><a href="#5-1-存储器结构" class="headerlink" title="5.1  存储器结构"></a>5.1  存储器结构</h2><p>由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。</p><h3 id="5-1-1寄存器"><a href="#5-1-1寄存器" class="headerlink" title="5.1.1寄存器"></a>5.1.1寄存器</h3><p>寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。</p><h3 id="5-1-2高速缓存"><a href="#5-1-2高速缓存" class="headerlink" title="5.1.2高速缓存"></a>5.1.2高速缓存</h3><p>它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。</p><h3 id="5-1-3主存输器"><a href="#5-1-3主存输器" class="headerlink" title="5.1.3主存输器"></a>5.1.3主存输器</h3><p>简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。</p><h3 id="5-1-4磁盘缓存"><a href="#5-1-4磁盘缓存" class="headerlink" title="5.1.4磁盘缓存"></a>5.1.4磁盘缓存</h3><p>目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。</p><h2 id="5-2-程序的处理阶段"><a href="#5-2-程序的处理阶段" class="headerlink" title="5.2  程序的处理阶段"></a>5.2  程序的处理阶段</h2><p>主要有编译，链接，装入，下面主要讲链接和装入。</p><h3 id="5-2-1程序的链接"><a href="#5-2-1程序的链接" class="headerlink" title="5.2.1程序的链接"></a>5.2.1程序的链接</h3><p>源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。<br>链接又可分为静态链接，装入时动态链接，运行时动态链接。</p><h3 id="5-2-2程序的装入"><a href="#5-2-2程序的装入" class="headerlink" title="5.2.2程序的装入"></a>5.2.2程序的装入</h3><p>分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。</p><h2 id="5-3-地址变换"><a href="#5-3-地址变换" class="headerlink" title="5.3  地址变换"></a>5.3  地址变换</h2><h3 id="5-3-1静态地址重定向"><a href="#5-3-1静态地址重定向" class="headerlink" title="5.3.1静态地址重定向"></a>5.3.1静态地址重定向</h3><p><strong>原理：</strong>Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。</p><h3 id="5-3-2动态地址重定位"><a href="#5-3-2动态地址重定位" class="headerlink" title="5.3.2动态地址重定位"></a>5.3.2动态地址重定位</h3><p><strong>关系：</strong>MA(物理地址)=BR(基址地址)+VR(虚拟地址)。</p><p>原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。</p><h2 id="5-4-分区存储管理"><a href="#5-4-分区存储管理" class="headerlink" title="5.4  分区存储管理"></a>5.4  分区存储管理</h2><p>分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。</p><h3 id="5-4-1固态分区法"><a href="#5-4-1固态分区法" class="headerlink" title="5.4.1固态分区法"></a>5.4.1固态分区法</h3><p>原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。</p><p>优点:易于实现，开销小。</p><p>缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。</p><h3 id="5-4-2动态分区法"><a href="#5-4-2动态分区法" class="headerlink" title="5.4.2动态分区法"></a>5.4.2动态分区法</h3><p><strong>原理：</strong>动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。</p><p><strong>优点：</strong>没有内碎片；</p><p><strong>缺点：</strong>有外碎片；</p><p><strong>算法：</strong>根据情况有以下俩种，着重介绍三种</p><p>a)     基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法</p><p>b)     基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法</p><h4 id="5-4-2-2-最先适应法"><a href="#5-4-2-2-最先适应法" class="headerlink" title="5.4.2.2     最先适应法"></a>5.4.2.2     最先适应法</h4><h4 id="5-4-2-3-最佳适应法"><a href="#5-4-2-3-最佳适应法" class="headerlink" title="5.4.2.3     最佳适应法"></a>5.4.2.3     最佳适应法</h4><h4 id="5-4-2-4-最坏适应法"><a href="#5-4-2-4-最坏适应法" class="headerlink" title="5.4.2.4     最坏适应法"></a>5.4.2.4     最坏适应法</h4><h3 id="5-4-3页式管理（离散分配）"><a href="#5-4-3页式管理（离散分配）" class="headerlink" title="5.4.3页式管理（离散分配）"></a>5.4.3页式管理（离散分配）</h3><p>基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。</p><h4 id="5-4-3-1-静态页式管理"><a href="#5-4-3-1-静态页式管理" class="headerlink" title="5.4.3.1    静态页式管理"></a>5.4.3.1    静态页式管理</h4><p>原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。</p><h4 id="5-4-3-2-动态页式管理"><a href="#5-4-3-2-动态页式管理" class="headerlink" title="5.4.3.2    动态页式管理"></a>5.4.3.2    动态页式管理</h4><h3 id="5-4-4段式和段页式管理"><a href="#5-4-4段式和段页式管理" class="headerlink" title="5.4.4段式和段页式管理"></a>5.4.4段式和段页式管理</h3><p>基本思想：todo</p><h4 id="5-4-4-1-段式管理"><a href="#5-4-4-1-段式管理" class="headerlink" title="5.4.4.1     段式管理"></a>5.4.4.1     段式管理</h4><p>原理：todo</p><h4 id="5-4-4-2-段页式管理"><a href="#5-4-4-2-段页式管理" class="headerlink" title="5.4.4.2     段页式管理"></a>5.4.4.2     段页式管理</h4><p>原理：todo</p><h3 id="5-4-5覆盖和交换技术"><a href="#5-4-5覆盖和交换技术" class="headerlink" title="5.4.5覆盖和交换技术"></a>5.4.5覆盖和交换技术</h3><h2 id="5-5-虚拟存输器"><a href="#5-5-虚拟存输器" class="headerlink" title="5.5  虚拟存输器"></a>5.5  虚拟存输器</h2><h3 id="5-5-1虚拟存储的实现方式"><a href="#5-5-1虚拟存储的实现方式" class="headerlink" title="5.5.1虚拟存储的实现方式"></a>5.5.1虚拟存储的实现方式</h3><p>虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式：</p><h4 id="5-5-1-1-分页请求系统"><a href="#5-5-1-1-分页请求系统" class="headerlink" title="5.5.1.1     分页请求系统"></a>5.5.1.1     分页请求系统</h4><p>在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。<br>  硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上</p><h4 id="5-5-1-2-请求分段系统"><a href="#5-5-1-2-请求分段系统" class="headerlink" title="5.5.1.2     请求分段系统"></a>5.5.1.2     请求分段系统</h4><p>在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页”</p><h3 id="5-5-2页面置换算法"><a href="#5-5-2页面置换算法" class="headerlink" title="5.5.2页面置换算法"></a>5.5.2页面置换算法</h3><h4 id="5-5-2-1-随机淘汰算法"><a href="#5-5-2-1-随机淘汰算法" class="headerlink" title="5.5.2.1     随机淘汰算法"></a>5.5.2.1     随机淘汰算法</h4><p>随机地选择某个用户地页面并将其换出。</p><h4 id="5-5-2-2-最佳置换算法（理想型淘汰算法OPT）"><a href="#5-5-2-2-最佳置换算法（理想型淘汰算法OPT）" class="headerlink" title="5.5.2.2     最佳置换算法（理想型淘汰算法OPT）"></a>5.5.2.2     最佳置换算法（理想型淘汰算法OPT）</h4><p>其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。</p><h4 id="5-5-2-3-先进先出置换算法（FIFO）"><a href="#5-5-2-3-先进先出置换算法（FIFO）" class="headerlink" title="5.5.2.3     先进先出置换算法（FIFO）"></a>5.5.2.3     先进先出置换算法（FIFO）</h4><p>总是先淘汰最先进入内存的页面。</p><h4 id="5-5-2-4-最近最久未使用算法（LRU）"><a href="#5-5-2-4-最近最久未使用算法（LRU）" class="headerlink" title="5.5.2.4     最近最久未使用算法（LRU）"></a>5.5.2.4     最近最久未使用算法（LRU）</h4><p>选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。</p><h4 id="5-5-2-5-最少使用置换算法（LFU）"><a href="#5-5-2-5-最少使用置换算法（LFU）" class="headerlink" title="5.5.2.5     最少使用置换算法（LFU）"></a>5.5.2.5     最少使用置换算法（LFU）</h4><p>在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。</p><h4 id="5-5-2-6-Clock置换算法"><a href="#5-5-2-6-Clock置换算法" class="headerlink" title="5.5.2.6     Clock置换算法"></a>5.5.2.6     Clock置换算法</h4><p>是一种LRU算法<br>每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；<br>当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；<br>再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面；</p><h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6   文件系统"></a>6   文件系统</h1><h2 id="6-1-文件系统基本概念"><a href="#6-1-文件系统基本概念" class="headerlink" title="6.1  文件系统基本概念"></a>6.1  文件系统基本概念</h2><p><strong>目的：</strong>文件系统地出现是为了更好地管理软件资源</p><p><strong>文件系统的定义：</strong>操作系统中与管理文件有关的软件和数据称为文件系统</p><p><strong>文件的定义：</strong>文件时一段程序和数据的集合</p><p><strong>文件的分类：</strong>按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。</p><h2 id="6-2-文件的逻辑结构和存取方式"><a href="#6-2-文件的逻辑结构和存取方式" class="headerlink" title="6.2  文件的逻辑结构和存取方式"></a>6.2  文件的逻辑结构和存取方式</h2><h3 id="6-2-1逻辑结构"><a href="#6-2-1逻辑结构" class="headerlink" title="6.2.1逻辑结构"></a>6.2.1逻辑结构</h3><p><strong>字符流的无结构文件：</strong>管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。</p><p><strong>记录式的有结构文件：</strong>把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。</p><h4 id="6-2-1-1-连续结构"><a href="#6-2-1-1-连续结构" class="headerlink" title="6.2.1.1     连续结构"></a>6.2.1.1     连续结构</h4><h4 id="6-2-1-2-多重结构"><a href="#6-2-1-2-多重结构" class="headerlink" title="6.2.1.2     多重结构"></a>6.2.1.2     多重结构</h4><h4 id="6-2-1-3-转置结构"><a href="#6-2-1-3-转置结构" class="headerlink" title="6.2.1.3     转置结构"></a>6.2.1.3     转置结构</h4><h4 id="6-2-1-4-顺序结构"><a href="#6-2-1-4-顺序结构" class="headerlink" title="6.2.1.4     顺序结构"></a>6.2.1.4     顺序结构</h4><h3 id="6-2-2逻辑存储方法"><a href="#6-2-2逻辑存储方法" class="headerlink" title="6.2.2逻辑存储方法"></a>6.2.2逻辑存储方法</h3><h4 id="6-2-2-1-顺序存输方法"><a href="#6-2-2-1-顺序存输方法" class="headerlink" title="6.2.2.1     顺序存输方法"></a>6.2.2.1     顺序存输方法</h4><h4 id="6-2-2-2-随机存输方法"><a href="#6-2-2-2-随机存输方法" class="headerlink" title="6.2.2.2     随机存输方法"></a>6.2.2.2     随机存输方法</h4><h4 id="6-2-2-3-按关键字存输方法"><a href="#6-2-2-3-按关键字存输方法" class="headerlink" title="6.2.2.3    按关键字存输方法"></a>6.2.2.3    按关键字存输方法</h4><p>多用于复杂文件系统。</p><h3 id="6-2-3逻辑搜索方式"><a href="#6-2-3逻辑搜索方式" class="headerlink" title="6.2.3逻辑搜索方式"></a>6.2.3逻辑搜索方式</h3><p>文件的获取是要找到文件内容所在的逻辑地址</p><h4 id="6-2-3-1-线性搜索法"><a href="#6-2-3-1-线性搜索法" class="headerlink" title="6.2.3.1     线性搜索法"></a>6.2.3.1     线性搜索法</h4><h4 id="6-2-3-2-散列法"><a href="#6-2-3-2-散列法" class="headerlink" title="6.2.3.2     散列法"></a>6.2.3.2     散列法</h4><h4 id="6-2-3-3-二分搜索法"><a href="#6-2-3-3-二分搜索法" class="headerlink" title="6.2.3.3     二分搜索法"></a>6.2.3.3     二分搜索法</h4><h2 id="6-3-文件的物理结构和存储设备"><a href="#6-3-文件的物理结构和存储设备" class="headerlink" title="6.3  文件的物理结构和存储设备"></a>6.3  文件的物理结构和存储设备</h2><h3 id="6-3-1文件物理结构"><a href="#6-3-1文件物理结构" class="headerlink" title="6.3.1文件物理结构"></a>6.3.1文件物理结构</h3><h4 id="6-3-1-1-连续文件"><a href="#6-3-1-1-连续文件" class="headerlink" title="6.3.1.1    连续文件"></a>6.3.1.1    连续文件</h4><p>连续文件采用连续分配方式：</p><p><strong>特点：</strong>为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。<br><strong>优点：</strong>顺序访问容易; 顺序访问速度快;<br><strong>缺点：</strong>要求有连续的存储空间; 必须事先知道文件的长度;</p><h4 id="6-3-1-2-串联文件"><a href="#6-3-1-2-串联文件" class="headerlink" title="6.3.1.2    串联文件"></a>6.3.1.2    串联文件</h4><p>串联文件采用链接分配</p><p><strong>特点：</strong>文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；<br><strong>优点：</strong>没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间;</p><h4 id="6-3-1-3-索引文件"><a href="#6-3-1-3-索引文件" class="headerlink" title="6.3.1.3    索引文件"></a>6.3.1.3    索引文件</h4><p>索引文件采用索引分配</p><p><strong>特点：</strong>每个文件都有自己的索引块，这是一个磁盘块地址的数组。</p><h3 id="6-3-2文件存储设备"><a href="#6-3-2文件存储设备" class="headerlink" title="6.3.2文件存储设备"></a>6.3.2文件存储设备</h3><p>存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。</p><h4 id="6-3-2-1-顺序存取存储设备—磁带"><a href="#6-3-2-1-顺序存取存储设备—磁带" class="headerlink" title="6.3.2.1    顺序存取存储设备—磁带"></a>6.3.2.1    顺序存取存储设备—磁带</h4><p><strong>特点：</strong>只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。</p><p><strong>影响因素：</strong>信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。</p><h4 id="6-3-2-2-直接存取存储设备—磁盘"><a href="#6-3-2-2-直接存取存储设备—磁盘" class="headerlink" title="6.3.2.2     直接存取存储设备—磁盘"></a>6.3.2.2     直接存取存储设备—磁盘</h4><h2 id="6-4-文件存储空间管理"><a href="#6-4-文件存储空间管理" class="headerlink" title="6.4  文件存储空间管理"></a>6.4  文件存储空间管理</h2><p>文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。</p><h3 id="6-4-1空闲目录管理"><a href="#6-4-1空闲目录管理" class="headerlink" title="6.4.1空闲目录管理"></a>6.4.1空闲目录管理</h3><h3 id="6-4-2空闲链块法"><a href="#6-4-2空闲链块法" class="headerlink" title="6.4.2空闲链块法"></a>6.4.2空闲链块法</h3><h3 id="6-4-3位示图"><a href="#6-4-3位示图" class="headerlink" title="6.4.3位示图"></a>6.4.3位示图</h3><h2 id="6-5-文件目录管理"><a href="#6-5-文件目录管理" class="headerlink" title="6.5  文件目录管理"></a>6.5  文件目录管理</h2><p>从文件管理角度看，一个文件包括文件说明和文件体。</p><h3 id="6-5-1文件目录的种类"><a href="#6-5-1文件目录的种类" class="headerlink" title="6.5.1文件目录的种类"></a>6.5.1文件目录的种类</h3><h4 id="6-5-1-1-单级文件目录"><a href="#6-5-1-1-单级文件目录" class="headerlink" title="6.5.1.1     单级文件目录"></a>6.5.1.1     单级文件目录</h4><p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。</p><h4 id="6-5-1-2-两级文件目录"><a href="#6-5-1-2-两级文件目录" class="headerlink" title="6.5.1.2     两级文件目录"></a>6.5.1.2     两级文件目录</h4><p>目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB；</p><h4 id="6-5-1-3-树形结构目录"><a href="#6-5-1-3-树形结构目录" class="headerlink" title="6.5.1.3     树形结构目录"></a>6.5.1.3     树形结构目录</h4><p>多级目录结构又称为树型目录结构；<br>主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点；</p><h3 id="6-5-2文件目录的共享"><a href="#6-5-2文件目录的共享" class="headerlink" title="6.5.2文件目录的共享"></a>6.5.2文件目录的共享</h3><p>从系统管理的方式来看，有三种方法可以实现文件共享</p><h4 id="6-5-2-1-绕道法"><a href="#6-5-2-1-绕道法" class="headerlink" title="6.5.2.1     绕道法"></a>6.5.2.1     绕道法</h4><h4 id="6-5-2-2-链接法"><a href="#6-5-2-2-链接法" class="headerlink" title="6.5.2.2     链接法"></a>6.5.2.2     链接法</h4><h4 id="6-5-2-3-基本文件目录表（BFD）"><a href="#6-5-2-3-基本文件目录表（BFD）" class="headerlink" title="6.5.2.3    基本文件目录表（BFD）"></a>6.5.2.3    基本文件目录表（BFD）</h4><h3 id="6-5-3目录管理"><a href="#6-5-3目录管理" class="headerlink" title="6.5.3目录管理"></a>6.5.3目录管理</h3><p>文件目录管理应该存放在磁盘，其他的没理解todo</p><h2 id="6-6-文件存取控制"><a href="#6-6-文件存取控制" class="headerlink" title="6.6  文件存取控制"></a>6.6  文件存取控制</h2><p>用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。</p><h3 id="6-6-1存取控制矩阵"><a href="#6-6-1存取控制矩阵" class="headerlink" title="6.6.1存取控制矩阵"></a>6.6.1存取控制矩阵</h3><h3 id="6-6-2存取控制表"><a href="#6-6-2存取控制表" class="headerlink" title="6.6.2存取控制表"></a>6.6.2存取控制表</h3><h3 id="6-6-3口令方式"><a href="#6-6-3口令方式" class="headerlink" title="6.6.3口令方式"></a>6.6.3口令方式</h3><h3 id="6-6-4密码方式"><a href="#6-6-4密码方式" class="headerlink" title="6.6.4密码方式"></a>6.6.4密码方式</h3><p>密码方式是保密性最好的验证方式。</p><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7    设备管理"></a>7    设备管理</h1><h2 id="7-1-设备的分类"><a href="#7-1-设备的分类" class="headerlink" title="7.1  设备的分类"></a>7.1  设备的分类</h2><p>在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。</p><h2 id="7-2-数据传输控制方式"><a href="#7-2-数据传输控制方式" class="headerlink" title="7.2  数据传输控制方式"></a>7.2  数据传输控制方式</h2><p>设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。</p><h3 id="7-2-1程序直接控制方式"><a href="#7-2-1程序直接控制方式" class="headerlink" title="7.2.1程序直接控制方式"></a>7.2.1程序直接控制方式</h3><p>由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。</p><h3 id="7-2-2中断方式"><a href="#7-2-2中断方式" class="headerlink" title="7.2.2中断方式"></a>7.2.2中断方式</h3><p>I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。</p><h3 id="7-2-3DMA方式"><a href="#7-2-3DMA方式" class="headerlink" title="7.2.3DMA方式"></a>7.2.3DMA方式</h3><p>在外围设备和内存之间开辟直接的数据交换通道。</p><h3 id="7-2-4通道控制方式"><a href="#7-2-4通道控制方式" class="headerlink" title="7.2.4通道控制方式"></a>7.2.4通道控制方式</h3><p>以内存为中心，实现设备和内存直接交换数据的控制的方式。</p><h2 id="7-3-中断技术"><a href="#7-3-中断技术" class="headerlink" title="7.3  中断技术"></a>7.3  中断技术</h2><p><strong>原理：</strong>中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。</p><p><strong>过程：</strong>判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点</p><h3 id="7-3-1中断技术的分类"><a href="#7-3-1中断技术的分类" class="headerlink" title="7.3.1中断技术的分类"></a>7.3.1中断技术的分类</h3><p>中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。</p><h4 id="7-3-1-1-外中断"><a href="#7-3-1-1-外中断" class="headerlink" title="7.3.1.1    外中断"></a>7.3.1.1    外中断</h4><p>一般是来自处理机和内存外部的中断</p><h4 id="7-3-1-2-内中断（陷阱）"><a href="#7-3-1-2-内中断（陷阱）" class="headerlink" title="7.3.1.2    内中断（陷阱）"></a>7.3.1.2    内中断（陷阱）</h4><p>一般是来自处理机和内存内部的中断</p><h4 id="7-3-1-3-软中断"><a href="#7-3-1-3-软中断" class="headerlink" title="7.3.1.3    软中断"></a>7.3.1.3    软中断</h4><p>是通信进程之间模拟硬中断的一种信号通信方式</p><h2 id="7-4-缓冲技术"><a href="#7-4-缓冲技术" class="headerlink" title="7.4  缓冲技术"></a>7.4  缓冲技术</h2><p><strong>目的：</strong>缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。</p><p><strong>分类：</strong>缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。</p><h3 id="7-4-1缓冲池的结构"><a href="#7-4-1缓冲池的结构" class="headerlink" title="7.4.1缓冲池的结构"></a>7.4.1缓冲池的结构</h3><p>缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。</p><h3 id="7-4-2缓冲池管理"><a href="#7-4-2缓冲池管理" class="headerlink" title="7.4.2缓冲池管理"></a>7.4.2缓冲池管理</h3><p>Todo</p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法格式（.md后缀-使用typora）</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法格式"><a href="#Markdown语法格式" class="headerlink" title="Markdown语法格式"></a>Markdown语法格式</h1><h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#标题1 （大）</span><span class="token comment">##标题2</span><span class="token comment">###标题3</span><span class="token comment">####标题4 （小）</span>以此类推 最高标题6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">​```代码块名称<span class="token punctuation">(</span>可以输入各种语言java、c++、html等<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="加粗："><a href="#加粗：" class="headerlink" title="加粗："></a>加粗：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//加粗**加粗**//代码高亮显示<span class="token operator">==</span>高亮<span class="token operator">==</span>//删除线~~删除线~~//斜体  *斜体内容*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//引用语法<span class="token operator">&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span>作者：泽<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>作者：泽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//分割线---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="图片插入："><a href="#图片插入：" class="headerlink" title="图片插入："></a>图片插入：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//在线图片与本地图片<span class="token operator">!</span><span class="token punctuation">[</span>照片名子<span class="token punctuation">]</span>（/image/me.png）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//超链接语法<span class="token punctuation">[</span>超链接名字<span class="token punctuation">]</span>（https://gihub.com/yerenping）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//无需列表- 目录1  -后加空格- 目录2- 目录3//有序列表  <span class="token number">1</span>+. +名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">右键》插入》表格用代码过于复杂不推荐使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="/posts/514.html"/>
      <url>/posts/514.html</url>
      
        <content type="html"><![CDATA[<p>列举一些常用的排序算法</p><p>#冒泡排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 冒泡排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void BubbleSort(int[] array, int count){    //设置标识符，如果为false意为当前数组为有序，不需要再排序了    bool shouldSorted = true;    for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++)    {        shouldSorted = false;        for (int j = count - 1; j &gt; i; j--)        {            if (array[j - 1] &gt; array[j])            {                shouldSorted = true;                Utilities.Swap(ref array[j - 1], ref array[j]);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#选择排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 选择排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void SelectSort(int[] array, int count){    int min;    for (int i = 0; i &lt; count - 1; i++)    {        min = i;        for (int j = i + 1; j &lt; count; j++)        {            if (array[min] &gt; array[j])            {                min = j;            }        }        if (min != i)        {            Utilities.Swap(ref array[min], ref array[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#插入排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 插入排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void InserSort(int[] array, int count){    int guard; //哨兵，用于暂存需要交换的值    for (int i = 0; i &lt; count - 1; i++)    {        if (array[i] &gt; array[i + 1])        {            guard = array[i + 1];            int j;            for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--)            {                array[j + 1] = array[j]; //赋值操作（依次后移）            }            array[j + 1] = guard;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#希尔排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 希尔排序/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void ShellSort(int[] array, int count){    int i, j, guard;    int increment = count;    do    {        increment = increment / 3 + 1; //增量序列        for (i = increment + 1; i &lt; count; i++)        {            if (array[i] &lt; array[i - increment])            {                guard = array[i]; //暂存在哨兵处                for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment)                {                    array[j + increment] = array[j]; //记录后移，查找插入位置                }                array[j + increment] = guard; //插入            }        }    } while (increment &gt; 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#堆排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 堆排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void HeapSort(int[] array, int count){    for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆    {        HeapAdjust(array, i, count - 1);    }    for (int i = count - 1; i &gt; 0; i--)    {        Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换        HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆    }}/// &lt;summary&gt;/// 堆排序_构造大顶堆函数/// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义/// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="startIndex"&gt;起始位置&lt;/param&gt;/// &lt;param name="endIndex"&gt;结束位置&lt;/param&gt;public static void HeapAdjust(int[] array, int startIndex, int endIndex){    int temp;    temp = array[startIndex];    for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选    {        if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1])        {            ++i; //i为关键字中较大记录的下标        }        if (temp &gt; array[i])        {            break; //rc应插入在位置s上        }        array[startIndex] = array[i];        startIndex = i;    }    array[startIndex] = temp; //插入}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#归并排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 归并排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void MergeSort(int[] array, int count){    int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果    int k = 1;    while (k &lt; count)    {        MergePass(array, tempArray, k, count); //array归并到tempArray        k = 2 * k; //子序列长度加倍        MergePass(tempArray, array, k, count); //tempArray归并到array        k = 2 * k; //子序列长度加倍    }}/// &lt;summary&gt;/// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="srChildLength"&gt;SR中子序列长度&lt;/param&gt;/// &lt;param name="arrayLength"&gt;原数组长度&lt;/param&gt;public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength){    int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数    while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2,            hasMergeCount + 2 * srChildLength - 2); //两两归并        hasMergeCount += 2 * srChildLength;    }    if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列    {        Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1);    }    else //若最后只剩下单个子序列    {        for (int j = hasMergeCount - 1; j &lt; arrayLength; j++)        {            tr[j] = sr[j];        }    }}/// &lt;summary&gt;/// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex]/// &lt;/summary&gt;/// &lt;param name="sr"&gt;SR数组&lt;/param&gt;/// &lt;param name="tr"&gt;TR数组&lt;/param&gt;/// &lt;param name="sr1StartIndex"&gt;SR数组子序列1起始位置&lt;/param&gt;/// &lt;param name="sr1EndIndex"&gt;SR数组子序列1结束位置&lt;/param&gt;/// &lt;param name="sr2EndIndex"&gt;SR数组子序列2结束位置&lt;/param&gt;private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex){    int sr2StartIndex, currentProcess; //currentProcess为当前进度    for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex;        sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex;        currentProcess++) //两个SR有一个被榨干后就要退出循环    {        if (sr[sr1StartIndex] &lt; sr[sr2StartIndex])        {            tr[currentProcess] = sr[sr1StartIndex++];        }        else        {            tr[currentProcess] = sr[sr2StartIndex++];        }    }    if (sr1StartIndex &lt;= sr1EndIndex)    {        for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++)        {            tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR        }    }    if (sr2StartIndex &lt;= sr2EndIndex)    {        for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++)        {            tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#快速排序</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">/// &lt;summary&gt;/// 快速排序_主函数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="count"&gt;数组元素个数&lt;/param&gt;public static void QuickSort(int[] array, int count){    QSort(array, 0, count - 1);}/// &lt;summary&gt;/// 快速排序_递归调用/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;private static void QSort(int[] array, int low, int high){    int pivot;    while (low &lt; high)    {        pivot = Partition(array, low, high);        QSort(array, low, pivot - 1);        //尾递归，可以减少一次递归堆栈深度        low = pivot + 1;    }}/// &lt;summary&gt;/// 获取枢轴数/// &lt;/summary&gt;/// &lt;param name="array"&gt;数组&lt;/param&gt;/// &lt;param name="low"&gt;低位索引&lt;/param&gt;/// &lt;param name="high"&gt;高位索引&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static int Partition(int[] array, int low, int high){    int pivotkey;    int m = low + (high - low) / 2;    //下面是三数取中优化    //交换左端与右端数据，保证左端较小    if (array[low] &gt; array[high])    {        Utilities.Swap(ref array[low],ref array[high]);    }    //交换中间与右端数据，保证中间较小    if (array[m] &gt; array[high])    {        Utilities.Swap(ref array[m],ref array[high]);    }    //交换中间与左端数据，保证左端较小    if (array[m] &gt; array[low])    {        Utilities.Swap(ref array[low],ref array[m]);    }    //默认选取当前数组的第一个值作为枢轴值    pivotkey = array[low];    //枢轴备份    int pivotkeyback = pivotkey;    while (low &lt; high)    {        while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey)        {            high--;        }        array[low] = array[high];        while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey)        {            low++;        }        array[high] = array[low];    }    //将枢轴数值替换回array[low]    array[low] = pivotkeyback;    //返回当前枢轴下标    return low;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#各种排序时空复杂度<br>![Image text]（<a href="https://s4.ax1x.com/2022/01/24/7o1K0O.jpg%EF%BC%89">https://s4.ax1x.com/2022/01/24/7o1K0O.jpg）</a><br>n: 数据规模<br>k: “桶”的个数<br>In-place: 占用常数内存，不占用额外内存<br>Out-place: 占用额外内存</p>]]></content>
      
      
      <categories>
          
          <category> CS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ET框架笔记</title>
      <link href="/posts/2049.html"/>
      <url>/posts/2049.html</url>
      
        <content type="html"><![CDATA[<h1 id="ET框架笔记"><a href="#ET框架笔记" class="headerlink" title="ET框架笔记"></a>ET框架笔记</h1>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity入门</title>
      <link href="/posts/1537.html"/>
      <url>/posts/1537.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#基础</title>
      <link href="/posts/1026.html"/>
      <url>/posts/1026.html</url>
      
        <content type="html"><![CDATA[<p>将之前的笔记记录在博客上</p><h1 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h1><p>特点：数据（变量）集合、自定义；</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>  枚举是一个被命名的整形常量集合，可以声明再命名空间、类和结构体中。</p><h3 id="枚举声明"><a href="#枚举声明" class="headerlink" title="枚举声明"></a>枚举声明</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">enum 变量名{  名1，//枚举中默认是0下面累加  名2=4，//可以赋值，下面数值接着从此开始  名3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举的类型转换"><a href="#枚举的类型转换" class="headerlink" title="枚举的类型转换"></a>枚举的类型转换</h3><p>1.枚举和int互转后是数值的转换<br>2.枚举转换成string是枚举名<br>3.string转换成枚举，必须有这个字符串名的枚举名，实例如下：</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Enum.Parse(typeof(声明枚举类型名)，"Other");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>  数组是储存一组相同的数值集合，下标从0开始。</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1，2，3，4……(第数组长度-1个) }；<br>获取长度：数组名.length;</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>声明：变量类型【，】 二维数组名=new 变量类型【行，列】{ { 1,1,1… }，{ 1,1,1…. }，{ 1,1,1…. }… };<br>获取长度:数组名.length(维度);</p><h3 id="交叉数组"><a href="#交叉数组" class="headerlink" title="交叉数组"></a>交叉数组</h3><p>  即数组的数组。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public struct 结构体名{  变量类型 变量名    构造函数（可选）    函数}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体和类相同点：<br>1.两者都拥有成员，包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。<br>2.两者的成员都有其各自的存取范围。例如，可以将某一个成员声明为Public，而将另一个成员声明为Private。<br>3.两者都可以实现接口。<br>4.两者都可以公开一个默认属性，然而前提是这个属性至少要取得一个自变量。<br>5.两者都可以声明和触发事件，而且两者都可以声明委托（Delegate）。<br>6.两者都是container类型，这表示它们可以包含其他数据类型作为成员。</p><p>区别：<br>1.结构是实值类型（Value Types），而类则是引用类型（Reference Types）。<br>2.结构使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation）。<br>3.所有结构成员默认都是Public，而类的变量和常量数则默认位Private，不过其他类成员默认都是Public。<br>4.结构成员不能被声明位Protected，而类成员可以。<br>5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化，但是类变量声明可以。<br>6.结构不能声明默认的构造函数，也就是不拥有参数的非共享构造函数，但是类则无此限制。<br>7.二者都可以拥有共享构造函数，结构的共享构造函数不能带有参数，但是类的共享构造函数则可以带或者不带参数。<br>8.结构不允许声明析构函数（Destructor），类则无此限制。<br>9.结构的实例（Instance）声明，不允许对包含的变量进行初始化设定，类则可以在声明类的实例时，同时进行变量初始化。<br>1.结构是隐式继承自ValueType类，而且不能继承任何其他类型，类则可以继续自ValueType以外的任何类。<br>11.结构是无法被继承的，类则可以。<br>12.结构永远不会终止，因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止，当内存回收进程检测到没有任何作用的类时，它就会调用类的Finalize方法。<br>13.结构不需要构造函数，类则需要构造函数。<br>14.结构只能在一种情况下使用非共享构造函数，那就是非共享构造函数会接受参数。但是类则无此限制，它可以使用带参数或不带参数的非共享构造函数。<br>15.每一个结构都具有无参数的隐含公共构造函数，此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上，由于结构是数值类型的，因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的，而且对象变量可引用不同的类实例，在此方面的区别，会对使用将结构和类造成如下的影响：<br>16.结构变量会隐式的使用结构的无参数构造函数来初始化成员，这就意味语句 Struct S = new Struct（）。<br>17.当您将一个结构变量赋值给另一个，或者将结构实例传递到程序变量时，所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个，或者将对象变量传递给程序时，则只是复制指针。<br>18.您可以将Null值赋值给结构变量，但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化，但是您还是可以调用变量的方法并访问其数据成员。相反的，如果您将对象变量设定为Null，您就会中断它与任何类型实例的关联，而且除非您再将另一个实例赋值给它，否则无法通过变量访问任何成员。<br>19.您可以在不同时间将不同的类的实例赋值给同一个对象变量，而且在同一时间可有好几个对象变量引用相同的类实例，如果您对类成员值做了改变，则其他指向相同实例的对象变量也会发生改变。然而，结构成员则会封装在他们自己的实例中，变更结构成员值并不会对其他任何结构变量的成员造成影响，甚至也不会影响相同结构声明的其他实例。<br>20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。</p><p>如何选择结构还是类:<br>1.堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些<br>2.结构表示如点、矩形和颜色这样的轻量对象，例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。<br>3.在表现抽象和多级别的对象层次时，类是最好的选择<br>4.大多数情况下该类型只是一些数据时，结构时最佳的选择</p><h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>  其他类型、结构体；<br>存储位置：栈空间–系统分配，自动回收，小而快<br>特点：在赋值时，把内容拷贝给对方，它变我不变，内存地址不变。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>  string、数组、类<br>存储位置：手动申请和释放，大而慢<br>特点：在赋值时，让俩者指向一个值，它变我也变，指向堆中相同内存地址。</p><h2 id="特殊引用类型string"><a href="#特殊引用类型string" class="headerlink" title="特殊引用类型string"></a>特殊引用类型string</h2><p>  string在赋值时也会再分配一个内存空间。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>  函数可以写在类中和结构体中。</p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>基本语法：static 返回类型 函数名（参数类型 参数名1….）{ 代码逻辑；return 返回值  }</p><h2 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h2><p>  在函数内部传入，里面变了，外面也变了。<br>声明：函数参数的修饰符；<br>区别：ref传入的参数必须初始化，out传入的变量必须在内部赋值；</p><h2 id="变长参数和参数默认值"><a href="#变长参数和参数默认值" class="headerlink" title="变长参数和参数默认值"></a>变长参数和参数默认值</h2><p>变长参数声明：params 变量类型[] 变量名；<br>参数默认值：可选参数，在方法声明时就进行赋值，可选参数必须写在普通参数后面；</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>定义：重载和返回值无关，和参数类型、个数、顺序有关；</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>定义：就是让函数自己调用自己，但是需要留出出口，否则就是死循环</p><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>  声明扩展方法，扩展方法必须是静态的，Add有三个参数，this 必须有，string表示我要扩展的类型（一般是类），stringName表示对象名，三个参数this和扩展的类型必不可少，对象名可以自己随意取如果需要传递参数，//再增加一个变量即可</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public static string Add(this string 变量名){  return ""}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#入门</title>
      <link href="/posts/1025.html"/>
      <url>/posts/1025.html</url>
      
        <content type="html"><![CDATA[<p>将之前的笔记记录在博客上</p><h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C#基础知识"></a>C#基础知识</h1><h2 id="主流语言的应用领域"><a href="#主流语言的应用领域" class="headerlink" title="主流语言的应用领域"></a>主流语言的应用领域</h2><p>C: 嵌入式硬件开发<br>C++: 游戏客户端、服务器、软件<br>C#: 游戏客户端、服务器、软件、网站</p><p>Java: 安卓、服务器、软件、网站<br>JavaScript: H5游戏、网站、服务器<br>PHP: 网站、服务器<br>Python: 网站、服务器、辅助开发</p><p>SQL: 数据库<br>Go: 服务器<br>Objective-C: 苹果(mac、ios)相关<br>Swift: 苹果(mac、ios)相关</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="IDE是什么"><a href="#IDE是什么" class="headerlink" title="IDE是什么"></a>IDE是什么</h3><p>IDE(Integrated Development Environment )<br>集成开发环境<br>它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调<br>试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。<br>它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代<br>码命令，听从你的指令和你进行交流。</p><h3 id="常用的IDE-集成开发环境-软件"><a href="#常用的IDE-集成开发环境-软件" class="headerlink" title="常用的IDE(集成开发环境)软件"></a>常用的IDE(集成开发环境)软件</h3><p>Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;<br>Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;<br>Android Studio: 谷歌推出，主要用于开发安卓应用;<br>Xcode:苹果推出，主要用于开发苹果应用;</p><h1 id="第一个应用程序"><a href="#第一个应用程序" class="headerlink" title="第一个应用程序"></a>第一个应用程序</h1><h2 id="理解写代码这件事"><a href="#理解写代码这件事" class="headerlink" title="理解写代码这件事"></a>理解写代码这件事</h2><p>通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算<br>机通过这些命令来执行一些行为，从而实现一些特定的需求。<br>比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能<br>够动起来</p><h2 id="注释的三种方式"><a href="#注释的三种方式" class="headerlink" title="注释的三种方式"></a>注释的三种方式</h2><p>1.两杠注释:用于注释一行信息<br>2.星号注释:用于注释多行信息<br>3.三杠注释:用于注释类、命名空间等</p><h2 id="快捷注释的方法"><a href="#快捷注释的方法" class="headerlink" title="快捷注释的方法"></a>快捷注释的方法</h2><p>1.上方工具栏<br>2.快捷键<br>CTRL + K + C 注释<br>CTRL + K + U 取消注释</p><h2 id="折叠代码"><a href="#折叠代码" class="headerlink" title="折叠代码"></a>折叠代码</h2><p>由#region #endregion配对出现</p><h2 id="控制台输入打印语句"><a href="#控制台输入打印语句" class="headerlink" title="控制台输入打印语句"></a>控制台输入打印语句</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.Write():输出Console.WriteLine:换行输出Console.ReadKey:检测用户按下Console.ReadLine:用户输入回车<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="有符号的整形变量"><a href="#有符号的整形变量" class="headerlink" title="有符号的整形变量"></a>有符号的整形变量</h3><p>sbyte: -128-127(字节占1);<br>short:  -32768-32767(字节占2);<br>int: -21亿-21亿多(字节占4);<br>long: -9百万兆-9百万兆(字节占8);</p><h3 id="无符号的整数变量"><a href="#无符号的整数变量" class="headerlink" title="无符号的整数变量"></a>无符号的整数变量</h3><p>byte:0-255(字节占1);<br>ushort: 0-65535(字节占2);<br>uint: 0-42亿多(字节占4);<br>ulong: 0-18百万兆(字节占8);</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;<br>double:(字节占8) 存储15-17位有效数字;<br>decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; </p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><p>bool:非真即假(字节占1);<br>char:存储单个字符(字节占2);<br>string:存储多个字符，没有上限(长度可变);</p><h2 id="变量的本质"><a href="#变量的本质" class="headerlink" title="变量的本质"></a>变量的本质</h2><p>  数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000<br>通过sizeof获取变量占用的内存空间(例如:sizeof(int);;<br>1byte=8bit;<br>1kb=1024byte;<br>1mb=1024kb;<br>1gb=1024mb;<br>1tb=1024gb;</p><h3 id="进制转换-整数，左侧第一位表示符号"><a href="#进制转换-整数，左侧第一位表示符号" class="headerlink" title="进制转换(整数，左侧第一位表示符号)"></a>进制转换(整数，左侧第一位表示符号)</h3><p>十进制转二进制:不停除2;<br>二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0);</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>1.不能重名;<br>2.不能以数字开头;<br>3.不能是关键字;<br>4.不能有特殊符号(下划线除外);</p><p>驼峰命名法(变量)、帕斯卡命名法(函数、类)</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>关键字const，必须初始化，不能被修改。</p><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>  是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行</p><h2 id="固定写法"><a href="#固定写法" class="headerlink" title="固定写法"></a>固定写法</h2><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>':单引号;<br>":双引号<br>\n:换行<br>\:斜杠</p><h3 id="不常用的转义字符"><a href="#不常用的转义字符" class="headerlink" title="不常用的转义字符"></a>不常用的转义字符</h3><p>\t:制表符(空一个tab键)<br>\b:光标退格<br>\0:空字符<br>\a:警告音</p><h3 id="取消转义字符"><a href="#取消转义字符" class="headerlink" title="取消转义字符"></a>取消转义字符</h3><p>  在字符串前面加一个@(例如@”\你好")</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>  不同变量类型之间的相互转换</p><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>  不同类型之间的自动转换，大范围转小范围</p><h3 id="相同大类型之间的转换"><a href="#相同大类型之间的转换" class="headerlink" title="相同大类型之间的转换"></a>相同大类型之间的转换</h3><p>  特殊类型不存在隐式转换</p><h3 id="不同大类型之间的转换"><a href="#不同大类型之间的转换" class="headerlink" title="不同大类型之间的转换"></a>不同大类型之间的转换</h3><h4 id="无符号和有符号之间"><a href="#无符号和有符号之间" class="headerlink" title="无符号和有符号之间"></a>无符号和有符号之间</h4><p>  有符号的变量不能隐式转换无符号的;<br>  无符号的变量隐式转换有符号的前提是范围一定是涵盖的;</p><h4 id="浮点数和整数之间"><a href="#浮点数和整数之间" class="headerlink" title="浮点数和整数之间"></a>浮点数和整数之间</h4><p>  浮点数可以转任何类型整数;<br>  整数不能转换浮点型(不能存小数);</p><h4 id="特殊类型和其他类型"><a href="#特殊类型和其他类型" class="headerlink" title="特殊类型和其他类型"></a>特殊类型和其他类型</h4><p>  char类型可以隐式转换成整数和浮点型(ASCII码);<br>  bool和string不能和其他类型互相转换;</p><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><p>  手动转换。</p><h3 id="括号强转"><a href="#括号强转" class="headerlink" title="括号强转"></a>括号强转</h3><p>  小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。</p><h3 id="Parse法"><a href="#Parse法" class="headerlink" title="Parse法"></a>Parse法</h3><p>  把字符串类型转换成对应类型，前提能转换，否则报错。<br>语法:变量类型.Parse(“字符串”)</p><h3 id="Convert法"><a href="#Convert法" class="headerlink" title="Convert法"></a>Convert法</h3><p>  更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。<br>语法:Convert.To目标类型(变量或者常量)</p><h3 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h3><p>作用:拼接打印;<br>语法:变量.ToString();</p><h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><p>  避免程序报错造成卡死</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">try{  }catch{  }finally{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>赋值运算符:=<br>算数运算符:+ - * / %<br>复合运算符:+= -+ *= /= %=<br>自增运算符:a++(先用再加)  ++a(先加再用)</p><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>1.乘除大于加减;<br>2.括号优先;</p><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>方法一:+号拼接;<br>方法二:string.Format(“{0}”，18);<br>控制台打印拼接:支持类似方法二;</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>  只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。<br>条件运算符:&gt; &lt; == != &gt;= &lt;=;</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符:&amp;&amp; || !</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>  ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)<br>位或:|(有1则1)<br>异或:^(对位运算，相同为0，不同为1)<br>位取反:~(0变1，1变0，反码补码问题)<br>左右移:&lt;&lt;(左移几位，右边加几个0)   &gt;&gt;(右移几位，右边去几个数)</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>语法:空位(bool类型)？空位:空位;</p><h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">if(){  }else if(){  }else{  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">switch(){  case 变量:  break;  default:  break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">while(循环跳出条件){  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">do{  }while();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">for(int i=1;i&lt;条件;i++){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">foreach(var i in 集合需要继承自一个接口){  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><h2 id="控制台相关"><a href="#控制台相关" class="headerlink" title="控制台相关"></a>控制台相关</h2><p>1.Console.Readkey().Keycahr-可以保存输入的字符;<br>2.Console.Clear()-清空控制台;<br>3.Console.SetWindowSize(宽，高);<br>4.Console.SetBufferSize(宽，高)-缓冲区大小;<br>5.Console.SetCursorPosition(x，y)-设置光标的位置<br>6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色<br>7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear<br>8.Console.CursorVisiable=false-设置光标显隐<br>9.Environment.Exit(0)-关闭控制台</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>语法:Random 变量名=new Random();<br>生成非负数:变量名.Next(最小到最大，范围不包括最大);</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
