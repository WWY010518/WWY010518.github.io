{"meta":{"title":"憨憨","subtitle":"憨憨の博客","description":"故事总需要个起点","author":"憨憨","url":"http://wwy010518.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-01-22T04:07:31.290Z","comments":false,"path":"about/index.html","permalink":"http://wwy010518.github.io/about/index.html","excerpt":"","text":"憨憨“ 不要惧怕别人的偏见、认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：憨憨的个人空间 QQ：3179342661 座右铭：保持初心，漫步远方"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"http://wwy010518.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"http://wwy010518.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"http://wwy010518.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"http://wwy010518.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"http://wwy010518.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"http://wwy010518.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"http://wwy010518.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"相册","date":"2022-01-22T03:16:54.165Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"http://wwy010518.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"http://wwy010518.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"http://wwy010518.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://wwy010518.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"ET框架笔记","slug":"04001-ET框架笔记","date":"2022-01-24T13:00:00.000Z","updated":"2022-01-24T14:59:49.759Z","comments":true,"path":"posts/2049.html","link":"","permalink":"http://wwy010518.github.io/posts/2049.html","excerpt":"","text":"ET框架笔记","categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ET","slug":"ET","permalink":"http://wwy010518.github.io/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"计算机操作系统原理笔记","slug":"01001-计算机操作系统","date":"2022-01-08T13:00:00.000Z","updated":"2022-01-24T15:05:15.066Z","comments":true,"path":"posts/513.html","link":"","permalink":"http://wwy010518.github.io/posts/513.html","excerpt":"","text":"1 操作系统绪论1.1 操作系统概念定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。 特征：并发、共享、虚拟、异步。 1.2 操作系统发展历程手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。 1.2.1单道批处理原理：计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。 特征：内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。 1.2.2多道批处理原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。 特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。 1.2.3分时系统特征：多路性、独立性、及时性、交互性。 1.2.4实时系统特征：多路性、独立性、及时性、交互性、可靠性。 2 操作系统用户界面2.1 作业定义：分用户和系统角度去理解 a) 用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业； b) 系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL) 2.2 一般用户输入输出方式2.2.1联机输入输出方式2.2.2脱机输入输出方式2.2.3直接耦合方式2.2.4Spooling系统原理：todo。 特点：系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。 2.2.5网络联机方式2.3 系统调用定义：系统调用是操作系统留给编程人员的唯一接口。 原理：todo 2.3.1系统调用指令int和trap指令进行系统调用。 call和jmp指令进入普通过程调用(子调用)。 3 进程管理3.1 进程的概念组成：进程=程序+数据+进程控制块(进程状态信息PCB) 定义：进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 目的：对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性； 优缺点：引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。 3.2 进程和程序的区别a) 进程是动态的，程序是静态的； b) 进程是暂时的，程序是永久的； c) 组成不同，进程的组成包括程序； d) 对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序； e) 进程可以并行，具有独立性、异步性。 f) 进程是竞争计算机资源的基本单位。 3.3 进程控制块(PCB)进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。 3.3.1描述信息3.3.2控制信息3.3.3资源管理信息3.3.4CPU保护现场结构3.4 进程上下文切换原因：进程中断、超时、进程调用。 步骤： a) 保存被切换进程的正文部分到有关存储区。 b) 进程有关调度和资源分配程序执行，选取新的进程。 c) 新进程正文部分从存储区取出，激活选中进程执行。 3.5 进程的状态和进程转换3.5.1进程状态初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止)) 3.5.2进程状态转换3.6 进程控制3.6.1进程创建和撤销3.6.2进程阻塞和唤醒3.6.3进程的挂起和激活3.7 进程互斥和同步3.7.1临界区和临界资源临界资源是一次仅允许一个进程使用的共享资源。 临界区是每个进程访问临界资源的那段代码。 3.7.2信号量和PV原语信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。 信号量的数值仅能由P、V原语操作改变。 3.7.3互斥的概念定义：不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。 3.7.4同步的概念定义：对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。 3.8 进程通信Todo 3.9 死锁问题3.9.1死锁的概念定义： 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。 起因：并发进程的资源竞争 条件：同时具备互斥条件、不剥夺条件、部分分配、环路条件。 3.9.2死锁的解决方案3.9.2.1 死锁预防3.9.2.2 死锁避免最具代表性的避免算法-银行家算法 3.9.2.3 死锁的检测和恢复3.10 线程3.10.1 线程的基本概念定义：引入线程后，线程是操作系统调度和分配的基本单位。 组成：线程=？+线程控制块(TCB) 3.10.2 线程状态和线程控制块(TCB)线程状态：执行状态、就绪状态、阻塞(等待)状态 线程控制块数据结构包括： a) 线程标识符 b) 一组寄存器 c) 线程执行状态 d) 优先级 e) 线程专有存储区 f) 信号屏蔽 g) 堆栈指针 3.10.3 线程和进程的区别从以下六点讨论 a) 调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。 b) 并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。 c) 拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。 d) 独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。 e) 系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。 f) 支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。 4 处理机调度4.1 调度层级一个作业提交后，往往会经历三种层级（加线程四种） 4.1.1作业调度又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。 4.1.1.1 周转时间相关周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间 平均周转时间=所有作业周转时间之和/总作业数 带权周转时间=作业周转时间/作业执行时间 平均带权周转时间=所有带权作业周转时间之和/总作业数 4.1.1.2 响应时间，截止时间和系统吞吐量响应时间是提交请求和返回该请求的响应之间使用的时间截止时间是某任务必须开始执行或者必须完成的最迟时间吞吐量是对单位时间内完成的工作量的量度 4.1.2交换调度又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存 4.1.3进程调度又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式 4.1.3.1 非抢占方式一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。 4.1.3.2 抢占方式系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程 a) 优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU b) 短作业优先原则：就绪的短进程有权抢占长进程的CPU c) 时间片原则：一个时间片用完后，系统重新进行进程调度 4.1.4线程调度Todo 4.2 作业和进程的关系系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。 4.3 调度算法宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。 ​ 微观调度：轮转法、优先级法、多级反馈轮转法。 5 存储管理5.1 存储器结构由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。 5.1.1寄存器寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。 5.1.2高速缓存它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。 5.1.3主存输器简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。 5.1.4磁盘缓存目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。 5.2 程序的处理阶段主要有编译，链接，装入，下面主要讲链接和装入。 5.2.1程序的链接源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。链接又可分为静态链接，装入时动态链接，运行时动态链接。 5.2.2程序的装入分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。 5.3 地址变换5.3.1静态地址重定向原理：Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。 5.3.2动态地址重定位关系：MA(物理地址)=BR(基址地址)+VR(虚拟地址)。 原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。 5.4 分区存储管理分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。 5.4.1固态分区法原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。 优点:易于实现，开销小。 缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。 5.4.2动态分区法原理：动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。 优点：没有内碎片； 缺点：有外碎片； 算法：根据情况有以下俩种，着重介绍三种 a) 基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法 b) 基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法 5.4.2.2 最先适应法5.4.2.3 最佳适应法5.4.2.4 最坏适应法5.4.3页式管理（离散分配）基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。 5.4.3.1 静态页式管理原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。 5.4.3.2 动态页式管理5.4.4段式和段页式管理基本思想：todo 5.4.4.1 段式管理原理：todo 5.4.4.2 段页式管理原理：todo 5.4.5覆盖和交换技术5.5 虚拟存输器5.5.1虚拟存储的实现方式虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式： 5.5.1.1 分页请求系统在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。 硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上 5.5.1.2 请求分段系统在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页” 5.5.2页面置换算法5.5.2.1 随机淘汰算法随机地选择某个用户地页面并将其换出。 5.5.2.2 最佳置换算法（理想型淘汰算法OPT）其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。 5.5.2.3 先进先出置换算法（FIFO）总是先淘汰最先进入内存的页面。 5.5.2.4 最近最久未使用算法（LRU）选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。 5.5.2.5 最少使用置换算法（LFU）在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。 5.5.2.6 Clock置换算法是一种LRU算法每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面； 6 文件系统6.1 文件系统基本概念目的：文件系统地出现是为了更好地管理软件资源 文件系统的定义：操作系统中与管理文件有关的软件和数据称为文件系统 文件的定义：文件时一段程序和数据的集合 文件的分类：按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。 6.2 文件的逻辑结构和存取方式6.2.1逻辑结构字符流的无结构文件：管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。 记录式的有结构文件：把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。 6.2.1.1 连续结构6.2.1.2 多重结构6.2.1.3 转置结构6.2.1.4 顺序结构6.2.2逻辑存储方法6.2.2.1 顺序存输方法6.2.2.2 随机存输方法6.2.2.3 按关键字存输方法多用于复杂文件系统。 6.2.3逻辑搜索方式文件的获取是要找到文件内容所在的逻辑地址 6.2.3.1 线性搜索法6.2.3.2 散列法6.2.3.3 二分搜索法6.3 文件的物理结构和存储设备6.3.1文件物理结构6.3.1.1 连续文件连续文件采用连续分配方式： 特点：为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。优点：顺序访问容易; 顺序访问速度快;缺点：要求有连续的存储空间; 必须事先知道文件的长度; 6.3.1.2 串联文件串联文件采用链接分配 特点：文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；优点：没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。缺点：存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间; 6.3.1.3 索引文件索引文件采用索引分配 特点：每个文件都有自己的索引块，这是一个磁盘块地址的数组。 6.3.2文件存储设备存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。 6.3.2.1 顺序存取存储设备—磁带特点：只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。 影响因素：信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。 6.3.2.2 直接存取存储设备—磁盘6.4 文件存储空间管理文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。 6.4.1空闲目录管理6.4.2空闲链块法6.4.3位示图6.5 文件目录管理从文件管理角度看，一个文件包括文件说明和文件体。 6.5.1文件目录的种类6.5.1.1 单级文件目录在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。 6.5.1.2 两级文件目录目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB； 6.5.1.3 树形结构目录多级目录结构又称为树型目录结构；主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点； 6.5.2文件目录的共享从系统管理的方式来看，有三种方法可以实现文件共享 6.5.2.1 绕道法6.5.2.2 链接法6.5.2.3 基本文件目录表（BFD）6.5.3目录管理文件目录管理应该存放在磁盘，其他的没理解todo 6.6 文件存取控制用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。 6.6.1存取控制矩阵6.6.2存取控制表6.6.3口令方式6.6.4密码方式密码方式是保密性最好的验证方式。 7 设备管理7.1 设备的分类在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。 7.2 数据传输控制方式设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。 7.2.1程序直接控制方式由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。 7.2.2中断方式I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。 7.2.3DMA方式在外围设备和内存之间开辟直接的数据交换通道。 7.2.4通道控制方式以内存为中心，实现设备和内存直接交换数据的控制的方式。 7.3 中断技术原理：中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。 过程：判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点 7.3.1中断技术的分类中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。 7.3.1.1 外中断一般是来自处理机和内存外部的中断 7.3.1.2 内中断（陷阱）一般是来自处理机和内存内部的中断 7.3.1.3 软中断是通信进程之间模拟硬中断的一种信号通信方式 7.4 缓冲技术目的：缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。 分类：缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。 7.4.1缓冲池的结构缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。 7.4.2缓冲池管理Todo","categories":[{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Unity相关_FairyGUI","slug":"03006-Unity相关_FairyGUI ","date":"2021-12-12T13:00:00.000Z","updated":"2022-01-25T07:38:29.851Z","comments":true,"path":"posts/1542.html","link":"","permalink":"http://wwy010518.github.io/posts/1542.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity相关_基于Lua的热更新解决方案","slug":"03008-Unity相关_基于Lua的热更新解决方案","date":"2021-10-28T13:00:00.000Z","updated":"2022-01-25T07:38:56.752Z","comments":true,"path":"posts/03008.html","link":"","permalink":"http://wwy010518.github.io/posts/03008.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"http://wwy010518.github.io/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://wwy010518.github.io/tags/AssetBundle/"}]},{"title":"Markdown语法格式（.md后缀-使用typora）","slug":"00001-Markdown语法格式","date":"2021-09-28T13:00:00.000Z","updated":"2022-01-24T06:26:54.746Z","comments":true,"path":"posts/1.html","link":"","permalink":"http://wwy010518.github.io/posts/1.html","excerpt":"","text":"Markdown语法格式标题：#标题1 （大） ##标题2 ###标题3 ####标题4 （小） 以此类推 最高标题6 代码块：​```代码块名称(可以输入各种语言java、c++、html等) 加粗：//加粗 **加粗** //代码高亮显示 ==高亮== //删除线 ~~删除线~~ //斜体 *斜体内容* 引用：//引用语法 &gt;作者：泽 &gt;&gt;作者：泽 &gt;&gt;&gt;作者：泽 分割线：//分割线 --- *** 图片插入：//在线图片与本地图片 ![照片名子]（/image/me.png） 超链接：//超链接语法 [超链接名字]（https://gihub.com/yerenping） 列表：//无需列表 - 目录1 -后加空格 - 目录2 - 目录3 //有序列表 1+. +名称 表格：右键》插入》表格 用代码过于复杂不推荐使用","categories":[{"name":"其他","slug":"其他","permalink":"http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://wwy010518.github.io/tags/Markdown/"}]},{"title":"常用排序算法","slug":"01002-常用排序算法","date":"2021-06-30T13:00:00.000Z","updated":"2022-01-24T15:05:02.801Z","comments":true,"path":"posts/514.html","link":"","permalink":"http://wwy010518.github.io/posts/514.html","excerpt":"","text":"列举一些常用的排序算法 #冒泡排序 /// &lt;summary&gt; /// 冒泡排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void BubbleSort(int[] array, int count) { //设置标识符，如果为false意为当前数组为有序，不需要再排序了 bool shouldSorted = true; for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++) { shouldSorted = false; for (int j = count - 1; j &gt; i; j--) { if (array[j - 1] &gt; array[j]) { shouldSorted = true; Utilities.Swap(ref array[j - 1], ref array[j]); } } } } #选择排序 /// &lt;summary&gt; /// 选择排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void SelectSort(int[] array, int count) { int min; for (int i = 0; i &lt; count - 1; i++) { min = i; for (int j = i + 1; j &lt; count; j++) { if (array[min] &gt; array[j]) { min = j; } } if (min != i) { Utilities.Swap(ref array[min], ref array[i]); } } } #插入排序 /// &lt;summary&gt; /// 插入排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void InserSort(int[] array, int count) { int guard; //哨兵，用于暂存需要交换的值 for (int i = 0; i &lt; count - 1; i++) { if (array[i] &gt; array[i + 1]) { guard = array[i + 1]; int j; for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--) { array[j + 1] = array[j]; //赋值操作（依次后移） } array[j + 1] = guard; } } } #希尔排序 /// &lt;summary&gt; /// 希尔排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void ShellSort(int[] array, int count) { int i, j, guard; int increment = count; do { increment = increment / 3 + 1; //增量序列 for (i = increment + 1; i &lt; count; i++) { if (array[i] &lt; array[i - increment]) { guard = array[i]; //暂存在哨兵处 for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment) { array[j + increment] = array[j]; //记录后移，查找插入位置 } array[j + increment] = guard; //插入 } } } while (increment &gt; 1); } #堆排序 /// &lt;summary&gt; /// 堆排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void HeapSort(int[] array, int count) { for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆 { HeapAdjust(array, i, count - 1); } for (int i = count - 1; i &gt; 0; i--) { Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换 HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆 } } /// &lt;summary&gt; /// 堆排序_构造大顶堆函数 /// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义 /// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"startIndex\"&gt;起始位置&lt;/param&gt; /// &lt;param name=\"endIndex\"&gt;结束位置&lt;/param&gt; public static void HeapAdjust(int[] array, int startIndex, int endIndex) { int temp; temp = array[startIndex]; for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选 { if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1]) { ++i; //i为关键字中较大记录的下标 } if (temp &gt; array[i]) { break; //rc应插入在位置s上 } array[startIndex] = array[i]; startIndex = i; } array[startIndex] = temp; //插入 } #归并排序 /// &lt;summary&gt; /// 归并排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void MergeSort(int[] array, int count) { int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果 int k = 1; while (k &lt; count) { MergePass(array, tempArray, k, count); //array归并到tempArray k = 2 * k; //子序列长度加倍 MergePass(tempArray, array, k, count); //tempArray归并到array k = 2 * k; //子序列长度加倍 } } /// &lt;summary&gt; /// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"srChildLength\"&gt;SR中子序列长度&lt;/param&gt; /// &lt;param name=\"arrayLength\"&gt;原数组长度&lt;/param&gt; public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength) { int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数 while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, hasMergeCount + 2 * srChildLength - 2); //两两归并 hasMergeCount += 2 * srChildLength; } if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1); } else //若最后只剩下单个子序列 { for (int j = hasMergeCount - 1; j &lt; arrayLength; j++) { tr[j] = sr[j]; } } } /// &lt;summary&gt; /// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"sr1StartIndex\"&gt;SR数组子序列1起始位置&lt;/param&gt; /// &lt;param name=\"sr1EndIndex\"&gt;SR数组子序列1结束位置&lt;/param&gt; /// &lt;param name=\"sr2EndIndex\"&gt;SR数组子序列2结束位置&lt;/param&gt; private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex) { int sr2StartIndex, currentProcess; //currentProcess为当前进度 for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex; sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex; currentProcess++) //两个SR有一个被榨干后就要退出循环 { if (sr[sr1StartIndex] &lt; sr[sr2StartIndex]) { tr[currentProcess] = sr[sr1StartIndex++]; } else { tr[currentProcess] = sr[sr2StartIndex++]; } } if (sr1StartIndex &lt;= sr1EndIndex) { for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++) { tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR } } if (sr2StartIndex &lt;= sr2EndIndex) { for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++) { tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR } } } #快速排序 /// &lt;summary&gt; /// 快速排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void QuickSort(int[] array, int count) { QSort(array, 0, count - 1); } /// &lt;summary&gt; /// 快速排序_递归调用 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; private static void QSort(int[] array, int low, int high) { int pivot; while (low &lt; high) { pivot = Partition(array, low, high); QSort(array, low, pivot - 1); //尾递归，可以减少一次递归堆栈深度 low = pivot + 1; } } /// &lt;summary&gt; /// 获取枢轴数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static int Partition(int[] array, int low, int high) { int pivotkey; int m = low + (high - low) / 2; //下面是三数取中优化 //交换左端与右端数据，保证左端较小 if (array[low] &gt; array[high]) { Utilities.Swap(ref array[low],ref array[high]); } //交换中间与右端数据，保证中间较小 if (array[m] &gt; array[high]) { Utilities.Swap(ref array[m],ref array[high]); } //交换中间与左端数据，保证左端较小 if (array[m] &gt; array[low]) { Utilities.Swap(ref array[low],ref array[m]); } //默认选取当前数组的第一个值作为枢轴值 pivotkey = array[low]; //枢轴备份 int pivotkeyback = pivotkey; while (low &lt; high) { while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey) { high--; } array[low] = array[high]; while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey) { low++; } array[high] = array[low]; } //将枢轴数值替换回array[low] array[low] = pivotkeyback; //返回当前枢轴下标 return low; } #各种排序时空复杂度n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存","categories":[{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"CS基础/数据结构和算法","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"游戏MVC系列框架","slug":"04003-游戏MVC系列框架","date":"2020-12-15T13:00:00.000Z","updated":"2022-01-24T14:59:35.646Z","comments":true,"path":"posts/2051.html","link":"","permalink":"http://wwy010518.github.io/posts/2051.html","excerpt":"","text":"模板","categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"MVC","slug":"MVC","permalink":"http://wwy010518.github.io/tags/MVC/"}]},{"title":"游戏程序基础框架","slug":"04002-游戏程序基础框架","date":"2020-11-20T13:00:00.000Z","updated":"2022-01-24T14:59:43.342Z","comments":true,"path":"posts/2050.html","link":"","permalink":"http://wwy010518.github.io/posts/2050.html","excerpt":"","text":"模板","categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"Unity相关_数据持久化","slug":"03007-Unity相关_数据持久化","date":"2020-05-24T13:00:00.000Z","updated":"2022-01-25T07:38:47.011Z","comments":true,"path":"posts/1543.html","link":"","permalink":"http://wwy010518.github.io/posts/1543.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}]},{"title":"Unity相关_UGUI","slug":"03005-Unity相关_UGUI","date":"2020-01-24T13:00:00.000Z","updated":"2022-01-25T07:37:17.604Z","comments":true,"path":"posts/1541.html","link":"","permalink":"http://wwy010518.github.io/posts/1541.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity进阶","slug":"03004-Unity进阶","date":"2019-11-13T13:00:00.000Z","updated":"2022-01-25T07:37:09.841Z","comments":true,"path":"posts/1540.html","link":"","permalink":"http://wwy010518.github.io/posts/1540.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity核心","slug":"03003-Unity核心","date":"2019-10-05T13:00:00.000Z","updated":"2022-01-25T07:36:58.398Z","comments":true,"path":"posts/1539.html","link":"","permalink":"http://wwy010518.github.io/posts/1539.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity基础","slug":"03002-Unity基础","date":"2019-09-25T13:00:00.000Z","updated":"2022-01-27T13:25:01.902Z","comments":true,"path":"posts/1538.html","link":"","permalink":"http://wwy010518.github.io/posts/1538.html","excerpt":"","text":"3D数学数学计算Mathf公共类Math：是C#中封装好的用于数学计算的工具)类) —— 位于System命名空间中；Mathf：是Unity中封装好的用于数学计算的工具)结构体) —— 位于UnityEngine命名空间中，Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法，使用Mathf中的方法用于Unity游戏开发中的数学计算即可； API 知识点三 Mathf中的常用方法——一般计算一次 //1.π - PI print(Mathf.PI); //2.取绝对值 - Abs print(Mathf.Abs(-10)); print(Mathf.Abs(-20)); print(Mathf.Abs(1)); //3.向上取整 - CeilToInt float f = 1.3f; int i = (int)f; print(i); print(Mathf.CeilToInt(f)); print(Mathf.CeilToInt(1.00001f)); //4.向下取整 - FloorToInt print(Mathf.FloorToInt(9.6f)); //5.钳制函数 - Clamp print(Mathf.Clamp(10, 11, 20)); print(Mathf.Clamp(21, 11, 20)); print(Mathf.Clamp(15, 11, 20)); //6.获取最大值 - Max print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8)); print(Mathf.Max(1, 2)); //7.获取最小值 - Min print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123)); print(Mathf.Min(1.1f, 0.4f)); //8.一个数的n次幂 - Pow print(\"一个数的n次方\" + Mathf.Pow(4, 2)); print(\"一个数的n次方\" + Mathf.Pow(2, 3)); //9.四舍五入 - RoundToInt print(\"四舍五入\" + Mathf.RoundToInt(1.3f)); print(\"四舍五入\" + Mathf.RoundToInt(1.5f)); //10.返回一个数的平方根 - Sqrt print(\"返回一个数的平方根\" + Mathf.Sqrt(4)); print(\"返回一个数的平方根\" + Mathf.Sqrt(16)); print(\"返回一个数的平方根\" + Mathf.Sqrt(64)); //11.判断一个数是否是2的n次方 - IsPowerOfTwo print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(4)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(8)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(3)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(1)); //12.判断正负数 - Sign print(\"判断正负数\" + Mathf.Sign(0)); print(\"判断正负数\" + Mathf.Sign(10)); print(\"判断正负数\" + Mathf.Sign(-10)); print(\"判断正负数\" + Mathf.Sign(3)); print(\"判断正负数\" + Mathf.Sign(-2)); 知识点四 Mathf中的常用方法——一般不停计算 //插值运算 - Lerp //Lerp函数公式 result = Mathf.Lerp(start, end, t); //t为插值系数，取值范围为 0~1 result = start + (end - start)*t //插值运算用法一 //每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置 start = Mathf.Lerp(start, 10, Time.deltaTime); //插值运算用法二 //每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果 time += Time.deltaTime; result = Mathf.Lerp(start, 10, time); UnityEngine.Mathf - Unity 脚本手册 Scripting API) 三角函数1.角度和弧度都是度量角的单位：角度：1°弧度：1 radian圆一周的角度：360°圆一周的弧度：2π radian 2.角度和弧度的转换关系：π rad = 180°1 rad = (180 / π)°=&gt; 1 rad = 180 / 3.14 ≈ 57.3°；1°= (π / 180) rad =&gt; 1°= 3.14 / 180 ≈ 0.01745 rad；由此可以得出弧度 * 57.3 = 对应角度角度 * 0.01745 = 对应弧 3.角度弧度相关API： 知识点一 弧度、角度相互转化 //弧度转角度 float rad = 1; float anger = rad * Mathf.Rad2Deg; //角度转弧度 anger = 1; rad = anger * Mathf.Deg2Rad; 知识点二 三角函数)可以让物体做曲线运动) //注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 知识点三 反三角函数 //注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 rad = Mathf.Asin(0.5f); print(rad * Mathf.Rad2Deg); rad = Mathf.Acos(0.5f); print(rad * Mathf.Rad2Deg); 坐标系说明1.世界坐标系：原点：世界的中心点轴向：世界坐标系的三个轴向是固定的 2.物体坐标系：原点：物体的中心点)建模时决定)轴向：物体右方为x轴正方向物体上方为y轴正方向物体前方为z轴正方向 3.屏幕坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向最大宽高：Screen.widthScreen.height 4.视口坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向特点：左下角为)0,0)右上角为)1,1)和屏幕坐标类似，将坐标单位化 汇总 知识点一 世界坐标系 //目前学习的和世界坐标系相关的 //this.transform.position; //this.transform.rotation; //this.transform.eulerAngles; //this.transform.lossyScale(全局缩放大小，只能得); //修改他们 会是相对世界坐标系的变化 知识点二 物体坐标系 //相对父对象的物体坐标系的位置 本地坐标 相对坐标 //this.transform.localPosition; //this.transform.localEulerAngles; //this.transform.localRotation; //this.transform.localScale; //修改他们 会是相对父对象物体坐标系的变化 知识点三 屏幕坐标系 //Input.mousePosition //Screen.width; //Screen.height; 知识点四 视口坐标系 //摄像机上的 视口范围 坐标转换相关 //世界转本地 //this.transform.InverseTransformDirection //this.transform.InverseTransformPoint //this.transform.InverseTransformVector //本地转世界 //this.transform.TransformDirection //this.transform.TransformPoint //this.transform.TransformVector //世界转屏幕 //Camera.main.WorldToScreenPoint //屏幕转世界 //Camera.main.ScreenToWorldPoint //世界转视口 //Camera.main.WorldToViewportPoint //视口转世界 //Camera.main.ViewportToWorldPoint //视口转屏幕 //Camera.main.ViewportToScreenPoint //屏幕转视口 //Camera.main.ScreenToViewportPoint; Vector3向量UnityEngine.Vector3 - Unity 脚本手册 Scripting API 向量模长和单位向量1.标量：有数值大小，没有方向 2.向量：有数值大小，有方向的矢量 3.两点决定一向量：A点：(Xa,Ya,Za)B点：(Xb,Yb,Zb)从A指向B的向量为AB向量B-A = (Xb-Xa, Yb-Ya, Zb-Za)从B指向A的向量为BA向量A-B = (Xa-Xb, Ya-Yb, Za-Zb)口诀：终点减起点 4.零向量和负向量：零向量(0,0,0)零向量是唯一一个大小为0的向量负向量(x,y,z)的负向量为(-x,-y,-z)负向量和原向量大小相等负向量和原向量方向相反 5.向量的模长：向量的模长就是向量的长度向量是由两个点算出，所以向量的模长就是两个点的距离模长公式：A向量(x,y,z)模长 = √x² + y² + z² 6.单位向量：模长为1的向量为单位向量任意一个向量经过归一化就是单位向量只需要方向，不想让模长影响计算结果时使用单位向量归一化公式：A向量(x,y,z)模长 = √x² + y² + z²单位向量 = (x/模长, y/模长, z/模长) 7.向量模长和单位向量相关API： 知识点一 向量 //三维向量 - Vector3 //Vector3有两种几何意义 //1.位置 —— 代表一个点 print(this.transform.position); //2.方向 —— 代表一个方向 print(this.transform.forward); print(this.transform.up); Vector3 v = new Vector3(1, 2, 3); Vector2 v2 = new Vector2(1, 2); 知识点二 两点决定一向量 //A和B此时 几何意义 是两个点 Vector3 A = new Vector3(1, 2, 3); Vector3 B = new Vector3(5, 1, 5); //求向量 //此时 AB和 BA 他们的几何意义 是两个向量 Vector3 AB = B - A; Vector3 BA = A - B; 知识点三 零向量和负向量 print(Vector3.zero); print(Vector3.forward); print(-Vector3.forward); 知识点四 向量的模长 //Vector3中提供了获取向量模长的成员属性 //magnitude print(AB.magnitude); Vector3 C = new Vector3(5, 6, 7); print(C.magnitude); print(Vector3.Distance(A, B)); 知识点五 单位向量 //Vector3中提供了获取单位向量的成员属性 //normalized print(AB.normalized); print(AB / AB.magnitude); 总结 //模长相当于可以得到 两点之间的距离 单位向量 主要是用来进行移动计算的 它不会影响我们想要的移动效果 向量加减乘除1.向量加法：向量A + 向量B = (Xa + Xb, Ya + Yb)；位置+位置：两个位置相加没有任何几何意义向量+向量：两个向量相加得到一个新向量；向量 + 向量 = 向量)向量相加，首尾相连)位置+向量：位置加向量得到一个新位置；位置 + 向量 = 位置；向量 + 位置 = 位置)位置和向量相加=平移位置) 2.向量减法向量A - 向量B = (Xa - Xb, Ya - Yb, Za);位置-位置：两个位置相减得到一个新向量；位置 - 位置 = 向量)两点决定一向量，终点 - 起点)；向量-向量：两个向量相减得到一个新向量；向量 - 向量 = 向量)向量相减，头连头，尾指尾，A - B = B头指A头)；位置-向量：位置减向量相当于 加负向量；位置 + (-向量)=位置)位置减向量 = 平移位置)；向量-位置：向量减位置没有任何几何意义 3.向量乘除向量只会和标量进行乘除法运算向量A标量a = (xa, ya, za);向量A/标量a = (x/a, y/a, z/a);向量 *or/ 标量 = 向量;向量 *or/ 正数，方向不变，放大缩小模长;向量 *or/ 负数，方向相反，放大缩小模长;向量 * 0，得到零向量; 4.知识点： 知识点一 向量加法 //this.transform.position += new Vector3(1, 2, 3); this.transform.Translate(Vector3.forward * 5); 知识点二 向量减法 //this.transform.position -= new Vector3(1, 2, 3); this.transform.Translate(-Vector3.forward * 5); 知识点三 向量乘除标量 this.transform.localScale *= 2; this.transform.localScale /= 2; 向量点乘1.点乘计算公式：向量A·向量B = XaXb + YaYb + Za*Zb=标量；点乘可以得到一个向量：在自己向量上投影的长度)我们可以用这个规律判断敌方的大致方位)；点乘结果 &gt; 0 两个向量夹角为锐角；点乘结果 = 0 两个向量夹角为直角；点乘结果 &lt; 0 两个向量夹角为钝； 2.公式推导：Cosβ = 直角边 / 单位向量B模长直角边 = Cosβ * 单位向量B模长)直角边 = 单位向量A · 单位向量B);↓Cosβ * 单位向量B模长 = 单位向量A · 单位向量B;↓Cosβ = 单位向量A · 单位向量B;↓推出结果：β = Acos(单位向量A · 单位向量B); 3.点乘API 知识点一 通过点乘判断对象方位)判断前后) //Vector3 提供了计算点乘的方法 Debug.DrawRay(this.transform.position, this.transform.forward, Color.red); Debug.DrawRay(this.transform.position, target.position - this.transform.position, Color.red); //得到两个向量的点乘结果 //向量 a 点乘 AB 的结果 float dotResult = Vector3.Dot(this.transform.forward, target.position - this.transform.position); if( dotResult &gt;= 0 ) { print(\"它在我前方\"); } else { print(\"它在我后方\"); } 知识点二 通过点乘推导公式算出夹角)判断夹角，但是夹角为0-180之间，不能判断左右) //步骤 //1.用单位向量算出点乘结果 dotResult = Vector3.Dot(this.transform.forward, (target.position - this.transform.position).normalized); //2.用反三角函数得出角度 print(\"角度-\" + Mathf.Acos(dotResult) * Mathf.Rad2Deg); //Vector3中提供了 得到两个向量之间夹角的方法 print(\"角度2-\" + Vector3.Angle(this.transform.forward, target.position - this.transform.position)); 向量叉乘1.叉乘计算公式：向量A x 向量B = (YaZb - ZaYb,ZaXb - XaZb,XaYb - YaX)=向量； 2.几何意义A x B 得到的向量同时垂直A和B；A x B 向量垂直于A和B组成的平面；A x B = -(B x A)； 3.叉乘API 知识点一 叉乘计算 print(Vector3.Cross(A.position, B.position)); 知识点二 叉乘几何意义 //假设向量 A和B 都在 XZ平面上 //向量A 叉乘 向量 B //y大于0 证明 B在A右侧 //y小于0 证明 B在A左侧 Vector3 C = Vector3.Cross(A.position, B.position); if( C.y &gt; 0) { print(\"B在A的右侧\"); } else { print(\"B在A的左侧\"); } 向量插值运算插值API: 知识点一 线性插值 //公式result = start + (end - start) * t //1.先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置 A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); //2.匀速 每帧改变时间 当t&gt;=1时 得到结果 //这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 //应该相当于Vector3.MoveToWards() if(nowTarget != target.position) { nowTarget = target.position; time = 0; startPos = B.position; } time += Time.deltaTime; B.position = Vector3.Lerp(startPos, nowTarget, time); 知识点二 球形插值 //做弧线运动，可以做弓箭射击，太阳东升西落 C.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up*0.1f, time*0.01f); Quaternion四元数UnityEngine.Quaternion - Unity 脚本手册 Scripting API 为什么使用四元数1.欧拉角)transform.eulerAngles)：由三个角度(x,y,z)组成，遵守heading-pitch-bank旋转序列约定)heading:物体绕自身的对象坐标系的Y轴，旋转的角度；pitch:物体绕自身的对象坐标系的X轴，旋转的角度；bank:物体绕自身的对象坐标系的Z轴，旋转的角度)；1.1.优点：直观、易理解；存储空间小)三个数表示)；可以进行从一个方向到另一个方向旋转大于180度的角度；1.2缺点：同一旋转的表示不唯一；万向节死锁； 2.万向节死锁：当某个特定轴达到某个特殊值时，绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度；Unity中X轴达到90度时，会产生万向节死锁； 四元数是什么1.轴-角对：在3D空间中，任意旋转都可以表示，绕着某个轴旋转一个旋转角得到； 2.四元数：对于给定旋转，假设为绕着n轴，旋转β度，n轴为(x,y,z)；四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z]； 3.四元数基本API 知识点一 四元数 Quaternion //四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z] //计算原理 //Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); //提供的轴角对 初始化 四元数的方法 Quaternion q = Quaternion.AngleAxis(60, Vector3.right); 知识点二 四元数和欧拉角转换 //1.欧拉角转四元数 Quaternion q2 = Quaternion.Euler(60, 0, 0); GameObject obj2 = GameObject.CreatePrimitive(PrimitiveType.Cube); obj2.transform.rotation = q2; //2.四元数转欧拉角 print(q2.eulerAngles); 知识点三 四元数弥补的欧拉角缺点 //1.同一旋转的表示不唯一 四元数旋转后 转换后的欧拉角 始终是 -180~180度 //2.万向节死锁 通过四元数旋转对象可以避免万向节死锁 //必备知识点：四元数相乘代表旋转四元数 this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up); 四元数常用方法知识点一 单位四元数 print(Quaternion.identity); //testObj.rotation = Quaternion.identity; Instantiate(testObj, Vector3.zero, Quaternion.identity); 知识点二 插值运算 //在四元数中Lerp和Slerp只有一些细微差别 //由于算法不同,Slerp的效果会好一些 //Lerp的效果相比Slerp更快但是如果旋转范围较大效果较差,所以建议使用Slerp进行插值运算 //无限接近 先快后慢 A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime); //匀速变化 time&gt;=1到达目标 time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 识点三 LookRotation //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position); //lookA.rotation = q; lookA.MyLookAt(lookB); 四元数计算知识点一 四元数相乘 //两个四元数相乘得到一个新的四元数,代表两个旋转量的叠加,相当于旋转(旋转相对的坐标系 是物体自身坐标系) Quaternion q = Quaternion.AngleAxis(20, Vector3.up); this.transform.rotation *= q; 知识点二 四元数乘向量 //四元数乘向量返回一个新向量,可以将指定向量旋转对应四元数的旋转量,相当于直接旋转向量 Vector3 v = Vector3.forward; v = Quaternion.AngleAxis(45, Vector3.up) * v; Mono重要内容延迟(延时)函数知识点一 什么是延迟函数 //延迟函数顾名思义 //就是会延时执行的函数 //我们可以自己设定延时要执行的函数和具体延时的时间 //是MonoBehaviour基类中实现好的方法 知识点二 延迟函数的使用 1.延迟函数 //Invoke //参数一：函数名 字符串 //参数二：延迟时间 秒为单位 Invoke(\"DelayDoSomething\", 1); //注意： //1-1.延时函数第一个参数传入的是函数名字符串 //1-2.延时函数没办法传入参数 只有包裹一层 //1-3.函数名必须是该脚本上申明的函数 2.延迟重复执行函数 //InvokeRepeating //参数一：函数名字符串 //参数二：第一次执行的延迟时间 //参数三：之后每次执行的间隔时间 InvokeRepeating(\"DelayRe\", 5, 1); //注意： //它的注意事项和延时函数一致 3.取消延迟函数 //3-1取消该脚本上的所有延时函数执行 CancelInvoke(); //3-2指定函数名取消 //只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消 CancelInvoke(\"DelayDoSomething\"); 4.判断是否有延迟函数 if( IsInvoking()) { print(\"存在延迟函数\"); } if( IsInvoking(\"DelayDoSomething\") ) { print(\"存在延迟函数DelayDoSomething\"); } 知识点三 延迟函数受对象失活销毁影响 //脚本依附对象失活 或者 脚本自己失活 //延迟函数可以继续执行 不会受到影响的 //脚本依附对象销毁或者脚本移除 //延迟函数无法继续执行 协同程序1.Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容(注意：Unity中的多线程 要记住关闭);2.协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿,继承MonoBehavior的类都可以使用协程;3.协程只有当组件单独失活时不受影响，其它情况协程会停止4.API 知识点一 协程的使用 //继承MonoBehavior的类 都可以开启 协程函数 //第一步：申明协程函数 // 协程函数2个关键点 // 1-1返回值为IEnumerator类型及其子类 // 1-2函数中通过 yield return 返回值; 进行返回 //第二步：开启协程函数 //协程函数 是不能够 直接这样去执行的！！！！！！！ //这样执行没有任何效果 //MyCoroutine(1, \"123\"); //常用开启方式 //IEnumerator ie = MyCoroutine(1, \"123\"); //StartCoroutine(ie); Coroutine c1 = StartCoroutine( MyCoroutine(1, \"123\") ); Coroutine c2 = StartCoroutine( MyCoroutine(1, \"123\")); Coroutine c3 = StartCoroutine( MyCoroutine(1, \"123\")); //第三步：关闭协程 //关闭所有协程 //StopAllCoroutines(); //关闭指定协程 //StopCoroutine(c1); 知识点二 yield return 不同内容的含义 //1.下一帧执行 //yield return 数字; //yield return null; //在Update和LateUpdate之间执行 //2.等待指定秒后执行 //yield return new WaitForSeconds(秒); //在Update和LateUpdate之间执行 //3.等待下一个固定物理帧更新时执行 //yield return new WaitForFixedUpdate(); //在FixedUpdate和碰撞检测相关函数之后执行 //4.等待摄像机和GUI渲染完成后执行 //yield return new WaitForEndOfFrame(); //在LateUpdate之后的渲染相关处理完毕后之后 //5.一些特殊类型的对象 比如异步加载相关函数返回的对象 //之后讲解 异步加载资源 异步加载场景 网络加载时再讲解 //一般在Update和LateUpdate之间执行 //6.跳出协程 //yield break; 协同程序原理1.协程的本质 就是利用 C#的迭代器函数”分步执行”的特点+协程调度逻辑 实现的一套分时执行函数的规则; 2.代码实现： 知识点一 协程的本质 //协程可以分成两部分 //1.协程函数本体 //2.协程调度器 //协程本体就是一个能够中间暂停返回的函数 //协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数 //Unity只实现了协程调度部分 //协程的本体本质上就是一个 C#的迭代器方法 知识点二 协程本体是迭代器方法的体现 //1.协程函数本体 //如果我们不通过 开启协程方法执行协程 //Unity的协程调度器是不会帮助我们管理协程函数的 IEnumerator ie = Test(); //但是我们可以自己执行迭代器函数内容 ie.MoveNext();//会执行函数中内容遇到 yield return为止的逻辑 print(ie.Current);//得到 yield return 返回的内容 //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //TestClass tc = ie.Current as TestClass; //print(tc.time); //MoveNext 返回值 代表着 是否到了结尾)这个迭代器函数 是否执行完毕) //2.协程调度器 //继承MonoBehavior后 开启协程 //相当于是把一个协程函数)迭代器)放入Unity的协程调度器中帮助我们管理进行执行 //具体的yield return 后面的规则 也是Unity定义的一些规则 #Resources资源动态加载 Unity中的特殊文件夹知识点一 工程路径获取 //注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用 //我们不会在实际发布游戏后 还使用该路径 //游戏发布过后 该路径就不存在了 print(Application.dataPath); 知识点二 Resources 资源文件夹 //路径获取： //一般不获取 //只能使用Resources相关API进行加载 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Resources\"); //注意： //需要我们自己将创建 //作用： //资源文件夹 //1-1.需要通过Resources相关API动态加载的资源需要放在其中 //1-2.该文件夹下所有文件都会被打包出去 //1-3.打包时Unity会对其压缩加密 //1-4.该文件夹打包后只读 只能通过Resources相关API加载 知识点三 StreamingAssets 流动资源文件夹 //路径获取： print(Application.streamingAssetsPath); //注意： //需要我们自己将创建 //作用： //流文件夹 //2-1.打包出去不会被压缩加密，可以任由我们摆布 //2-2.移动平台只读，PC平台可读可写 //2-3.可以放入一些需要自定义动态加载的初始资源 知识点四 persistentDataPath 持久数据文件夹 //路径获取： print(Application.persistentDataPath); //注意： //不需要我们自己将创建 //作用： //固定数据文件夹 //3-1.所有平台都可读可写 //3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中 知识点五 Plugins 插件文件夹 //路径获取： //一般不获取 //注意： //需要我们自己将创建 //作用： //插件文件夹 //不同平台的插件相关文件放在其中 //比如IOS和Android平台 知识点六 Editor 编辑器文件夹 //路径获取： //一般不获取 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Editor\"); //注意： //需要我们自己将创建 //作用： //编辑器文件夹 //5-1.开发Unity编辑器时，编辑器相关脚本放在该文件夹中 //5-2.该文件夹中内容不会被打包出去 知识点七 默认资源文件夹 Standard Assets //路劲过去： //一般不获取 //注意： //需要我们自己将创建 //作用： //默认资源文件夹 //一般Unity自带资源都放在这个文件夹下 //代码和资源优先被编译 UnityEngine.Application - Unity 脚本手册 Scripting API Resources同步加载知识点一 常用资源类型 //1.预设体对象——GameObject)要实例化) //2.音效文件——AudioClip //3.文本文件——TextAsset //4.图片文件——Texture //5.其它类型——需要什么用什么类型 知识点二 资源同步加载 普通方法 //在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 //打包时 Resources文件夹 里的内容 都会打包在一起 //1.预设体对象 想要创建在场景上 记住实例化 // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj = Resources.Load(\"Cube\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj); // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj2 = Resources.Load(\"Sphere\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj2); //2.音效资源 //第一步：就是加载数据 Object obj3 = Resources.Load(\"Music/BKMusic\"); //第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可 audioS.clip = obj3 as AudioClip; audioS.Play(); //3.文本资源 //文本资源支持的格式 //.txt //.xml //.bytes //.json //.html //.csv //..... TextAsset ta = Resources.Load(\"Txt/Test\") as TextAsset; //文本内容 print(ta.text); //字节数据组 //print(ta.bytes); //4.图片 tex = Resources.Load(\"Tex/TestJPG\") as Texture; GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);)(画出图片) //5.其它类型 需要什么类型 就用什么类型就行 //6.问题：资源同名怎么办 //Resources.Load加载同名资源时 无法准确加载出你想要的内容 //可以使用另外的API //6-1加载指定类型的资源 //tex = Resources.Load(\"Tex/TestJPG\", typeof(Texture)) as Texture; ta = Resources.Load(\"Tex/TestJPG\", typeof(TextAsset)) as TextAsset; //print(ta.text); //6-2加载指定名字的所有资源 Object[] objs = Resources.LoadAll(\"Tex/TestJPG\"); 知识点三 资源同步加载 泛型方法 TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(\"Tex/TestJPG\"); print(ta2.text); tex = Resources.Load&lt;Texture&gt;(\"Tex/TestJPG\"); Resources异步加载知识点一 Resources异步加载方法 //注意： //异步加载 不能马上得到加载的资源 至少要等一帧 //1.通过异步加载中的完成事件监听 使用加载的资源 //这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载 //ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); //马上进行一个 资源下载结束 的一个事件函数监听 //rq.completed += LoadOver; print(Time.frameCount); //这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的 //一定要等加载结束过后 才能使用 //rq.asset ×××××××××××× //2.通过协程 使用加载的资源 StartCoroutine(Load()); IEnumerator Load() { //迭代器函数 当遇到yield return时 就会 停止执行之后的代码 //然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时 ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); print(Time.frameCount); //第一部分 //Unity 自己知道 该返回值 意味着你在异步加载资源 //yield return rq; //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码 print(Time.frameCount); //判断资源是否加载结束 while(!rq.isDone) { //打印当前的 加载进度 (0-1浮点型值) print(rq.progress); yield return null; } tex = rq.asset as Texture; } 总结： //1.完成事件监听异步加载 //好处：写法简单 //坏处：只能在资源加载结束后 进行处理 //“线性加载” //2.协程异步加载 //好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新 //坏处：写法稍麻烦 //“并行加载” //注意： //理解为什么异步加载不能马上加载结束，为什么至少要等1帧 //理解协程异步加载的原理 Resources卸载资源知识点一 Resources重复加载资源会浪费内存吗？ //其实Resources加载一次资源过后 //该资源就一直存放在内存中作为缓存 //第二次加载时发现缓存中存在该资源 //会直接取出来进行使用 //所以 多次重复加载不会浪费内存 //但是 会浪费性能)每次加载都会去查找取出，始终伴随一些性能消耗) 知识点二 如何手动释放掉缓存中的资源 //1.卸载指定资源 //Resources.UnloadAsset 方法 //注意： //该方法 不能释放 GameObject对象 因为它会用于实例化对象 //它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等 //一般情况下 我们很少单独使用它 //GameObject obj = Resources.Load&lt;GameObject&gt;(\"Cube\"); //即使是没有实例化的 GameObject对象也不能进行卸载 //Resources.UnloadAsset(obj); //2.卸载未使用的资源 //注意： //一般在过场景时和GC一起使用 Resources.UnloadUnusedAssets(); GC.Collect(); 场景切换 需要把要加载的场景Build Settings中。 知识点一 场景同步切换 //在切换场景时 //Unity会删除当前场景上所有对象 //并且去加载下一个场景的相关信息 //如果当前场景 对象过多或者下一个场景对象过多 //这个过程会非常的耗时 会让玩家感受到卡顿 SceneManager.LoadScene(\"Lesson20Test\"); 知识点二 场景异步切换 //场景异步加载和资源异步加载 几乎一致 有两种方式 //1.通过事件回调函数 异步加载 //AsyncOperation ao = SceneManager.LoadSceneAsync(\"Lesson20Test\"); //当场景异步加载结束后 就会自动调用该事件函数 我们如果希望在加载结束后 做一些事情 那么久可以在该函数中 //写处理逻辑 //ao.completed += (a) =&gt; //{ // print(\"加载结束\"); //}; //ao.completed += LoadOver; //2.通过协程异步加载 //需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了 //所以 协程中的部分逻辑 可能是执行不了的 //解决思路 //让处理场景加载的脚本依附的对象 过场景时 不被移除 //该脚本依附的对象 过场景时 不会被 移除 DontDestroyOnLoad(this.gameObject); StartCoroutine(LoadScene(\"Lesson20Test\")); IEnumerator LoadScene(string name) { //第一步 //异步加载场景 AsyncOperation ao = SceneManager.LoadSceneAsync(name); //Unity内部的 协程协调器 发现是异步加载类型的返回对象 那么就会等待 //等待异步加载结束后 才会继续执行 迭代器函数中后面的步骤 print(\"异步加载过程中 打印的信息\"); //协程的好处 是异步加载场景时 我可以在加载的同时 做一些别的逻辑 //yield return ao; //第二步 print(\"异步加载结束后 打印的信息\"); //比如 我们可以在异步加载过程中 去更新进度条 //第一种 就是利用 场景异步加载 的进度 去更新 但是 不是特别准确 一般也不会直接用 //while(!ao.isDone) //{ // print(ao.progress); // yield return null; //} //离开循环后 就会认为场景加载结束 //可以把进度条顶满 然后 隐藏进度条 //第二种 就是根据你游戏的规则 自己定义 进度条变化的条件 yield return ao; //场景加载结束 更新20%进度 //接着去加载场景中 的其它信息 //比如 //动态加载怪物 //这时 进度条 再更新20% //动态加载 场景模型 //这时 就认为 加载结束了 进度条顶满 //隐藏进度条 } SceneManagement.SceneManager - Unity 脚本手册 Scripting API 画线功能Linerenderer组件知识点一 LineRenderer是什么 //LineRenderer是Unity提供的一个用于画线的组件 //使用它我们可以在场景中绘制线段 //一般可以用于 //1绘制攻击范围 //2武器红外线 //3辅助功能 //4其它画线功能 知识点二ineRender代码相关 //动态添加一个线段 GameObject line = new GameObject(); line.name = \"Line\"; LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;(); //首尾相连 lineRenderer.loop = true; //开始结束宽 lineRenderer.startWidth = 0.02f; lineRenderer.endWidth = 0.02f; //开始结束颜色 lineRenderer.startColor = Color.white; lineRenderer.endColor = Color.red; //设置材质 m = Resources.Load&lt;Material&gt;(\"M\"); lineRenderer.material = m; //设置点 //一定注意 设置点 要 先设置点的个数 lineRenderer.positionCount = 4; //接着就设置 对应每个点的位置 lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0), new Vector3(0,0,5), new Vector3(5,0,5)}); lineRenderer.SetPosition(3, new Vector3(5, 0, 0)); //是否使用世界坐标系 //决定了 是否随对象移动而移动 lineRenderer.useWorldSpace = false; //让线段受光影响 会接受光数据 进行着色器计算 lineRenderer.generateLightingData = true; UnityEngine.LineRenderer - Unity 脚本手册 Scripting API 核心系统UnityEngine.Physics - Unity 脚本手册 Scripting API 物理系统之范围检测知识点二 如何进行范围检测 //必备条件：想要被范围检测到的对象 必须具备碰撞器 //注意点： //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的 //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已 //范围检测API //1.盒状范围检测 //参数一：立方体中心点 //参数二：立方体三边大小 //参数三：立方体角度 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) print(LayerMask.NameToLayer(\"UI\")); Collider[] colliders = Physics.OverlapBox( Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up), 1 &lt;&lt; LayerMask.NameToLayer(\"UI\") | 1 &lt;&lt; LayerMask.NameToLayer(\"Default\"), QueryTriggerInteraction.UseGlobal); //0000 0001 //0010 0000 //重要知识点： //关于层级 //通过名字得到层级编号 LayerMask.NameToLayer //我们需要通过编号左移构建二进制数 //这样每一个编号的层级 都是 对应位为1的2进制数 //我们通过 位运算 可以选择想要检测层级 //好处 一个int 就可以表示所有想要检测的层级信息 //层级编号是 0~31 刚好32位 //是一个int数 //每一个编号 代表的 都是二进制的一位 //0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1 //1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2 //2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4 //3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8 //4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16 //5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32 //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapBoxNonAlloc() if(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) //2.球形范围检测 //参数一：中心点 //参数二：球半径 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer(\"Default\")); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapSphereNonAlloc if( Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0 ) //3.胶囊范围检测 //参数一：半圆一中心点 //参数二：半圆二中心点 //参数三：半圆半径 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer(\"UI\"), QueryTriggerInteraction.UseGlobal); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapCapsuleNonAlloc if ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders ) != 0 ) 物理系统之射线检测知识点一 射线对象 //1.3D世界中的射线 //假设有一条 //起点为坐标(1,0,0) //方向为世界坐标Z轴正方向的射线 //注意： //理解参数含义 //参数一：起点 //参数二：方向)一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量) //目前只是申明了一个射线对象 对于我们来说 没有任何的用处 Ray r = new Ray(Vector3.right, Vector3.forward); //Ray中的参数 print(r.origin);//起点 print(r.direction);//方向 //2.摄像机发射出的射线 // 得到一条从屏幕位置作为起点 // 摄像机视口方向为 方向的射线 Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition); 知识点三 碰撞检测函数 //Physics类中提供了很多进行射线检测的静态函数 //他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了 //注意： //射线检测也是瞬时的 //执行代码时进行一次射线检测 //1.最原始的射线检测 // 准备一条射线 Ray r3 = new Ray(Vector3.zero, Vector3.forward); // 进行射线检测 如果碰撞到对象 返回true //参数一：射线 //参数二: 检测的最大距离 超出这个距离不检测 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：bool 当碰撞到对象时 返回 true 没有 返回false if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向 if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //2.获取相交的单个物体信息 //物体信息类 RaycastHit RaycastHit hitInfo; //参数一：射线 //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中 //参数三：距离 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal if( Physics.Raycast(r3, out hitInfo, 1000, 1&lt;&lt;LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) ) { //碰撞器信息 print(\"碰撞到物体的名字\" + hitInfo.collider.gameObject.name); //碰撞到的点 print(hitInfo.point); //法线信息 print(hitInfo.normal); //得到碰撞到对象的位置 print(hitInfo.transform.position); //得到碰撞到对象 离自己的距离 print(hitInfo.distance); //RaycastHit 该类 对于我们的意义 //它不仅可以得到我们碰撞到的对象信息 //还可以得到一些 碰撞的点 距离 法线等等的信息 } //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //3.获取相交的多个物体 //可以得到碰撞到的多个对象 //如果没有 就是容量为0的数组 //参数一：射线 //参数二：距离 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //之前的参数一射线 通过两个点传入 hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种函数 返回的碰撞的数量 通过out得到数据 if(Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) &gt; 0 ) UnityEngine.Ray - Unity 脚本手册 Scripting API UnityEngine.RaycastHit - Unity 脚本手册 Scripting API","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity入门","slug":"03001-Unity入门","date":"2019-08-30T13:00:00.000Z","updated":"2022-01-26T14:50:32.995Z","comments":true,"path":"posts/1537.html","link":"","permalink":"http://wwy010518.github.io/posts/1537.html","excerpt":"","text":"将之前的笔记整理下来 Unity概叙 Unity是一个游戏开发的集成工具，降低了游戏开发的门槛，提高了开发效率。 工程文件夹Assets：工程资源文件夹(美术资源脚本)Library:库文件夹Logs:日志文件夹obj:编译中间文件Packages:包配置信息ProjectSettings:工程设置信息 Unity界面基础Inspector检查窗口：用于设置游戏对象具体信息Console控制台窗口：用于显示调试信息，报错、警告、打印信息等Scene场景窗口：所有游戏对象所在地Hierarchy层级窗口：所有游戏的对象名单Game游戏窗口：玩家看到的游戏画面Project工程窗口：所有游戏资源和脚本内容 Scence场景和Hierarchy层级窗口Hierarchy 我们可以在Hierarchy窗口中创建或拖入各种游戏对象。Hierarchy层级窗口快捷键：F2：对象改名Ctrl+C：复制Ctrl+V：粘贴Ctrl+D：克隆一个Delete：删除 Scence 我们可以在Scene窗口中查看所有游戏对象设置所有游戏对象。窗口上方工具条内容：1.渲染模式2.2D、3D视图切换3.光源、音效、特效显示开启4.辅助线显示5.辅助功能，控制场景上提示图标等6.搜索7.场景轴向 关于Unity中的3D世界坐标轴：红色为X轴正向绿色为Y轴正向蓝色为Z轴正向 以屏幕为参照物：垂直屏幕向内为Z正方向平行屏幕向右为X正方向平行屏幕向上为Y正方向 场景中的操作：左键相关： 鼠标单击：选中单个物体 鼠标框选：选中多个物体 Ctrl+鼠标单击：多选物体 长按ALT键+鼠标左键+移动鼠标：相对观察视口中心点旋转 选中物体之后，按F键：居中显示物体(或者在层级窗口中双击对象) 右键相关： 鼠标右键按下+移动鼠标：旋转视口 鼠标右键按下+WASD：漫游场景 鼠标右键按下+WASD+Shift：快速漫游场景长按ALT键+鼠标右键+移动鼠标：相对屏幕中心点拉近拉远 中键相关：滚动鼠标中间：相对屏幕中心点拉近拉远鼠标中间按下+移动鼠标：平移观察视口长按ALT键+滚动鼠标中间：鼠标指哪就朝哪拉近拉 Game游戏和Project工程Game 游戏画面窗口，玩家能看到的画面内容. Project 工程资源窗口，所有的工程资源都会在该窗口中显示，显示的内容为Assets文件夹中的所有内容. Project工程窗口关键功能:1.窗口设置2.创建相关资源文件3.查找4.按资源类型查找5.按名字查找 资源类型:图片格式：jpg、png、tga模型格式：fbx、max、maya音效：wav、mp3、ogg文本：txt、json、bytes视频：mp4 Inspector检查和Console控制台Inspector 查看场景中游戏对象关联的C#脚本信息. Console 用于查看调试信息的窗口报错、警告、测试打印都可以显示在其中,默认未开启可以在Window——&gt;General中开启或者使用快捷键：Ctrl+Shift+C，该窗口将显示代码编译过程中或者游戏运行过程中的报错、警告、测试信息主要用于查错和调试用。 Console控制台窗口：1.清空控制台2.相同内容折叠显示3.运行时清空4.构建时清空5.报错暂停运行6.是否显示错误信息7.是否显示警告信息8.是否显示打印信息 工具栏和父子关系工具栏从左到右：1.文件操作：新建工程，新建场景，工程打包等等2.编辑操作：对象编辑操作相关，工程设置，引擎设置相关3.资源操作：基本等同于Project窗口中右键相关功能4.对象操作：基本等同于Hierarchy窗口中右键相关功能5.脚本操作：Unity自带的脚本，可以添加各系统中的脚本7.窗口：可以打开Unity各核心系统的窗口9.帮助：检查更新，查看版本等等功能 File中的重要选项：BuildSetting(工程发布打包)Edit中的重要选项：Project Setting(工程各系统设置)、Preferences(首选项，可以设置编程软件)、GameObject中的重要选项：MoveToView、Align With View、Align View to Selected(几种快捷设置位置的功能) 父子关系 对象之间产生父子关系后，如何相互影响？爸爸干嘛，儿子干嘛；儿子干嘛，爸爸不管。Scene上方作用：pivot：以本身为中心点；center：以整体为中心点；local：以本身旋转为朝向；global：以世界坐标为朝向； Unity工作原理 使用它时是处于运行中的，我们是在一个运行中的软件里制作游戏的，Unity开发的本质就是在Unity引擎的基础上,利用反射和引擎提供的各种功能进行的拓展开发。 反射机制和游戏场景反射机制的体现：除了Transform这个表示位置的标配剧本外，我们可以为这个演员(GameObject)关联各种剧本(C#脚本)，让它按照我们剧本中(代码逻辑中)的命令来处理事情，而为演员添加剧本的这个过程，就是在利用反射new一个新的剧本对，象和演员(GameObject)对象进行关联，让其按我们的命令做事； 利用反射举例体现：1.修改Inspector面板中Transform的内容：已知对象，类名，变量名，通过反射为该对象设置变量值；2.新建一个脚本后，添加给一个指定的GameObject对象：已知类名，可以获取所有公共成员，故可以在Inspector面板上创建各公共字段信息 游戏场景的本质：游戏场景文件后缀为.unity，它的本质就是一个配置文件，Unity有一套自己识别处理它的机制，但是本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象； 预设物和资源包的导入导出后缀名：.prefab，Prefabs放该类型文件;预制物删除变红处理：点击预制物右键Unpack Prefab;Project右键：导入导出包(.unitypackage); Unity脚本基础默认脚本内容：Editor\\Data\\Resources\\ScriptTemplates 脚本基本规则1.创建规则： 1.不在VS中创建脚本了 2.可以放在Assets文件夹下的任何位置(建议同一文件夹管理) 3.类名和文件名必须一致,不然不能挂载(因为反射机制创建对象，会通过文件名去找Type) 4.建议不要使用中文名命名 5.没有特殊需求 不用管命名空间 6.创建的脚本默认继承MonoBehavior 2.MonoBehavior基类： 1.创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 2.继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 3.继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 4.继承了MonoBehavior的脚本可以在一个对象上挂多个(如果没有加DisallowMultipleComponent特性) 5.继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 3.不继承MonoBehavior的类 1.不继承Mono的类 不能挂载在GameObject上 2.不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 3.不继承Mono的类 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据) 4.不继承Mono的类 不用保留默认出现的几个函数 生命周期函数总结：这些生命周期函数 如果你不打算在其中写逻辑 那就不要使用这些命周期函数。我们要知道，虽然建议大家不在继承MonoBehavior的类中写构造函数；但是不意味着我们不能写，当我们在继承MonoBehavior的类中写无参构造函数时，你会发现在编辑模式下或者运行后，只要该脚本挂载在场景中，那么该无参构造函数是会被自动执行的。因为Unity的工作原理中提到的反射机制，Unity实际上通过反射帮助我们实例化了该脚本对象，既然要实例化那么肯定是需要new的，只不过Unity中不需要我们自己new继承了MonoBehavior的类，只要挂载后Unity帮助我们做了这件事。那么为什么不建议大家写构造函数呢？1.Unity的规则就是，继承MonoBehavior的脚本不能new只能挂载2.生命周期函数的Awake是类似构造函数的存在，当对象出生就会自动调用3.写构造函数反而在结构上会破坏Unity设计上的规范 打印方式：普通：Debug.Log(“123”);报错：Debug.LogError(“出错了！！！！！”);警告：Debug.LogWarning(“警告！！！”); Inspector窗口可编辑变量知识点一: 私有和保护无法显示编辑，公共的可以显示编辑；知识点二 ：[SerializeField]让私有的和保护的也可以被显示；知识点三：[HideInInspector]公共的也不让其显示编辑；知识点四：[System.Serializable] 让自定义类型可以被访问；//加在类前，而字典怎么都不行知识点七： 辅助特性1.[Header(“分组说明”)] ：分组说明特性，为成员分组；2.[Tooltip(“说明内容”)] //悬停注释，为变量添加说明；3.[Space()]：间隔特性，让两个字段间出现间隔4.[Range(最小值, 最大值)] //修饰数值的滑条范围；5.[TextArea(3, 4)] ：滚动条显示字符串，默认不写参数就是超过3行显示滚动条；6.[ContextMenuItem(“显示按钮名”, “方法名”)] ：为变量添加快捷方法，参数1 显示按钮名，参数2 方法名 不能有参数；7.[Multiline(4)] ：多行显示字符串 默认不写参数显示3行8.[ContextMenu(“测试函数”)] ：方法添加特性能够在Inspector中执行 继承自MonoBehavior重要内容重要成员1.获取依附的GameObject：this.gameObject;2.获取依附的GameObject的位置信息：-print(this.transform.position);//位置-print(this.transform.eulerAngles);//角度-print(this.transform.lossyScale);//缩放大小3.获取脚本是否激活： this.enabled； 重要方法1:得到依附对象上挂载的其它脚本 //1.得到自己挂载的单个脚本,获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空 this.GetComponent(\"脚本名\"); //2.得到自己挂载的多个脚本 this.GetComponents&lt;泛形类型&gt;(); //3.得到子对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) //函数是有一个参数的 默认不传 是false 意思就是 如果子对象失活 是不会去找这个对象上是否有某个脚本的 //如果传true 及时 失活 也会找 //得子对象 挂载脚本 单个 this.GetComponentInChildren&lt;泛形类型&gt;(true); this.GetComponentsInChildren&lt;泛形类型&gt;(true); //4.得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) this.GetComponentInParent&lt;泛形类型&gt;(); this.GetComponentsInParent&lt;泛形类型&gt;(); //5.尝试获取脚本 //提供了一个更加安全的 获取单个脚本的方法 如果得到了 会返回true //然后在来进行逻辑处理即可 this.TryGetComponent&lt;泛形类型&gt;(out 赋值变量) Unity重要组件和APIGameObject最小单位直接实例化：new GameObject(“实体名”，typeof(要添加的组件名)…….) ； 注意事项：1.建议使用Destroy方法，它是异步的，不会马上删除对象，只是给对象加一个标识，一般情况下下一帧才会把对象从内存一处。；2.如果继承自mono，可以省略GameObject字段；3.对象失活也是可以用一些方式获取的；4.广播方法效率很低，不建议使用； 知识点一 GameObject中的成员变量 //名字 print(this.gameObject.name); this.gameObject.name = \"Lesson4唐老狮改名\"; print(this.gameObject.name); //是否激活 print(this.gameObject.activeSelf); //是否是静态 print(this.gameObject.isStatic); //层级 print(this.gameObject.layer); //标签 print(this.gameObject.tag); transform this.transform 上一节课讲解的 通过Mono去得到的依附对象的GameObject的位置信息 //他们得到的信息是一样 都是依附的GameObject的位置信息 print(this.gameObject.transform.position); 知识点二 GameObject中的静态方法 //创建自带几何体 //只要得到了一个GameObject对象 我就可以得到它身上挂在的任何脚本信息 //通过obj.GetComponent来得去 GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.name = \"唐老狮创建的立方体\"; //查找对象相关的知识 //两种找单个对象的共同点: //1.无法找到失活的对象的 // 只能找到 激活的对象 //2.如果场景中 存在多个满足条件的对象 // 我们无法准确确定找到的是谁 //1查找单个对象 //通过对象名查找 //这个查找效率比较低下 因为他会在场景中的所有对象去查找 //没有找到 就会返回null GameObject obj2 = GameObject.Find(\"唐老狮\"); //通过tag来查找对象 GameObject obj3 = GameObject.FindWithTag(\"Player\"); //和上面的方法一样，名字不一样而已 GameObject obj3 = GameObject.FindGameObjectWithTag(\"Player\"); //得到某一个单个对象 目前有2种方式了 //1.是public从外部面板拖 进行关联 //2.通过API去找 //2查找多个对象 //找多个对象的API 只能是通过tag去找多个 通过名字 是没有找多个的方法的 //通过tag找到多个对象 //它也是 只能找到 激活对象 无法找到失活对象 GameObject obj3 = GameObject.FindGameObjectsWithTag(\"Player\"); //还有几个查找对象相关是用的比较少的方法 是GameObject父类 Object提供的方法 //引出额外知识点 Unity中的Object和C#中的万物之父的区别 //Unity里面的Object 不是指的万物之父object //Unity里的Object 命名空间在UnityEngine中的 Object类 也是集成万物之父的一个自定义类 //C#中的Object 命名空间是在System中的 //它可以找到场景中挂载的某一个脚本对象 //效率更低 上面的GameObject.Find 和通过FindWithTag找 只是遍历对象 //这个方法 不仅要遍历对象 还要遍历对象上挂载的脚本 Lesson4 o = GameObject.FindObjectOfType&lt;Lesson4&gt;(); print(o.gameObject.name); //实例化对象(克隆对象)的方法 //实例化(克隆)对象 它的作用 是根据一个GameObject对象 创建出一个和它一模一样的对象 GameObject obj5 = GameObject.Instantiate(myObj); //以后学了更多知识点 就可以在这操作obj5 //如果你继承了 MonoBehavior 其实可以不用写GameObject一样可以使用 //因为 这个方法时Unity里面的 Object基类提供给我们的 所以可以直接用 Instantiate(myObj); //删除对象的方法 GameObject.Destroy(myObj2); //第二个参数 代表延迟几秒钟删除 GameObject.Destroy(obj5, 5); Destroy不仅可以删除对象 还可以删除脚本 GameObject.Destroy(this); //删除对象有两种作用 //1.是删除指定的一个游戏对象 //2.是删除一个指定的脚本对象 //注意：这个Destroy方法 不会马上移除对象 只是给这个对象加了一个移除标识 // 一般情况下 它会在下一帧时把这个对象移除并从内存中移除 //如果没有特殊需求 就是一定要马上移除一个对象的话 //建议使用上面的 Destroy方法 因为 是异步的 降低卡顿的几率 //下面这个方法 就是立即把对象 从内存中移除了 GameObject.DestroyImmediate(myObj); //如果是继承MonoBehavior的类 不用写GameObject Destroy(myObj2); DestroyImmediate(myObj); //过场景不移除 //默认情况 在切换场景时 场景中对象都会被自动删除掉 //如果你希望某个对象 过场景不被移除 //下面这句代码 就是不想谁过场景被移除 就传谁 //一般都是传 依附的GameObject对象 //比如下面这句代码的意思 就是自己依附的GameObject对象 过场景不被删除 GameObject.DontDestroyOnLoad(this.gameObject); //如果继承MOnoBehavior也可以直接写 DontDestroyOnLoad(this.gameObject); 知识点三 GameObject中的成员方法 //创建空物体 //new一个GameObject就是在创建一个空物体 GameObject obj6 = new GameObject(); GameObject obj7 = new GameObject(\"唐老狮创建的空物体\"); GameObject obj8 = new GameObject(\"顺便加脚本的空物体\", typeof(Lesson2),typeof(Lesson1)); //为对象添加脚本 //继承MOnoBehavior的脚本 是不能够去new //如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上 //直接使用GameObject提供的方法即可 Lesson1 les1 = obj6.AddComponent(typeof(Lesson1)) as Lesson1; //用泛型更方便 Lesson2 les2 = obj6.AddComponent&lt;Lesson2&gt;(); //通过返回值 可以得到加入的脚本信息 //来进行一些处理 //得到脚本的成员方 和继承Mono的类得到脚本的方法 一模一样 //标签比较 //下面两种比较的方法 是一样的 if(this.gameObject.CompareTag(\"Player\")) { print(\"对象的标签 是 Player\"); } if(this.gameObject.tag == \"Player\") { print(\"对象的标签 是 Player\"); } //设置激活失活 //false 失活 true 激活 obj6.SetActive(false); obj7.SetActive(false); obj8.SetActive(false); //次要的成员方法 了解即可 不建议使用 //强调 //下面讲的方法 都不建议大家使用 效率比较低 //通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法 //通知自己 执行什么行为 //命令自己 去执行这个TestFun这个函数 会在自己身上挂在的所有脚本去找这个名字的函数 //它会去找到 自己身上所有的脚本 有这个名字的函数去执行 this.gameObject.SendMessage(\"TestFun\"); this.gameObject.SendMessage(\"TestFun2\", 199); //广播行为 让自己和自己的子对象执行 this.gameObject.BroadcastMessage(\"函数名\"); //向父对象和自己发送消息 并执行 this.gameObject.SendMessageUpwards(\"函数名\"); Unity 脚本 API (unity3d.com) Time时间相关作用：主要 用于游戏中参与位移、记时、时间暂停等；重要内容: //知识点一 时间缩放比例 //时间停止 Time.timeScale = 0; //回复正常 Time.timeScale = 1; //2倍速 Time.timeScale = 2; //知识点二 帧间隔时间 //帧间隔时间 主要是用来计算位移 //路程 = 时间*速度 //根据需求 选择参与计算的间隔时间 //如果希望 游戏暂停时就不动的 那就使用 Time.deltaTime; //如果希望 不受暂停影响 Time.unscaledDeltaTime; //帧间隔时间：最近的一帧 用了多长时间(秒) //受scale影响 print(\"帧间隔时间\" + Time.deltaTime); //不受scale影响的帧间隔时间 print(\"不受scale影响的帧间隔时间\" + Time.unscaledDeltaTime); 知识点三 游戏开始到现在的时间 //它主要用来计时 单机游戏中计时 //受scale影响 print(\"游戏开始到现在的时间:\" + Time.time); //不受scale影响 print(\"不受scale影响的游戏开始到现在的时间:\" + Time.unscaledTime); 知识点四 物理帧间隔时间 FixedUpdate //受scale影响 Time.fixedDeltaTime; //不受scale影响 Time.fixedUnscaledDeltaTime; 知识点五 帧数 //从开始到现在游戏跑了多少帧(次循环) print(Time.frameCount); UnityEngine.Time - Unity 脚本 API (unity3d.com) Transfrom-位置和位移Vector3常用： //常用变量 print(Vector3.zero);//000 print(Vector3.right);//100 print(Vector3.left);//-100 print(Vector3.forward);//001 print(Vector3.back);//00-1 print(Vector3.up);//010 print(Vector3.down);//0-10 //常用方法 (后续加) //计算两个点之间的距离的方法 print(Vector3.Distance(v1, v12)); //返回float 两个向量之间的角度(以度为单位) Vector3.Angle(); UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 位置(注意：位置的赋值不能直接改变x，y，z 只能整体改变)位移方式： //知识点一：位置 //相对世界坐标系 this.gameObject.transform； //相对父对象 this.transform.localPosition； //世界正朝向 Vector3.forwad; //本身正朝向 transform.forward； //知识点二 位移 //坐标系下的位移计算公式：路程 = 方向 * 速度 * 时间 //方式一 自己计算 //想要变化的 就是 position //用当前的位置 + 我要动多长距离 得出最终所在的位置 this.transform.position = this.transform.position + this.transform.up * 1 * Time.deltaTime; //因为我用的是 this.transform.forward 所以它始终会朝向相对于自己的面朝向去动 this.transform.position += this.transform.forward * 1 * Time.deltaTime; //方向非常重要 因为 它决定了你的前进方向 this.transform.position += Vector3.forward * 1 * Time.deltaTime; //方式二 API //参数一：表示位移多少 路程 = 方向 * 速度 * 时间 //参数二：表示 相对坐标系 默认 该参数 是相对于自己坐标系的 //1相对于世界坐标系的 Z轴 动 始终是朝 世界坐标系 的 Z轴正方向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); //2相对于世界坐标的 自己的面朝向去动 始终朝自己的面朝向移动 this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World); //3相对于自己的坐标系 下的 自己的面朝向向量移动 (一定不会这样让物体移动) XXXXXXX this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.Self); //4相对于自己的坐标系 下的 Z轴正方向移动 始终朝自己的面朝向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self); UnityEngine.Transform - Unity 脚本 API (unity3d.com) Tramsfrom-角度和旋转知识点一 角度相关 相对世界坐标角度：transform.eulerAngles； 相对父对象角度：transform.localEulerAngles； 知识点二 旋转相关 //自己计算(省略 和位置一样 不停改变角度即可) //API计算 //自转 //每个轴 具体转多少度 //第一个参数 相当于 是旋转的角度 每一帧 //第二个参数 默认不填 就是相对于自己坐标系 进行的旋转 this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime); this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World); //相对于某个轴 转多少度 //参数一：是相对哪个轴进行转动 //参数二：是转动的 角度 是多少 //参数三：默认不填 就是相对于自己的坐标系 进行旋转 // 如果填 可以填写相对于 世界坐标系进行旋转 this.transform.Rotate(Vector3.right, 10 * Time.deltaTime); this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World); //相对于某一个点转 //参数一：相当于哪一个点 转圈圈 //参数二：相对于那一个点的 哪一个轴转圈圈 //参数三：转的度数 旋转速度 * 时间 this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime); Transfrom-缩放和看向知识点一 缩放 //相对世界坐标系 print(this.transform.lossyScale); //相对本地坐标系(父对象) print(this.transform.localScale); //注意： //1.同样缩放不能只改xyz 只能一起改(相对于世界坐标系的缩放大小只能得 不能改) //所以 我们一般要修改缩放大小 都是改的 相对于父对象的 缩放大小 localScale this.transform.localScale = new Vector3(3, 3, 3); //2.Unity没有提供关于缩放的API //之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有 //如果你想要 让 缩放 发生变化 只能自己去写(自己算) this.transform.localScale += Vector3.one * Time.deltaTime; 知识点二 看向 //让一个对象的面朝向 可以一直看向某一个点或者某一个对象 //看向一个点 相对于世界坐标系的 this.transform.LookAt(Vector3.zero); //看向一个对象 就传入一个对象的 Transform信息 this.transform.LookAt(lookAtObj); Transfrom-父子关系知识点一 获取和设置父对象 //获取父对象 print(this.transform.parent.name); //设置父对象 断绝父子关系 this.transform.parent = null; //设置父对象 认爸爸 this.transform.parent = GameObject.Find(\"Father2\").transform; //通过API来进行父子关系的设置 this.transform.SetParent(null);//断绝父子关系 this.transform.SetParent(GameObject.Find(\"Father2\").transform);//认爸爸 //参数一：我的父亲 //参数二：是否保留世界坐标的 位置 角度 缩放 信息 // true 会保留 世界坐标下的状态 和 父对象 进行计算 得到本地坐标系的信息 // false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 this.transform.SetParent(GameObject.Find(\"Father3\").transform, false); 知识点二 抛妻弃子 //就是和自己的所有儿子 断绝关系 没有父子关系了 this.transform.DetachChildren(); 知识点三 获取子对象 //按名字查找儿子 //找到儿子的 transform信息 //Find方法 是能够找到 失活的对象的 ！！！！！ GameObject相关的 查找 是不能找到失活对象的 print(this.transform.Find(\"Cube (1)\").name); //他只能找到自己的儿子 找不到自己的孙子 ！！！！！！ print(this.transform.Find(\"GameObject\").name); //虽然它的效率 比GameObject.Find相关 要高一些 但是 前提是你必须知道父亲是谁 才能找 //遍历儿子 //如何得到有多少个儿子 //1.失活的儿子也会算数量 //2.找不到孙子 所以孙子不会算数量 print(this.transform.childCount); //通过索引号 去得到自己对应的儿子 //如果编号 超出了儿子数量的范围 那会直接报错的 //返回值 是 transform 可以得到对应儿子的 位置相关信息 this.transform.GetChild(0); 知识点四 儿子的操作 //判断自己的爸爸是谁 //一个对象 判断自己是不是另一个对象的儿子 if(son.IsChildOf(this.transform)) { print(\"是我的儿子\"); } //得到自己作为儿子的编号 print(son.GetSiblingIndex()); //把自己设置为第一个儿子 son.SetAsFirstSibling(); //把自己设置为最后一个儿子 son.SetAsLastSibling(); //把自己设置为指定个儿子 //就算你填的数量 超出了范围(负数或者更大的数) 不会报错 会直接设置成最后一个编号 son.SetSiblingIndex(1); Transfrom-坐标转换知识点一 世界坐标转本地坐标 print(Vector3.forward); //世界坐标系 转本地坐标系 可以帮助我们大概判断一个相对位置 //世界坐标系的点 转换 为相对本地坐标系的点 //受到缩放影响 print(\"转换后的点 \" + this.transform.InverseTransformPoint(Vector3.forward)); //世界坐标系的方向 转换 为相对本地坐标系的方向 //不受缩放影响 print(\"转换后的方向\" + this.transform.InverseTransformDirection(Vector3.forward)); //受缩放影响 print(\"转换后的方向(受缩放影响)\" + this.transform.InverseTransformVector(Vector3.forward)); 知识点二 本地坐标转世界坐标 //本地坐标系的点 转换 为相对世界坐标系的点 受到缩放影响 print(\"本地 转 世界 点\" + this.transform.TransformPoint(Vector3.forward)); //本地坐标系的方向 转换 为相对世界坐标系的方向 //不受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformDirection(Vector3.forward)); //受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformVector(Vector3.forward)); Input输入相关//知识点一 鼠标在屏幕位置 Input.mousePosition //知识点二 检测鼠标输入 //鼠标按下一瞬间 进入 //0左键 1右键 2中键 Input.GetMouseButtonDown(0) //中键滚动 //返回值的 y -1往下滚 0没有滚 1往上滚 //它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值 print(Input.mouseScrollDelta); //知识点三 检测键盘输入 //传入字符串的重载 //这里传入的 字符串 不能是大写的 不然会报错 //只能传入小写字符串 Input.GetKeyDown(\"q\") //推荐枚举型 Input.GetKey(KeyCode.W) //知识点四 检测默认轴输入 //我们学习鼠标 键盘输入 主要是用来 //控制玩家 比如 旋转 位移等等 //所以Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转 //键盘AD按下时 返回 -1到1之间的变换 //相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转 float h = Input.GetAxis(\"Horizontal\"); //键盘SW按下时 返回 -1到1之间的变换 //得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转 print(Input.GetAxis(\"Vertical\")); //鼠标横向移动时 -1 到 1 左 右 print(Input.GetAxis(\"Mouse X\")); //鼠标竖向移动时 -1 到 1 下 上 print(Input.GetAxis(\"Mouse Y\")); //我们默认的 GetAxis方法 是有渐变的 会总 -1~0~1之间 渐变 会出现小数 //GetAxisRaw方法 和 GetAxis使用方式相同 //只不过 它的返回值 只会是 -1 0 1 不会有中间值 //知识点三 其它的监听 //是否有任意键或鼠标长按 if(Input.anyKey) //是否有任意键或鼠标按下 if(Input.anyKeyDown) //这一帧的键盘输入 print(Input.inputString); //手柄输入相关 //得到连接的手柄的所有按钮名字 string[] strs = Input.GetJoystickNames(); //某一个手柄键按下 if( Input.GetButtonDown(\"Jump\") ) //某一个手柄键抬起 if (Input.GetButtonUp(\"Jump\")) //某一个手柄键长按 if (Input.GetButton(\"Jump\")) //移动设备触摸相关 if(Input.touchCount &gt; 0) { Touch t1 = Input.touches[0]; //位置 print(t1.position); //相对上次位置的变化 print(t1.deltaPosition); } //是否启用多点触控 Input.multiTouchEnabled = false; //陀螺仪(重力感应) //是否开启陀螺仪 必须开启 才能正常使用 Input.gyro.enabled = true; //重力加速度向量 print(Input.gyro.gravity); //旋转速度 print(Input.gyro.rotationRate); //陀螺仪 当前的旋转四元数 //比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响 //手机怎么动 它怎么动 print(Input.gyro.attitude); UnityEngine.Input - Unity 脚本 API (unity3d.com) Screen屏幕相关//知识点一 静态属性 //常用 //当前屏幕分辨率 Resolution r = Screen.currentResolution; print(\"当前屏幕分辨率的宽\" + r.width + \"高\" + r.height); //屏幕窗口当前宽高 //这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高 //一般写代码 要用窗口宽高 做计算时 就用他们 print(Screen.width); print(Screen.height); //屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; //不常用 //运行时是否全屏模式 Screen.fullScreen = true; //窗口模式 //独占全屏FullScreenMode.ExclusiveFullScreen //全屏窗口FullScreenMode.FullScreenWindow //最大化窗口FullScreenMode.MaximizedWindow //窗口模式FullScreenMode.Windowed Screen.fullScreenMode = FullScreenMode.Windowed; //移动设备屏幕转向相关 //允许自动旋转为左横向 Home键在左 Screen.autorotateToLandscapeLeft = true; //允许自动旋转为右横向 Home键在右 Screen.autorotateToLandscapeRight = true; //允许自动旋转到纵向 Home键在下 Screen.autorotateToPortrait = true; //允许自动旋转到纵向倒着看 Home键在上 Screen.autorotateToPortraitUpsideDown = true; //指定屏幕显示方向 Screen.orientation = ScreenOrientation.Landscape; 知识点二 静态方法 //设置分辨率 一般移动设备不使用 Screen.SetResolution(1920, 1080, false); UnityEngine.Screen - Unity 脚本 API (unity3d.com) Camera摄像机相关1.*Clear Flags： 如何清除背景： skybox天空盒(3D) Solid Color颜色填充(2D) Depth only 只画该层，背景透明(叠加渲染) Don't Clear 不移除，覆盖渲染 2.*Culling Mask 选择性渲染部分层级：可以指定只渲染对应层级的对象 3.*Projection 2.1Perspective 透视模式 FOV Axis：视场角 轴-决定了光学仪器的视野范围 Field of view：视口大小 Physical Camera：物理摄像机、勾选后可以模拟真实世界中、摄像机、焦距、传感器尺寸、透镜移位等等 Focal Length：焦距 Sensor Type：传感器类型 Sensor Size：传感器尺寸 Lens Shift：透镜移位 Gate Fit：闸门配合 2.2orthographic 正交摄像机(一般用于2D游戏制作) Size：摄制范围 4.*Clipping Planes： 裁剪平面距离(近和远) 5.Viewport Rect： 视口范围屏幕上将绘制该摄像机视图的位置： 主要用于双摄像机游戏 0~1 相当于宽高百分比 6.*Depth: 渲染顺序上的深度(多个摄像机，越小的越先渲染，大的覆盖小的) 7.Redering path: 渲染路径 8.*Target Texture: 渲染纹理: 可以把摄像机画面渲染到一张图上:主要用于制作小地图(摄像机渲染到这张图上) 在Project右键创建 Render Texture 9.*Occlusion Culling: 是否启用剔除遮挡(性能优化) 10.Allow HDR: 是否允许高动态范围渲染 11.Allow MSAA: 是否允许抗锯齿 12.Allow Dynamic Resolution: 是否允许动态分辨率呈现 13.Target Display: 用于哪个显示器:主要用来开发有多个屏幕的平台游戏 摄像机 - Unity 手册 (unity3d.com) 代码相关： 知识点一 重要静态成员 //1.获取摄像机 //如果用之前的知识 来获取摄像机 //主摄像机的获取 //如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机 print(Camera.main.name); //获取摄像机的数量 print(Camera.allCamerasCount); //得到所有摄像机 Camera[] allCamera = Camera.allCameras; print(allCamera.Length); //2.渲染相关委托 //摄像机剔除前处理的委托函数 Camera.onPreCull += (c) =&gt; { }; //摄像机 渲染前处理的委托 Camera.onPreRender += (c) =&gt; { }; //摄像机 渲染后 处理的委托 Camera.onPostRender += (c) =&gt; { }; 知识点二 重要成员 //1.界面上的参数 都可以在Camera中获取到 //比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置 Camera.main.depth = 10; //2.世界坐标转屏幕坐标 //转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远 //我们会用这个来做的功能 最多的 就是头顶血条相关的功能 Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position); print(v); //3.屏幕坐标转世界坐标 //只所以改变Z轴 是因为 如果不改 Z默认为0 //转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点 //如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点 Vector3 v = Input.mousePosition; v.z = 5; obj.position = Camera.main.ScreenToWorldPoint(v); //print(Camera.main.ScreenToWorldPoint(v)); UnityEngine.Camera - Unity 脚本 API (unity3d.com) 核心系统光源系统基础Light组件1.*Type:光源类型 Spot:聚光灯 Range:发光范围距离 Spot Angle:光锥角度 Directional:方向光(环境光) Point:点光源 Area:面光源(烘焙下用) 2.*Color: 颜色 3.*Mode:光源模式 Realtime: 实时光源 每帧实时计算，效果好，性能消耗大 Baked: 烘焙光源 事先计算好，无法动态变化 Mixed: 混合光源 预先计算+实时运算 4.*Intensity: 光源亮度 5.Indirect Multiplier: 改变间接光的强度 低于1，每次反弹会使光更暗大于1，每次反弹会使光更亮 6.*Shadow Type: NoShadows:关闭阴影 HardShadows:生硬阴影 SoftShadows:柔和阴影 7.RealtimeShadows Strength:阴影暗度 0~1之间，越大越黑 Resolution:阴影贴图渲染分辨率，越高越逼真，消耗越高 Bias:阴影推离光源的距离 Normal Bias:阴影投射面沿法线收缩距离 Near Panel:渲染阴影的近裁剪面 8.*Cookie: 投影遮罩(用图制作光照的样子) 9.Cookie Size： 大小设置 10.Draw Halo: 球形光环开关(光晕) 11.*Flare: 耀斑(工程文件可以自己右键创建该类型文件，想再Game显示，摄像机添加Flare Layer脚本) 12.Render Mode:渲染模式 Auto:运行时确定 Important:以像素质量为单位进行渲染，效果逼真，消耗大 Not Important:以快速模式进行渲染 13.*Culling Mask:剔除遮罩层，决定哪些层的对象受到该光源影响 光源 - Unity 手册 (unity3d.com) UnityEngine.Light - Unity 脚本 API (unity3d.com) 光窗口1.Environment-环境相关设置 Skybox Material-天空盒材质：可以改变天空盒(创建天空盒创建一个材质球将种类设置为skybox) Sun Source-太阳来源：不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting-环境光设置： Source-环境光光源颜色： Skybox：天空和材质作为环境光颜色 Gradient：可以为天空、地平线、地面单独选择颜色和他们之间混合 Intensity Multiplier-环境光亮度； Ambient Mode-全局光照模式只有启用了实时全局和全局烘焙时才有用： Realtime(已弃用) Baked 2.OtherSettings-其它设置： Fog-雾开关(性能消耗)： Color-雾颜色： Mode-雾计算模式： Linear-随距离线性增加： Start：离摄像机多远开始有雾 End：离摄像机多远完全遮挡 Exponential-随距离指数增加：-Density-强度； Exponential Qquare-随距离比指数更快的增加-Density：强度； Halo Texture：光源周围挥着光环的纹理 Halo Strength：光环可见性 Flare Fade Speed：耀斑淡出时间最初出现之后淡出的时间； Flare Strength：耀斑可见性 Spot Cookie：聚光灯默认剪影纹理 Lighting 窗口 - Unity 手册 (unity3d.com) 物理系统之碰撞检测Rigidbody组件重点：碰撞产生的必要条件，两个物体都有碰撞器，至少一个物体有刚体。 1.RigidBody组件信息： Mass：质量(默认为千克)质量越大惯性越大； Drag：空气阻力根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力； Angular Drag：根据扭矩旋转对象时影响对象的空气阻力大小。0 表示没有空气阻力； Use Gravity：是否受重力影响 Is Kinematic：如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用； Interpolate-(物理帧时间长时使用)插值运算，让刚体物体移动更平滑： None：不应用插值运算； Interpolate：根据前一帧的变换来平滑变换； Extrapolate：差值运算，根据下一帧的估计变换来平滑变换； Constraints-约束，对刚体运动的限制： Freeze Position：有选择地停止刚体沿世界 X、Y 和 Z 轴的移动； Freeze Rotation：有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转； Collision Detection(碰撞检测模式)-用于防止快速移动的对象穿过其它对象而不检测碰撞： Discrete(离散检测)：对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞(这是默认值)； Continuous(连续检测)：对动态碰撞体(具有刚体)使用离散碰撞检测，并对静态碰撞体(没有刚体)使用连续碰撞检测；设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。(此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置)，其他刚体将使用离散碰撞检测。 Continuous Speculative(连续推测检测)：对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 刚体 - Unity 手册 (unity3d.com) API: //知识点一 刚体自带添加力的方法 //给刚体加力的目标就是 //让其有一个速度 朝向某一个方向移动 //1.首先应该获取刚体组件 rigidBody = this.GetComponent&lt;Rigidbody&gt;(); //2.添加力 //相对世界坐标 //世界坐标系 Z轴正方向加了一个里 //加力过后 对象是否停止移动 是由阻力决定的 //如果阻力为0 那给了一个力过后 始终 是不会停止运动 rigidBody.AddForce(Vector3.forward * 10); //如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动 rigidBody.AddForce(this.transform.forward * 10); //相对本地坐标 rigidBody.AddRelativeForce(Vector3.forward * 10); //3.添加扭矩力，让其旋转 //相对世界坐标 rigidBody.AddTorque(Vector3.up * 10); //相对本地坐标 rigidBody.AddRelativeTorque(Vector3.up * 10); //4.直接改变速度 //这个速度方向 是相对于 世界坐标系的 //如果要直接通过改变速度 来让其移动 一定要注意这一点 rigidBody.velocity = Vector3.forward * 5; //5.模拟爆炸效果 //模拟爆炸的力 一定是 所有希望产生爆炸效果影响的对象 //都需要得到他们的刚体 来执行这个方法 才能都有效果 rigidBody.AddExplosionForce(100, Vector3.zero, 10); //知识点二 力的几种模式 //第二个参数 力的模式 主要的作用 就是 计算方式不同而已 //由于4中计算方式的不同 最终的移动速度就会不同 rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration); //动量定理 //Ft = mv // v = Ft/m; //F:力 //t：时间 //m:质量 //v:速度 //1.Acceleration //给物体增加一个持续的加速度，忽略其质量 //v = Ft/m //F:(0,0,10) //t:0.02s //m:默认为1 //v = 10*0.02/ 1 = 0.2m/s //每物理帧移动0.2m/s*0.02 = 0.004m //2.Force //给物体添加一个持续的力，与物体的质量有关 //v = Ft/m //F:(0,0,10) //t:0.02s //m:2kg //v = 10*0.02/ 2 = 0.1m/s //每物理帧移动0.1m/s*0.02 = 0.002m //3.Impulse //给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:2kg //v = 10*1/ 2 = 5m/s //每物理帧移动5m/s*0.02 = 0.1m //4.VelocityChange //给物体添加一个瞬时速度，忽略质量，忽略时间 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:默认为1 //v = 10*1/ 1 = 10m/s //每物理帧移动10m/s*0.02 = 0.2m //知识点三 力场脚本(Unity封装好了的组件) ConstantForce组件 //补充 刚体的休眠 //获取刚体是否处于休眠状态 如果是 if (rigidBody.IsSleeping()) { //就唤醒它 rigidBody.WakeUp(); } UnityEngine.Rigidbody - Unity 脚本 API (unity3d.com) 碰撞器碰撞器面板说明： 1.3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 2.共同参数： Is Trigger：是否是触发器，如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略，主要用于进行没有物理效果的碰撞检测； Material：物理材质(工程右键可以创建一个物理材质.material文件)，可以确定碰撞体和其它对象碰撞时的交互(表现)方式。 Center：碰撞体在对象局部空间中的中心点位置 3.常用碰撞器： BoxCollider-盒状碰撞器-Size：碰撞体在X、Y、Z方向上的大小； Sphere Collider-球状碰撞器-Radius：球形碰撞体的半径大小； Capsule Collider-胶囊碰撞器： Radius：胶囊体的半径 Height：胶囊体的高度 Direction：胶囊体在对象局部空间中的轴向 4.异形物体使用多种碰撞器组合：刚体对象的子对象碰撞器信息参与碰撞检测； 5.不常用碰撞器： Mesh Collider-网格碰撞器： Convex：勾选此复选框可启用 Convex。如果启用此属性，该 Mesh Collider 将与其他 Mesh Collider 发生碰撞。Convex Mesh Collider 最多 255 个三角形。 Cooking Options-启用或禁用影响物理引擎对网格处理方式的网格烹制选项： -None：禁用下方列出的所有 Cooking Options -Everything：启用下方列出的所有 Cooking Options。 -Cook for Faster Simulation：使物理引擎烹制网格以加快模拟速度。启用此设置后，这会运行一些额外步骤，以保证生成的网格对于运行时性能是最佳的。这会影响物理查询和接触生成的性能。禁用此设置后，物理引擎会使用更快的烹制速度，并尽可能快速生成结果。因此，烹制的 Mesh Collider 可能不是最佳的。 -Enable Mesh Cleaning：使物理引擎清理网格。启用此设置后，烹制过程会尝试消除网格的退化三角形以及其他几何瑕疵。此过程生成的网格更适合于在碰撞检测中使用，往往可生成更准确的击中点。 -Weld Colocated Vertices：使物理引擎在网格中删除相等的顶点。启用此设置后，物理引擎将合并具有相同位置的顶点。这对于运行时发生的碰撞反馈十分重要。 Mesh：引用需要用于碰撞的网格。 Wheel Collider-环状 碰撞器： Mass：车轮的质量 Radius：车轮的半径 Wheel Damping Rate：这是应用于车轮的阻尼值 Suspension Distance：车轮悬架的最大延伸距离(在局部空间中测量)。悬架始终向下延伸穿过局部 Y 轴。 Force App Point Distance：此参数定义车轮上的受力点。此距离应该是距车轮底部静止位置的距离(沿悬架行程方向)，以米为单位。当 forceAppPointDistance = 0 时，受力点位于静止的车轮底部。较好的车辆会使受力点略低于车辆质心。 Suspension Spring：悬架尝试通过增加弹簧力和阻尼力来到达目标位置 (Target Position) -Spring：弹簧力尝试到达目标位置。值越大，悬架达到目标位置就越快 -Damper：抑制悬架速度。值越大，悬架弹簧移动就越慢 -Target Position：悬架沿悬架距离 (Suspension Distance) 的静止距离。1 对应于完全展开的悬架，0 对应于完全压缩的悬架。默认值为 0.5，与常规汽车的悬架行为匹配。 Forward Friction-车轮向前滚动时轮胎摩擦的特性；Sideways Friction车轮侧向滚动时轮胎摩擦的特性—： -Extremum Slip：曲线的极值点。 -Extremum Value：曲线的极值点。 -Asymptote Slip：曲线的渐近点。 -Asymptote Value：曲线的渐近点。 -Stiffness：Extremum Value 和 Asymptote Value 的乘数(默认值为 1)。改变摩擦力的刚度。将此值设置为零将完全禁用车轮的所有摩擦力。通常在运行时修改刚度以使用脚本来模拟各种地面材质。 注意事项：不必通过转动或滚动 WheelCollider 对象来控制汽车；附加了 WheelCollider 的对象应始终相对于汽车本身固定； Terrain Collider-地形碰撞器 Terrain Data：地形数据 Enable Tree Colliders：选中此属性时，将启用树碰撞体 碰撞体 - Unity 手册 (unity3d.com) 物理材质物理材质参数说明 Dynamic Friction：已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止(除非用很大的力或重力推动对象) Static Friction：当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness：表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine-两个碰撞对象的摩擦力的组合方式： -Average：对两个摩擦值求平均值。 -Minimum：使用两个值中的最小值。 -Maximum：使用两个值中的最大值。 -Multiply：两个摩擦值相乘。 unce Combine：两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同 碰撞检测函数注意：碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用. //知识点一 物理碰撞检测响应函数 //碰撞触发接触时会 自动执行这个函数 private void OnCollisionEnter(Collision collision) { //Collision类型的 参数 包含了 碰到自己的对象的相关信息 //关键参数 //1.碰撞到的对象碰撞器的信息 //collision.collider //2.碰撞对象的依附对象(GameObject) //collision.gameObject //3.碰撞对象的依附对象的位置信息 //collision.transform //4.触碰点数相关 //collision.contactCount //接触点 具体的坐标 //ContactPoint[] pos = collision.contacts; //只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息 print(this.name + \"被\" + collision.gameObject.name + \"撞到了\"); } //碰撞结束分离时 会自动执行的函数 private void OnCollisionExit(Collision collision) { print(this.name + \"被\" + collision.gameObject.name + \"结束碰撞了\"); } //两个物体相互接触摩擦时 会不停的调用该函数 private void OnCollisionStay(Collision collision) { print(this.name + \"一直在和\" + collision.gameObject.name + \"接触\"); } //知识点二 触发器检测响应函数 //触发开始的函数 当第一次接触时 会自动调用 protected virtual void OnTriggerEnter(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"触发了\"); } //触发结束的函数 当水乳相融的状态结束时 会调用一次 private void OnTriggerExit(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"结束水乳相融的状态了\"); } //当两个对象 水乳相融的时候 会不停调用 private void OnTriggerStay(Collider other) { print(this.name + \"和\" + other.gameObject.name + \"正在水乳相融\"); } 音效系统音频文件导入1.导入参数设置 常用格式：wav、mp3、ogg、aiff； 音频文件属性设置 Force To Mono：多声道转单声道； Normalize：强制为单声道时，混合过程中被标准化； Load In Background：在后台加载，不阻塞主线程； Ambisonic：立体混响声 ，非常适合 360 度视频和 XR 应用程序，如果音频文件包含立体混响声编码的音频，请启用此选项； LoadType-加载类型： Decompress On Load：不压缩形式存在内存，加载块，但是内存占用高(适用于小音效文件)； Compress in memory：压缩形式存在内存，加载慢，内存小(仅适用于较大音效文件) Streaming：以流形式存在，使用时解码。内存占用最小，cpu消耗高(性能换内存) Preload Audio Data：预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format-压缩方式： PCM：音频以最高质量存储 Vorbis：相对PCM压缩的更小，根据质量决定 ADPCM：包含噪音，会被多次播放的声音，如碰撞声 Quality：音频质量，确定要应用于压缩剪辑的压缩量。(不适用于 PCM/ADPCM/HEVAG 格式) Sample Rate Setting-PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率： Preserve Sample Rate：此设置可保持采样率不变(默认值)； Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率； Override Sample Rate：此设置允许手动覆盖采样率，因此可有效地将其用于丢弃频率内容； 音频源和音频监听组件组件面板说明： AudioSource-音频源： AudioClip：声音剪辑文件(音频文件) Output：默认将直接输出到场景中的音频监听器，可以更改为输出到混音器(音乐游戏可能会用)； Mute：静音开关； Bypass Effect：开关滤波器效果； Bypass Listener Effects：快速开关所有监听器； Bypass Reverb Zones：快速开关所有混响区 Play On Awake：对象创建时就播放音乐，也就是开关启动游戏就播放； Loop：循环 Priority：优先级(越大越不容易被其他音效覆盖) Volume：音量大小 Pitch：音高 Stereo Pan：2D声音立体声位置。相当于左右声道 Spatial Blend：音频受3D空间的影响程度(设置是2d游戏还是3d音效) Reverb Zone Mix：到混响区的输出信号量 3D Sound Settings-和Spatial Blend参数成正比应用： Doppler Level：多普勒效果等级 Spread：扩散角度设置为3D立体声还是多声道 Volume Rolloff-声音衰减速度： Logarithmic Rolloff：靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff：与音频源的距离越远，听到的声音越小。 Custom Rolloff：音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance：最小距离内，声音保持最大响度；最大距离外，声音开始减弱； AudioListener-音频监听脚本； 音频源代码控制//知识点一 代码控制播放停止 //播放音效 audioSource.Play(); //延迟播放 填写的是秒数 audioSource.PlayDelayed(5); //停止音效 audioSource.Stop(); //暂停 audioSource.Pause(); //停止暂停 和暂停后 Play效果是一样的 都会继续播放现在的音效 audioSource.UnPause(); 知识点二 如何检测音效播放完毕 //如果你希望某一个音效播放完毕后 想要做什么事情 //那就可以在Update生命周期函数中 不停的去检测 它的 该属性 //如果是false就代表播放完毕了 audioSource.isPlaying 知识点三 如何动态控制音效播放 //1.直接在要播放音效的对象上挂载脚本 控制播放 //2.实例化挂载了音效源脚本的对象 //这种方法 其实用的比较少 //Instantiate(obj); //3.用一个AudioSource来控制播放不同的音效 //AudioSource aus = this.gameObject.AddComponent&lt;AudioSource&gt;(); //aus.clip = clip; //aus.Play(); //潜在知识点 //一个GameObject可以挂载多个 音效源脚本AudioSource //使用时要注意 如果要挂载多个 那一定要自己管理他们 控制他们的播放 停止 不然 我们没有办法准确的获取 //谁是谁 UnityEngine.AudioClip - Unity 脚本 API (unity3d.com) 麦克风输入相关知识点一 获取设备麦克风信息 string[] strs = Microphone.devices; 知识点二 开始录制 //参数一：设备名 传空使用默认设备 //参数二：超过录制长度后 是否重头录制 //参数三：录制时长 //参数四：采样率 clip = Microphone.Start(null, false, 10, 44100); 知识点三 结束录制 Microphone.End(null); 知识点四 获取音频数据用于存储或者传输 //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[clip.channels * clip.samples]; clip.GetData(f, 0); print(f.Length); UnityEngine.Microphone - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"C#进阶","slug":"02004-C#进阶","date":"2019-08-02T13:00:00.000Z","updated":"2022-01-25T14:31:33.892Z","comments":true,"path":"posts/1028.html","link":"","permalink":"http://wwy010518.github.io/posts/1028.html","excerpt":"","text":"CLR中简答数据结构类命名空间：System.Collections； ArrayList语法:new ArrayList();建议：本质是一个自动扩容的object数值，存在装箱拆箱，尽量少用；C# 动态数组(ArrayList) |菜鸟教程 (runoob.com) Stack(栈)语法：new Stack();建议：存在装箱拆箱；C# 堆栈(Stack) | 菜鸟教程 (runoob.com) Queue(队列)语法：new Queue();建议：存在装箱拆箱；C# 队列(队列) |菜鸟教程 (runoob.com) Hashtable(哈希表)定义：又叫散列表，是基于键的哈希代码组织起来的键值对，主要用来提高数据查询效率；语法：new Hashtable();迭代器遍历法: IDictionaryEnumerator me=哈希表对象名.GetEnumerator(); while(me.MoveNext()){ } 建议：存在装箱拆箱；C# 哈希表(Hashtable) |菜鸟教程 (runoob.com) CLR中的泛形命名空间：System.Collections.Generic 泛形定义：通过类型参数来实现代码操作多种类型；原理：相当于占位符，定义类或者方法是用替代符代替变量类型，当真正使用时再指定具体类型； 泛形约束关键字：where，可以多个使用;种类：6种如下：1.值类型 where 泛形字母:struct；2.引用类型 where 泛形字母:class；3.存在无参公共构造函数 where 泛形字母:new()；4.某个类本身或者派生类 where 泛形字母:类名；5.每个接口的派生 where 泛形字母:接口名；6.另一个泛形类型或者派生类型 where 泛形字母:另一个泛形字母； List定义：表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。语法：new List&lt;&gt;();List 类 (System.Collections.Generic) | Microsoft Docs Dictionary定义：表示键和值的集合。语法：new Dictionart&lt;键,值&gt;();Dictionary 类 (System.Collections.Generic) | Microsoft Docs LinkedList定义：表示双重链接列表。语法：new LinkedList&lt;&gt;();LinkedList 类 (System.Collections.Generic) | Microsoft Docs 泛形队列定义：表示对象的先进先出泛形集合。语法：new Queue&lt;&gt;();Queue 类 (System.Collections.Generic) | Microsoft Docs 泛形栈定义：表示相同指定类型的实例可变大小的后进先出 (LIFO) 集合。语法：new Stack&lt;&gt;();Stack 类 (System.Collections.Generic) | Microsoft Docs 委托和事件委托定义：C# 中的委托(Delegate)类似于 C 或 C++ 中函数的指针,本质时一个类。委托(Delegate) 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变，专门用来装载函数的容器。语法： //定义 访问修饰符 delegate 返回值类型 委托名&lt;泛形类型&gt;(参数列表) //实例化 委托名 变量名=new 委托名(); //赋值,参数要一致 变量名[+或-]=方法名() //使用 委托变量名(对应参数): 系统自带的委托：Action&lt;泛形类型,……泛形类型&gt;和Func&lt;泛形类型,…..返回值&gt;;(d都支持16个泛形类型) 事件定义:让委托使用更加安全，事件是一种特殊的变量类型语法：访问修饰符 event 委托类型 事件名和委托区别：不能再类外部赋值(可以加减)，不能在类外部调用，只能在类内部封装调用； 匿名函数定义：没有名字的函数，要配合委托和事件使用；缺点：没有名字，无法通过+-移除；语法： Action a=delegate(参数列表){ } Lambad表达式定义：可以理解成是匿名函数的简写； (参数列表)=&gt;{ } 多线程和任务前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存 多线程(Thread)命名空间：using System.Threading语法: //启动线程，将要执行的代码逻辑封装到一个函数语句块中 Thread 线程名=new Thread(委托方法); //启动线程 线程名.start(); //设置为后台线程,当进程结束后台线程结束 线程名.IsBackground=true; //关闭释放一个死循环进程，有俩中方法 //为线程死循环加一个标志变量 //通过线程提供的方法(在.net core版本会无法中止报错),可以加异常捕捉 线程名.Abort(); //线程休眠 线程名.Sleep(时间/ms); C# 多线程 | 菜鸟教程 (runoob.com) 共享数据问题：多线程操作同一内存区域可能出现问题，可以通过加锁的形式避免问题 lock(同一引用类型变量){ } 线程池(ThreadPoll)命名空间：using System.Threading定义:ThreadPoll是线程池(享元设计模式)，其目的是为了减少开启新线程消耗的资源(使用线程池中的空闲线程，不必在开启新线程，以及统一管理线程(线程池中的线程执行完毕后，回归到线程池里，等待新任务).优缺点：ThreadPoll性能优于Thread，但是Thread和ThreadPoll对线程的控制都不是很好，例如线程等待(线程执行一段时间无响应后，直接停止线程，释放资源 等 都没有直接的API来控制 只能通过硬编码来实现，同时ThreadPool使用的是线程池全局队列，全局队列中的线程依旧会存在竞争共享资源的情况，从而影响性能。语法： //快速启动 ThreadPool.QueueUserWorkItem(委托方法); //获取线程池中辅助线程的最大数量(workerThreadsMax)和线程池中异步I/O线程的最大数量(completionPortThreadsMax) ThreadPool.GetMaxThreads(out int workerThreadsMax, out int completionPortThreadsMax); //获取线程池中辅助线程的最小数量(workerThreadsMin)和线程池中异步I/O线程的最小数量(completionPortThreadsMin) ThreadPool.GetMinThreads(out int workerThreadsMin, out int completionPortThreadsMin); //设置最大线程数量 和 设置最小线程数量，在进程内是全局的。在一个地方设置了，后面所有的请求中都是这个数量了 //委托异步调用、Task、Parallel、async/await 都使用的是线程池的线程； new Thread()不受限制，但是会占用线程池的数量。 ThreadPool.SetMaxThreads(12, 12);//不能低于当前电脑的线程数；比如四核八线程，就不能低于8，否则无效 ThreadPool.SetMinThreads(1, 1); //线程等待，需要使用ManualResetEvent来完成 ManualResetEvent mre = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem((obj) =&gt; { DoSomething(\"\"); mre.Set(); } ); mre.WaitOne()； 任务(Task)命名空间：using System.Threading.Tasks特点：Task是基于任务的异步编程模型,Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。建议：使用Task的时候应该尽量结合async和await关键字来使用。避免使用.Result 和 .Wait()来阻塞等待;.Result 和 .Wait()会占用线程资源，直到任务完成；而await的基于异步回调的，不会浪费CPU资源；async和await是语法糖，本质上其实是ContinueWith()。基本语法： //Task使用方式1 Task task1 = new Task(() =&gt; { DoSomething(\"张三\"); }); task1.Start(); //Task使用方式2 var taskFactory = Task.Factory; Task&lt;int&gt; t1 = taskFactory.StartNew&lt;int&gt;(() =&gt; { DoSomething(\"王五\"); return 1; }); Task t2 = taskFactory.StartNew(() =&gt; { DoSomething(\"赵六\"); }); Task t3 = taskFactory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"所有线程都完成了，就会调用这个函数， 不会阻塞主线程\"); }); Task t4 = taskFactory.ContinueWhenAny(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"任意一个线程完成了，就会调用这个函数， 不会阻塞主线程\"); }); //Task使用方式3 Task&lt;int&gt; task = Task.Run&lt;int&gt;(() =&gt; { DoSomething(\"李四\"); return 1; }); int temp = task.Result; //阻塞执行完毕并获取结果，不建议使用这种方式 task.Wait(); //阻塞，直到子线程执行完毕，不建议使用这种方式 await task; //阻塞，直到子线程执行完毕。 但是主线程(调用方)将继续往下执行，await task后面的代码等同于封装在ContinueWith()里面 //Task其它使用方式 //Task.Delay(2000)不阻塞当前线程，一般配合ContinueWith使用，在ContinueWith里面的子线程将等待2秒之后执行 //Thread.Sleep(2000)是阻塞当前线程 Task task3 = Task.Delay(2000).ContinueWith((t) =&gt; { }); //等待所有线程完成 Task.WaitAll(new Task[] { task1, t1 }); //等待任意一个线程完成 Task.WaitAny(new Task[] { task1, t1 }); //线程回调 task1.ContinueWith((o) =&gt; { Console.WriteLine(\"线程回调，task1执行完毕之后执行这里。\"); } //Task取消任务 CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; ManualResetEvent resetEvent = new ManualResetEvent(true); //定义任务 Task task = new Task(async () =&gt; { while (true) { if (token.IsCancellationRequested) { return; } // 初始化为true时执行WaitOne不阻塞 resetEvent.WaitOne(); // Doing something....... // 模拟等待100ms await Task.Delay(100); } }, token); //任务开始 task.Start(); //任务暂停 resetEvent.Reset(); //任务继续 resetEvent.Set(); //取消Task tokenSource.Cancel(); async/await语法使用案例： static void Main(string[] args) { string content = GetContentAsync(Environment.CurrentDirectory + @\"/test.txt\").Result; //调用同步方法 //string content = GetContent(Environment.CurrentDirectory + @\"/test.txt\"); Console.WriteLine(content); Console.ReadKey(); } //异步读取文件内容 async static Task&lt;string&gt; GetContentAsync(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //ReadAync方法异步读取内容，不阻塞线程 Console.WriteLine(\"开始读取文件\"); int len = await fs.ReadAsync(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } //同步读取文件内容 static string GetContent(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //Read方法同步读取内容，阻塞线程 int len = fs.Read(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } 预处理器指令什么是编译器源语言程序：某种程序设计语言写的，像c#、c、c++、java等；目标语言程序：计算机可以识别的二进制数程序；编译器：是一种翻译程序(编译原理 )，将源语言程序翻译成目标语言程序； 什么是预处理器指令定义：指导编译器，在实际编译开始时对信息进行预处理，都是以#开始，不是指令，所以不以；结束； 常见的预处理器指令//写在脚本最前面，配合if指令或特性使用1.#define：定义一个符号，类似一个没有值的变量2.#undef：取消define定义的符号3.#if、#elif、#else、#endif：和if语法规则一样，用于告诉编译器进行编译代码的流程控制；4.#warning、#error：告诉编译器是报警告还是报错； 反射和特性程序集：由编译器编译(.exe或者.dll)，供编译执行的中间产物；元数据：数据的数据； 反射概念：程序正在运行时可以查看其他程序集或者自己的元数据这就叫反射；type定义：类的信息类，是访问元数据的主要方式，反射的技术；语法：获取的type指向的内存都是一样的 //1.通过object.GetType()获取对象的Type Type t1=object.GetType(); //2.通过typeof关键字获取类的Type Type t2=typeof(int); //3.通过类名获取，但是必须有命名空间 Type p3=Type.GetType(\"System.Int32\"); //程序集获取 t1.Assembly; //获取类的所有公共成员 MemberInfo[] infos=t1.GetMembers(); //获取类所有构造函数并调用 ConstructorInfo[] ctors=t1.GetConstructors(); //获取构造函数传入 Type数组 数组中按顺序是参数类型，执行构造函数传入 object数组 表示按顺序传入的参数； //得到无参构造 ConstructorInfo info =t1.GetConstructor(new Type[]); info.Invoke(null) as 类名; //得到有参构造 ConstructorInfo info =t1.GetConstructor(new Type[]{typeof(int)}); info.Invoke(new object[]{2}) as 类名; //得到所有成员变量 FieldInfo[] fieldINfos=t1.GetFields(); //得到指定名称的公共成员变量 FieldInfo infoj=t1.GetField(\"变量名\")； //通过反射获取变量值 infoj.GetValue(类实例); //通过反射设置变量值 infoj.SetValue(类实例,要赋的值)； //获得类的公共成员方法 MethodInfo[] methods=t1.GetMethods(); //获取指定方法 MethodInfo method=t1.GetMethod(\"方法名\"，new Type[]{反射参数类型同上}); method.Invoke(参数)； 特性定义：本质是个类，可以利用特性类为元数据添加额外信息，之后可以用反射获取这些额外信息，类、变量、函数前都可以添加；自定义特性：继承特性基类 Attribute(使用自定义特性时类名后面会省略Attribute这几个字);语法 //1.定义特性 class 特性类名：Attribute{ } //2.特性使用 [特性名(参数列表)] //类、函数、变量上一行 //3.判断是否使用了某个特性 //参数一：特性的类型 参数二：是否搜索继承链(属性和时间忽略) if(类type类型.IsDefind(typeof(特性类型)，false)){} //4.获取Type元数据中的所有特性 t.GetCustomAttributes(ture); //5.为特性类加特性，限制自定义特性 //参数一：AttributeTargets--特性可以用在哪里 //参数二：AllowMultiple--是否允许多个特性在同一个目标上 //参数三：Inherited--特性是否能被派生类和重写成员继承 [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple=true,Inherited=true)] //6.系统自带特性 //6.1过时特性 [Obsolete(\"过时特性，后面是ture直接报错，否则警告\"，false)] //6.2调用者信息特性 用处不大，省略，用工具就可以了 //6.3条件编译特性 //和#define配套使用，必须有该参数名的预指令符号才会执行修饰成员 using System.Runtime.CompilerServices [Conditional(\"Fun\")] //6.4外部Dll包函数特性 //用来标记非.Net的函数，表明在一个外部的DLL中定义，用来调用c或者c++得DLL包写好的方法 using System.Runtime.InteropServices [DllImport(\"程序集全名\")] public static extern int 外部DLL元数据函数名() 其他补充协变逆变协变：out逆变：in作用一：用out修饰的泛形只能作为返回值，用in修饰的泛形只能作为参数作用二：用out和in修饰的泛形委托可以i互相装载(有父子关系的委托) //结合里氏替换原则理解 //协变 父类总是能被子类替代 TestOut&lt;Son&gt; os=()=&gt;{ } TestOut&lt;Father&gt; of=os;//参数必须声明out of();//实际上os装的函数返回的是Son的 //逆变 子类装父类委托 TestIn&lt;Father&gt; of=()=&gt;{ } TestIn&lt;Son&gt; os=of;//参数必须声明in os();//实际上os装的函数返回的是Father的 迭代器(iterator)概念：又称为光标(cursor)，是程序设计的软件设计模式，是可以在遍历访问的接口，设计人员无需关心容器的内存细节，能用foreach遍历的类，都实现了迭代器；关键接口：IEnumerator(迭代器实现),IEnumerable(foreach实现，有方法即可);命名空间：using System.Collections;yield return：是c#提供的语法糖(糖衣语法)，可以将复杂逻辑简单化，增加程序可读性，yield关键字可以理解为暂时返回，保留当前状态； 特殊语法# 隐藏类型var 可以用来表示任何类型的变量，一般用来临时变量，但是不能再更改类型。 # 设置对象初始值 可以直接通过大括号来进行赋值。 # 设置集合初始值 可以直接通过大括号来进行赋值。 # 匿名类型 var变量可声明为自定义的匿名类型，但是只能有变量。语法 var v=new {age=10,name=\"小明}; # 可空类型//1.数值类型使用，声明时再值类型后面加？可以赋值为空 int?lue=null; //又如 int[] os=null; int? x=os?[0]; //2.引用类型使用，相当于一种语法糖，自动判断是否为空,例如判断委托是否为不为空才执行 o?Invoke(); //3.判断值类型是否为空 值变量名.HasValue； //4.安全获取值类型默认值(可以指定默认值) 值变量名.GetValueOrDefault(默认值); # 空和并操作符定义：左边值？？右边值，左边为null返回右边值，否则左边； # 内插字符串 用关键字$，类似于Format拼接字符串。语法 Console.WriteLine($\"你好，{name}”); # 单句逻辑简略写法 逻辑语句只有一句代码的话可以省略{}，而属性只有一句getset可以写成get=&gt;返回值;set=&gt;变量名=要赋的值，方法同理。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#核心","slug":"02003-C#核心","date":"2019-07-15T13:00:00.000Z","updated":"2022-01-25T07:47:52.980Z","comments":true,"path":"posts/1027.html","link":"","permalink":"http://wwy010518.github.io/posts/1027.html","excerpt":"","text":"面向对象基本概念其他编程方式：面向过程编程；三大特征：封装+继承+多态；七大原则：1.单一原则：一个类只处理自己应该处理的。应该各司其职，例如把每个移动技能都尽量写出一个类，方便修改。2.开闭原则：新功能尽量是加处理而不是改代码。继承就是最明显的开闭原则，不要修改模板的内容，例如定义属性要用方法定义， getset，方便修改，修改类时或者改别人的方法，不清楚逻辑的就再写一个类。3.依赖倒置原则：不依赖于具体实现，要依赖抽象(接口)。要依赖于抽象，不要依赖于具体实现，可以先了解需求，再画图，最后变成代码。4.接口隔离原则：一个接口一个行为。接口里的单一原则，需要分的事件要分清楚。5.里氏替换原则：用父类容器装载子类，任何地方子类都能替换父类。不要修改别人的代码，可以继承他的代码去重写(注：多态：父类的指针指向子类，而调用子类的方法)6.合成复用原则：尽量用组合复用的形式。继承关系中，父类要可以解决子类共同的问题，子类时解决特与的问题，能用现有的类，就别再自己创建类。7.迪米特法则：一个类尽量减少对别的类引用。又叫最少知识原则，减少耦合性，类自己能解决的，尽量不要牵扯别的类，比如A类引用B类的方法，但是B类方法参数改了，A类也要改。 面向对象三特征-封装一般类定义： 类和对象class 类名{ 类名 对象名=new 类名; } 类一般成员和封装成员变量：成员变量是声明在类中的变量，可以是任意类型；成员方法(函数)：类的成员函数是一个在类定义中有它的定义或原型的函数;访问修饰符种类：public(接口成员、命名空间、枚举默认)、private(类成员)、protected、internal(类、结构、接口、委托默认)； 构造函数构造函数：类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行，构造函数的名称与类的名称完全相同，它没有任何返回类型默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，以下是它的特殊写法： public 类名(参数1，参数2):this(参数1){ //默认会先调用无参构造(this)或者父类构造函数(换成base) } ##析构函数析构函数：类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行，析构函数的名称是在类的名称前加上一个波浪形(~)作为前缀，它不返回值，也不带任何参数，析构函数用于在结束程序(比如关闭文件、释放内存等)之前释放资源，就是当引用类型的堆被回收时被调用，析构函数不能继承或重载。 垃圾回收机制定义:简称GC，当堆(Heap)中的变量没有被任何对象引用时，就会被自动回收；算法：引用计数、标记清除、标记整理、复制集合；注意事项：GC只负责堆的垃圾回收,而栈(stack)的内存时系统自动管理的，值类型有自己的生命周期，会自动分配和释放；原理：C#会把堆中的内存分为0代内存、1代内存、2代内存(代是分代算法，代系数越大速度越慢，内存越大)，新分配的对象会配置在0代内存，每次分配都可能会进行垃圾回收释放内存(0代内存或者1代内存满时)，垃圾回收机制确认堆中的垃圾，首先会标记对象，发现是否有引用，标记后可达对象，未标记未不可达对象(垃圾)，然后就将对象压缩堆(挂起执行托管代码线程)释放垃圾，搬迁可达对象地址到下一代内存(到第二代内存不会在搬迁)，大对象(83kb以上)总认为是第二代内存。手动触发代码：GC.Collect();一般Loading过场景调用 成员属性语法： 访问修饰符 属性类型 属性名{ 访问修饰符 get{}//自动属性可以省略{} 访问修饰符 set{}//自动属性可以省略{} } 索引器概念:让对象可以像数组一样通过索引访问元素，索引器可以重载；语法： 访问修饰符 返回值 this[参数1、参数2]{ get{} set{} } 静态类和静态成员static静态类：不能被实例化，只能有静态成员；静态变量：当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本；静态函数：这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在；静态构造函数：不能使用访问修饰符，不能有参数，使用静态类或者普通类的成员时会自动且仅调用一次； 拓展方法特点：一定是写在静态类，一定是静态函数，第一个参数为拓展目标，第一个参数用this修饰；语法： 访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数1，参数2){ } 运算符重载概念：使用operator关键字让自定义类和结构体可以使用运算符；特点：一定是公告静态方法，返回值在operator前(条件运算要成对出现，一个符号可以多个重载，不能使用ref和out);语法： public static 返回类型 operator 运算符(参数列表){ } 不可重载的运算符:逻辑与&amp;&amp; 、逻辑非||、索引符[]、强转符号()、点.、三目运算符?:、赋值符号=； 内部类和分部类内部类定义:在一个类中再声明一个类，使用时要外部类点出自己；分部类：用partial把类分成几部分,注意访问修饰符要一样;分部方法:用partial将方法声明和实现分离，强制私有，只能在分部类声明，不能有返回值，不能用out关键字； 面向对象三特征-继承继承基本规则语法： class 类名 ：被继承的类{ } 里氏替换原则概念:任何父类出现的地方，子类都可以替代语法: 父类 变量名=new 子类()； ###is关键字定义:判断一个对象是否为指定类对象，返回bool值语法:对象 is 类名 ###as关键字定义:将一个对象转换为指定类对象，没有返回null语法:对象 as 类名 继承中的构造函数特点:实例化时先执行父类构造函数,再执行子类构造函数； 万物之父和装箱拆箱万物之父关键字:object装箱:例如object存储值类型发生，把值类型从栈中迁移到堆中，变成引用类型；拆箱:例如把object转为值类型发生，把引用类型从堆中迁移到栈中，变成值类型； 密封类概念:使用sealed关键字使类无法再被继承； 面向对象三特征-多态vob关键字：virtual(虚函数)和override(重写); 抽象类和抽象方法关键字：abstract(抽象函数)；特点：抽象类不能被实例化，但是遵守里氏替换原则，抽象方法没有方法体； 接口关键字:interface；特点：不包含成员变量，只有抽象方法、属性、索引器、事件，成员不能被实现，不能是私有成员，类可以继承多个接口，接口也遵守里氏替换原则；作用：不作为实体基类,但是可以作为一个行为基类;命名规则:帕斯卡命名法前面加I; ###显示实现接口作用：当实现俩个接口后，其中有相同方法时；语法：用接口名点出方法名; 密封方法关键字:sealed修饰不能再被重写； 面向对象相关知识点命名空间特点：命名空间可以包裹命名空间;语法： namespace 命名空间名{ } 万物之父中的方法静态方法Equals:判断俩个对象是否相等,值类型比较数值，引用类型比较地址;静态方法RefereceEquals：判断俩个对象引用是否相等，主要用于应用类型，值类型返回始终false;普通方法GetType():获取对象运行时的类型(反射相关);普通方法MemberwiseClone：拷贝对象,引用对象指向相同地址;虚方法Equals:相当于RefereceEquals,但是在种类中ValueType中重写了,可以用来比较值相等；虚方法GetHashCode：获取对象哈希值(对象唯一编码，但是也可能u不同对象哈希码一样)；虚方法ToString：返回对象代表的字符串; string注意事项：string大部分方法需要赋值再使用，因为会实例化一个新的字符串；字符串名[]：字符串索引器;(静态)string.Format()：字符串拼接(替代);字符串名.IndexOf()：正向查找字符位置;字符串名.LastIndexOf()：反向查找字符位置;字符串名.Remove()：移除指定位置的字符;字符串名.Replace()：替换指定字符串;字符串名.ToUpper()：字符串全部大写；字符串名.ToLower()：字符串全部小写;字符串名.Substring()：字符串截取；字符串名.Split()：字符串切割； StringBuilder作用：修改字符串而不创建新的对象字符串.Capacity:获取容量；字符串.Append:增；字符串.AppendFormat():拼接；字符串.Insert():插入；字符串.Remove():删；字符串.Clear():清空；索引-字符串[]:用来查和改；str.Replace():替换； 字符串拼接的方式直接通过+拼接 会有性能问题，字符串少还好，越多GC越严重。 通过StringBuilder拼接字符串 字符串数量越多性能相对直接+拼接方法越高。 通过StringBuffer拼接字符串 区别：线程安全版的StringBuilder，但是性能不如StringBuilder; string.Format原理：其底层本质还是StringBuilder来实现的； $方式拼接字符串原理：是string.Format简化版，C#6.0新增操作；语法： string str = $\"my name is{name}, I'm {age} years old\"; 知识拓展多脚本文件.cs：源码文件.sln：解决方案入口文件.dll：编译文件 UML定义：统一建模语言，是面向对象设计的建模语言；理解：可以通过一些UML可视化软件(visio)就可以生成代码；","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#基础","slug":"02002-C#基础","date":"2019-07-02T13:00:00.000Z","updated":"2022-01-25T04:23:57.493Z","comments":true,"path":"posts/1026.html","link":"","permalink":"http://wwy010518.github.io/posts/1026.html","excerpt":"","text":"将之前的笔记记录在博客上 复杂数据类型特点：数据(变量)集合、自定义； 枚举 枚举是一个被命名的整形常量集合,可以声明再命名空间、类和结构体中。 枚举声明enum 变量名{ 名1,//枚举中默认是0下面累加 名2=4,//可以赋值,下面数值接着从此开始 名3 } 枚举的类型转换1.枚举和int互转后是数值的转换2.枚举转换成string是枚举名3.string转换成枚举,必须有这个字符串名的枚举名,实例如下： Enum.Parse(typeof(声明枚举类型名),\"Other\"); 数组 数组是储存一组相同的数值集合,下标从0开始。 一维数组声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1,2,3,4……(第数组长度-1个) }；获取长度：数组名.length; 二维数组声明：变量类型【,】 二维数组名=new 变量类型【行,列】{ { 1,1,1… },{ 1,1,1…. },{ 1,1,1…. }… };获取长度:数组名.length(维度); 交叉数组 即数组的数组。 结构体public struct 结构体名{ 变量类型 变量名 构造函数(可选) 函数 } 结构体和类相同点：1.两者都拥有成员,包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。2.两者的成员都有其各自的存取范围。例如,可以将某一个成员声明为Public,而将另一个成员声明为Private。3.两者都可以实现接口。4.两者都可以公开一个默认属性,然而前提是这个属性至少要取得一个自变量。5.两者都可以声明和触发事件,而且两者都可以声明委托(Delegate)。6.两者都是container类型,这表示它们可以包含其他数据类型作为成员。 区别：1.结构是实值类型(Value Types),而类则是引用类型(Reference Types)。2.结构使用栈存储(Stack Allocation),而类使用堆存储(Heap Allocation)。3.所有结构成员默认都是Public,而类的变量和常量数则默认位Private,不过其他类成员默认都是Public。4.结构成员不能被声明位Protected,而类成员可以。5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化,但是类变量声明可以。6.结构不能声明默认的构造函数,也就是不拥有参数的非共享构造函数,但是类则无此限制。7.二者都可以拥有共享构造函数,结构的共享构造函数不能带有参数,但是类的共享构造函数则可以带或者不带参数。8.结构不允许声明析构函数(Destructor),类则无此限制。9.结构的实例(Instance)声明,不允许对包含的变量进行初始化设定,类则可以在声明类的实例时,同时进行变量初始化。1.结构是隐式继承自ValueType类,而且不能继承任何其他类型,类则可以继续自ValueType以外的任何类。11.结构是无法被继承的,类则可以。12.结构永远不会终止,因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止,当内存回收进程检测到没有任何作用的类时,它就会调用类的Finalize方法。13.结构不需要构造函数,类则需要构造函数。14.结构只能在一种情况下使用非共享构造函数,那就是非共享构造函数会接受参数。但是类则无此限制,它可以使用带参数或不带参数的非共享构造函数。15.每一个结构都具有无参数的隐含公共构造函数,此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上,由于结构是数值类型的,因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的,而且对象变量可引用不同的类实例,在此方面的区别,会对使用将结构和类造成如下的影响：16.结构变量会隐式的使用结构的无参数构造函数来初始化成员,这就意味语句 Struct S = new Struct()。17.当您将一个结构变量赋值给另一个,或者将结构实例传递到程序变量时,所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个,或者将对象变量传递给程序时,则只是复制指针。18.您可以将Null值赋值给结构变量,但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化,但是您还是可以调用变量的方法并访问其数据成员。相反的,如果您将对象变量设定为Null,您就会中断它与任何类型实例的关联,而且除非您再将另一个实例赋值给它,否则无法通过变量访问任何成员。19.您可以在不同时间将不同的类的实例赋值给同一个对象变量,而且在同一时间可有好几个对象变量引用相同的类实例,如果您对类成员值做了改变,则其他指向相同实例的对象变量也会发生改变。然而,结构成员则会封装在他们自己的实例中,变更结构成员值并不会对其他任何结构变量的成员造成影响,甚至也不会影响相同结构声明的其他实例。20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。 如何选择结构还是类:1.堆栈的空间有限,对于大量的逻辑的对象,创建类要比创建结构好一些2.结构表示如点、矩形和颜色这样的轻量对象,例如,如果声明一个含有 1000 个点对象的数组,则将为引用每个对象分配附加的内存。在此情况下,结构的成本较低。3.在表现抽象和多级别的对象层次时,类是最好的选择。4.大多数情况下该类型只是一些数据时,结构时最佳的选择。 值类型和引用类型值类型 其他类型、结构体；存储位置：栈空间–系统分配,自动回收,小而快特点：在赋值时,把内容拷贝给对方,它变我不变,内存地址不变。 引用类型 string、数组、类存储位置：手动申请和释放,大而慢特点：在赋值时,让俩者指向一个值,它变我也变,指向堆中相同内存地址。 特殊引用类型string string在赋值时也会再分配一个内存空间。 函数 函数可以写在类中和结构体中。 函数基础基本语法：static 返回类型 函数名(参数类型 参数名1….){ 代码逻辑；return 返回值 } ref和out 在函数内部传入,里面变了,外面也变了。声明：函数参数的修饰符；区别：ref传入的参数必须初始化,out传入的变量必须在内部赋值； 变长参数和参数默认值变长参数声明：params 变量类型[] 变量名；参数默认值：可选参数,在方法声明时就进行赋值,可选参数必须写在普通参数后面； 函数重载定义：重载和返回值无关,和参数类型、个数、顺序有关； 递归函数定义：就是让函数自己调用自己,但是需要留出出口,否则就是死循环","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#入门","slug":"02001-C#入门","date":"2019-06-18T13:00:00.000Z","updated":"2022-01-24T15:04:28.242Z","comments":true,"path":"posts/1025.html","link":"","permalink":"http://wwy010518.github.io/posts/1025.html","excerpt":"","text":"将之前的笔记记录在博客上 C#基础知识主流语言的应用领域C: 嵌入式硬件开发C++: 游戏客户端、服务器、软件C#: 游戏客户端、服务器、软件、网站 Java: 安卓、服务器、软件、网站JavaScript: H5游戏、网站、服务器PHP: 网站、服务器Python: 网站、服务器、辅助开发 SQL: 数据库Go: 服务器Objective-C: 苹果(mac、ios)相关Swift: 苹果(mac、ios)相关 开发环境搭建IDE是什么IDE(Integrated Development Environment )集成开发环境它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代码命令，听从你的指令和你进行交流。 常用的IDE(集成开发环境)软件Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;Android Studio: 谷歌推出，主要用于开发安卓应用;Xcode:苹果推出，主要用于开发苹果应用; 第一个应用程序理解写代码这件事通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算机通过这些命令来执行一些行为，从而实现一些特定的需求。比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能够动起来 注释的三种方式1.两杠注释:用于注释一行信息2.星号注释:用于注释多行信息3.三杠注释:用于注释类、命名空间等 快捷注释的方法1.上方工具栏2.快捷键CTRL + K + C 注释CTRL + K + U 取消注释 折叠代码由#region #endregion配对出现 控制台输入打印语句Console.Write():输出 Console.WriteLine:换行输出 Console.ReadKey:检测用户按下 Console.ReadLine:用户输入回车 变量变量类型有符号的整形变量sbyte: -128-127(字节占1);short: -32768-32767(字节占2);int: -21亿-21亿多(字节占4);long: -9百万兆-9百万兆(字节占8); 无符号的整数变量byte:0-255(字节占1);ushort: 0-65535(字节占2);uint: 0-42亿多(字节占4);ulong: 0-18百万兆(字节占8); 浮点型float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;double:(字节占8) 存储15-17位有效数字;decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; 特殊类型bool:非真即假(字节占1);char:存储单个字符(字节占2);string:存储多个字符，没有上限(长度可变); 变量的本质 数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000通过sizeof获取变量占用的内存空间(例如:sizeof(int);;1byte=8bit;1kb=1024byte;1mb=1024kb;1gb=1024mb;1tb=1024gb; 进制转换(整数，左侧第一位表示符号)十进制转二进制:不停除2;二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0); 命名规则1.不能重名;2.不能以数字开头;3.不能是关键字;4.不能有特殊符号(下划线除外); 驼峰命名法(变量)、帕斯卡命名法(函数、类) 常量关键字const，必须初始化，不能被修改。 转义字符 是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行 固定写法常用的转义字符':单引号;\":双引号\\n:换行\\:斜杠 不常用的转义字符\\t:制表符(空一个tab键)\\b:光标退格\\0:空字符\\a:警告音 取消转义字符 在字符串前面加一个@(例如@”\\你好\") 类型转换 不同变量类型之间的相互转换 隐式转换 不同类型之间的自动转换，大范围转小范围 相同大类型之间的转换 特殊类型不存在隐式转换 不同大类型之间的转换无符号和有符号之间 有符号的变量不能隐式转换无符号的; 无符号的变量隐式转换有符号的前提是范围一定是涵盖的; 浮点数和整数之间 浮点数可以转任何类型整数; 整数不能转换浮点型(不能存小数); 特殊类型和其他类型 char类型可以隐式转换成整数和浮点型(ASCII码); bool和string不能和其他类型互相转换; 显示转换 手动转换。 括号强转 小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。 Parse法 把字符串类型转换成对应类型，前提能转换，否则报错。语法:变量类型.Parse(“字符串”) Convert法 更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。语法:Convert.To目标类型(变量或者常量) 其他类型转string作用:拼接打印;语法:变量.ToString(); 异常捕获 避免程序报错造成卡死 try{ }catch{ }finally{ } 运算符算数运算符赋值运算符:=算数运算符:+ - * / %复合运算符:+= -+ *= /= %=自增运算符:a++(先用再加) ++a(先加再用) 运算符的优先级1.乘除大于加减;2.括号优先; 字符串拼接方法一:+号拼接;方法二:string.Format(“{0}”，18);控制台打印拼接:支持类似方法二; 条件运算符 只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。条件运算符:&gt; &lt; == != &gt;= &lt;=; 逻辑运算符逻辑运算符:&amp;&amp; || ! 运算符优先级 ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。 位运算符位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)位或:|(有1则1)异或:^(对位运算，相同为0，不同为1)位取反:~(0变1，1变0，反码补码问题)左右移:&lt;&lt;(左移几位，右边加几个0) &gt;&gt;(右移几位，右边去几个数) 三目运算符语法:空位(bool类型)？空位:空位; 条件分支语句if语句if(){ }else if(){ }else{ } switch语句switch(){ case 变量: break; default: break; } 循环语句while循环while(循环跳出条件){ } do-while循环do{ }while(); for循环for(int i=1;i&lt;条件;i++){ } foreach循环foreach(var i in 集合需要继承自一个接口){ } 知识补充控制台相关1.Console.Readkey().Keycahr-可以保存输入的字符;2.Console.Clear()-清空控制台;3.Console.SetWindowSize(宽，高);4.Console.SetBufferSize(宽，高)-缓冲区大小;5.Console.SetCursorPosition(x，y)-设置光标的位置6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear8.Console.CursorVisiable=false-设置光标显隐9.Environment.Exit(0)-关闭控制台 随机数语法:Random 变量名=new Random();生成非负数:变量名.Next(最小到最大，范围不包括最大);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]}],"categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"},{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"其他","slug":"其他","permalink":"http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构和算法","slug":"CS基础/数据结构和算法","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"ET","slug":"ET","permalink":"http://wwy010518.github.io/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Lua","slug":"Lua","permalink":"http://wwy010518.github.io/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://wwy010518.github.io/tags/AssetBundle/"},{"name":"Markdown","slug":"Markdown","permalink":"http://wwy010518.github.io/tags/Markdown/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"MVC","slug":"MVC","permalink":"http://wwy010518.github.io/tags/MVC/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]}