{"meta":{"title":"雪夜","subtitle":"雪夜の博客","description":"天再高又怎么样，踮起脚尖就能更接近太阳","author":"雪夜","url":"https://wwy.wwywy.com","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-01-22T04:07:31.290Z","comments":false,"path":"about/index.html","permalink":"https://wwy.wwywy.com/about/index.html","excerpt":"","text":"憨憨“ 不要惧怕别人的偏见、认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：憨憨的个人空间 QQ：3179342661 座右铭：保持初心，漫步远方"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://wwy.wwywy.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://wwy.wwywy.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://wwy.wwywy.com/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://wwy.wwywy.com/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://wwy.wwywy.com/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://wwy.wwywy.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://wwy.wwywy.com/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"相册","date":"2022-01-22T03:16:54.165Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://wwy.wwywy.com/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"https://wwy.wwywy.com/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://wwy.wwywy.com/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://wwy.wwywy.com/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构和算法","slug":"01040-数据结构和算法","date":"2022-03-03T13:00:00.000Z","updated":"2022-03-11T03:13:03.604Z","comments":true,"path":"posts/544.html","link":"","permalink":"https://wwy.wwywy.com/posts/544.html","excerpt":"","text":"绪论数据结构概论数据结构的定义1.数据：描述客观事物的数和字符的集合； 2.数据项：数据最小单位； 3.数据对象：性质相同的数据元素集合； 4.数据结构：数据元素之间的关系； 数据逻辑结构：由数据元素之间的逻辑关系组成； 数据的存储结构：数据元素以及其关系的物理结构； 数据的运算：施加在该数据上的操作； 逻辑结构1.定义：数据之间的抽象逻辑关系； 2.表示方法：图表表示、二元组表示； 3.逻辑结构类型： 集合：同属集合，无关系； 线性结构：一对一； 树形结构：一对多； 图：多对多； 存储结构（物理结构）1.定义：指数据的实际存储，逻辑结构在计算机存储实现； 2.物理存输类型： 顺序存储结构：连续存储 链式存储结构：非连续存储 索引存储结构：键值对 哈希（散列）存储：计算关键字哈希值仅存数据数据运算 1.定义：对数据实施的操作； 运算定义和运算实现分离：基于逻辑结构定义运算，基于存储结构实现运算 2.常用数据运算类型：增删改查以及排序； 数据类型和抽象数据类型1.数据类型：值类型，引用类型等； 2.抽象数据类型：从求解问题抽象出来的数据逻辑结构和抽象运算，与具体实现无关（重要特征是数据抽象和数据封装），算法就是抽象运算的实现； 3.抽象数据结构定义： ADT:数据结构名（例如List）； Data:数据结构的描述（例如线性表元素一一对应）； Operation:数据结构定义了哪些操作（例如对线性表的清空、插入、添加、删除、初始化等等）； 算法概论1.算法的定义：对特定问题的一种描叙，是指令的有限序列，应具有以下特征； 有穷性：是可以终止结束的算法； 确定性：相同输入相同输出； 可行性：算法每一步都必须是可行的，每一步都能执行有限次数完成； 有输入输出：输入加工对象，加功得到结果； 2.算法的设计目标：如下几点 正确性：对于非法的数据能够得到满足规格的结果； 可读可使用性：便于阅读、交流和使用； 健壮性：数据不合法时，也能做出相应处理； 时间高效率和低存储：满足时间高效率和低存储； 3.算法的描述：采用计算机语言描叙算法； 算法分析概论1.算法分析的定义：分析算法占用的计算机CPU时间和内存空间的多少； 算法时间性能分析（重点理解）1.时间算法类型： 事后统计法：统计执行时间，必须执行程序且很多因素掩盖了算法本质，如计算机速度、语言、问题规模等； 事前估计法：抛开问题，仅考虑算法本身的效率； 2.算法时间复杂度定义：平均情况下的问题规模n的函数的最高阶表示，推导如下 执行次数T(n) ==&gt; 问题规模n的函数； 总算法执行时间 ==&gt; 原操作+ T(n)(执行次数或算法频率)； 简化算法执行时间 ==&gt; 仅考虑执行次数T(n) ； 上界f(n) ==&gt; 由T(n)对于n的阶级函数的拆解，是问题规模n的某个函数； 问题阶级增率比较 ==&gt; 1(仅原操作)&lt;${log}{2}$n&lt;n&lt;n${log}{2}$n&lt;$n^2$&lt;$n^3$&lt;$2^n$&lt;n!&lt;$n^n$； 渐进时间复杂度（函数渐进增长问题） ==&gt; O(f(n))（O是找出T(n)最高阶或者说最紧凑的上界）； 平均时间复杂度 ==&gt;最好时间复杂度（算法运气好的时间）与最坏时间复杂度（算法运气坏的时候）的折中考虑； 3.推导大O阶的方法： 用常数1取代运行时间中所有加法常数； 修改后的运行次数函数，只保留最高阶数； 去除最高阶的相乘系数，得到的就是大O阶； 4.算法复杂度求和求积： T1(n)+T2(n)=O(Max(fn,g(n))) 例如并列循环 T1(n) * T2(n) = O(f(n)*g(n)) 例如多层嵌套循环 5.递归算法时间复杂度：自己调用自己，不能采用前面的分析方法； 算法空间性能分析1.算法空间复杂度：记作S(n) = O(g(n))，n为问题的规模，f(n)为语句所占用的存储空间函数，解释如下； 局部空间：初始只分配一次空间，参与原操作完继续使用，如果算法只有该形式空间分配，即问题规模n为常数，则该算法为原地工作或就地工作算法，空间复杂度为O(1)； 临时空间：原操作时才分配空间，原操作完即可释放，基本是其算法执行次数的考虑，空间复杂度和时间复杂度相关； 2.递归算法空间复杂度：待记； 程序概论1.程序=数据结构+算法； 2.数据结构和算法的联系：数据存储结构会影响算法的好坏，不能只单单考虑一种，存储强、信息多的存储结构，算法会比较好设计，反而相对简单的存储结构可能要设计一套复杂的算法； 线性表1.线性表定义：具有相同特征的数据元素的一个有限序列； 2.线性表的抽象数据类型： ADT：线性表（List） Data：一个有n个数据元素的数据集合，且元素类型相同，除了第一个和最后一个元素，每一个元素只有一个前驱元素和后继元素，且它之间的关系是一一对应的； Operation： Init:初始化操作 IsEmpty:判断是否为空 Clear(:清空操作 Get:根据下标获取元素 Insert:在下标位置插入元素 Delete:删除下标元素，并且返回其值 Lengtn:获取个数 顺序存储结构链式存储结构栈和队列串递归数组和广义表数和二叉树图查找内排序外排序","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"大学知识/CS基础/数据结构和算法","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"编译原理","slug":"01010-编译原理","date":"2022-03-03T13:00:00.000Z","updated":"2022-03-10T11:41:36.247Z","comments":true,"path":"posts/520.html","link":"","permalink":"https://wwy.wwywy.com/posts/520.html","excerpt":"","text":"重要信息：老师电话13574404624 引论编译器前端主要知识：词法分析、语法分析、语义处理； 编译器后端主要知识：中间代码生成、代码优化、目标代码生成； 文法和语言文法的定义：文法是语言的抽象规则（例如我们的语言都是遵守主谓宾这个文法）； 词法分析自顶向下语法分析方法（重点）确定的自顶向下分析思想LL(1)文法的判别自顶向上优先分析LR分析语法制导的语义计算静态语义分析和中间代码生成运行时存储组织代码优化和目标代码生成","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"编译原理","slug":"大学知识/CS基础/编译原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理","slug":"01020-计算机组成原理","date":"2022-03-03T13:00:00.000Z","updated":"2022-03-11T05:05:53.095Z","comments":true,"path":"posts/528.html","link":"","permalink":"https://wwy.wwywy.com/posts/528.html","excerpt":"","text":"计算机概论计算机软硬件概念1.软硬件概念：计算机系统由软件和硬件俩大部分组成，如下； 硬件：是计算机的实体部分； 软件：由各类特殊功能的程序组成，通常存放在计算机的主存或者辅存中，通常分为系统软件和应用软件； 冯·诺依曼体系结构计算机的基本组成1.冯·诺依曼计算机：1945年提出“存储程序”概念设计的计算机，冯·诺依曼计算机是以运算器为中心的，现代的计算机已经转化为以存储器为中心，如下图； 2.计算机组成：以下五部分组成 输入设备：将程序和数据以机器所能识别和接受的信息形式输入到计算机内（键盘、鼠标、扫描仪、语音输入设备、手写笔、触摸屏、数码摄像设备等）； 输出设备：将计算机处理的结果以人们所能接受的信息形式或其它系统所要求的信息形式输出（显示器、打印机、绘图仪 、音箱）； 存储器：用于存放程序和数据。存储器是计算机存储信息的核心，一般分为如下主存和外存。 主存储器(主存，内存)：CPU能直接访问，主存分为若干个存储单元，每个单元都有唯一的地址编码，通常是按字节或字节的整数倍编码。存储器总是按地址访问的； 辅助存储器(外存，辅存)：CPU不能直接访问，辅存中的信息必须调入主存后，才能为CPU所使用，辅存速度较慢，但容量大，用于存放CPU暂时不用的程序和数据（软盘、硬盘、光盘、磁带机）； 运算器：用于完成算术和逻辑运算，核心是算术逻辑部件(ALU)，是CPU的核心部件，还有若干寄存器，用于存放操作数、中间结果或最终结果； 控制器：控制器是整个计算机的指挥中心，通过实现编好的程序用于控制整个计算机系统中的各部件有条不紊地进行工作，其控制部件（CU）是CPU的核心部件，运作如下。 程序计数器PC（Program Counter）：存放将要执行的指令的地址（指向存储单元），具有自增功能； 指令寄存器IR（ Instruction Register）： 存放当前正在执行的指令； 指令译码器ID（Instruction Decoder）：分析指令； 时序部件（Sequencer）：分析指令时序； 控制信号发生器：运作； 3.计算机硬件技术指标： 机器字长：数据的位数，一般和CPU寄存器有关； 存储容量：存储器的容量； 运算速度：计算机运行速度； 计算计信息和运算机器数的表示机器数和真值1.机器数：如下分类 定义：计算机中的数据通常存放在寄存器中，通常称寄存器的位数为机器字长，而存储的数据叫机器数； 格式：符号和数值均二进制化，小数点隐含在某一固定位置上，不占存储空间，位数受机器字长的限制。超过机器字长的数值位要舍去； 分类：俩种情况 无符号数：机器字长的所有二进制均表示数值部分； 带符号数：第1个二进制位为符号位，其余为数值部分 ； 2.真值：机器数所表示的实际数值，例：8位机器数为11011011分以下情况 若为无符号整数，其真值为 219； 若为带符号整数，且采用原码表示，则最高位为符号， 1 1011011 表示二进制整数 -1011011，其真值为 -91； 原码表示法1.原码的定义：符号位0表示正数，1表示负数，数值位即真值的绝对值，约定符号位用逗号隔开，小数位用小数点隔开，如下整数和小数的定义式； 整数原码定义式：其中x为真值，n为整数位位数， ${[x]}_{原}$ = 0,x 当$2^n$&gt;x&gt;=0时 ${[x]}_{原}$ = $2^n$-x 当0&gt;=x&gt;$-2^n$时 小数原码定义式：其中x为真值 ${[x]}_{原}$ = x 当1&gt;x&gt;=0时 ${[x]}_{原}$ = 1-x 当0&gt;=x&gt;-0时 0的表示： 纯小数 ：[+0]原=0.00…0，[-0]原=1.00…0 纯整数：[+0]原=00…0，[-0]原=10…0 2.原码的优缺点： 优点： 表示简单； 和真值转换容易； 缺点： 0有俩种表示，给使用带来不便； 原码表示加减法运算很复杂； 补码表示法存储器输入输出系统指令系统控制器和中央处理器系统总线补充附录常用进位计数制1.定义：用进位的原则进行计数称为进位计数制，简称进制； 2.有关的概念： 数码：一组用来表示某种数制的符号，eg：二进制的0和1； 基数：数制所使用的数码个数，常用R表示，称为R进制； 位权：数码在不同位置的权值 eg：十进制的位权就是10的几次方； 十进制1.定义： 数码：1，2，3，4，5，6，7，8，9； 基数：10； 位权：10为底的幂； 写法规则：2022 D （D是DEC，可以省略）； 2.转二进制：转换规则：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来，如下图： 180（十进制）转换二进制为：10110100 3.转八进制：按照8除十进制整数取余，直到商为0为止； 4.转十六进制：转换规则：用16整除十进制整数，可以得到一个商和余数；再用16去除商，又会得到一个商和余数，如此进行； 二进制1.定义： 数码：0，1； 基数： R= 2； 位权：2为底的幂； 写法规则：0B 10010101 B （0B是c#中s使用二进制的前缀，D是BIN，可以省略）； 2.转十进制：把二进制按权展开，相加即得十进制数 3.转八进制：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。 4.转十六进制：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。 八进制1.定义： 数码：0,1,2,3,4,5,6,7； 基数：8； 位权：8为底的幂； 写法规则：0 720 O （0是c#中使用八进制的前缀，O是OCT，可以省略）； 2.转十进制：把八进制数按权展开、相加即得十进制数。 3.转二进制：八进制通过除二取余，得到二进制数，对每个八进制为3个二进制，不足在最左边补零； 4.转十六进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换； 十六进制1.定义： 数码：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F; 基数：16; 位权：16为底的幂； 写法规则：0X 1AF H （0X是c#中使用十六进制的前缀，D是HEX，可以省略）； 2.转十进制：把十六进制数按权展开、相加即得十进制数。 3.转二进制：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。 4.转八进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换 CPU类型复杂指令：X86（CISC）精简指令：ARM（RISC） ASCII码（美国信息交换标准代码）1.ASCII 码说明：ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。其中： 0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 。 32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。 65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。 同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1 [1] 。 后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1] 。 2.ASCII码表具体如下所示 : Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 0001 01 1 0x01 SOH(start of headline) 标题开始 0000 0010 02 2 0x02 STX (start of text) 正文开始 0000 0011 03 3 0x03 ETX (end of text) 正文结束 0000 0100 04 4 0x04 EOT (end of transmission) 传输结束 0000 0101 05 5 0x05 ENQ (enquiry) 请求 0000 0110 06 6 0x06 ACK (acknowledge) 收到通知 0000 0111 07 7 0x07 BEL (bell) 响铃 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0000 1110 016 14 0x0E SO (shift out) 不用切换 0000 1111 017 15 0x0F SI (shift in) 启用切换 0001 0000 020 16 0x10 DLE (data link escape) 数据链路转义 0001 0001 021 17 0x11 DC1 (device control 1) 设备控制1 0001 0010 022 18 0x12 DC2 (device control 2) 设备控制2 0001 0011 023 19 0x13 DC3 (device control 3) 设备控制3 0001 0100 024 20 0x14 DC4 (device control 4) 设备控制4 0001 0101 025 21 0x15 NAK (negative acknowledge) 拒绝接收 0001 0110 026 22 0x16 SYN (synchronous idle) 同步空闲 0001 0111 027 23 0x17 ETB (end of trans. block) 结束传输块 0001 1000 030 24 0x18 CAN (cancel) 取消 0001 1001 031 25 0x19 EM (end of medium) 媒介结束 0001 1010 032 26 0x1A SUB (substitute) 代替 0001 1011 033 27 0x1B ESC (escape) 换码(溢出) 0001 1100 034 28 0x1C FS (file separator) 文件分隔符 0001 1101 035 29 0x1D GS (group separator) 分组符 0001 1110 036 30 0x1E RS (record separator) 记录分隔符 0001 1111 037 31 0x1F US (unit separator) 单元分隔符 0010 0000 040 32 0x20 (space) 空格 0010 0001 041 33 0x21 ! 叹号 0010 0010 042 34 0x22 “ 双引号 0010 0011 043 35 0x23 # 井号 0010 0100 044 36 0x24 $ 美元符 0010 0101 045 37 0x25 % 百分号 0010 0110 046 38 0x26 &amp; 和号 0010 0111 047 39 0x27 ‘ 闭单引号 0010 1000 050 40 0x28 ( 开括号 0010 1001 051 41 0x29 ) 闭括号 0010 1010 052 42 0x2A * 星号 0010 1011 053 43 0x2B + 加号 0010 1100 054 44 0x2C , 逗号 0010 1101 055 45 0x2D - 减号/破折号 0010 1110 056 46 0x2E . 句号 0010 1111 057 47 0x2F / 斜杠 0011 0000 060 48 0x30 0 字符0 0011 0001 061 49 0x31 1 字符1 0011 0010 062 50 0x32 2 字符2 0011 0011 063 51 0x33 3 字符3 0011 0100 064 52 0x34 4 字符4 0011 0101 065 53 0x35 5 字符5 0011 0110 066 54 0x36 6 字符6 0011 0111 067 55 0x37 7 字符7 0011 1000 070 56 0x38 8 字符8 0011 1001 071 57 0x39 9 字符9 0011 1010 072 58 0x3A : 冒号 0011 1011 073 59 0x3B ; 分号 0011 1100 074 60 0x3C &lt; 小于 0011 1101 075 61 0x3D = 等号 0011 1110 076 62 0x3E &gt; 大于 0011 1111 077 63 0x3F ? 问号 0100 0000 0100 64 0x40 @ 电子邮件符号 0100 0001 0101 65 0x41 A 大写字母A 0100 0010 0102 66 0x42 B 大写字母B 0100 0011 0103 67 0x43 C 大写字母C 0100 0100 0104 68 0x44 D 大写字母D 0100 0101 0105 69 0x45 E 大写字母E 0100 0110 0106 70 0x46 F 大写字母F 0100 0111 0107 71 0x47 G 大写字母G 0100 1000 0110 72 0x48 H 大写字母H 0100 1001 0111 73 0x49 I 大写字母I 01001010 0112 74 0x4A J 大写字母J 0100 1011 0113 75 0x4B K 大写字母K 0100 1100 0114 76 0x4C L 大写字母L 0100 1101 0115 77 0x4D M 大写字母M 0100 1110 0116 78 0x4E N 大写字母N 0100 1111 0117 79 0x4F O 大写字母O 0101 0000 0120 80 0x50 P 大写字母P 0101 0001 0121 81 0x51 Q 大写字母Q 0101 0010 0122 82 0x52 R 大写字母R 0101 0011 0123 83 0x53 S 大写字母S 0101 0100 0124 84 0x54 T 大写字母T 0101 0101 0125 85 0x55 U 大写字母U 0101 0110 0126 86 0x56 V 大写字母V 0101 0111 0127 87 0x57 W 大写字母W 0101 1000 0130 88 0x58 X 大写字母X 0101 1001 0131 89 0x59 Y 大写字母Y 0101 1010 0132 90 0x5A Z 大写字母Z 0101 1011 0133 91 0x5B [ 开方括号 0101 1100 0134 92 0x5C \\ 反斜杠 0101 1101 0135 93 0x5D ] 闭方括号 0101 1110 0136 94 0x5E ^ 脱字符 0101 1111 0137 95 0x5F _ 下划线 0110 0000 0140 96 0x60 ` 开单引号 0110 0001 0141 97 0x61 a 小写字母a 0110 0010 0142 98 0x62 b 小写字母b 0110 0011 0143 99 0x63 c 小写字母c 0110 0100 0144 100 0x64 d 小写字母d 0110 0101 0145 101 0x65 e 小写字母e 0110 0110 0146 102 0x66 f 小写字母f 0110 0111 0147 103 0x67 g 小写字母g 0110 1000 0150 104 0x68 h 小写字母h 0110 1001 0151 105 0x69 i 小写字母i 0110 1010 0152 106 0x6A j 小写字母j 0110 1011 0153 107 0x6B k 小写字母k 0110 1100 0154 108 0x6C l 小写字母l 0110 1101 0155 109 0x6D m 小写字母m 0110 1110 0156 110 0x6E n 小写字母n 0110 1111 0157 111 0x6F o 小写字母o 0111 0000 0160 112 0x70 p 小写字母p 0111 0001 0161 113 0x71 q 小写字母q 0111 0010 0162 114 0x72 r 小写字母r 0111 0011 0163 115 0x73 s 小写字母s 0111 0100 0164 116 0x74 t 小写字母t 0111 0101 0165 117 0x75 u 小写字母u 0111 0110 0166 118 0x76 v 小写字母v 0111 0111 0167 119 0x77 w 小写字母w 0111 1000 0170 120 0x78 x 小写字母x 0111 1001 0171 121 0x79 y 小写字母y 0111 1010 0172 122 0x7A z 小写字母z 0111 1011 0173 123 0x7B { 开花括号 0111 1100 0174 124 0x7C | 垂线 0111 1101 0175 125 0x7D } 闭花括号 0111 1110 0176 126 0x7E ~ 波浪号 0111 1111 0177 127 0x7F DEL (delete) 删除","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"计算机组成原理","slug":"大学知识/CS基础/计算机组成原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机网络技术","slug":"01030-计算机网络技术","date":"2022-03-03T13:00:00.000Z","updated":"2022-03-09T02:12:38.549Z","comments":true,"path":"posts/536.html","link":"","permalink":"https://wwy.wwywy.com/posts/536.html","excerpt":"","text":"计算机网络概叙基本概念1.定义：一些互连的、独立自治的计算机集合； 2.目的：资源共享、数据通信、负载均衡和分布式计算、数据信息集中处理； 3.一般分类： 按通信媒体：有线网络、无线网络； 按使用对象：公众网络、专用网络、接入网； 网络传输技术：广播式网络、点到点网络； 按地理覆盖（常用）： 局域网：几十米到几千米之间； 城域网：几千米到几十千米； 广域网 ：几十千米到几千千米，例如Internet； 网络拓扑结构1.常见的拓扑结构： 总线型拓扑结构：结构简单、易于阔充、属于广播网络； 星型拓扑结构：结构简单、易于实现和管理、但是耗费电缆、中心出问题会带动其他地方； 树形拓扑结构：易于分级管理和控制； 环形拓扑结构：结构简单、易于实现、传输时延确定和路径选择简单； 网状拓扑结构：充分利用网络资源，但是成本高； 计算机网络性能指标1.比特的概念：比特(bit)意思是一个二进制数字（0或1）。 B为字节(Byte)，b为比特(bit)，一字节为8比特，即1B = 8b。 网络技术中的数率指的是数据的传送速率，当数据率较高时，常常在bit/s前面加上字母，比如k = $10^3$,M = $10^6$,G = $10^9$,T = $10^{12}$等。 （注意区分网络传输和文件系统中的数据后缀字母，文件系统一般是字节。比如一个100MB的文件，这里的M就是$2^{20}$，传输率为100Mbit/s，这里的M为$10^6$） 2.数据传输率：又叫比特率，指连接在网络上的主机在数字信道上传送数据的速率。 速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等； 3.信道容量：信道容量即是指最大的数据传输速率，通常说数字通信系统所说的带宽与数据传输速率相等，注意这个数据传输速率是实际的传输速率，实际与最大的数据传输速率二者之间满足香农公式，具体如下俩种情况 在有噪声的情况下即信道不是理想信道，信道容量是信道能够达到的最大数据速率，此时数字信道的带宽W与信道容量C满足香农公式C=W${Log}_{2}$（1+S/N） ; 理想信道时，根据奈奎斯特定理，C=最大的数据传输速率=2W； 4.带宽：分以下俩种情况 对于模拟通信或传输介质，带宽指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）； 而数字通信系统中“带宽”，理论上是指传输信道的信道容量，也即信道中传递信息的最大值，单位为“比特/秒”。由于数字系统中的信道多指逻辑信道，而信道容量又是理论上的最大值(不可能达到)，所以平时我们使用的“带宽”一词，是指信道中数据的实际传输速率； 5.误码率：误码指信号传输过程中受干扰的和衰减的数据传输错误，是衡量传输可靠性的主要观测点，误码率${P}_{e}$=接受的错位数 除以 传输总数； 6.时延： 发送时延：发送数据时，数据帧从结点进入到传输媒体所需要的时间。 $\\mathrm{发送时延};=;\\frac{\\mathrm{数据帧长度}(b)}{\\mathrm{发送速率}(b/s)}$ 传播时延：电磁波在信道中需要传播一定的距离而花费的时间。 $\\mathrm{传播时延};=;\\frac{\\mathrm{信道长度}(米)}{\\mathrm{信号在信道上的传输速率}(b/s)}$ 处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间； 排队时延：结点缓存队列中分组排队所经历的时延. 总时延：总时延 = 发送时延+传播时延+处理时延+处理时延 7.利用率：信道利用率指出某信道有百分之几的时间是被利用的。 网络利用率则是全网络的信道利用率的加权平均值. $D;=;\\frac{D_0}{1;-;U}$ $D_0$为网络空闲时的时延，$D$为当前时延，U为利用率。 计算机网络的体系结构ISO/OSI七层模型1.专业术语 实体和对等实体：每一层中，用于实现该层功能的活动元素被称为实体，不同机器同一层、完成相同功能的实体称为对等实体； 协议：对等实体之间交换数据的约定； 服务和接口：下层为上层提供的功能叫服务，通过上下层之间的接口实现； 2.OSI理想模型层级（由上到下）： 应用层（APDU）：负责为用户程序提供网络服务； 表示层（PPDU）：表示层以下关心可靠的数据传输，而表示层关心传输数据的语法和语义； 会话层（SPDU）：在俩个节点之间建立、维护和释放用户连接； 传输层（分段）：该层负责两台主机中进程之间的通信，而传输层上三层主要面向用户提供服务，下三层面向网络通信； 网络层（分组）：端到端的主机通信； 数据链路层（帧）：解决相邻节点的数据传输等问题； 物理层（比特流）：直接面向原始比特流的传输； TCP/IP模型1.TCP\\IP模型层级（从上到下）：应用层、传输层、网络层、网络访问层； 2.OSI模型和TCP/IP模型比较： 相同点： 均采用层次结构，并具有可比的运输层和网络层； 都基于协议数据单元的包交换网络，且分别作为概念模型和事实标准； 不同点： OSI七层，TCP四层，TCP应用层中包含了OSI上三层的功能，网络访问层包含了下俩层的功能； OSI对分层很好的说明服务、协议、接口的概念，是最重要的计算机网络概念模型，但是每层都存在寻址、流量控制、差错控制等机制，所以比较复杂，缺乏实现上的操作性； TCP/IP层次较少，显得更加简洁，容易实现，但是服务、协议、接口区分并不是很清晰。 五层结构（OSI和TCP/IP折中方案）1.五层结构（从上到下）： 应用层：是体系中的最高层，任务是通过应用进程间的交互来完成特定网络应用，把应用层交互的数据单元称为报文。 运输层：负责两台主机中进程之间的通信提供通用的数据传输服务。主要用到以下两种协议; TCP：传输控制协议（Transmission Control Protocol），提供面向连接，可靠地数据传输服务，其数据传输的单位是报文段。 UDP：用户数据报协议（User Datagram Protocol）,提供无连接的，尽最大努力的数据传输服务，是不可靠的。其数据传输的单位是用户数据报。 网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。在TCP/IP体系中使用IP协议，因此分组也叫做IP数据报。 数据链路层：两台主机之间的数据传输，总是在一段一段的链路上进行传送的，需要使用专门的链路层协议，在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点之间的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样数据链路层在接收到一个帧后，就可以从中提取出数据部分，上交给网络层。 物理层：物理层上所传数据的单位是比特。传递信息所用的载体（比如双绞线，光缆等）不属于物理层，是物理层下面一层。 分组交换技术☆1.介绍：提高信道利用率，提高抗毁性 端到端数据流被划分为若干数据块，添加首部形成若干分组，分组首部中携带地址、长度等控制信息 主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。 路由器的用途则是用来转发分组的，即进行分组交换的，分组交换也称包交换，它是将用户传送的数据划分成一定的长度，每个部分叫做一个分组。在每个分组的前面加上一个分组头，用以指明该分组发往何地址，然后由交换机根据每个分组的地址标志，将他们转发至目的地，这一过程称为分组交换。进行分组交换的通信网称为分组交换网。从交换技术的发展历史看，数据交换经历了电路交换、报文交换、分组交换和综合业务数字交换的发展过程。分组交换实质上是在“存储—转发”基础上发展起来的。它兼有电路交换和报文交换的优点。分组交换在线路上采用动态复用技术传送按一定长度分割为许多小段的数据—分组。每个分组标识后，在一条物理线路上采用动态复用的技术，同时传送多个数据分组。把来自用户发端的数据暂存在交换机的存储器内，接着在网内转发。到达接收端，再去掉分组头将各数据字段按顺序重新装配成完整的报文。分组交换比电路交换的电路利用率高，比报文交换的传输时延小，交互性好，如下图所示； 2.存储转发：路由器在输入链路上接收整个分组 存储接收的分组 然后选择输出链路，并以最大传输速率向输出链路转发； 3.优点： 高效：动态分配传输带宽，对通信链路是逐段占用； 灵活：以分组为传送单位和查找路由； 迅速：不必先建立连接就能向其他主机发送分组； 可靠：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性； 物理层物理层概述1.说明：物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 2.物理层主要问题： 信号和信道类型选择 传输媒体选择 提高传输媒体的利用率 关于衰减和噪音影响的处理 通信方式的选择 物理互通的实现 3.物理层传输质量的评估：通过数据传输速率和误码率作为评估主要标准； 基带传输和数字数据编码1.基本概念：二进制数字数据利用脉冲信号（数字信号和信道）来进行传输和编码，数字信号是离散的电压或电流脉冲序列，常用方法是使用脉冲信号来表示二进制数字字符“0”和“1”； 2.数字信号编码方式：如下 不归零制：正电平代表1，负电平代表0； 归零制：正脉冲代表1，负脉冲代表0； 曼彻斯特编码：位周期中心的向上跳代表0，位周期中心的向下跳代表1，也可以反过来定义； 差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1； 频带传输和调制解调1.频带传输基本概念：基带传输受到距离限制，所以远距离一般采用模拟通信； 2.调制解调方法：如下三种 幅度调制 频率调制 相位调制 传输媒体1.分类：如下几种 有线传输媒体： 双绞线：最古老又最常用、价格便宜，但是对电磁干扰敏感，主要用于室内； 同轴电缆：新标准已经不再推荐； 光纤：传输带宽大，传输损耗小，中继距离长，抗干扰能力强（雷电和电磁干扰），保密性好（不易被窃听）体积小，重量轻。精确对接困难。 无线传输媒体： 无线电波：通过空间电磁传播、无需安装物理线路，频率范围再30kHz到30000MHz之间，波长10km~0.1mm； 微波（卫星）： 带宽高，容量大，不受环境影响，且不需实现铺好电缆，但是需要相关部门许可； 红外线：通过空间电磁传播、不受电磁干扰和射频干扰，但是必须再直线视距之间，且数据传输速率相对较低； 激光通信：短距离传输，但是受天气影响大； 2.传输媒体的比较和选用：如下图 多路复用技术1.基本概念：指在一条物理线路上建立多条通信信道； 2.分类： 频分复用（FDM）：将线路带宽划分成若干较小带宽来达到多路复用目的，用户在分配在一定频宽后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。 时分复用（TDM）：将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占领固定序号的时隙，时分复用的所有用户是在不同的时间占用同样的频带宽度，时分复用分为同步（STDM）和异步（ATDM）技术。 波分复用（WDM）：采用光波波长的分隔的多路复用方法； 码分复用（CDM）：是一种移动通信系统的复用技术，基于码型分割信道，每个用户可以在同样时间使用同样频带进行通信，具有很强的抗干扰性。 通信方式1.串行通信和并行通信： 串行通信：指发送端所发送和的数据，按照数据位的先后顺序，依次通过信源和信宿之间的单条信道到达接收端； 并行通信：发送端和接受端之间多条并行信道实现一个节拍下多个数据位的并行传送； 2.全双工通信和半双工通信 单工通信：能有一个方向的通信而没有反方向的交互（广播和电视节目）； 半双工通信：通信的双方都可以发送信息，但不能双方同时发送和同时接收（对讲机）； 全双工通信：通信的双方可以同时发送和接收信息（手机）； 常见物理层组件和设备1.常见的物理组件设备：指物理层提供的无源器件，如下所示 端接器件：为网络线缆连接提供良好的端接，不同线缆对应的连接头不能通用； 转换器：用于不同接口或媒体之间进行信号转换； 2.常见的物理组件：用于增强网络覆盖和传输距离的网络互联网设施 中继器：对物理信号进行放大再生，单进单出，网络规模增加时，需要多个中继器； 集线器：拥有多个接端口，但是只能提供一路的信号放大、整形和转发，否则会出问题； 数据链路层1.基本概念： 使用一对一的点对点通信方式； 数据链路=物理链路+数据链路协议； 数据链路层是为了克服物理层的不足而建立的，旨在实现网络俩个相邻节点之间的无差错传输； 2.待解决主要问题： 物理寻址： ​ 网络层运输层应用层","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络技术","slug":"大学知识/CS基础/计算机网络技术","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"计算机网络技术","slug":"计算机网络技术","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"}]},{"title":"人工智能导论","slug":"01005-人工智能导论","date":"2022-03-02T13:00:00.000Z","updated":"2022-03-10T09:50:27.565Z","comments":true,"path":"posts/517.html","link":"","permalink":"https://wwy.wwywy.com/posts/517.html","excerpt":"","text":"绪论人工智能基本概念1.自然界四大奥秘：物质的本质、宇宙的起源、生命的本质、智能的发生； 2.智能的定义：智能是只是和智力的总和； 3.智能的特征： 感知能力（游戏AI必须品）：主动信息的输入，实现视觉、听觉、触觉、嗅觉等感觉器官； 记忆力和思维能力：信息的存储和信息的模拟，记忆存储由感知器官感知到的外部信息以及由思维所产生的知识，思维能力对记忆的信息进行处理； 逻辑思维（抽象思维）：例如理科生通过逻辑去肢解一道数学题； 形象思维（直感思维）：例如人的第五感； 顿悟思维（灵感思维）：例如牛顿如何发现了力学； 学习能力：被动信息的输入，学习既可能是自觉的、有意识的，也可能是不自觉的、无意识的；既可以是有教师指导的，也可以是通过自己实践的； 行为能力（表达能力）：信息的输入，人工智能实现的目的； 人工智能发展简史人工智能发展史：了解就好了，知乎看看就好；人工智能发展史 - 知乎 (zhihu.com) 人工智能研究的基本内容1.知识表达：将人类知识形式化或者模型化，方法有符号表示法、连接机制表示法，简单点说就是建立一个能把人懂的东西弄成机器能懂的东西的东西； 2.机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主； 3.机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理； 4.机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识； 5.机器行为：计算机的表达能力，即“说”、“写”、“画”等能力； 人工智能的主要研究领域主要领域：自动定理证明、博弈、模式识别、机器视觉 、自然语言理解、机器翻译、智能信息检索 、数据挖掘与知识发现、专家系统、自动程序设计、机器人、组合优化问题、人工神经网络； 其他领域：分布式人工智能与多智能体、智能控制、智能仿真、智能CAD 、智能CAI 、智能管理与智能决策 、智能多媒体系统 、智能操作系统、智能计算机系统 、智能通信 、智能网络系统、人工生命 ； 知识表示与知识图谱知识和知识表示知识的概念1.知识的定义：把有关信息关联在一起所形成的信息结构； 2.知识的作用：反映了客观世界中事物之间的关系； 3.知识的特性： 相对正确性：知识在一定的条件及环境下产生的才是正确的； 不确定性： 随机性引起的不确定性 ：清明一般都会下雨，但是也有不下雨的时候； 模糊性引起的不确定性 ：根据人的外貌去判断年龄； 经验引起的不确定性：经历丰富的人相对知识也更加丰富； 不完全性引起的不确定性：比如对人类对宇宙的了解并不完整； 可表示性和可利用性：知识可以用适当形式表示和利用； 知识表示的概念1.知识表示的定义：将人类的知识形式化或者模型化（人类划重点）； 2.知识表示的作用：计算机可以接受的描述知识的数据结构 3.知识选择方法的原则：有利于知识的充分表示和分利用、便于组织、维护、管理、理解和实现； 一阶谓词逻辑表示法非专业作了解： 人工智能一阶谓词逻辑表示法 产生式表示法非专业作了解：产生式表示法 框架表示法非专业作了解：知识表示之框架表示法 知识图谱（推荐学习）定义：是一种揭示实体之间关系的语义网络；目的：知识图谱的目的是为了提高搜索引擎的能力，改善用户的搜索质量以及搜索体验； 1.知识图谱的逻辑结构： 数据层：主要是由一系列的事实组成，而知识以事实为单位进行存储。 模式层：构建在数据层之上，是知识图谱的核心。 2.知识图谱的原始数据类型： 结构化数据：是指知识定义和表示都比较完备的数据，如关系数据库； 半结构化数据：是指部分数据是结构化的，但存在大量结构化程度较低的数据，如XML、JSON； 非结构化数据：是指没有定义和规范约束的“自由”数据，如文本、视频、音频、图片； 了解更多：通俗易懂解释知识图谱 确定性推导方法非专业作了解：确定性推理方法 不确定性推导方法非专业作了解：不确定推理方法 搜索求解策略搜索的概念1.搜索算法主要解决问题： 是否一定能找到一个解。 找到的解是否是最佳解。 时间与空间复杂性如何。 是否终止运行或是否会陷入一个死循环 2.搜索方向： 从初始给出的条件出发； 从目的地出发，进行逆推算； （A*算法）从开始状态出发作正向搜索，同时又从目的状态出发作逆向搜索，直到两条路径在中间的某处汇合为止；状态空间的搜索策略非专业作了解：状态空间表示法 盲目的图搜索策略回溯策略1.回溯策略的数据结构： Pass集合：记录寻路算法中的可走路径，保存搜索路径的状态，如果找到了目的，该集合就是解； Open集合：等待搜索或者待访问的状态集合； Close集合：已经被访问的状态集合； 广度优先搜索策略1.算法特点：如下俩点 每次选择深度最浅的节点首先扩展，搜索是逐层进行的，如图5.6所示； 一种高价搜索，会遍历所有节点，但若有解存在，则必能找到它，且是最短路径（可以理解很多人沿着不同的方向走，人多力量大）； 2.算法描述如下： a：选择一个未访问的顶点入队； b：从队里选出一个顶点V出队，并且标记为已经访问； c：将顶点V的所有未被访问的邻接顶点入队并且设置该节点父节点为顶点V； d：重复步骤a~b，直到所有顶点都已经被访问； e：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条） 3.核心算法实现： /// &lt;summary&gt; /// 广度优先算法BFS /// &lt;/summary&gt; /// &lt;param name=\"originNode\"&gt;起点位置&lt;/param&gt; /// &lt;param name=\"targetNode\"&gt;目标位置&lt;/param&gt; /// &lt;param name=\"passNodeList\"&gt;可走路径&lt;/param&gt; public static void BFSSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeList) { Queue&lt;Node&gt; openQue = new Queue&lt;Node&gt;(); openQue.Enqueue(originNode); while (openQue.Count &gt; 0) { Node head = openQue.Dequeue(); //获取该节点周围的节点 List&lt;Node&gt; neighborLst = Program.GetNeighbor(head); //检查周围的节点 for (int i = 0; i &lt; neighborLst.Count; i++) { Node neighborNode = neighborLst[i]; //节点被访问或者是障碍物的直接继续 if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue; //记录节点被访问 neighborNode.isVisit = true; //记录父节点 neighborNode.parent = head; openQue.Enqueue(neighborNode); //这个时候整个地图已经遍历完了 if (neighborNode.Equals(targetNode)) { //反向输出父节点，就是要找的路径 while (!neighborNode.Equals(originNode)) { neighborNode = neighborNode.parent; passNodeList.Add(neighborNode); neighborNode.nodeType = NodeType.Pass; } //最后添加目标点（其实直接返回目标节点也是可以的） passNodeList.Add(targetNode); targetNode.nodeType = NodeType.Pass; return; } } } } 深度优先搜索策略1.算法特点： 扩展最深的节点的结果使得搜索沿着状态空间某条单一的路径从起始节点向下进行下去；仅当搜索到达一个没有后裔的状态时，才考虑另一条替代的路径； 为了保证找到解，应选择合适的深度限制值，或采取不断加大深度限制值的办法，反复搜索，直到找到解； 深度优先搜索并不能保证第一次搜索到的某个状态时的路径是到这个状态的最短路径，如果路径距离很重要的话，它应该尝试保留最短路径； 2.算法描述如下： a：选择传入的起始顶点，并将顶点标记已经访问； b：访问邻接顶点，直到某个顶点没有邻接顶点再继续下一步； c：回溯到上一层顶点，重复b步，直到所有顶点都被访问； d：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）； 3.核心算法实现： /// &lt;summary&gt; /// 深度优先算法BFS（简单实现，非最优路径） /// &lt;/summary&gt; /// &lt;param name=\"currentNode\"&gt;当前位置&lt;/param&gt; /// &lt;param name=\"originNode\"&gt;起点位置&lt;/param&gt; /// &lt;param name=\"targetNode\"&gt;目标位置&lt;/param&gt; /// &lt;param name=\"passNodeList\"&gt;可走路径&lt;/param&gt; public static void DFSSearch(Node currentNode, Node originNode, Node targetNode,ref List&lt;Node&gt; passNodeList) { //标记该节点已经被访问 currentNode.isVisit = true; //获取该节点周围的节点 List&lt;Node&gt; neighborLst = Program.GetNeighbor(currentNode); for(int i = 0; i &lt; neighborLst.Count; i++) { Node neighborNode = neighborLst[i]; //节点被访问或者是障碍物的直接继续 if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue; //记录父节点 neighborNode.parent = currentNode; //递归调用,先深再广 DFSSearch(neighborNode, originNode, targetNode, ref passNodeList); //这个时候已经找到目标节点了 if (neighborNode.Equals(targetNode)) { //反向输出父节点，就是要找的路径 while (!neighborNode.Equals(originNode)) { neighborNode = neighborNode.parent; passNodeList.Add(neighborNode); neighborNode.nodeType = NodeType.Pass; } //最后添加目标点（其实直接返回目标节点也是可以的） passNodeList.Add(targetNode); targetNode.nodeType = NodeType.Pass; return; } } } 启发式图搜索策略启发式策略1.启发式信息定义：用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息； 2.启发式策略特点：重排Open表，选择最有希望的节点加以扩展； 3.启发信息分类：按以下俩种情况考虑 按运用的方法分类： 陈述性启发信息：用于更准确、更精炼地描述状态； 过程性启发信息：用于构造操作算子； 控制性启发信息：表示控制策略的知识； 按作用分类： 用于扩展节点的选择，即用于决定应先扩展哪一个节点，以免盲目扩展； 用于生成节点的选择，即用于决定要生成哪些后继节点，以免盲目生成过多无用的节点； 用于删除节点的选择，即用于决定删除哪些无用节点，以免造成进一步的时空浪费； 4.估价函数：用来估算初始节点经过 n节点到达目标节点的路径的最小代价，如下推理 估价函数值f(n) ==&gt; g(n) + h(n); g(n) ==&gt; 从当前节点到待访问节点n的实际代价（其实就是距离） h(n) ==&gt; 从待访问节点n到目标距离的估算代价（其实就是方向） h(n) 比重大：降低搜索工作量，但可能导致找不到最优解； h(n) 比重小：一般导致工作量加大，极限情况下变为盲目搜索，但可能可以找到最优解； A*算法","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"人工智能","slug":"大学知识/CS基础/人工智能","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"定点数数学库","slug":"04202-定点数数学库","date":"2022-03-01T13:00:00.000Z","updated":"2022-03-06T14:09:52.100Z","comments":true,"path":"posts/2178.html","link":"","permalink":"https://wwy.wwywy.com/posts/2178.html","excerpt":"","text":"定点数FInt基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化，使用位运算来直接操作二进制进行放大缩小，这里可以放大1024倍，也就是1&lt;&lt;10，使用完之后在缩小1024倍还原即可;乘法还原正负不同问题：按照上面的流程，乘法运算后绝对值相同的正负数值经过还原后会出现不对等的问题，比如500乘FInt(0.3f)的RawInt值是是14，但是500乘FInt(-0.3f)的RawInt值却是-15，这是因为二进制中，正数由原码表示，负数由补码表示，补码是在原码的反码上再加一得来的，要简单的解决这一个问题可以对值进行取反运算再取反，让已经实现好的底层去解决； 定点向量FVector3常用运算FCalc","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"第三方库","slug":"Game-Play/第三方库","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"第三方库","slug":"第三方库","permalink":"https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"定点数数学库","slug":"定点数数学库","permalink":"https://wwy.wwywy.com/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"}]},{"title":"确定性物理库","slug":"04203-确定性物理库","date":"2022-03-01T13:00:00.000Z","updated":"2022-03-06T14:09:35.513Z","comments":true,"path":"posts/2179.html","link":"","permalink":"https://wwy.wwywy.com/posts/2179.html","excerpt":"","text":"","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"第三方库","slug":"Game-Play/第三方库","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"第三方库","slug":"第三方库","permalink":"https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"确定性物理库","slug":"确定性物理库","permalink":"https://wwy.wwywy.com/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"}]},{"title":"ET6.0框架Demo源码解析","slug":"04004-ET6.0框架Demo源码解析","date":"2022-02-28T13:00:00.000Z","updated":"2022-03-03T08:03:42.117Z","comments":true,"path":"posts/2052.html","link":"","permalink":"https://wwy.wwywy.com/posts/2052.html","excerpt":"","text":"","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"ET","slug":"ET","permalink":"https://wwy.wwywy.com/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"Unity相关-角色换装","slug":"03100-Unity相关-角色换装","date":"2022-02-18T13:00:00.000Z","updated":"2022-03-03T10:03:36.641Z","comments":true,"path":"posts/1600.html","link":"","permalink":"https://wwy.wwywy.com/posts/1600.html","excerpt":"","text":"待写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"换装","slug":"换装","permalink":"https://wwy.wwywy.com/tags/%E6%8D%A2%E8%A3%85/"}]},{"title":"Unity插件-Animancer插件使用","slug":"03051-Unity插件-Animancer插件使用","date":"2022-01-29T13:00:00.000Z","updated":"2022-03-03T10:05:30.867Z","comments":true,"path":"posts/1577.html","link":"","permalink":"https://wwy.wwywy.com/posts/1577.html","excerpt":"","text":"Animancer介绍Animancer初步使用使用方法：添加Animator组件和AnimancerComponent相关组件，再编写脚本控制动画； 脚本案例： public sealed class PlayAnimation : MonoBehaviour { [SerializeField] private AnimancerComponent _Animancer; [SerializeField] private AnimationClip _Clip; private void OnEnable() { _Animancer.Play(_Clip); var state = _Animancer.Play(_Clip); state.Speed = ... state.Time = ... state.NormalizedTime = ... state.Events.OnEnd = ... _Animancer.Play(_Clip).Time = 0; } } Animancer核心组件AnimancerComponent说明：普通的动画师组件 AnimancerComponent类中的API： 成员变量： //1.获取Animator Controller组件 animancer.Animator //2.获取Playable animancer.Playable //3.获取该组件上的动画状态字典 animancer.States //4.获取该组件上的动画层级 animancer.Layers 成员方法： //1.播放动画 animancer.Play(AnimationClip, float, FadeMode) //2.使用键值播放动画。如果该键没有注册，返回null animancer.TryPlay(Object, float, FadeMode) //3.停止当前动画或者目标动画 animancer.Stop(参数) //4.判断是否播放当前动画或者目标动画 animancer.IsPlaying() NamedAnimancerComponent说明：继承自AnimancerComponent并添加一个数组，并按名称注册动画，可以使用名字播放动画，这与 Unity 的旧版组件非常相似； AnimancerComponent类中的API： 增加的成员变量： //1.获取动画源列表 animancer.Animations //1.获取默认动画源 animancer.DefaultAnimation HybridAnimancerComponent说明：继承自NamedAnimancerComponent，并且添加了控制器，可以融合Animator Controller组件和Animancer； Animancer动画状态动画状态说明：播放动画时，Animancer会创建一个状态来管理它并跟踪它的进度，如果以后再次播放相同的动画，它将重用相同的状态； AnimancerState类API 成员变量： //1.获取动画源文件 state.Clip //2.动画事件集合 state.Events //3.动画的长度 state.Length //4.动画的速度 state.Speed //5.状态的开始时间，该变量改变，动画事件也会变 state.NormalizedTime //6.状态的结束时间，该变量改变，动画事件也会变 state.NormalizedEndTime //7.状态的事件集合 state.Events 成员方法： //1.销毁动画 state.Destroy() 主要访问和创建状态的方法： //1.此属性存储该方法最近返回的状态 var state = animancer.States.Current; //2.此属性存储最近由 Layer 的方法返回的状态 var state = animancer.Layers[x].CurrentState; //3.索引器获取 var state = animancer.States[clip]; //4.方法获取 animancer.States.TryGet(clip, out var state); //5.如果已存在的状态，则此方法将返回该状态。否则它将创建并返回一个新的 var state = animancer.States.GetOrCreate(clip); //6.创建新状态，即使该动画已存在一个状态。请注意，每个状态必须具有不同的密钥，否则将引发，注意key时object类型，所以会有装拆箱问题 var state = animancer.States.Create(key, clip); //7.创建新状态，而不为其提供键。 var state = new ClipState(clip); //8.如果存在的状态，则此方法将销毁该状态并返回，否则，它将返回false animancer.States.Destroy(clip); Animancer动画过渡过渡说明：Animancer中除了使用Clip动画源文件来进行使用，也可以使用ClipTransition播放动画，并且这样效果更好； 过渡类类型： //基本过渡： 1.ClipTransition：实现ITransition接口，最基本的过渡类型，FadeDuration可以控制动画淡入淡出过渡的时长，Speed控制速度，StartTime和EndTime控制起始时间，同时动画支持添加帧事件； 2.ClipTransitionSequence：继承自ClipTransition并简单地添加一个数组，这些数组将在第一个之后按顺序播放（使用他们的每个结束事件来播放下一个）； 3.PlayableAssetTransition //混合过渡： 1.ManualMixerTransition：简单的混合动画； 2.LinearMixerTransition：1D混合动画，用一个参数控制，参数信息和Animator里的混合一致； 3.MixerTransition2D：2D混合模式，用俩个参数控制，参数信息和Animator里的混合一致； //控制器过渡： 1.ControllerTransition：使用控制器文件； //过渡资源 1.过渡类+Asset：过渡资源在资源面板下可以创建该过渡资源文件，和上面不同的时，过渡文件整个项目全局共享，而不是每个对象都有自己单独的过渡。它们都遵循相同的命名约定； 2.过渡类+Asset.UnShared:不共享分过渡资源，一般用不着； Animancer混合动画淡入淡出淡入淡出说明：淡入淡出通常不用于动画，因为它们不能混合，但是对于骨架动画非常有用，因为它允许角色模型从一个动画的结束姿势平滑地过渡到另一个动画的起始姿势，而不需要两个姿势完全相同。这也意味着，如果动画在任何时候被中断，过渡仍然可以是平滑的； 常用淡入淡出类型： //1.参数值按百分比计算 下标0:FadeMode.FixedSpeed //2.参数根据事件计算 下标1:FadeMode.FixedDuration //3.好像是不会创建的新的状态 下标2:FadeMode.FromStart 动画的层层说明：基本和Animator使用方法一致； AnimancerLayer类API说明 重要成员变量： //1.层级下标 layer.Index //2.层级叠加模式还是覆盖模式 layer.IsAdditive //3.层权重 layer.Weight 重要成员方法： //1.设置骨骼蒙版 layer.SetMask(AvatarMask) //2.设置层权重 layer.SetWeight(float) 动画混合树混合树说明：基本和Animator使用方法一致； 混合树使用： //混合类类型说明 1.ManualMixerState：没有参数 2.LinearMixerState：float参数，线性插值算法 3.CartesianMixerState：Vector参数，梯度波段O(n2)插值算法 4.DirectionalMixerState：Vector参数，极地梯度波段O(n2)插值算法 //案例 public sealed class LinearMixerExample : MonoBehaviour { private AnimancerComponent _Animancer; private AnimationClip _back; private AnimationClip _forward; private AnimationClip _left; private AnimationClip _right; private float _MovementSpeed; public CartesianMixerState mixState; private void Awake() { mixState = new CartesianMixerState(); //初始化混合动画 mixState.Initialize(_back, _forward，_left，_right); //设置动画参数 mixState.SetThreshold(0, new Vector2(0, 0)); mixState.SetThreshold(1,new Vector2(0,-1)); mixState.SetThreshold(2, new Vector2(0, 1)); mixState.SetThreshold(3, new Vector2(-1, 0)); mixState.SetThreshold(4, new Vector2(1, 0)); //设置混合动画的同步，同步适用于移动，但对于空闲动画，通常应禁用同步 MixerState.AutoSynchronizeChildren = false; mixer.DontSynchronizeChildren(); mixer.DontSynchronize(mixer.GetChild(0)); mixer.Synchronize(mixer.GetChild(1)); //播放 _Animancer.Play(mixState); } private void Update() { var input = new Vector2( Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\")); mixState.Parameter = Vector2.MoveTowards( mixState.Parameter, input, _MovementSpeed * Time.deltaTime); } } Animancer事件事件说明：基本和Animator使用方法一致，但是性能更好，且使用Clip文件使用时，每次都会创建垃圾，除非您缓存事件回调，而ClipTransition访问它将直接引用ClipTransition拥有的，因此当您再次播放时，您所做的任何修改都将保留。这意味着修改通常只应在启动时执行一次，而不是每次播放时都重复进行； 用法说明： //1.添加事件 state.Events.Add(0.4f, 事件); //2.结束事件，结束一定会调用 state.Events.OnEnd = 事件; Animancer搭配推荐","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Animancer","slug":"Animancer","permalink":"https://wwy.wwywy.com/tags/Animancer/"},{"name":"Playable","slug":"Playable","permalink":"https://wwy.wwywy.com/tags/Playable/"}]},{"title":"ET6.0框架笔记","slug":"04001-ET6.0框架笔记","date":"2022-01-24T13:00:00.000Z","updated":"2022-03-03T08:03:32.624Z","comments":true,"path":"posts/2049.html","link":"","permalink":"https://wwy.wwywy.com/posts/2049.html","excerpt":"","text":"ET6.0框架介绍项目的初步运行1.运行Unity客户端项目，并且打开编程软件进行初步编译；2.打开服务端项目，第一次打开编译Client下的Mono文件夹；3.重新编译整个解决方案；4.客户端F5生成代码； ET前后端通讯机制登录实例：1.通过NetKcpComponent组件创建Session会话连接；2.Session（由ET框架管理）会话的Id和TChannel进行绑定；3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器； ET的多线程和分布式第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构 登录实例（接上）：1.网关负载均衡服务器随机分配网关配置；2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；4.游戏客户端和游戏网关建立正式连接；5.登录进Map服务器注意：C就是客户端，R是网关负载均衡服务器，G是网关； ET的ECS组件编程ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）； 遵守的编程原则：1.实体即组件、组件即实体；2.编写一个实体或者组件，绝不继承除Entity外的任何父类；3.不使用任何虚函数，使用逻辑分发替代；4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误； 其他原则：1.系统命名必须是实体名+System；2.系统必须是静态类；3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件； //1.实体或者组件 public class Computer: Entity,IAwake,IUpdate,IDestroy public class MouseComponent : Entity, IAwake //2.系统 public static class ComputerSystem { //需要使用拓展方法 public static void Start(this Computer self) { Log.Debug(\"计算机启动\"); //这里可以调用身上的组件 self.GetComponent&lt;PCCaseComponent&gt;().StartPower(); self.GetComponent&lt;MonitorsComponent&gt;().DisPlay(); } } //3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上 Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;(); computer.AddComponent&lt;PCCaseComponent&gt;(); computer.AddComponent&lt;MonitorsComponent&gt;(); computer.AddComponent&lt;KeyBoardComponent&gt;(); computer.AddComponent&lt;MouseComponent&gt;(); computer.Start(); ET中ECS编程的生命周期 ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。 //1.生命周期函数类 public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt; public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt; public class ComputerDestroySystem : DestroySystem&lt;Computer&gt; ET的逻辑分发OOP面向对象的缺点：继承层次过深时，牵一发而动全身； ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承； ET的Scene层级树Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id； 客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）: 服务端Scene的层级关系: 服务端机器人Scene的层级关系 ET的Excel配置工具Excel配置工具注意事项：1.配置文件从第三行第三列开始写，跟VBA宏有关；2.第一个类型字段名必须是Id；3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；4.加#是注释，仅给策划使用，不会添加到游戏数据中；5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\\Assets\\Bundles\\Config下；可以查看文本形式在Bin\\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；7.行是可以空行的，可以用来分类注释，目测加#；8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；9.配置工具支持的导表类型可以在Tools\\Apps\\EXcelExporter文件下的Convert静态类中定义或查看；10.数组类型默认在配置文件中加英文,配置; //1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型 //获取单个 UnitConfig config = UnitConfigCategory.Instance.Get(1001) //获取所有 var configs = UnitConfigCategory.Instance.GetAll() ET中的事件系统1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意； //1.定义事件，添加事件,必须EventType命名空间下进行定义 public struct InstallComputer { //定义参数 public Computer computer; } //2.调用事件，触发事件 //同步Publish Game.EventSystem.Publish(new EventType.InstallComputer() { computer = computer }); //同步PublishAnycs await Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }); //异步PublishAnycs Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine(); //3.编写事件触发逻辑 public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt; { //必须添加async protected async override ETTask Run(InstallComputer arg) { Computer computer = arg.computer; computer.AddComponent&lt;PCCaseComponent&gt;(); computer.AddComponent&lt;MonitorsComponent&gt;(); computer.AddComponent&lt;KeyBoardComponent&gt;(); computer.AddComponent&lt;MouseComponent&gt;(); await ETTask.CompletedTask; } } ET中的ETTask异步编程同步操作：先完成其全部工作在返回调用者；异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码; 1.ETTask函数编写 //无返回值,参数类型用来控制取消异步函数 public async ETTask TestAsync(ETCancellationToken cancellationToken) { //表明该函数可能是同步函数 await ETTask.CompletedTask; //第二参数同上 bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken); //根据返回值控制 if (rt) Log.Debug(\"函数取消了\"); else Log.Debug(\"继续执行下面逻辑\"); } //有返回值 public async ETTask&lt;int&gt; TestResultAsync() { await TimerComponent.Instance.WaitAsync(1000); return 10; } 2.ETTask函数的调用 //定义取消异步函数实例 ETCancellationToken cancellationToken=new ETCancellationToken(); //等待无返回值函数调用完成 await TestAsync(cancellationToken); //不等待无返回值函数完成，执行下面逻辑 TestAsync(cancellationToken).Coroutine(); //等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题 int value = await TestResultAsync(); //取消函数 cancellationToken.Cancel(); ET中的Protobuf通讯消息Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；Protobuf的Github开源地址 :GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式 ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\\Apps\\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版; .proto描叙文件编写的的注意事项：1.Proto数据结构描叙文件存放在Proto文件夹下；2.OuterMessage是定义客户端和服务端通信的消息；3.InnerMessage是服务端内部通信的消息；4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；6.消息定义体中的Id不能重复；7.生成的转换类型列表可以在Tools\\Apps\\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\\Generate\\Message下；8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；9.字符之间必须要留空格；10.proto文件中的注释意义重大； 网络Handler消息编写注意事项1.类名定义务必以消息类名+Handler作为声明2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与； ET普通网络消息编写普通消息.proto文件编写： // ResponseType R2C_LoginTest（普通请求消息一定要注释返回类） message C2R_LoginTest // IRequest（普通请求消息必须注释） { int32 RpcId = 90;（普通请求消息必须声明该字段） string Account = 1; string Password = 2; } message R2C_LoginTest // IResponse（普通响应消息必须注释） { int32 RpcId = 90;（普通响应消息必须声明该字段） int32 Error = 91; string Message = 92; string GateAddress = 1; string Key = 2; } message C2R_SayHello // IMessage（一般消息必须注释） { string Hello = 1; } 普通消息C#代码： //1.客户端编写登录逻辑 public static async ETTask LoginTest(Scene zoneScene, string address) { try { Session session = null; R2C_LoginTest r2C_LoginTest = null; try { session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address)); { r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = \"123\", Password = \"456\" }); Log.Debug(r2C_LoginTest.Key); session.Send(new C2R_SayHello() { Hello = \"你好\" }); } } finally { session?.Dispose(); } } catch(Exception e) { Log.Error(e.ToString()); } } //2.普通请求消息逻辑 [MessageHandler] public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt; { protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply) { response.Key = \"110\"; reply(); await ETTask.CompletedTask; } } //3.一般消息（不用响应） [MessageHandler] public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt; { protected override async ETTask Run(Session session, C2R_SayHello message) { Log.Debug(message.Hello); await ETTask.CompletedTask; } } ET中的Actor通信模型Actor模型： Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。 ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理； ActorLocation消息Proto文件编写: //ResponseType M2C_TestActorLocationResponse message C2M_TestActorLocationReqeust // IActorLocationRequest { int32 RpcId = 90; string Content = 1; } message M2C_TestActorLocationResponse // IActorLocationResponse { int32 RpcId = 90; int32 Error = 91; string Message = 92; string Content = 1; } message C2M_TestActorLocationMessage // IActorLocationMessage { int32 RpcId = 90; string Content = 1; } ActorLocation消息C#代码编写: 1.客户端场景切换逻辑 try { Session session = zoneScene.GetComponent&lt;Session&gt;(); var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = \"111\" }); Log.Debug(message.Content); session.Send(new C2M_TestActorLocationMessage() { Content = \"22222\" }); } catch (Exception e) { Log.Error(e); } 2.ActorLocation请求消息逻辑 [ActorMessageHandler] public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt; { protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply) { Log.Debug(request.Content); response.Content = \"333333\"; reply(); await ETTask.CompletedTask; } } 3.ActorLocation一般消息逻辑 [ActorMessageHandler] public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt; { protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message) { Log.Debug(message.Content); //MessageHelper.SendToClient(entity, 发送给客户端的消息); await ETTask.CompletedTask; } } ET教程登录实例实例步骤：1.编写账号登录请求和响应俩条协议Proto；2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）; 事后心得：1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"ET","slug":"ET","permalink":"https://wwy.wwywy.com/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"计算机操作系统原理笔记","slug":"01001-计算机操作系统","date":"2022-01-08T13:00:00.000Z","updated":"2022-03-03T09:51:20.704Z","comments":true,"path":"posts/513.html","link":"","permalink":"https://wwy.wwywy.com/posts/513.html","excerpt":"","text":"1 操作系统绪论1.1 操作系统概念定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。 特征：并发、共享、虚拟、异步。 1.2 操作系统发展历程手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。 1.2.1单道批处理原理：计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。 特征：内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。 1.2.2多道批处理原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。 特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。 1.2.3分时系统特征：多路性、独立性、及时性、交互性。 1.2.4实时系统特征：多路性、独立性、及时性、交互性、可靠性。 2 操作系统用户界面2.1 作业定义：分用户和系统角度去理解 a) 用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业； b) 系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL) 2.2 一般用户输入输出方式2.2.1联机输入输出方式2.2.2脱机输入输出方式2.2.3直接耦合方式2.2.4Spooling系统原理：todo。 特点：系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。 2.2.5网络联机方式2.3 系统调用定义：系统调用是操作系统留给编程人员的唯一接口。 原理：todo 2.3.1系统调用指令int和trap指令进行系统调用。 call和jmp指令进入普通过程调用(子调用)。 3 进程管理3.1 进程的概念组成：进程=程序+数据+进程控制块(进程状态信息PCB) 定义：进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 目的：对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性； 优缺点：引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。 3.2 进程和程序的区别a) 进程是动态的，程序是静态的； b) 进程是暂时的，程序是永久的； c) 组成不同，进程的组成包括程序； d) 对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序； e) 进程可以并行，具有独立性、异步性。 f) 进程是竞争计算机资源的基本单位。 3.3 进程控制块(PCB)进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。 3.3.1描述信息3.3.2控制信息3.3.3资源管理信息3.3.4CPU保护现场结构3.4 进程上下文切换原因：进程中断、超时、进程调用。 步骤： a) 保存被切换进程的正文部分到有关存储区。 b) 进程有关调度和资源分配程序执行，选取新的进程。 c) 新进程正文部分从存储区取出，激活选中进程执行。 3.5 进程的状态和进程转换3.5.1进程状态初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止)) 3.5.2进程状态转换3.6 进程控制3.6.1进程创建和撤销3.6.2进程阻塞和唤醒3.6.3进程的挂起和激活3.7 进程互斥和同步3.7.1临界区和临界资源临界资源是一次仅允许一个进程使用的共享资源。 临界区是每个进程访问临界资源的那段代码。 3.7.2信号量和PV原语信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。 信号量的数值仅能由P、V原语操作改变。 3.7.3互斥的概念定义：不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。 3.7.4同步的概念定义：对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。 3.8 进程通信Todo 3.9 死锁问题3.9.1死锁的概念定义： 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。 起因：并发进程的资源竞争 条件：同时具备互斥条件、不剥夺条件、部分分配、环路条件。 3.9.2死锁的解决方案3.9.2.1 死锁预防3.9.2.2 死锁避免最具代表性的避免算法-银行家算法 3.9.2.3 死锁的检测和恢复3.10 线程3.10.1 线程的基本概念定义：引入线程后，线程是操作系统调度和分配的基本单位。 组成：线程=？+线程控制块(TCB) 3.10.2 线程状态和线程控制块(TCB)线程状态：执行状态、就绪状态、阻塞(等待)状态 线程控制块数据结构包括： a) 线程标识符 b) 一组寄存器 c) 线程执行状态 d) 优先级 e) 线程专有存储区 f) 信号屏蔽 g) 堆栈指针 3.10.3 线程和进程的区别从以下六点讨论 a) 调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。 b) 并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。 c) 拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。 d) 独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。 e) 系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。 f) 支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。 4 处理机调度4.1 调度层级一个作业提交后，往往会经历三种层级（加线程四种） 4.1.1作业调度又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。 4.1.1.1 周转时间相关周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间 平均周转时间=所有作业周转时间之和/总作业数 带权周转时间=作业周转时间/作业执行时间 平均带权周转时间=所有带权作业周转时间之和/总作业数 4.1.1.2 响应时间，截止时间和系统吞吐量响应时间是提交请求和返回该请求的响应之间使用的时间截止时间是某任务必须开始执行或者必须完成的最迟时间吞吐量是对单位时间内完成的工作量的量度 4.1.2交换调度又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存 4.1.3进程调度又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式 4.1.3.1 非抢占方式一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。 4.1.3.2 抢占方式系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程 a) 优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU b) 短作业优先原则：就绪的短进程有权抢占长进程的CPU c) 时间片原则：一个时间片用完后，系统重新进行进程调度 4.1.4线程调度Todo 4.2 作业和进程的关系系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。 4.3 调度算法宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。 ​ 微观调度：轮转法、优先级法、多级反馈轮转法。 5 存储管理5.1 存储器结构由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。 5.1.1寄存器寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。 5.1.2高速缓存它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。 5.1.3主存输器简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。 5.1.4磁盘缓存目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。 5.2 程序的处理阶段主要有编译，链接，装入，下面主要讲链接和装入。 5.2.1程序的链接源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。链接又可分为静态链接，装入时动态链接，运行时动态链接。 5.2.2程序的装入分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。 5.3 地址变换5.3.1静态地址重定向原理：Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。 5.3.2动态地址重定位关系：MA(物理地址)=BR(基址地址)+VR(虚拟地址)。 原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。 5.4 分区存储管理分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。 5.4.1固态分区法原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。 优点:易于实现，开销小。 缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。 5.4.2动态分区法原理：动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。 优点：没有内碎片； 缺点：有外碎片； 算法：根据情况有以下俩种，着重介绍三种 a) 基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法 b) 基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法 5.4.2.2 最先适应法5.4.2.3 最佳适应法5.4.2.4 最坏适应法5.4.3页式管理（离散分配）基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。 5.4.3.1 静态页式管理原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。 5.4.3.2 动态页式管理5.4.4段式和段页式管理基本思想：todo 5.4.4.1 段式管理原理：todo 5.4.4.2 段页式管理原理：todo 5.4.5覆盖和交换技术5.5 虚拟存输器5.5.1虚拟存储的实现方式虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式： 5.5.1.1 分页请求系统在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。 硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上 5.5.1.2 请求分段系统在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页” 5.5.2页面置换算法5.5.2.1 随机淘汰算法随机地选择某个用户地页面并将其换出。 5.5.2.2 最佳置换算法（理想型淘汰算法OPT）其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。 5.5.2.3 先进先出置换算法（FIFO）总是先淘汰最先进入内存的页面。 5.5.2.4 最近最久未使用算法（LRU）选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。 5.5.2.5 最少使用置换算法（LFU）在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。 5.5.2.6 Clock置换算法是一种LRU算法每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面； 6 文件系统6.1 文件系统基本概念目的：文件系统地出现是为了更好地管理软件资源 文件系统的定义：操作系统中与管理文件有关的软件和数据称为文件系统 文件的定义：文件时一段程序和数据的集合 文件的分类：按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。 6.2 文件的逻辑结构和存取方式6.2.1逻辑结构字符流的无结构文件：管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。 记录式的有结构文件：把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。 6.2.1.1 连续结构6.2.1.2 多重结构6.2.1.3 转置结构6.2.1.4 顺序结构6.2.2逻辑存储方法6.2.2.1 顺序存输方法6.2.2.2 随机存输方法6.2.2.3 按关键字存输方法多用于复杂文件系统。 6.2.3逻辑搜索方式文件的获取是要找到文件内容所在的逻辑地址 6.2.3.1 线性搜索法6.2.3.2 散列法6.2.3.3 二分搜索法6.3 文件的物理结构和存储设备6.3.1文件物理结构6.3.1.1 连续文件连续文件采用连续分配方式： 特点：为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。优点：顺序访问容易; 顺序访问速度快;缺点：要求有连续的存储空间; 必须事先知道文件的长度; 6.3.1.2 串联文件串联文件采用链接分配 特点：文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；优点：没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。缺点：存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间; 6.3.1.3 索引文件索引文件采用索引分配 特点：每个文件都有自己的索引块，这是一个磁盘块地址的数组。 6.3.2文件存储设备存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。 6.3.2.1 顺序存取存储设备—磁带特点：只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。 影响因素：信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。 6.3.2.2 直接存取存储设备—磁盘6.4 文件存储空间管理文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。 6.4.1空闲目录管理6.4.2空闲链块法6.4.3位示图6.5 文件目录管理从文件管理角度看，一个文件包括文件说明和文件体。 6.5.1文件目录的种类6.5.1.1 单级文件目录在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。 6.5.1.2 两级文件目录目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB； 6.5.1.3 树形结构目录多级目录结构又称为树型目录结构；主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点； 6.5.2文件目录的共享从系统管理的方式来看，有三种方法可以实现文件共享 6.5.2.1 绕道法6.5.2.2 链接法6.5.2.3 基本文件目录表（BFD）6.5.3目录管理文件目录管理应该存放在磁盘，其他的没理解todo 6.6 文件存取控制用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。 6.6.1存取控制矩阵6.6.2存取控制表6.6.3口令方式6.6.4密码方式密码方式是保密性最好的验证方式。 7 设备管理7.1 设备的分类在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。 7.2 数据传输控制方式设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。 7.2.1程序直接控制方式由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。 7.2.2中断方式I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。 7.2.3DMA方式在外围设备和内存之间开辟直接的数据交换通道。 7.2.4通道控制方式以内存为中心，实现设备和内存直接交换数据的控制的方式。 7.3 中断技术原理：中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。 过程：判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点 7.3.1中断技术的分类中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。 7.3.1.1 外中断一般是来自处理机和内存外部的中断 7.3.1.2 内中断（陷阱）一般是来自处理机和内存内部的中断 7.3.1.3 软中断是通信进程之间模拟硬中断的一种信号通信方式 7.4 缓冲技术目的：缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。 分类：缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。 7.4.1缓冲池的结构缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。 7.4.2缓冲池管理Todo","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"计算机操作系统","slug":"大学知识/CS基础/计算机操作系统","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Unity进阶-FairyGUI","slug":"03006-Unity进阶-FairyGUI ","date":"2021-12-12T13:00:00.000Z","updated":"2022-03-03T10:08:03.433Z","comments":true,"path":"posts/1542.html","link":"","permalink":"https://wwy.wwywy.com/posts/1542.html","excerpt":"","text":"FairyGUI概叙FairyGUI基础FairyGUI基本元件FairyGUI控件普通文本字体处理富文本输入文本组控制器关联系统标签按钮单选和多选框进度条滑动条滚动条滚动容器列表下拉框Unity中的使用必备组件拓展类分辨率自适应坐标系统输入处理事件机制拖拽相关插入其他对象DrawCall优化FairyGUI进阶分支多国语言树窗口弹出功能曲面UI动效其他功能","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"FairyGUI","slug":"FairyGUI","permalink":"https://wwy.wwywy.com/tags/FairyGUI/"}]},{"title":"Unity相关-Excel工具","slug":"03052-Unity相关-Excel工具","date":"2021-11-16T13:00:00.000Z","updated":"2022-03-11T15:44:05.920Z","comments":true,"path":"posts/1578.html","link":"","permalink":"https://wwy.wwywy.com/posts/1578.html","excerpt":"","text":"Excel介绍1.Excel的本质：Excel表本质上也是一堆数据，只不过它有自己的存储读取规则，如果我们想要通过代码读取它，那么必须知道它的存储规则，官网是专门提供了对应的DLL文件用来解析Excel文件的； 2.获取Excel数据信息的意义： 可以根据表中数据来动态的生成相关数据，如数据结构类、容器类、二进制数据类； 转成二进制数据也可以提升读取效率，提升数据安全性； Excel官方工具使用//主要知识点： //1.FileStream读取文件流 //2.IExcelDataReader类，从流中读取Excel数据 //3.DataSet 数据集合类 将Excel数据转存进其中方便读取 //4.DataTable 数据表类 表示Excel文件中的一个表 //5.DataRow 数据行类 表示某张表中的一行数据 [MenuItem(\"GameTool/读取Excel里的具体信息\")] private static void ReadExcel() { using (FileStream fs = File.Open(Application.dataPath + \"/ArtRes/Excel/PlayerInfo.xlsx\", FileMode.Open, FileAccess.Read)) { IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs); DataSet result = excelReader.AsDataSet(); for (int i = 0; i &lt; result.Tables.Count; i++) { //得到其中一张表的具体数据 DataTable table = result.Tables[i]; Debug.Log(\"表名：\" + result.Tables[i].TableName); Debug.Log(\"行数：\" + result.Tables[i].Rows.Count); Debug.Log(\"列数：\" + result.Tables[i].Columns.Count); //得到其中一行的数据 DataRow row = table.Rows[0]; //得到行中某一列的信息 Debug.Log(row[1].ToString()); DataRow row; for (int j = 0; j &lt; table.Rows.Count; j++) { //得到每一行的信息 row = table.Rows[j]; Debug.Log(\"*********新的一行************\"); for (int k = 0; k &lt; table.Columns.Count; k++) { //得到每一列的信息 Debug.Log(row[k].ToString()); } } } fs.Close(); } } 制定规则1.Excel读取规则： 数据类型生成要知道字段名，容器（一般字典）要知道主键，二进制要知道从哪行哪列开始； 第一行是字段名，第二行是数据类型，第三行容器可以再加一个key表示主键（也可以默认第一列），第四行是中文解释（给策划写的，不会生成进去）； 下方的表名作为生成的类型名； Excel工具编写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Excel","slug":"Excel","permalink":"https://wwy.wwywy.com/tags/Excel/"}]},{"title":"Lua语言","slug":"02500-Lua语言","date":"2021-10-28T13:00:00.000Z","updated":"2022-03-09T02:19:36.223Z","comments":true,"path":"posts/1344.html","link":"","permalink":"https://wwy.wwywy.com/posts/1344.html","excerpt":"","text":"模板","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"编程语言/Lua","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://wwy.wwywy.com/tags/Lua/"}]},{"title":"Unity进阶-基于Lua的热更新解决方案","slug":"03041-Unity进阶-Lua逻辑热更新解决方案","date":"2021-10-28T13:00:00.000Z","updated":"2022-03-09T02:18:17.213Z","comments":true,"path":"posts/1569.html","link":"","permalink":"https://wwy.wwywy.com/posts/1569.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"https://wwy.wwywy.com/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://wwy.wwywy.com/tags/AssetBundle/"}]},{"title":"游戏同步方案","slug":"04201-游戏同步方案","date":"2021-10-12T13:00:00.000Z","updated":"2022-03-07T11:57:52.054Z","comments":true,"path":"posts/2177.html","link":"","permalink":"https://wwy.wwywy.com/posts/2177.html","excerpt":"","text":"帧同步方案","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"同步技术","slug":"Game-Play/同步技术","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"}]},{"title":"Markdown语法格式（.md后缀-使用typora）","slug":"00001-Markdown语法格式","date":"2021-09-28T13:00:00.000Z","updated":"2022-03-11T14:59:00.379Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://wwy.wwywy.com/posts/1.html","excerpt":"","text":"Markdown基本语法格式标题：#标题1 （大） ##标题2 ###标题3 ####标题4 （小） 以此类推 最高标题6 代码块：​```代码块名称(可以输入各种语言java、c++、html等) 加粗：//加粗 **加粗** //代码高亮显示 ==高亮== //删除线 ~~删除线~~ //斜体 *斜体内容* 引用：//引用语法 &gt;作者：泽 &gt;&gt;作者：泽 &gt;&gt;&gt;作者：泽 分割线：//分割线 --- *** 图片插入：//在线图片与本地图片 ![照片名子]（/image/me.png） 超链接：//超链接语法 [超链接名字]（https://gihub.com/yerenping） 列表：//无需列表 - 目录1 -后加空格 - 目录2 - 目录3 //有序列表 1+. +名称 表格：右键》插入》表格 用代码过于复杂不推荐使用 用 Markdown 写数学公式Markdown 是很优秀的标记语言，目前很多平台都带 $\\TeX$ 公式引擎（XTeX, Mathjax 等）的 Markdown 编辑器。文章介绍使用 Typora 客户端做公式笔记，主要为多行公式的 $\\TeX$ 语法和公式识别两个问题。 Markdown 的用法本文不再赘述了，直接讲一下公式的问题： 行内公式和简单单行公式行内公式： 系统状态方程 $\\dot{x}=Ax$ 的解为 $x=e^Ax(0)$ 渲染效果： 系统状态方程 $\\dot{x}=Ax$ 的解为 $x=e^Ax(0)$ 简单行间公式： 系统状态方程 $\\dot{x}=Ax$ 的解为 $$ x=e^Ax(0) $$ 渲染效果： 系统状态方程 $\\dot{x}=Ax$ 的解为$$x=e^Ax(0)$$Remark： 在 Typora 中，公式功能需要自行开启 在 Typora 中，默认是无编号，需要自行开启 多行公式简单多行公式用法：用两个$$ 嵌套，或者使用 \\begin{equation}\\end{equation} 示例： $$ f_1(x)\\\\ % 使用 \\\\ 换行 f_2(x)\\label{Multi1} % 设置 label 是为了方便引用 $$ $$ \\begin{equation} f_1(x)\\\\ f_2(x)\\notag % \\notag 取消编号 \\end{equation} $$ 渲染效果$$f_1(x)\\f_2(x)\\label{Multi1}$$ $$\\begin{equation}f_1(x)\\f_2(x)\\notag\\end{equation}$$ Remark: 设置 label 可以很方便的引用公式，使用 \\eqref{} 引用 \\notag 可以取消编号，相应的，\\tag{} 可以设置任意的标注内容 array 环境array 环境用于简单的多行公式，比式 $\\eqref{Multi1}$ 多了一个对对齐选项 用法：\\begin{array}{l}\\end{array}，l 为对齐方式。left, right, center 示例： $$ \\begin{equation} \\dot{\\boldsymbol{x}}=f(\\boldsymbol{x}) =\\left\\{ \\begin{array}{ll} % 对齐选项有l/c/r(对应左中右)，需要几列就写几个 f_{1}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{1} \\\\ f_{2}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{2} % &amp; 分列，\\\\ 分行 \\end{array}\\right. \\end{equation} $$ 渲染效果：$$\\begin{equation}\\dot{\\boldsymbol{x}}=f(\\boldsymbol{x})=\\left{ \\begin{array}{ll} f_{1}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{1} \\ f_{2}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{2} \\end{array}\\right.\\end{equation}$$Remark: \\left\\{ 和 \\right. 用于自适应括号大小，只需要单边括号时，另一侧括号用 . 代替 大括号在 $\\LaTeX$ 中用作参数括号，需要加转义字符 \\ 使用 array 环境中需要几列就设置几列的对齐方式，使用 &amp; 分列，\\\\ 分行 \\boldsymbol{} 用于粗体数学符号 array 也用于矩阵输入，但矩阵现多使用 matrix 环境 aligned 环境aligned 环境用于需要设置对齐点的多行公式 用法：\\begin{aligned}\\end{ailgned} 示例： $$ \\begin{equation} \\begin{aligned} &amp;\\dot{\\boldsymbol{x}}=A \\boldsymbol{x}+B \\boldsymbol{u}, \\quad \\boldsymbol{x}(0)=\\boldsymbol{x}_{0}\\\\ % 使用 &amp; 设置对齐点，使用 \\\\ 分行 &amp;y=C x+D u \\end{aligned} \\end{equation} $$ 渲染效果：$$\\begin{equation}\\begin{aligned}&amp;\\dot{\\boldsymbol{x}}=A \\boldsymbol{x}+B \\boldsymbol{u}, \\quad \\boldsymbol{x}(0)=\\boldsymbol{x}_{0}\\&amp;y=C x+D u\\end{aligned}\\end{equation}$$Remark: aligned 需要 amsmath 宏包支持，现在大部分的引擎都会带有该宏包 \\quad 用于生成空白间距，类似的命令有：\\qquad \\, \\: \\; （正间距）\\! （负间距） 嵌套的 equation 环境是为了生成编号 在 $\\LaTeX$ 中aligned 是无法单独使用的，必须嵌套在 equation 环境中，在很多其他基于 $TeX$ 的引擎中，都默认省去了 equation 环境，任何行间公式都是当做 equaiton 环境处理，所以会出现 aligned 能够单独使用的情况，但是在需要编号的时候，aligned 是无法自动生成编号的，这是可以嵌套一个 equation 环境来生成编号 简单宏定义宏定义能够实现自定义算符、简化过于冗长的命令 自定义命令用法：\\newcommand\\定义命令[参数个数]{内容}（内容中用 #1, #2, #3 … 来设置形参） 自定义算符用法：\\DeclareMathOperator{\\定义命令}{算符} 示例： $$ \\newcommand{\\bx}{\\boldsymbol{x}} \\notag \\DeclareMathOperator{\\sign}{sign} $$ 渲染效果：$\\sign{x},\\bx$ (\\sign{x},\\bx) Remark: 声明需在文章最开头设置 在 Typora 中，如果公式渲染异常，可以再编辑中找到刷新公式 公式识别问题[Mathpix][] 提供 $\\LaTeX$ 公式识别，准确度很高，每月 50 次免费，推荐注册可以获得 50-200 次额外次数，API 可以获得没有 1000 次，日常使用是足够了。 参考文档文章简单介绍了几个多行公式的实现，这里再贴出几个文档，以飨读者： MathJax参考文档：http://docs.mathjax.org/en/latest/ LaTeX参考文档：http://www.ctan.org/pkg/lshort-zh-cn","categories":[{"name":"其他","slug":"其他","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://wwy.wwywy.com/tags/Markdown/"}]},{"title":"Unity进阶-Editor","slug":"03030-Unity进阶-Editor","date":"2021-07-09T13:00:00.000Z","updated":"2022-03-11T14:52:41.392Z","comments":true,"path":"posts/1560.html","link":"","permalink":"https://wwy.wwywy.com/posts/1560.html","excerpt":"","text":"Editor文件夹1.Editor介绍：以下介绍 Editor文件夹可以放在项目的任何文件夹下，可以有多个； 放在其中的内容，项目打包时不会被打包到项目中； 一般编辑器相关代码都可以放在该文件夹中； 要想访问Editor的代码，必须也放在该文件夹下； 添加菜单栏1.编辑器菜单栏添加新的选项入口 //可以通过Unity提供我们的MenuItem特性在菜单栏添加选项按钮 //特性名：MenuItem //命名空间：UnityEditor //规则一：一定是静态方法 //规则二：我们这个菜单栏按钮 必须有至少一个斜杠 不然会报错 它不支持只有一个菜单栏入口 //规则三：这个特性可以用在任意的类当中 [MenuItem(\"GameTool/Test\")] private static void Test() 2.刷新Project窗口内容 //类名：AssetDatabase //命名空间：UnityEditor //方法：Refresh Directory.CreateDirectory(Application.dataPath + \"/测试文件夹\"); AssetDatabase.Refresh(); 3.Editor文件夹","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"UnityEditor","slug":"游戏引擎/Unity/UnityEditor","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"UnityEditor","slug":"UnityEditor","permalink":"https://wwy.wwywy.com/tags/UnityEditor/"}]},{"title":"常用排序算法","slug":"01041-常用排序算法","date":"2021-06-30T13:00:00.000Z","updated":"2022-03-06T01:20:16.945Z","comments":true,"path":"posts/545.html","link":"","permalink":"https://wwy.wwywy.com/posts/545.html","excerpt":"","text":"列举一些常用的排序算法 #冒泡排序 /// &lt;summary&gt; /// 冒泡排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void BubbleSort(int[] array, int count) { //设置标识符，如果为false意为当前数组为有序，不需要再排序了 bool shouldSorted = true; for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++) { shouldSorted = false; for (int j = count - 1; j &gt; i; j--) { if (array[j - 1] &gt; array[j]) { shouldSorted = true; Utilities.Swap(ref array[j - 1], ref array[j]); } } } } #选择排序 /// &lt;summary&gt; /// 选择排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void SelectSort(int[] array, int count) { int min; for (int i = 0; i &lt; count - 1; i++) { min = i; for (int j = i + 1; j &lt; count; j++) { if (array[min] &gt; array[j]) { min = j; } } if (min != i) { Utilities.Swap(ref array[min], ref array[i]); } } } #插入排序 /// &lt;summary&gt; /// 插入排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void InserSort(int[] array, int count) { int guard; //哨兵，用于暂存需要交换的值 for (int i = 0; i &lt; count - 1; i++) { if (array[i] &gt; array[i + 1]) { guard = array[i + 1]; int j; for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--) { array[j + 1] = array[j]; //赋值操作（依次后移） } array[j + 1] = guard; } } } #希尔排序 /// &lt;summary&gt; /// 希尔排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void ShellSort(int[] array, int count) { int i, j, guard; int increment = count; do { increment = increment / 3 + 1; //增量序列 for (i = increment + 1; i &lt; count; i++) { if (array[i] &lt; array[i - increment]) { guard = array[i]; //暂存在哨兵处 for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment) { array[j + increment] = array[j]; //记录后移，查找插入位置 } array[j + increment] = guard; //插入 } } } while (increment &gt; 1); } #堆排序 /// &lt;summary&gt; /// 堆排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void HeapSort(int[] array, int count) { for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆 { HeapAdjust(array, i, count - 1); } for (int i = count - 1; i &gt; 0; i--) { Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换 HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆 } } /// &lt;summary&gt; /// 堆排序_构造大顶堆函数 /// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义 /// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"startIndex\"&gt;起始位置&lt;/param&gt; /// &lt;param name=\"endIndex\"&gt;结束位置&lt;/param&gt; public static void HeapAdjust(int[] array, int startIndex, int endIndex) { int temp; temp = array[startIndex]; for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选 { if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1]) { ++i; //i为关键字中较大记录的下标 } if (temp &gt; array[i]) { break; //rc应插入在位置s上 } array[startIndex] = array[i]; startIndex = i; } array[startIndex] = temp; //插入 } #归并排序 /// &lt;summary&gt; /// 归并排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void MergeSort(int[] array, int count) { int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果 int k = 1; while (k &lt; count) { MergePass(array, tempArray, k, count); //array归并到tempArray k = 2 * k; //子序列长度加倍 MergePass(tempArray, array, k, count); //tempArray归并到array k = 2 * k; //子序列长度加倍 } } /// &lt;summary&gt; /// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"srChildLength\"&gt;SR中子序列长度&lt;/param&gt; /// &lt;param name=\"arrayLength\"&gt;原数组长度&lt;/param&gt; public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength) { int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数 while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, hasMergeCount + 2 * srChildLength - 2); //两两归并 hasMergeCount += 2 * srChildLength; } if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1); } else //若最后只剩下单个子序列 { for (int j = hasMergeCount - 1; j &lt; arrayLength; j++) { tr[j] = sr[j]; } } } /// &lt;summary&gt; /// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"sr1StartIndex\"&gt;SR数组子序列1起始位置&lt;/param&gt; /// &lt;param name=\"sr1EndIndex\"&gt;SR数组子序列1结束位置&lt;/param&gt; /// &lt;param name=\"sr2EndIndex\"&gt;SR数组子序列2结束位置&lt;/param&gt; private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex) { int sr2StartIndex, currentProcess; //currentProcess为当前进度 for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex; sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex; currentProcess++) //两个SR有一个被榨干后就要退出循环 { if (sr[sr1StartIndex] &lt; sr[sr2StartIndex]) { tr[currentProcess] = sr[sr1StartIndex++]; } else { tr[currentProcess] = sr[sr2StartIndex++]; } } if (sr1StartIndex &lt;= sr1EndIndex) { for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++) { tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR } } if (sr2StartIndex &lt;= sr2EndIndex) { for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++) { tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR } } } #快速排序 /// &lt;summary&gt; /// 快速排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void QuickSort(int[] array, int count) { QSort(array, 0, count - 1); } /// &lt;summary&gt; /// 快速排序_递归调用 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; private static void QSort(int[] array, int low, int high) { int pivot; while (low &lt; high) { pivot = Partition(array, low, high); QSort(array, low, pivot - 1); //尾递归，可以减少一次递归堆栈深度 low = pivot + 1; } } /// &lt;summary&gt; /// 获取枢轴数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static int Partition(int[] array, int low, int high) { int pivotkey; int m = low + (high - low) / 2; //下面是三数取中优化 //交换左端与右端数据，保证左端较小 if (array[low] &gt; array[high]) { Utilities.Swap(ref array[low],ref array[high]); } //交换中间与右端数据，保证中间较小 if (array[m] &gt; array[high]) { Utilities.Swap(ref array[m],ref array[high]); } //交换中间与左端数据，保证左端较小 if (array[m] &gt; array[low]) { Utilities.Swap(ref array[low],ref array[m]); } //默认选取当前数组的第一个值作为枢轴值 pivotkey = array[low]; //枢轴备份 int pivotkeyback = pivotkey; while (low &lt; high) { while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey) { high--; } array[low] = array[high]; while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey) { low++; } array[high] = array[low]; } //将枢轴数值替换回array[low] array[low] = pivotkeyback; //返回当前枢轴下标 return low; } #各种排序时空复杂度n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"大学知识/CS基础/数据结构和算法","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"游戏MVC系列框架","slug":"04003-游戏MVC系列框架","date":"2020-12-15T13:00:00.000Z","updated":"2022-03-03T08:04:38.446Z","comments":true,"path":"posts/2051.html","link":"","permalink":"https://wwy.wwywy.com/posts/2051.html","excerpt":"","text":"MVC基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑; 流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据; 总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架； 不使用MVC的逻辑： public class PlayerLevPanel : MonoBehaviour { public Button btnLevUp; public Button btnClose; //展示UI面板 public static void ShowMe() { //todo } //隐藏UI面板 public static void HideMe() { //todo } void Start() { //2.监听事件 btnClose.onClick.AddListener(ClickClose); btnLevUp.onClick.AddListener(ClickLevUp); } public void ClickClose() { Debug.Log(\"关闭\"); HideMe(); } public void ClickLevUp() { Debug.Log(\"升级\"); //存储数据 //同步更新面板上的数据 UpdateInfo(); //更新主面板的内容 MainPanel.Panel.UpdateInfo(); } //3.更新面板 public void UpdateInfo() { //更新数据 } } 不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发； 使用MVC：Model层：负责增删查改获取界面上需要的数据 public class PlayerLevModel{ //定义数据 private int lev; //外界只能获取字段 public int Lev { get { return lev; } } //通知外部更新的事件 //通过它和外部建立联系 而不是直接获取外部的面板 private event UnityAction&lt;PlayerLevModel&gt; updateEvent; //在外部第一次获取这个数据 如何获取 //通过单例模式 来达到数据的唯一性 和数据的获取 private static PlayerLevModel data = null; public static PlayerLevModel Data { get { if( data == null ) { data = new PlayerLevModel(); data.Init(); } return data; } } //数据相关的操作 // 初始化 public void Init() { lev = PlayerPrefs.GetInt(\"PlayerLev\", 1); } } public void LevUp() { //升级 改变内容 lev += 1; //改变过后保存 SaveData(); } public void SaveData() { //把这些数据内容 存储到本地 PlayerPrefs.SetInt(\"PlayerLev\", lev); UpdateInfo(); } public void AddEventListener(UnityAction&lt;PlayerModel&gt; function) { updateEvent += function; } public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function) { updateEvent -= function; } //通知外部更新外部数据的方法 private void UpdateInfo() { //找到对应的 使用数据的脚本 去更新数据 updateEvent?Invoke(this); } 视图层：负责获取控件，更新控件信息 public class PlayerLevView : MonoBehaviour{ //1.找控件 public Button btnClose; public Button btnLevUp; //2.提供面板更新的相关方法给外部 public void UpdateInfo(PlayerModel data) { txtLev.text = \"LV.\" + data.Lev; } } 控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新） public class PlayerLevController : MonoBehaviour{ //视图实例，这里视图和控制在一个物体上 private PlayerLevView roleView; private static PlayerLevController controller = null; //控制层单例 public static PlayerLevController Controller { get { return controller; } } public static void ShowMe() { if (controller == null) { //实例化面板对象 //设置它的父对象 为Canvas } //如果是隐藏的形式hide 在这要显示 controller.gameObject.SetActive(true); } public static void HideMe() { if (controller != null) { //方式一 直接删 //方式二 设置可见为隐藏 } } void Start() { //这里视图和控制在一个物体上 roleView = this.GetComponent&lt;RoleView&gt;(); //第一次更新面板 roleView.UpdateInfo(PlayerLevModel.Data); roleView.btnClose.onClick.AddListener(ClickCloseBtn); roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn); //告知数据模块 当更新时 通知哪个函数做处理 PlayerModel.Data.AddEventListener(UpdateInfo); } private void ClickCloseBtn() { HideMe(); } private void ClickLevUpBtn() { //通过数据模块 进行升级 达到数据改变 PlayerLevModel.Data.LevUp(); } private void UpdateInfo( PlayerModel data ) { if( roleView != null ) { roleView.UpdateInfo(data); } } private void OnDestroy() { PlayerLevModel.Data.RemoveEventListener(UpdateInfo); } } 好处：1.各司其职，互不干涉 —— 编程思路更清晰2.有利开发中的分工 —— 多人协同开发时，同步并行3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率缺点：1.增加了程序文件的体量 —— 脚本由一变三2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大） MV*的概念MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变； 所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。 MVP 切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部. Model层:不变 View层:不能直接传入Model模型来更新 Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入； MVVM（MP） MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细； 了解的话可以看看这些第三方MVVM框架：loxodon-Framework:vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)uMVVM:MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com) 所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心； MVE E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可； 商业框架PureMVC官网：PureMVC 框架PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；Model（数据模型）：关联Proxy(代理)对象，负责处理数据；View（界面）：关联Mediator(中介)对象，负责处理界面；Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；Notification：通知，负责传递信息；","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"MVC","slug":"MVC","permalink":"https://wwy.wwywy.com/tags/MVC/"}]},{"title":"游戏程序基础框架","slug":"04002-游戏程序基础框架","date":"2020-11-20T13:00:00.000Z","updated":"2022-02-19T13:48:55.810Z","comments":true,"path":"posts/2050.html","link":"","permalink":"https://wwy.wwywy.com/posts/2050.html","excerpt":"","text":"单例管理者基类不继承自Mono1.利用单例模式和泛形去实现模块管理者基类； public class SingletonBase&lt;T&gt; where T:new() { private static T instance; public static T GetInstance() { if (instance == null) instance = new T(); return instance; } } 继承自Mono1.直接实例化通过生成游戏对象并且附加脚本；2.Awake实例化的话要保证单例的唯一性； public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour { private static T instance; public static T GetInstance() { if (instance == null) { GameObject go = new GameObject { name = typeof(T).Name, }; instance = go.AddComponent&lt;T&gt;(); DontDestroyOnLoad(go); } return instance; } protected virtual void Awake() { if (instance == null) { instance = this as T; DontDestroyOnLoad(gameObject); } } } 事件管理者1.观察者模式，利用了泛形和委托（事件）2.这里的事件字典只能对付小游戏，大型游戏仍是不够 public interface IEventInfo { } public class EventInfo : IEventInfo { public event UnityAction actions; public EventInfo(UnityAction action) { actions += action; } public void EventTrigger() { actions?.Invoke(); } } public class EventInfo&lt;T&gt; : IEventInfo { public event UnityAction&lt;T&gt; actions; public EventInfo(UnityAction&lt;T&gt; action) { actions += action; } public void EventTrigger(T Info) { actions?.Invoke(Info); } } public class EventMgr : SingletonBase&lt;EventMgr&gt; { //暂时只定义一个字典进行储存，小游戏够用了 private Dictionary&lt;string, IEventInfo&gt; eventDic = new Dictionary&lt;string, IEventInfo&gt;(); public void AddListenter(string name,UnityAction action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions += action; else eventDic.Add(name,new EventInfo(action)); } public void AddListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions += action; else eventDic.Add(name, new EventInfo&lt;T&gt;(action)); } public void RemoveListenter(string name, UnityAction action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions -= action; } public void RemoveListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions -= action; } public void EventTrigger(string name) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).EventTrigger(); } public void EventTrigger&lt;T&gt;(string name,T info) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).EventTrigger(info); } public void Clear() { eventDic.Clear(); } } Mono根节点1.可以创建一个全局唯一的Mono节点使用2.实现游戏入口继承自该节点即可，但是实现Awake单例 public class MonoRoot : SingletonMono&lt;MonoRoot&gt; { private event UnityAction updateActions; protected override void Awake() { base.Awake(); } protected virtual void Update() { updateActions?.Invoke(); } public void AddUpdateListenter(UnityAction updateAction) { updateActions += updateAction; } public void RemoveUpdateListenter(UnityAction updateAction) { updateActions -= updateAction; } } 资源加载管理者1.资源加载有同步加载和异步加载，异步加载用协程实现2.资源加载管理者包括场景切换，以及配置文件加载 public class ResMgr : SingletonBase&lt;ResMgr&gt; { #region 资源加载 private Dictionary&lt;string,Object&gt; ObjCacheDic=new Dictionary&lt;string, Object&gt;(); public T LoadObj&lt;T&gt;(string path , bool isIns=true , bool isCache= true ) where T : Object { T obj; if (ObjCacheDic.TryGetValue(path, out Object cacheObj)) obj = cacheObj as T; else { obj = Resources.Load&lt;T&gt;(path); if (isCache) ObjCacheDic.Add(path, obj); }; if (obj is GameObject &amp;&amp; isIns) return GameObject.Instantiate(obj); else return obj; } public void LoadObjAsyn&lt;T&gt;(string path,UnityAction&lt;T&gt; callback, bool isIns = true, bool isCache = true) where T : Object { if (ObjCacheDic.TryGetValue(path, out Object obj)) { if (obj is GameObject &amp;&amp; isIns) callback(GameObject.Instantiate(obj) as T); else callback(obj as T); } else MonoRoot.GetInstance().StartCoroutine(ReallyLoadObjAsyn(path, callback, isIns, isCache)); } public IEnumerator ReallyLoadObjAsyn&lt;T&gt;(string path, UnityAction&lt;T&gt; callback, bool isIns, bool isCache) where T : Object { ResourceRequest r = Resources.LoadAsync&lt;T&gt;(path); yield return r; if(isCache) ObjCacheDic.Add(path, r.asset); if (r.asset is GameObject &amp;&amp; isIns) callback(GameObject.Instantiate(r.asset) as T); else callback(r.asset as T); } #endregion #region 场景切换 public void LoadScene(string name, UnityAction fun) { //场景同步加载 SceneManager.LoadScene(name); //加载完成过后 才会去执行fun fun(); } public void LoadSceneAsyn(string name, UnityAction fun) { MonoRoot.GetInstance().StartCoroutine(ReallyLoadSceneAsyn(name, fun)); } public IEnumerator ReallyLoadSceneAsyn(string name, UnityAction fun) { AsyncOperation op = SceneManager.LoadSceneAsync(name); while (!op.isDone) { //这里可以去做一些事情，例如更新进度条 //EventMgr.GetInstance().EventTrigger(\"更新进度条\", op.progress); yield return op.progress; } //加载完成过后 才会去执行fun fun(); } #endregion } 缓存池管理者1.用一个类类型去包装缓存队列，这个类里面应该封装了获取和设置缓存对象的方法2.缓存池目前只支持预制物的缓存 public class PoolMgr :SingletonBase&lt;PoolMgr&gt; { private Dictionary&lt;string, PoolData&gt; poolDic=new Dictionary&lt;string, PoolData&gt;(); private GameObject poolRoot; public void GetObj(string name, UnityAction&lt;GameObject&gt; callBack) { if(poolDic.TryGetValue(name, out PoolData poolData) &amp;&amp; poolData.Count &gt; 0) { callBack(poolData.GetObj()); } else { //创建资源应使用资源路径 ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(name, (go) =&gt;{ go.name = name; callBack(go); }); } } public void PushObj(string name,GameObject obj) { if(poolRoot=null)poolRoot=new GameObject(\"PoolRoot\"); if(poolDic.TryGetValue(name,out PoolData poolData)) poolData.PushObj(obj); else poolDic.Add(name, new PoolData(obj,poolRoot)); } public void Clear() { poolDic.Clear(); poolRoot = null; } } public class PoolData { private GameObject parentRoot; private Queue&lt;GameObject&gt; objQue; public PoolData(GameObject obj,GameObject poolObj) { parentRoot = new GameObject($\"{obj.name}Root\"); parentRoot.transform.parent = poolObj.transform; objQue = new Queue&lt;GameObject&gt;(); } public int Count { get { return objQue.Count; } } public void PushObj(GameObject obj) { //存起来 objQue.Enqueue(obj); //失活 让其隐藏 obj.SetActive(false); //设置父对象 obj.transform.parent = parentRoot.transform; } public GameObject GetObj() { //取出第一个 GameObject obj = objQue.Dequeue(); //激活 让其显示 obj.SetActive(true); //断开了父子关系 obj.transform.parent = null; return obj; } } 输入管理者1.输入管理者耦合事件监听和Mono根节点 public class InputMgr : SingletonBase&lt;InputMgr&gt; { private bool isStart = false; public InputMgr() { MonoMgr.GetInstance().AddUpdateListener(UpdateIpt); } public void StartOrEndCheck(bool isOpen) { isStart = isOpen; } private void CheckKeyCode(KeyCode key) { //事件中心模块 分发按下抬起事件 if (Input.GetKeyDown(key)) EventCenter.GetInstance().EventTrigger(\"某键按下\", key); //事件中心模块 分发按下抬起事件 if (Input.GetKeyUp(key)) EventCenter.GetInstance().EventTrigger(\"某键抬起\", key); } private void UpdateIpt() { //没有开启输入检测 就不去检测 直接return if (!isStart) return; CheckKeyCode(KeyCode.W); CheckKeyCode(KeyCode.S); CheckKeyCode(KeyCode.A); CheckKeyCode(KeyCode.D); } } 音效管理者1.一般音效资源应该做缓存池处理 public class MusicMgr : MonoBehaviour { private bool isMute = false; //背景音乐源 private AudioSource bkSource; //背景音乐大小 private float bkValue = 1; //一般音乐列表 private List&lt;AudioSource&gt; sourceLst = new List&lt;AudioSource&gt;(); //背景音乐大小 private float soundValue = 1; //音乐源节点 private GameObject musicRoot; public MusicMgr() { MonoMgr.GetInstance().AddUpdateListener(UpdateMsc); } //音乐播放完就回收 private void UpdateMsc() { for (int i = sourceLst.Count - 1; i &gt;= 0; --i) { if (!sourceLst[i].isPlaying) { GameObject.Destroy(sourceLst[i]); sourceLst.RemoveAt(i); } } } public void PlayBkMusic(string name) { if(!musicRoot) musicRoot=new GameObject(\"MusicRoot\"); if (bkSource) bkSource = musicRoot.AddComponent&lt;AudioSource&gt;(); //异步加载背景音乐 加载完成后 播放 ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;(\"Music/BK/\" + name, (clip) =&gt; { bkSource.clip = clip; bkSource.loop = true; bkSource.volume = bkValue; bkSource.Play(); }); } public void PauseBKMusic() { bkSource?.Pause(); } public void StopBKMusic() { bkSource?.Stop(); } public void ChangeBKValue(float v) { bkValue = v; if (bkSource == null) bkSource.volume = bkValue; } public void PlaySound(string name, bool isLoop=false, GameObject parent=null, UnityAction&lt;AudioSource&gt; callBack = null) { if (!musicRoot) musicRoot = new GameObject(\"MusicRoot\"); //当音效资源异步加载结束后 再添加一个音效 ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;(\"Music/Sound/\" + name, (clip) =&gt; { AudioSource source; if (parent) source=parent.AddComponent&lt;AudioSource&gt;(); else source = musicRoot.AddComponent&lt;AudioSource&gt;(); source.clip = clip; source.loop = isLoop; source.volume = soundValue; source.Play(); sourceLst.Add(source); if (callBack != null) callBack(source); }); } public void ChangeSoundValue(float value) { soundValue = value; for (int i = 0; i &lt; sourceLst.Count; ++i) sourceLst[i].volume = value; } public void StopSound(AudioSource source) { if (sourceLst.Contains(source)) { sourceLst.Remove(source); source.Stop(); GameObject.Destroy(source); } } } UI管理者和UI面板基类面板基类public class BasePanel : MonoBehaviour { //通过里式转换原则 来存储所有的控件 private Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt; controlDic = new Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt;(); protected virtual void Awake() { FindChildrenControl&lt;Button&gt;(); FindChildrenControl&lt;Image&gt;(); FindChildrenControl&lt;Text&gt;(); FindChildrenControl&lt;Toggle&gt;(); FindChildrenControl&lt;Slider&gt;(); FindChildrenControl&lt;ScrollRect&gt;(); FindChildrenControl&lt;InputField&gt;(); } public virtual void ShowMe() { } public virtual void HideMe() { } protected virtual void OnClick(string btnName) { } protected virtual void OnValueChanged(string toggleName, bool value) { } protected T GetControl&lt;T&gt;(string controlName) where T : UIBehaviour { if (controlDic.ContainsKey(controlName)) { for (int i = 0; i &lt; controlDic[controlName].Count; ++i) { if (controlDic[controlName][i] is T) return controlDic[controlName][i] as T; } } return null; } private void FindChildrenControl&lt;T&gt;() where T : UIBehaviour { T[] controls = this.GetComponentsInChildren&lt;T&gt;(); for (int i = 0; i &lt; controls.Length; ++i) { string objName = controls[i].gameObject.name; if (controlDic.ContainsKey(objName)) controlDic[objName].Add(controls[i]); else controlDic.Add(objName, new List&lt;UIBehaviour&gt;() { controls[i] }); //如果是按钮控件 if (controls[i] is Button) { (controls[i] as Button).onClick.AddListener(() =&gt; { OnClick(objName); }); } //如果是单选框或者多选框 else if (controls[i] is Toggle) { (controls[i] as Toggle).onValueChanged.AddListener((value) =&gt; { OnValueChanged(objName, value); }); } } } } UI管理者public class UIMgr : SingletonBase&lt;UIMgr&gt; { public Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;(); private Transform bot; private Transform mid; private Transform top; private Transform system; //记录我们UI的Canvas父对象 方便以后外部可能会使用它 public RectTransform canvas; public UIMgr() { //创建Canvas 让其过场景的时候 不被移除 GameObject obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;(\"UI/Canvas\"); canvas = obj.transform as RectTransform; GameObject.DontDestroyOnLoad(obj); //找到各层 bot = canvas.Find(\"Bot\"); mid = canvas.Find(\"Mid\"); top = canvas.Find(\"Top\"); system = canvas.Find(\"System\"); //创建EventSystem 让其过场景的时候 不被移除 obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;(\"UI/EventSystem\"); GameObject.DontDestroyOnLoad(obj); } /// &lt;summary&gt; /// 通过层级枚举 得到对应层级的父对象 /// &lt;/summary&gt; /// &lt;param name=\"layer\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Transform GetLayerFather(EUIayer layer) { switch (layer) { case EUIayer.Bot: return this.bot; case EUIayer.Mid: return this.mid; case EUIayer.Top: return this.top; case EUIayer.System: return this.system; } return null; } /// &lt;summary&gt; /// 显示面板 /// &lt;/summary&gt; /// &lt;typeparam name=\"T\"&gt;面板脚本类型&lt;/typeparam&gt; /// &lt;param name=\"panelName\"&gt;面板名&lt;/param&gt; /// &lt;param name=\"layer\"&gt;显示在哪一层&lt;/param&gt; /// &lt;param name=\"callBack\"&gt;当面板预设体创建成功后 你想做的事&lt;/param&gt; public void ShowPanel&lt;T&gt;(string panelName, EUIayer layer = EUIayer.Mid, UnityAction&lt;T&gt; callBack = null) where T : BasePanel { if (panelDic.ContainsKey(panelName)) { panelDic[panelName].ShowMe(); // 处理面板创建完成后的逻辑 if (callBack != null) callBack(panelDic[panelName] as T); //避免面板重复加载 如果存在该面板 即直接显示 调用回调函数后 直接return 不再处理后面的异步加载逻辑 return; } ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(\"UI/\" + panelName, (obj) =&gt; { //把他作为 Canvas的子对象 //并且 要设置它的相对位置 //找到父对象 你到底显示在哪一层 Transform father = bot; switch (layer) { case EUIayer.Mid: father = mid; break; case EUIayer.Top: father = top; break; case EUIayer.System: father = system; break; } //设置父对象 设置相对位置和大小 obj.transform.SetParent(father); obj.transform.localPosition = Vector3.zero; obj.transform.localScale = Vector3.one; (obj.transform as RectTransform).offsetMax = Vector2.zero; (obj.transform as RectTransform).offsetMin = Vector2.zero; //得到预设体身上的面板脚本 T panel = obj.GetComponent&lt;T&gt;(); // 处理面板创建完成后的逻辑 if (callBack != null) callBack(panel); panel.ShowMe(); //把面板存起来 panelDic.Add(panelName, panel); }); } /// &lt;summary&gt; /// 隐藏面板 /// &lt;/summary&gt; /// &lt;param name=\"panelName\"&gt;&lt;/param&gt; public void HidePanel(string panelName) { if (panelDic.ContainsKey(panelName)) { panelDic[panelName].HideMe(); GameObject.Destroy(panelDic[panelName].gameObject); panelDic.Remove(panelName); } } /// &lt;summary&gt; /// 得到某一个已经显示的面板 方便外部使用 /// &lt;/summary&gt; public T GetPanel&lt;T&gt;(string name) where T : BasePanel { if (panelDic.ContainsKey(name)) return panelDic[name] as T; return null; } /// &lt;summary&gt; /// 给控件添加自定义事件监听 /// &lt;/summary&gt; /// &lt;param name=\"control\"&gt;控件对象&lt;/param&gt; /// &lt;param name=\"type\"&gt;事件类型&lt;/param&gt; /// &lt;param name=\"callBack\"&gt;事件的响应函数&lt;/param&gt; public static void AddCustomEventListener(UIBehaviour control, EventTriggerType type, UnityAction&lt;BaseEventData&gt; callBack) { EventTrigger trigger = control.GetComponent&lt;EventTrigger&gt;(); if (trigger == null) trigger = control.gameObject.AddComponent&lt;EventTrigger&gt;(); EventTrigger.Entry entry = new EventTrigger.Entry(); entry.eventID = type; entry.callback.AddListener(callBack); trigger.triggers.Add(entry); } } /// &lt;summary&gt; /// UI层级 /// &lt;/summary&gt; public enum EUIayer { Bot, Mid, Top, System, }","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"Unity进阶-数据持久化PlayerPrefs","slug":"03007-Unity进阶-数据持久化PlayerPrefs","date":"2020-05-24T13:00:00.000Z","updated":"2022-03-09T02:22:25.055Z","comments":true,"path":"posts/1543.html","link":"","permalink":"https://wwy.wwywy.com/posts/1543.html","excerpt":"","text":"概述1.数据持久化定义：数据持久化就是将内存中的数据模型和硬盘中的存储模型相互转换的过程； 2.PlayerPrefs是Unity的内置API; 基本知识点基本方法1.存储相关 //PlayerPrefs的数据存储 类似于键值对存储 一个键对应一个值 //提供了存储3种数据的方法 int float string //键: string类型 //值：int float string 对应3种API PlayerPrefs.SetInt(\"myAge\", 18); PlayerPrefs.SetFloat(\"myHeight\", 177.5f); PlayerPrefs.SetString(\"myName\", \"唐老狮\"); //直接调用Set相关方法 只会把数据存到内存里 //当游戏结束时 Unity会自动把数据存到硬盘中 //如果游戏不是正常结束的 而是崩溃 数据是不会存到硬盘中的 //只要调用该方法 就会马上存储到硬盘中 PlayerPrefs.Save(); //PlayerPrefs是有局限性的 它只能存3种类型的数据 //如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储 bool sex = true; PlayerPrefs.SetInt(\"sex\", sex ? 1 : 0); //如果不同类型用同一键名进行存储 会进行覆盖 PlayerPrefs.SetFloat(\"myAge\", 20.2f); 2.读取相关 //注意 运行时 只要你Set了对应键值对 //即使你没有马上存储Save在本地 //也能够读取出信息 //int int age = PlayerPrefs.GetInt(\"myAge\"); print(age); //前提是 如果找不到myAge对应的值 就会返回函数的第二个参数 默认值 age = PlayerPrefs.GetInt(\"myAge\", 100); print(age); //float float height = PlayerPrefs.GetFloat(\"myHeight\", 1000f); print(height); //string string name = PlayerPrefs.GetString(\"myName\"); print(name); //第二个参数 默认值 对于我们的作用 //就是 在得到没有的数据的时候 就可以用它来进行基础数据的初始化 //判断数据是否存在 if( PlayerPrefs.HasKey(\"myName\") ) { print(\"存在myName对应的键值对数据\"); } 3.删除数据 //删除指定键值对 PlayerPrefs.DeleteKey(\"myAge\"); //删除所有存储的信息 PlayerPrefs.DeleteAll(); 存储位置1.PlayerPrefabs各个平台存储位置： Windos存储位置：注册路径：HKEY_Current_User/Software/Unity/[公司名称]/[产品名称]； Android：/data/data/包名/shared_prefs/pkg_name.xml； IOS：/Library/Preferences/[应用ID].plist； 2.PlayerPrefabs中数据的唯一性：储存键值对，数据具有唯一性，要保证数据不丢失要建立一个保证唯一键的规则；","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"https://wwy.wwywy.com/tags/PlayerPrefs/"}]},{"title":"Unity进阶-数据持久化二进制","slug":"03010-Unity进阶-数据持久化二进制","date":"2020-05-24T13:00:00.000Z","updated":"2022-03-11T14:43:06.583Z","comments":true,"path":"posts/1544.html","link":"","permalink":"https://wwy.wwywy.com/posts/1544.html","excerpt":"","text":"概述1.二进制说明：2进制是计算技术中广泛采用的一种数制。2进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”；计算机中存储的数据本质上都是2进制数的存储，在计算机中位（bit）是最小的存储单位，1位就是一个0或者一个1； 2.XML和Json的缺点：xml和json安全性和效率较低，如下分析 清晰易懂是他们的共同好处，但是也是一把双刃剑，比如如果我们用xml或者json存储数据，只要玩家找到对应的存储信息， 就能够快速修改其中的内容； 而且由于他们把数据转换成了对应的xml或者json字符串，我们最终在存储数据时存储的都是字符串数据，在读写时效率较低，内存和硬盘空间占用较大； 3.二进制数据持久化的优点： 安全性较高； 效率较高； 网络通信铺垫； 基础知识各类型转字节数组1.二进制读写的本质 //它就是通过将各类型变量转换为字节数组 //将字节数组直接存储到文件中 //一般人是看不懂存储的数据的 //不仅可以节约存储空间，提升效率 //还可以提升安全性 //而且在网络通信中我们直接传输的数据也是字节数据（2进制数据） 2.各类型数据和字节数据相互转换 //C#提供了一个公共类帮助我们进行转化 //我们只需要记住API即可 //类名：BitConverter //命名空间：using System //1.将各类型转字节 byte[] bytes = BitConverter.GetBytes(256); //2.字节数组转各类型 int i = BitConverter.ToInt32(bytes, 0); 3.字符串类型和字节数据相互转换 // 在C#中有一个专门的编码格式类 来帮助我们将字符串和字节数组进行转换 // 类名：Encoding // 需要引用命名空间：using System.Text; //1.将字符串以指定编码格式转字节 byte[] bytes2 = Encoding.UTF8.GetBytes(\"唐老狮\"); //2.字节数组以指定编码格式转字符串 string s = Encoding.UTF8.GetString(bytes2); 4.标准编码格式 //编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。 //为保证编码的正确性，编码要规范化、标准化，即需有标准的编码格式。 //常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF - 8、GB18030和UNICODE等。 // 说人话 // 计算机中数据的本质就是2进制数据 // 编码格式就是用对应的2进制数 对应不同的文字 // 由于世界上有各种不同的语言，所有会有很多种不同的编码格式 // 不同的编码格式 对应的规则是不同的 // 如果在读取字符时采用了不统一的编码格式，可能会出现乱码 // 游戏开发中常用编码格式 UTF-8 // 中文相关编码格式 GBK // 英文相关编码格式 ASCII 文件操作相关——文件1.文件操作相关说明 //在电脑上我们可以在操作系统中创建删除修改文件 //可以增删查改各种各样的文件类型 //代码中的文件操作就是通过代码来做这些事情 //C#提供了一个名为File（文件）的公共类 //让我们可以快捷的通过代码操作文件相关 //类名：File //命名空间： System.IO 2.文件操作File类的常用内容 //1.判断文件是否存在 if(File.Exists(Application.dataPath + \"/UnityTeach.tang\")) //2.创建文件 FileStream fs = File.Create(Application.dataPath + \"/UnityTeach.tang\"); //3.写入文件 //将指定字节数组 写入到指定路径的文件中 byte[] bytes = BitConverter.GetBytes(999); File.WriteAllBytes(Application.dataPath + \"/UnityTeach.tang\", bytes); //将指定的string数组内容 一行行写入到指定路径中 string[] strs = new string[] { \"123\", \"唐老狮\", \"123123kdjfsalk\", \"123123123125243\"}; File.WriteAllLines(Application.dataPath + \"/UnityTeach2.tang\", strs); //将指定字符串写入指定路径 File.WriteAllText(Application.dataPath + \"/UnityTeach3.tang\", \"唐老狮哈\\n哈哈哈哈123123131231241234123\"); //4.读取文件 //读取字节数据 bytes = File.ReadAllBytes(Application.dataPath + \"/UnityTeach.tang\"); print(BitConverter.ToInt32(bytes, 0)); //读取所有行信息 strs = File.ReadAllLines(Application.dataPath + \"/UnityTeach2.tang\"); for (int i = 0; i &lt; strs.Length; i++) { print(strs[i]); } //读取所有文本信息 print(File.ReadAllText(Application.dataPath + \"/UnityTeach3.tang\")); //5.删除文件 //注意 如果删除打开着的文件 会报错 File.Delete(Application.dataPath + \"/UnityTeach.tang\"); //6.复制文件 //参数一：现有文件 需要是流关闭状态 //参数二：目标文件 //参数三：是否覆盖 File.Copy(Application.dataPath + \"/UnityTeach2.tang\", Application.dataPath + \"/唐老狮.tanglaoshi\", true); //7.文件替换 //参数一：用来替换的路径 //参数二：被替换的路径 //参数三：备份路径 File.Replace(Application.dataPath + \"/UnityTeach3.tang\", Application.dataPath + \"/唐老狮.tanglaoshi\", Application.dataPath + \"/唐老狮备份.tanglaoshi\"); //8.以流的形式 打开文件并写入或读取 //参数一：路径 //参数二：打开模式 //参数三：访问模式 FileStream fs = File.Open(Application.dataPath + \"/UnityTeach2.tang\", FileMode.OpenOrCreate, FileAccess.ReadWrite); 文件操作相关——文件流1.什么是文件流 //在C#中提供了一个文件流类 FileStream类 //需要引用命名空间：System.IO //它主要作用是用于读写文件的细节 //我们之前学过的File只能整体读写文件 //而FileStream可以以读写字节的形式处理文件 //说人话： //文件里面存储的数据就像是一条数据流（数组或者列表） //我们可以通过FileStream一部分一部分的读写数据流 //比如我可以先存一个int（4个字节）再存一个bool（1个字节）再存一个string（n个字节） //利用FileStream可以以流式逐个读写 2. FileStream文件流类常用方法 (1)打开或创建指定文件 //方法一：new FileStream //参数一：路径 //参数二：打开模式 // CreateNew:创建新文件 如果文件存在 则报错 // Create:创建文件，如果文件存在 则覆盖 // Open:打开文件，如果文件不存在 报错 // OpenOrCreate:打开或者创建文件根据实际情况操作 // Append:若存在文件，则打开并查找文件尾，或者创建一个新文件 // Truncate:打开并清空文件内容 //参数三：访问模式 //参数四：共享权限 // None 谢绝共享 // Read 允许别的程序读取当前文件 // Write 允许别的程序写入该文件 // ReadWrite 允许别的程序读写该文件 FileStream fs = new FileStream(Application.dataPath + \"/Lesson3.tang\", FileMode.Create, FileAccess.ReadWrite); //方法二：File.Create //参数一：路径 //参数二：缓存大小 //参数三：描述如何创建或覆盖该文件（不常用） // Asynchronous 可用于异步读写 // DeleteOnClose 不在使用时，自动删除 // Encrypted 加密 // None 不应用其它选项 // RandomAccess 随机访问文件 // SequentialScan 从头到尾顺序访问文件 // WriteThrough 通过中间缓存直接写入磁盘 FileStream fs2 = File.Create(Application.dataPath + \"/Lesson3.tang\"); //方法三：File.Open //参数一：路径 //参数二：打开模式 FileStream fs3 = File.Open(Application.dataPath + \"/Lesson3.tang\", FileMode.Open); (2)重要属性和方法 //文本字节长度fs.Length //是否可写fs.CanRead //是否可读fs.CanWrite //将字节写入文件 当写入后 一定执行一次 fs.Flush() //关闭流 当文件读写完毕后 一定执行fs.Close() //缓存资源销毁回收 fs.Dispose() （3）写入字节 //方法：Write //参数一：写入的字节数组 //参数二：数组中的开始索引 //参数三：写入多少个字节 fs.Write(bytes, 0, bytes.Length); (4).读取字节 a:挨个读取字节数组 //读取第一个整形 byte[] bytes2 = new byte[4]; //参数一：用于存储读取的字节数组的容器 //参数二：容器中开始的位置 //参数三：读取多少个字节装入容器 //返回值：当前流索引前进了几个位置 int index = fs2.Read(bytes2, 0, 4); int i = BitConverter.ToInt32(bytes2, 0); print(\"取出来的第一个整数\" + i);//999 print(\"索引向前移动\" + index + \"个位置\"); //读取第二个字符串 //读取字符串字节数组长度 index = fs2.Read(bytes2, 0, 4); print(\"索引向前移动\" + index + \"个位置\"); int length = BitConverter.ToInt32(bytes2, 0); //要根据我们存储的字符串字节数组的长度 来声明一个新的字节数组 用来装载读取出来的数据 bytes2 = new byte[length]; index = fs2.Read(bytes2, 0, length); print(\"索引向前移动\" + index + \"个位置\"); //得到最终的字符串 打印出来 print(Encoding.UTF8.GetString(bytes2)); fs2.Dispose(); b:一次性读取再挨个读取 //一开始就申明一个 和文件字节数组长度一样的容器 byte[] bytes3 = new byte[fs3.Length]; fs3.Read(bytes3, 0, (int)fs3.Length); fs3.Dispose(); //读取整数 print(BitConverter.ToInt32(bytes3, 0)); //得去字符串字节数组的长度 int length2 = BitConverter.ToInt32(bytes3, 4); //得到字符串 print(Encoding.UTF8.GetString(bytes3, 8, length2)); 3.更加安全的使用文件流对象 //using关键字重要用法 //using (申明一个引用对象) //{ //使用对象 //} //无论发生什么情况 当using语句块结束后 //会自动调用该对象的销毁方法 避免忘记销毁或关闭流 //using是一种更安全的使用方法 //强调：目前我们对文件流进行操作 为了文件操作安全 都用using来进行处理最好 文件操作相关——文件夹1.文件夹操作说明 //平时我们可以在操作系统的文件管理系统中 //通过一些操作增删查改文件夹 //我们目前要学习的就是通过代码的形式 //来对文件夹进行增删查改的操作 //类名:Directory //命名空间：using System.IO 2.C#提供给我们的文件夹操作公共类 //1.判断文件夹是否存在 if( Directory.Exists(Application.dataPath + \"/数据持久化\")) //2.创建文件夹 DirectoryInfo info = Directory.CreateDirectory(Application.dataPath + \"/数据持久化四\"); //3.删除文件夹 //参数一：路径 //参数二：是否删除非空目录，如果为true，将删除整个目录，如果是false，仅当该目录为空时才可删除 //Directory.Delete(Application.dataPath + \"/数据持久化四\"); //4.查找文件夹和文件 //得到指定路径下所有文件夹名 string[] strs = Directory.GetDirectories(Application.dataPath); //得到指定路径下所有文件名 strs = Directory.GetFiles(Application.dataPath); //5.移动文件夹 //如果第二个参数所在的路径 已经存在了一个文件夹 那么会报错 //移动会把文件夹中的所有内容一起移到新的路径 Directory.Move(Application.dataPath + \"/数据持久化四\", Application.dataPath + \"/123123123\"); 3.DirectoryInfo和FileInfo //DirectoryInfo目录信息类 //我们可以通过它获取文件夹的更多信息 //它主要出现在以下几个地方 //1.创建文件夹方法的返回值 DirectoryInfo dInfo = Directory.CreateDirectory(Application.dataPath + \"/数据持久化123\"); //2.查找上级文件夹信息 dInfo = Directory.GetParent(Application.dataPath + \"/数据持久化123\"); //全路径 print(dInfo.FullName); //文件名 print(dInfo.Name); //所有子文件夹的目录信息 DirectoryInfo[] dInfos = dInfo.GetDirectories(); //FileInfo文件信息类 //我们可以通过DirectoryInfo得到该文件下的所有文件信息 FileInfo[] fInfos = dInfo.GetFiles(); C#类对象的序列化和反序列化1.序列化类对象第一步—申明类对象 //注意：如果要使用C#自带的序列化2进制方法 //申明类时需要添加[System.Serializable]特性 2.序列化类对象第二步—将对象进行2进制序列化 （1）方法一：使用内存流得到2进制字节数组 //主要用于得到字节数组 可以用于网络传输 //新知识点 //1.内存流对象 //类名：MemoryStream //命名空间：System.IO //2.2进制格式化对象 //类名：BinaryFormatter //命名空间：System.Runtime.Serialization.Formatters.Binary、 //主要方法：序列化方法 Serialize using (MemoryStream ms = new MemoryStream()) { //2进制格式化程序 BinaryFormatter bf = new BinaryFormatter(); //序列化对象 生成2进制字节数组 写入到内存流当中 bf.Serialize(ms, p); //得到对象的2进制字节数组 byte[] bytes = ms.GetBuffer(); //存储字节 File.WriteAllBytes(Application.dataPath + \"/Lesson5.tang\", bytes); //关闭内存流 ms.Close(); } （2）方法二：使用文件流进行存储 //主要用于存储到文件中 using (FileStream fs = new FileStream(Application.dataPath + \"/Lesson5_2.tang\", FileMode.OpenOrCreate, FileAccess.Write)) { //2进制格式化程序 BinaryFormatter bf = new BinaryFormatter(); //序列化对象 生成2进制字节数组 写入到内存流当中 bf.Serialize(fs, p); fs.Flush(); fs.Close(); } 3.反序列化 （1）反序列化网络传输过来的2进制数据 //主要类 //MemoryStream内存流类 //BinaryFormatter 2进制格式化类 //主要方法 //Deserizlize //目前没有网络传输 我们还是直接从文件中获取 byte[] bytes = File.ReadAllBytes(Application.dataPath + \"/Lesson5_2.tang\"); //申明内存流对象 一开始就把字节数组传输进去 using (MemoryStream ms = new MemoryStream(bytes)) { //申明一个 2进制格式化类 BinaryFormatter bf = new BinaryFormatter(); //反序列化 Person p = bf.Deserialize(ms) as Person; ms.Close(); } （2）反序列化文件中数据 //主要类 //FileStream文件流类 //BinaryFormatter 2进制格式化类 //主要方法 //Deserizlize //通过文件流打开指定的2进制数据文件 using (FileStream fs = File.Open(Application.dataPath + \"/Lesson5_2.tang\", FileMode.Open, FileAccess.Read)) { //申明一个 2进制格式化类 BinaryFormatter bf = new BinaryFormatter(); //反序列化 Person p = bf.Deserialize(fs) as Person; fs.Close(); } 二进制数据加密1.加密说明：加密只能起到提升一定的安全性，通过各种尝试始终是可以破解加密规则的，只是时间问题，一定记住加密只是提高破解门槛，没有100%保密的数据； 2.常用加密算法：MD5算法、SHA1算法、HMAC算法、AES/DES/3DES算法； 1.异或加密 Person p = new Person(); byte key = 199; using (MemoryStream ms = new MemoryStream()) { BinaryFormatter bf = new BinaryFormatter(); bf.Serialize(ms, p); byte[] bytes = ms.GetBuffer(); //异或加密 for (int i = 0; i &lt; bytes.Length; i++) { bytes[i] ^= key; } File.WriteAllBytes(Application.dataPath + \"/Lesson7.tang\", bytes); } //解密 byte[] bytes2 = File.ReadAllBytes(Application.dataPath + \"/Lesson7.tang\"); for (int i = 0; i &lt; bytes2.Length; i++) { bytes2[i] ^= key; } using (MemoryStream ms = new MemoryStream(bytes2)) { BinaryFormatter bf = new BinaryFormatter(); Person p2 = bf.Deserialize(ms) as Person; ms.Close(); } 知识补充","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"二进制","slug":"二进制","permalink":"https://wwy.wwywy.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"Unity进阶-数据持久化Json","slug":"03009-Unity进阶-数据持久化Json","date":"2020-05-24T13:00:00.000Z","updated":"2022-03-11T07:38:36.682Z","comments":true,"path":"posts/03009.html","link":"","permalink":"https://wwy.wwywy.com/posts/03009.html","excerpt":"","text":"Json概述1.Json说明：Json是国际通用的一种轻量级的数据交换格式，主要在网络通讯中用于传输数据，或本地数据存储和读取，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率； 2.Json和XML的区别： 共同点： 都是纯文本； 都有层次结构； 都具有描述性； 不同点： Json配置更加简单； Json在某些情况读写更快速； Json文件格式Json配置规则 1.注释规则：和C#一模一样； 2.符号含义： 大括号{}：对象； 中括号[]：数组； 冒号:：键值对对应关系； 逗号,：数据分割； 双引号””：键名/字符串； Excel转Json的网站1.Excel转Json的网站在线Excel、CSV转JSON格式-BeJSON.com 2.自己写编辑器工具去转换 C#存取Json文件JsonUtlity1.JsonUtlity是什么？ //JsonUtlity 是Unity自带的用于解析Json的公共类 //它可以 //1.将内存中对象序列化为Json格式的字符串 //2.将Json字符串反序列化为类对象 2.必备知识点——在文件中存读字符串 //1.存储字符串到指定路径文件中 //第一个参数 填写的是 存储的路径 //第二个参数 填写的是 存储的字符串内容 //注意：第一个参数 必须是存在的文件路径 如果没有对应文件夹 会报错 File.WriteAllText(Application.persistentDataPath + \"/Test.json\", \"存储的json文件\"); print(Application.persistentDataPath); //2.在指定路径文件中读取字符串 string str = File.ReadAllText(Application.persistentDataPath + \"/Test.json\"); 3.使用JsonUtlity进行序列化 //序列化：把内存中的数据 存储到硬盘上 //方法：JsonUtility.ToJson(对象) //Jsonutility提供了现成的方法 可以把类对象 序列化为 json字符串 string jsonStr = JsonUtility.ToJson(t); File.WriteAllText(Application.persistentDataPath + \"/MrTang.json\", jsonStr); //注意： //1.float序列化时看起来会有一些误差 //2.自定义类需要加上序列化特性[System.Serializable] //3.想要序列化私有变量 需要加上特性[SerializeField] //4.JsonUtility不支持字典 //5.JsonUtlity存储null对象不会是null 而是默认值的数据 4.使用JsonUtlity进行反序列化 //反序列化：把硬盘上的数据 读取到内存中 //方法： //JsonUtility.FromJson(字符串) //读取文件中的 Json字符串 jsonStr = File.ReadAllText(Application.persistentDataPath + \"/MrTang.json\"); //使用Json字符串内容 转换成类对象 MrTang t2 = JsonUtility.FromJson(jsonStr, typeof(MrTang)) as MrTang; MrTang t3 = JsonUtility.FromJson&lt;MrTang&gt;(jsonStr); //注意： //如果Json中数据少了，读取到内存中类对象中时不会报错 5.注意事项 //1.JsonUtlity无法直接读取数据集合，要用一个类去包裹数组可以（如下图） jsonStr = File.ReadAllText(Application.streamingAssetsPath + \"/RoleInfo2.json\"); print(jsonStr); //List&lt;RoleInfo&gt; roleInfoList = JsonUtility.FromJson&lt;List&lt;RoleInfo&gt;&gt;(jsonStr); RoleData data = JsonUtility.FromJson&lt;RoleData&gt;(jsonStr); //2.文本编码格式需要时UTF-8 不然无法加载 LitJsonLitJSON下载地址(github.com) 1.LitJson是什么 //它是一个第三方库，用于处理Json的序列化和反序列化 //LitJson是C#编写的，体积小、速度快、易于使用 //它可以很容易的嵌入到我们的代码中 //只需要将LitJson代码拷贝到工程中即可 2.使用LitJson进行序列化 //方法：JsonMapper.ToJson(对象) string jsonStr = JsonMapper.ToJson(t); print(Application.persistentDataPath); File.WriteAllText(Application.persistentDataPath + \"/MrTang2.json\", jsonStr); //注意： //1.相对JsonUtlity不需要加特性 //2.不能序列化私有变量 //3.支持字典类型,字典的键 建议都是字符串 因为 Json的特点 Json中的键会加上双引号 //4.需要引用LitJson命名空间 //5.LitJson可以准确的保存null类型 3.使用LitJson反序列化 //方法：JsonMapper.ToObject(字符串) jsonStr = File.ReadAllText(Application.persistentDataPath + \"/MrTang2.json\"); //JsonData是LitJson提供的类对象 可以用键值对的形式去访问其中的内容 JsonData data = JsonMapper.ToObject(jsonStr); print(data[\"name\"]); print(data[\"age\"]); //通过泛型转换 更加的方便 建议使用这种方式 MrTang2 t2 = JsonMapper.ToObject&lt;MrTang2&gt;(jsonStr); //注意： //1.类结构需要无参构造函数，否则反序列化时报错 //2.字典虽然支持 但是键在使用为数值时会有问题 需要使用字符串类型 4.注意事项 //1.LitJson可以直接读取数据集合（记住最后不用写逗号） jsonStr = File.ReadAllText(Application.streamingAssetsPath + \"/RoleInfo.json\"); RoleInfo2[] arr = JsonMapper.ToObject&lt;RoleInfo2[]&gt;(jsonStr); List&lt;RoleInfo2&gt; list = JsonMapper.ToObject&lt;List&lt;RoleInfo2&gt;&gt;(jsonStr); jsonStr = File.ReadAllText(Application.streamingAssetsPath + \"/Dic.json\"); Dictionary&lt;string, int&gt; dicTest = JsonMapper.ToObject&lt;Dictionary&lt;string, int&gt;&gt;(jsonStr); //2.文本编码格式需要是UTF-8 不然无法加载 俩种方法对比1.JsonUtlity和LitJson相同点 //1.他们都是用于Json的序列化反序列化 //2.Json文档编码格式必须是UTF-8 //3.都是通过静态类进行方法调用 2.JsonUtlity和LitJson不同点 //1.JsonUtlity是Unity自带，LitJson是第三方需要引用命名空间 //2.JsonUtlity使用时自定义类需要加特性,LitJson不需要 //3.JsonUtlity支持私有变量(加特性),LitJson不支持 //4.JsonUtlity不支持字典,LitJson支持(但是键只能是字符串) //5.JsonUtlity不能直接将数据反序列化为数据集合(数组字典),LitJson可以 //6.JsonUtlity对自定义类不要求有无参构造，LitJson需要 //7.JsonUtlity存储空对象时会存储默认值而不是null，LitJson会存null 3.如何选择两者 //根据实际需求 //建议使用LitJson //原因：LitJson不用加特性，支持字典，支持直接反序列化为数据集合，存储null更准确","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"Json","slug":"Json","permalink":"https://wwy.wwywy.com/tags/Json/"}]},{"title":"Unity进阶-数据持久化XML","slug":"03008-Unity进阶-数据持久化XML","date":"2020-05-24T13:00:00.000Z","updated":"2022-03-11T06:10:52.994Z","comments":true,"path":"posts/03008.html","link":"","permalink":"https://wwy.wwywy.com/posts/03008.html","excerpt":"","text":"XML概述1.XML说明：可扩展标记语言，XML是国际通用的，它是用来传输和存储数据的一种文本特殊格式，后缀名一般为.xml，xml是一种树形结构； XML文件格式XML基本语法1.编码格式：不同的字符，在内存中的二进制是不一样的，每一个字符对应一个数字，不同的编码格式字符对应的二进制是不一样的，否则会出现乱码； 2.注释：； 3.固定语法：； 4.基本语法：&lt;元素标签&gt;元素内容&lt;/元素标签&gt;，多层嵌套包裹，形成树形结构，如下规则 每个元素都必须有关闭标签； 元素命名规则基本遵照C#中变量名命名规则； XML标签对大小写敏感； XML文档必须有根元素 特殊的符号应该用实体引用 &amp;lt — &lt; 小于 &amp;gt — &gt;大于 &amp;amp — &amp;和号 &amp;apos — ‘ 单引号 &amp;quot — “ 引号 XML 教程 | 菜鸟教程 (runoob.com) XML属性1.属性语法：&lt;元素标签 子元素名=”值” &gt;元素内容&lt;/元素标签&gt; or &lt;元素标签 子元素名=”值” /&gt; 2.查语法错误：可以使用专门的xml软件，也可以在菜鸟验证对错; XML 验证器 | 菜鸟教程 (runoob.com) C#中XML存取使用unit中xml文件存取位置1.只读不取：可以放在Resources或者StreamingAssets文件夹下，一般作为配置文件使用； 2.动态存储：放在Application.presistentDataPath路径下； C#读取XML1.C#读取XML的方法 //1.XmlDocument (把数据加载到内存中，方便读取) //2.XmlTextReader (以流形式加载，内存占用更少，但是是单向只读，使用不是特别方便，除非有特殊需求，否则不会使用) //3.Linq (以后专门讲Linq的时候讲) //使用XmlDocument类读取是较方便最容易理解和操作的方法 2.读取API //1.读取XML文件 //XmlDocument xml = new XmlDocument(); //读取文本方式1-xml.LoadXml(先用资源加载出来为TextAsset文件，再传入xml文本字符串) //读取文本方式2-xml.Load(传入路径) //2.读取元素和属性 //获取单个节点 : XmlNode node = xml.SelectSingleNode(节点名) //获取多个节点 : XmlNodeList nodeList = xml.SelectNodes(节点名) //获取节点元素内容：node.InnerText //获取节点元素属性： //1.item.Attributes[\"属性名\"].Value //2.item.Attributes.GetNamedItem(\"属性名\").Value //通过迭代器遍历或者循环遍历XmlNodeList对象 可以获取到各单个元素节点 C#存储XML1.Unity推荐储存 //注意：存储xml文件 在Unity中一定是使用各平台都可读可写可找到的路径 // 1.Resources 可读 不可写 打包后找不到 × // 2.Application.streamingAssetsPath 可读 PC端可写 找得到 × // 3.Application.dataPath 打包后找不到 × // 4.Application.persistentDataPath 可读可写找得到 √ 2.C#存取 //2.存储xml关键类 //XmlDocument 文件 // 创建节点 CreateElement() // 创建固定内容方法 CreateXmlDeclaration() // 添加节点 AppendChild() // 保存 Save() //XmlDeclaration 版本 //XmlElement 元素节点 // 设置属性方法SetAttribute() //3.修改 //RemoveChild()移除节点 //可以通过 /的形式 来表示 子节点的子节点","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"https://wwy.wwywy.com/tags/XML/"}]},{"title":"Unity进阶-UGUI","slug":"03005-Unity进阶-UGUI","date":"2020-01-24T13:00:00.000Z","updated":"2022-03-03T10:07:49.093Z","comments":true,"path":"posts/1541.html","link":"","permalink":"https://wwy.wwywy.com/posts/1541.html","excerpt":"","text":"六大基础组件1.Canvas对象上依附的：Canvas：画布组件，主要用于渲染UI控件Canvas Scaler：画布分辨率自适应组件，主要用于分辨率自适应Graphic Raycaster：射线事件交互组件，主要用于控制射线响应相关RectTransform：UI对象位置锚点控制组件，主要用于控制位置和对其方式 2.EventSystem对象上依附的：EventSystem和Standalone Input Module：玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作 Canvas画布组件1.Screen Space - Overlay：屏幕空间，覆盖模式，UI始终在前； Pixel Perfect：是否开启无锯齿精确渲染（性能换效果） SortOrder：排序层编号（用于控制多个Canvas时的渲染先后顺序） TargetDisplay：目标设备（在哪个显示设备上显示） Additional Shader Channels：其他着色器通道，决定着色器可以读取哪些数据 2.Screen Space - Camera(不推荐设置成主摄像机)：屏幕空间，摄像机模式，3D物体可以显示在UI之前； RenderCamera：用于渲染UI的摄像机（如果不设置将类似于覆盖模式） Plane Distance：UI平面在摄像机前方的距离，类似整体Z轴的感觉 Sorting Layer：所在排序层 Order in Layer：排序层的序号 3.World Space：世界空间，3D模式； Event Camera：用于处理UI事件的摄像机（如果不设置，不能正常注册UI事件） 画布 - Unity 手册 (unity3d.com) CanvasScaler画布缩放控制器组件 CanvasScaler意思是画布缩放控制器，它是用于分辨率自适应的组件，它主要负责在不同分辨率下UI控件大小自适应，它并不负责位置，位置由之后的RectTransform组件负责； 1.屏幕分辨率（UI画布宽高*缩放系数 = 屏幕分辨率）：当前设备的分辨率，编辑器下Game窗口中可以查看到；2.参考分辨率：在其中一种适配模式中出现的关键参数，参与分辨率自适应的计算；3.画布宽高和缩放系数：分辨率自适应会改变的参数，通过屏幕分辨率和参考分辨率计算而来；4.分辨率大小自适应：通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数，该结果会影响所有UI控件的缩放大小； 画布缩放器 (Canvas Scaler) - Unity 手册 (unity3d.com) 缩放模式 根据屏幕尺寸进行缩放，随着屏幕尺寸变化来放大缩小（游戏开发中常用）； 1.Reference Resolution：参考分辨率（美术同学出图的标准分辨率）； 缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算； 2.Screen Match Mode：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式； Expand：水平或垂直拓展画布区域，会根据宽高比的变化来放大缩小画布，可能有黑边(缩放系数 = Mathf.Min(屏幕宽/参考分辨率宽，屏幕高/参考分辨率高)); Shrink：水平或垂直裁剪画布区域，会根据宽高比的变化来放大缩小画布，可能会裁剪(缩放系数 = Mathf.Max(屏幕宽/参考分辨率宽，屏幕高/参考分辨率高)); Match Width Or Height：以宽高或者二者的平均值作为参考来缩放画布区(在取平均值之前，我们先取相对宽度和高度的对数,float logWidth = Mathf.Log(屏幕宽 / 参考分辨率宽, 2);float logHeight = Mathf.Log(屏幕高 / 参考分辨率高, 2);,在对数空间中变换是为了获得更好的性能以及更准确的结果,float logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);scaleFactor = Mathf.Pow(2, logWeightedAverage);); 恒定像素模式 无论屏幕大小如何，UI始终保持相同像素大小。 1.Scale Factor：缩放系数，按此系数缩放画布中的所有UI元素； 2.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素），图片设置中的Pixels Per Unit设置，会和该参数一起参与计算； 计算公式：UI原始尺寸 = 图片大小（像素）/ (Pixels Per Unit / Reference Pixels Per Unit） 恒定物理模式 无论屏幕大小和分辨率如何，UI元素始终保持相同物理大小（DPI：（Dots Per Inch，每英寸点数）图像每英寸长度内的像素点数）。 1.Physical Unit：物理单位，使用的物理单位种类 2.Fallback Screen DPI：备用DPI，当找不到设备DPI时，使用此值 3.Default Sprite DPI：默认图片DP 单位种类 与1英寸的关系： Centimeters（厘米cm） 2.54 Millimeters（毫米mm） 25.4 Inches（英寸） 1 Points（点） 72 Picas（皮卡） 计算公式：根据DPI算出新的Reference Pixels Per Unit （单位参考像素） 新单位参考像素 =单位参考像素 * Physical Unit / Default Sprite DPI 再使用模式一：恒定像素模式的公式进行计算 原始尺寸 =图片大小（像素）/ (Pixels Per Unit / 新单位参考像素) ##3D模式 当Canvas的渲染模式设置为，世界空间3D渲染模式时，这时Canvas Scaler 的缩放模式会强制变为，World 3D世界模式； 1.Dynamic Pixels Per Unit：UI中动态创建的位图（例如文本）中，单位像素数（类似密度） 2.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单 位为100像素） Graphic Raycaster图像射线投射器 Graphic Raycaster意思是图形射线投射器,它是用于检测UI输入事件的射线发射器,它主要负责通过射线检测玩家和UI元素的交互,判断是否点击到了UI元素; 1.Ignore Reversed Graphics：是否忽略反转图形 2.Blocking Objects：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效） 3.Blocking Mask：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效） 图形射线投射器 - Unity 手册 (unity3d.com) RectTransform RectTransform意思是矩形变换，它继承于Transform，是专门用于处理UI元素位置大小相关的组件，Transform组件只处理位置、角度、缩放，RectTransform在此基础上加入了矩形相关，将UI元素当做一个矩形来处理，加入了中心点、锚点、长宽等属性，其目的是更加方便的控制其大小以及分辨率自适应中的位置适应； 1.Pivot：轴心(中心)点，取值范围0~1 2.Anchors(相对父矩形锚点)： 3.Min是矩形锚点范围X和Y的最小值 4.Max是矩形锚点范围X和Y的最大值 取值范围都是0~1 5.Pos(X,Y,Z)：轴心点(中心点)相对锚点的位置 6.Width/Height：矩形的宽高 7.Left/Top/Right/Bottom：矩形边缘相对于锚点的位置；当锚点分离时会出现这些内容 8.Rotation：围绕轴心点旋转的角度 9.Scale：缩放大小 10.Blueprint Mode（蓝图模式）:启用后，编辑旋转和缩放不会影响矩形，只会影响显示内容 11.Raw Edit Mode（原始编辑模式）:启用后，改变轴心和锚点值不会改变矩形位置 矩形变换 - Unity 手册 (unity3d.com) EventSystem Event System意思是事件系统，它是用于管理玩家的输入事件并分发给各UI控件，它是事件逻辑处理模块，所有的UI事件都通过EventSystem组件中轮询检测并做相应的执行，它类似一个中转站，和许多模块一起共同协作，如果没有它，所有点击、拖曳等等行为都不会被响应； 1.First Selected：首先选择的游戏对象，可以设置游戏一开始的默认选择 2.Send Navigation Events：是否允许导航事件（移动/按下/取消） 3.Drag Threshold：拖拽操作的阈值（移动多少像素算拖拽） 事件系统管理器 - Unity 手册 (unity3d.com) Standalone Input Module Standalone Input Module意思是独立输入模块，它主要针对处理鼠标/键盘/控制器/触屏（新版Unity）的输入，输入的事件通过EventSystem进行分发，它依赖于EventSystem组件，他们两缺一不可； 1.Horizontal Axis：水平轴按钮对应的热键名（该名字对应Input管理器） 2.Vertical Axis：垂直轴按钮对应的热键名（该名字对应Input管理器） 3.Submit Button：提交（确定）按钮对应的热建名（该名字对应Input管理器） 4.Cancel Button：取消按钮对应的热建名（该名字对应Input管理器） 5.Input Actions Per Second：每秒允许键盘/控制器输入的数量 6.Repeat Delay：每秒输入操作重复率生效前的延迟时间 7.ForceModule Active：是否强制模块处于激活状态 独立输入模块 - Unity 手册 (unity3d.com) 三大基础控件Text 是UGUI中用于显示文本的关键组件，可以加OutLine组件和Shadow组件配合。 Text参数: Text：文本显示内容 Font：字体 FontStyle：字体样式 Normal：普通 Bold：加粗 Italic：斜体 Bold And Italic：加粗 + 斜体 Font Size：字体大小 Line Spacing：行之间的垂直间距 Rich Text：是否开启富文本 Alignment：对其方式 Align By Geometry：使用字形集合形状范围进行水平对其，而不是字形指标 Horizontal Overflow：处理文本太宽无法放入矩形范围内时的处理方式 Wrap：包裹模式-字体始终在矩形范围内，会自动换行 Overflow：溢出模式-字体可以溢出矩形框 Vertical Overflow：处理文本太高无法放入矩形范围内时的处理方式 Truncate：截断模式-字体始终在矩形范围内，超出部分裁剪 Overflow：溢出模式-字体可以溢出矩形框 Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整字体大小 MinSize：最小多小 MaxSize：最大多大 富文本: 加粗&lt;b&gt;文本内容&lt;/b&gt; 斜体&lt;i&gt;文本内容&lt;/i&gt; 大小&lt;size=50&gt;文本内容&lt;/size&gt; 颜色: &lt;color=#ff0000ff&gt;文本内容&lt;/size&gt; &lt;color=red&gt;文本内容&lt;/size&gt; 文本 (Text) - Unity 手册 (unity3d.com) Image 是UGUI中用于显示精灵图片的关键组件，除了背景图等大图，一般都使用Image来显示UI中的图片元素。Image参数 Source Image：图片来源（图片类型必须是”精灵“类型） Color：图像的颜色 Material：图像的材质（一般不修改，会使用UI的默认材质） Raycast Target：是否作为射线检测的目标（如果不勾选将不会响应射线检测） Maskable：是否能被遮罩（之后结合遮罩相关知识点进行讲解） Image Type：图片类型 Simple-普通模式，均匀缩放整个图片 Sliced-切片模式，9宫格拉伸，只拉伸中央十字区域 Pixels Per UnitMultiplier：每单位像素乘数 Fill Center：中心填充 Tiled-平铺模式，重复平铺中央部分 Filled-填充模式 Fill Method：填充方式 Fill Origin：填充原点 Fill Amount：填充量 Clockwise：顺时针方向 Use Sprite Mesh：使用精灵网格，勾选的话Unity会帮我们生成图片网格 Preserve Aspect：确保图像保持其现有尺寸 Set Native Size：设置为图片资源的原始大小 图像 (Image) - Unity 手册 (unity3d.com) RawImage 它和Image的区别是 一般RawImage用于显示大图(背景图，不需要打入图集的图片，网络下载的图等等)。 原始图像 (Raw Image) - Unity 手册 (unity3d.com) 组合控件Button按钮控件 是UGUI中用于处理玩家按钮相关交互的关键组件。参数： Interactable：是否接受输入 Transition：响应用户输入的过渡效果 None：没有状态变化效果 ColorTint：用颜色表示不同状态的变化 TargetGraphic：控制的目标图形 Normal Color：正常状态颜色 Highlighted Color：鼠标进入时显示高亮颜色 Pressed Color：按下颜色 Selected Color：选中的颜色 Disabled Color：禁用时的颜色 Color Multiplier：颜色倍增器，过渡颜色乘以该值 FadeDuration：衰减持续时间，从一个状态进入另一个状态时需要的时间 Sprite Swap：用图片表示不同状态的变化 Highlighted Sprite：鼠标进入时图片 Pressed Sprite：按下时图片 Selected Color：选中时的颜色 Disabled Sprite：禁用时显示的图片 Animation：用动画表示不同状态的变化 Normal Trigger：正常动画触发器 Highlighted Trigger：鼠标进入状态时触发器 Pressed Trigger：按下时触发器 Selected Trigger：选中时触发器 Disabled Trigger：禁用时触发器 Navigation：导航模式，可以设置UI元素如何在播放模式中控制导航 None：无键盘导航 Horizontal：水平导航 Verticval：垂直导航 Automatic：自动导航 Explicit：指定周边控件进行导航 Visualize:可以在场景窗口看到导航连线 OnClick：单击（按下再抬起）执行的函数列表(btn.onClick.AddListenter(事件);) 按钮 (Button) - Unity 手册 (unity3d.com) Toggle开关控件 是UGUI中用于处理玩家单选框多选框相关交互的关键组件，可以通过配合ToggleGroup组件制作为单选框，默认创建的Toggle由4个对象组成，父对象——Toggle组件依附，子对象——背景图（必备）、选中图（必备）、说明文字（可选）。 Toggle参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) IsOn：当前是否处于打开状态 Toggle Transition：在开关值变化时的过渡方式 None：无任何过渡，直接显示隐藏 Fade：淡入淡出 Graphic：用于表示选中状态的图片 Group：单选框分组(需要挂载Toggle Group组件) Allow Switch Off：是否允许不选中任何一个单选框（注意：单选框分组组件可以挂载在任何对象上，只需要将其和一组的单选框关联即可） OnValueChanged：开关状态变化时执行的函数列表（ tog.onValueChanged.AddListener(事件);） 开关 (Toggle) - Unity 手册 (unity3d.com) InputField文本输入控件 是UGUI中用于处理玩家文本输入相关交互的关键组件，默认创建的InputField由3个对象组成，父对象——InputField组件依附对象 以及 同时在其上挂载了一个Image作为背景图，子对象——文本显示组件（必备）、默认显示文本组件（必备）。 InputField参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) TextComponent：用于关联显示输入内容的文本组件 Text：输入框的起始默认值 Character Limit：可以输入字符长度的最大值（0默认无限） Content Type：输入的字符类型限制 Standard：标准模式；可以输入任何字符 Autocorrected：自动更正模式；跟踪未知单词，向用户建议合适的替换候选词 Integer Number：整数模式；用户只能输入整数 Decimal Number：十进制数模式；用于只能输入数字包括小数 Alphanumeric：字母数字模式；只能输入字母和数字 Name：名字模式；自动将每个单子首字母大写 Email Address：邮箱地址模式；允许最多输入一个@符号组成的字符和数字字符串 Password：密码模式；用星号隐藏输入的字符，允许使用字符 Pin：别针模式；用星号隐藏输入的字符，只允许输入整数 Custom：自定义模式；允许自定义行类型，输入类型，键盘类型和字符验证 Line Type：行类型，定义文本格式 Single Line：只允许单行显示 Multi Line Submit：允许使用多行。仅在需要时使用新的一行 Multi Line NewLine：允许使用多行。用户可以按回车键空行 Placeholder：关联用于显示初始内容文本控件 Caret Blink Rate：光标闪烁速率 Caret Width：光标宽 Custom Caret Color：自定义光标颜色 Selection Color：批量选中的背景颜色 Hide Mobile Input：隐藏移动设备屏幕上键盘，仅适用于IOS Read Only：只读，不能改 OnValueChanged：滑动条值改变时执行的函数列表 input.onValueChanged.AddListener(事件） input.onEndEdit.AddListener(事件） 输入字段 (Input Field) - Unity 手册 (unity3d.com) Slider滑动条控件 Slider是滑动条组件，默认创建的Slider由4组对象组成，父对象——Slider组件依附的对象，子对象——背景图、进度图、滑动块三组对象。 Slider参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) FillRect：用于填充的进度条图形 Handle Rect：用于滑动的滑动块图形 Direction：滑动条值增加的方向 Left To Right：从左到右 Right To Left：从右到左 Bottom To Top：从下到上 Top To Bottom：从上到下 Min Value 和 Max Value：最小值和最大值，滑动滚动条时值从最小到最大之间变化（左右、上下极值） Whole Numbers：是否约束为整数值变化 Value：当前滑动条代表的数值 OnValueChanged：滑动条值改变时执行的函数列表（ s.onValueChanged.AddListener(事件)） 滑动条 (Slider) - Unity 手册 (unity3d.com) ScrollBar滚动条控件 是UGUI中用于处理滚动条相关交互的关键组件，默认创建的Scrollbar由2组对象组成，父对象——Scrollbar组件依附的对象，子对象——滚动块对象，一般情况下我们不会单独使用滚动条 ，都是配合ScrollView滚动视图来使用。 ScrollBar参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) Handle Rect：关联滚动块图形对象 Direction：滑动条值增加的方向 Left To Right：从左到右 Right To Left：从右到左 Bottom To Top：从下到上 Top To Bottom：从上到下 Value：滚动条初始位置值（0~1） Value：滚动块在条中的比例大小（0~1） Number Of Steps：允许可以滚动多少次（不同滚动位置的数量） OnValueChanged：滚动条值改变时执行的函数列表（ sb.onValueChanged.AddListener(事件)） 滚动条 (Scrollbar) - Unity 手册 (unity3d.com) ScrollView滚动视图控件 是UGUI中用于处理滚动视图相关交互的关键组件，默认创建的ScrollRect由4组对象组成，父对象——ScrollRect组件依附的对象 还有一个Image组件 最为背景图，子对象——Viewport控制滚动视图可视范围和内容显示、Scrollbar Horizontal 水平滚动条、Scrollbar Vertical 垂直滚动条。 ScrollRect参数: Content：控制滚动视图显示内容的父对象，它的尺寸有多大(滚动视图就能拖多远) Horizontal：启用水平滚动 Vertical：启用垂直滚动 Movement Type：滚动视图元素的运动类型。主要控制拖动时的反馈效果 Unrestricted（一般不使用）：不受限制，随便拖动 Elastic（常用）：回弹效果，当滚出边缘后，会弹回边界 Elasticity：回弹系数，控制回弹效果。值越大回弹越慢 Clamped：夹紧效果，始终限制在范围内，没有回弹效果 Inertia：移动惯性，如果开启，松开鼠标后会有一定的移动惯性 Deceleration Rate：减速率（0~1），0没有惯性，1不会停止 Scroll Sensitivity：滚轮（鼠标中间）和触摸板（笔记本）的滚动事件敏感性 Viewport：关联滚动视图内容视口对象 Horizontal Scrollbar：关联水平滚动条 Visibility：是否在不需要时自动隐藏等模式 Permanent：一直显示滚动条 Auto Hide：自动隐藏滚动条 Auto Hide And Expand Viewport：自动隐藏滚动条并且自动拓展内容视口 Spacing：滚动条和视口之间的间隔空间 OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener(事件)） Dropdow下拉列表控件 是UGUI中用于处理下拉列表相关交互的关键组件，默认创建的DropDown由4组对象组成，父对象——DropDown组件依附的对象 还有一个Image组件 作为背景图，子对象——Label是当前选项描Arrow右侧小箭头、Template下拉列表选单。 Dropdow参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) Template：关联下拉列表对象 Caption Text：关联显示当前选择内容的文本组件 Caption Image：关联显示当前选择内容的图片组件 Item Text：关联下拉列表选项用的文本控件 Item Image：关联下拉列表选项用的图片控件 Value：当前所选选项的索引值 Alpha Fada Speed：下拉列表窗口淡入淡出的速度 Options：存在的选项列表 OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener(事件)） 下拉选单 (Dropdown) - Unity 手册 (unity3d.com) 进阶知识图集制作 打图集注意的是在游戏场景插入同图集的图会打断批处理，即使在同一个图集也不行，所以要额外注意UI元素的排列顺序。 事件监听接口EventTrigger事件触发器屏幕坐标转UI相对坐标遮罩Mask模型和粒子显示在UI之前异形按钮自动布局组件画布组Canvas Group","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"UGUI","slug":"UGUI","permalink":"https://wwy.wwywy.com/tags/UGUI/"}]},{"title":"Unity进阶-GUI","slug":"03004-Unity进阶-GUI","date":"2020-01-10T13:00:00.000Z","updated":"2022-03-03T10:07:35.248Z","comments":true,"path":"posts/1540.html","link":"","permalink":"https://wwy.wwywy.com/posts/1540.html","excerpt":"","text":"GUI概叙基础控件重要参数文本按钮单选框多选框输入框拖动条图像绘制和框复合控件工具栏和选择网格滚动视图和分组窗口自定义整体样式","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"GUI","slug":"GUI","permalink":"https://wwy.wwywy.com/tags/GUI/"}]},{"title":"Unity进阶-ScriptableObject","slug":"03014-Unity进阶-ScriptableObject","date":"2019-11-13T13:00:00.000Z","updated":"2022-03-09T02:25:56.698Z","comments":true,"path":"posts/1548.html","link":"","permalink":"https://wwy.wwywy.com/posts/1548.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"ScriptableObject","slug":"ScriptableObject","permalink":"https://wwy.wwywy.com/tags/ScriptableObject/"}]},{"title":"Unity进阶-InputSystem","slug":"03013-Unity进阶-InputSystem","date":"2019-11-13T13:00:00.000Z","updated":"2022-03-09T02:27:22.884Z","comments":true,"path":"posts/1547.html","link":"","permalink":"https://wwy.wwywy.com/posts/1547.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"InputSystem","slug":"InputSystem","permalink":"https://wwy.wwywy.com/tags/InputSystem/"}]},{"title":"Unity进阶-Addressables","slug":"03015-Unity进阶-Addressables","date":"2019-11-13T13:00:00.000Z","updated":"2022-03-09T02:31:12.241Z","comments":true,"path":"posts/1549.html","link":"","permalink":"https://wwy.wwywy.com/posts/1549.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Addressables","slug":"Addressables","permalink":"https://wwy.wwywy.com/tags/Addressables/"}]},{"title":"Unity进阶-Timeline","slug":"03012-Unity进阶-Timeline","date":"2019-11-13T13:00:00.000Z","updated":"2022-03-10T07:15:02.011Z","comments":true,"path":"posts/1546.html","link":"","permalink":"https://wwy.wwywy.com/posts/1546.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Timeline","slug":"Timeline","permalink":"https://wwy.wwywy.com/tags/Timeline/"}]},{"title":"Unity核心","slug":"03003-Unity核心","date":"2019-10-05T13:00:00.000Z","updated":"2022-03-03T07:46:38.666Z","comments":true,"path":"posts/1539.html","link":"","permalink":"https://wwy.wwywy.com/posts/1539.html","excerpt":"","text":"2D相关图片导入设置Unity支持的图片格式BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大; TIF:基本不损失图片信息的图片格式，缺点是体积大; JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道; PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道; TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道; PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面; 其它:还支持,EXR、GIF、HDR、IFF、PICT等等,其中Unity最常用的图片格式是JPG、PNG、TGA三种格式; 纹理类型设置（Texture Type）1.Default-默认纹理，大部分导入的模型贴图都是该类型 sRGB(Color Texture)：启用可以将纹理存储在伽马空间(见下图一)中（对每一个像素做一次幂函数运算） Alpha Source：指定如何生成纹理的Alpha通道 None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道 Input Texture Alpha：输入纹理中的Alpha From Gray Scale：从输入纹理RGB值的平均值生成Alpha Alpha Is Transparency：启用可以避免边缘上的过滤瑕疵 2.Normal map-法线贴图格式： 法线贴图说明：就是在原物体的凹凸表面的每个点上均作法线法线就是垂直于某个点的切线的方向向量 Create From Grayscale：启用此属性可以从灰度高度贴图创建法线贴图 Bumpiness：控制凹凸程度，值越大凹凸感越强 Filtering：如何计算凹凸值 Smooth：使用标准算法生成法线贴图 Sharp：生成比标准模式更锐利的法线贴图 3.Editor GUI and Legacy GUI：一般在编辑器中或者GUI上使用的纹理 4.Sprite（2D and UI）：2D游戏或者UGUI中使用的格式 Sprite Mode：图像中提取精灵图形的方式 Single：按原样使用精灵图像 Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片 Polygon：网格精灵模式 Pixels Per Unit：世界空间中的一个距离单位对应多少像素 MeshType：网格类型；只有Single和Multiple模式才支持 Full Rect：创建四边形，将精灵显示在四边形上 Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状；任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是； Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小 Pivot：精灵图片的轴心点，Single模式才有此选项，对应九宫格布局的九个点，还可以自定义 Generate Physics Shape：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状，只有Single 和Multiple模式才可使用 Sprite Editor：编辑Sprite，需要安装2D Sprite包，之后单独讲解 5.Cursor：自定义光标 6.Cookie：光源剪影格式 Light Type：应用的光源类型，一般点光源的剪影需要设置为立方体纹理，方向光和聚光灯的剪影设置为2D纹理； Spotlight：聚光灯类型，需要边缘纯黑色纹理 Directional：方向光，平铺纹理 Point：点光源，需要设置为立方体形状 7.Lightmap：光照贴图格式 8.Single Channel：纹理只需要单通道的格式 Channel：希望将纹理处理为Alpha还是Red通道 Alpha：使用Alpha通道，不允许进行压缩 Red：使用红色通道; 图一：线性和伽马颜色空间说明 纹理形状（Texture Shape）1.2D：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上; 2.Cube：立方体贴图，主要用于天空盒和反射探针 Mapping：如何将纹理投影到游戏对象上 Auto：根据纹理信息创建布局 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像 Latitude-Longitude Layout：将纹理映射到2D维度/经度 Mirrored Ball：将纹理映射到类似球体的立方体贴图上 Convolution Type：纹理的过滤类型 None：无过滤 Specular：将立方体作为反射探针 Diffuse：将纹理进行过滤表示辐照度，可作为光照探针 Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误； 纹理高级设置 高级设置主要是纹理的一些尺寸规则、读写规则、以及MipMap相关设置 1.Non-Power of 2：如果纹理尺寸非2的幂如何处理(为什么纹理要设置为2的N次方：因为图形学规则，纹理必须是2的幂尺寸) None：纹理尺寸大小保持不变 To nearest：将纹理缩放到最接近2的幂的大小（注意：PVRTC格式要求纹理为正方形） To larger：将纹理缩放到最大尺寸大小值的2的幂的大小 To smaller：将纹理缩放到最小尺寸大小值的2的幂的大小 2.Read/Write Enabled：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启） 3.Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存 Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap 4.Generate Mip Maps：允许生成MipMap(开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片,在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率); Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘 Mip Map Filtering：优化图像质量的过滤方法 Box：随着尺寸减小，级别更加平滑 Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法 Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率 Alpha Cutoff Value：覆盖率参考值 Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色 纹理平铺拉伸设置Wrap Mode：平铺纹理时的方式 Repeat：在区块中重复纹理 Clamp：拉伸纹理的边缘 Mirror：在每个整数边界上镜像纹理以创建重复图案 Mirror Once：镜像纹理一次，然后将拉伸边缘纹理 Per-axis：单独控制如何在U轴和V轴上包裹纹理 Filter Mode：纹理在通过3D变化拉伸时如何进行过度 Point：纹理在靠近时变为块状 Bilinear：纹理在靠近时变得模糊 Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊 Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高 纹理平台打包设置（非常重要）1.Max Size：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内 2.Resize Algorithm：当纹理尺寸大于指定的Max Size时，使用的缩小算法 Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法 Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多 Format：纹理格式（各平台支持的格式有所不同，如果选择Automatic，会根据平台使用默认设置） 都支持的格式:下图一 移动端和网页端特有格式：下图二 不同平台单独进行设置： IOS：选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。 Andorid：推荐如下图三 由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包； 构建一个以 OpenGL ES 3 为目标的 APK，访问 Android 的 Player Settings，菜单：Edit &gt; Project Settings &gt;Player Settings，然后选择 Android 类别），向下滚动到 Graphics APIs 部分，确保 OpenGL ES 2 不在列表中，构建 APK，（菜单：File &gt; Build Settings，然后单击 Build）； 构建一个以 OpenGL ES 2 为目标的单独 APK，访问 Android Player Settings，向下滚动到 Graphics APIs 部分，在列表中添加 OpenGL ES 2，并删除 OpenGL ES 3 和 Vulkan，构建 APK。 3.Compression：选择纹理的压缩类型，帮助Unity正确选择压缩格式，会根据平台和压缩格式的可用性进行压缩； None：不压缩纹理 Low Quality：以低质量格式压缩纹理 Normal Quality：以标准格式压缩纹理 High Quality：以高质量格式压缩纹理 4.Use Crunch Compression：启用后，使用Crunch压缩，Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快； Compressor Quality:压缩质量条，质量越高意味着纹理越大，压缩事件越长。 5.Split Alpha Channel：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。 6.Override ETC2 fallback：不支持ETC2压缩的设备上，使用的格式。 图一：都支持的格式图二：移动端和网页端特有格式图三：移动端和网页端特有格式 SpriteSprite Editor1.Single图片编辑： 右下角设置窗口： Name：名字 Position：在图片中的偏移位置和宽高 Border：边框，用于设置九宫格的4条边 Pivot：轴心（中心）点位置 Pivot Unit Mode：轴心点单位模式 Normalized：标准化模式，0~1 Pixels：像素模式 Custom Pivot：自定义轴心点 （OutLine）自定义边缘线和(Physics)自定义物理形状： Snap：将控制点贴近在最近的像素 Outline Tolerance：轮廓点的复杂性和准确性，0~1值越大轮廓点越多，越准确 Generate：生成网格轮廓 //1.Sprite Editor // 基础图片设置（右下角窗口） // 主要用于设置单张图片的基础属性 //2.Custom Outline（决定渲染区域） // 自定义边缘线设置，可以自定义精灵网格的轮廓形状 // 默认情况下不修改都是在矩形网格上渲染,边缘外部透明区域会被渲染，浪费性能 // 使用自定义轮廓，可以调小透明区域，提高性能 //3.Custom Physics Shape（决定碰撞判断区域） // 自定义精灵图片的物理形状，主要用于设置需要物理碰撞判断的2D图形 // 它决定了之后产生碰撞检测的区域 //4.Secondary Textures(为图片添加特殊效果) // 次要纹理设置，可以将其它纹理和该精灵图片关联 // 着色器可以得到这些辅助纹理然后用于做一些效果处理 // 让精灵应用其它效果 2.Multiple图集元素分割： 自动分割(Automatic)： Pivot：单张图片轴心点位置 Custom Pivot：自定义轴心点 Method：如何处理现有对象 Delete Existing：替换掉已经选择的任何矩形 Smart：尝试创建新矩形同时保留或调整现有矩形 Safe：添加新矩形而不更改任何已经存在的矩形 按单元格大小分割(Grid By Cell Size)： Pixel Size：单元格宽高 Offset：偏移位置 Padding：和边缘的偏移位置 Keep Empty Rects：是否保留空矩形 按单元格大小分割(Grid By Cell Count) 增加参数Column &amp; Row：行列数 3.Polygon多边形编辑： Sprite Editor - Unity 手册 (unity3d.com) Sprite Renderer 所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的。 参数讲解: 1.Sprite：渲染的精灵图片 2.Color：定义着色，一般没有特殊需求不会修改 3.Filp：水平或竖直翻转精灵图片 4.Draw Mode：绘制模式，当尺寸变化时的缩放方式 Simple：简单模式，缩放时整个图像一起缩放 Sliced：切片模式，9宫格切片模式，十字区域缩放，4个角不变化,一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect） Tiled：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect） Continuous：当尺寸变化时，中间部分将均匀平铺 Adaptive：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺 5.Mask Interaction：与精灵遮罩交互时的方式 None：不与场景中任何精灵遮罩交互 Visible inside Mask：精灵遮罩覆盖的地方可见，而遮罩外部不可见 Visible Outside Mask：精灵遮罩外部的地方可见，而遮罩覆盖处不可见 6.Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改 7.Material：材质，可以使用一些自定义材质来显示一些特殊效果,一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse 8.Additional Settings：高级设置 Sorting Layer：排序层选择 Order in Layer：层级序列号，数值越大约会显示在前面 Sprite Renderer - Unity 手册 (unity3d.com) API： 知识点一 代码设置 GameObject obj = new GameObject(); SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;(); //动态的改变图片 sr.sprite = Resources.Load&lt;Sprite&gt;(\"dead1\"); //动态的加载 图集中的图 Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;(\"RobotBoyIdleSprite\"); sr.sprite = sprs[10]; UnityEngine.SpriteRenderer - Unity 脚本 API (unity3d.com) Sprite Creator 我们可以利用Sprite Editor的多边形工具创造出各种多边形,Unity也为我们提供了现成的一些多边形,它的主要作用是2D游戏的替代资源,在等待美术出资源时我们可以用他们作为替代品,有点类似Unity提供的自带几何体(在Project窗口右键创建各种形状的Sprite精灵图片). Sprite Creator - Unity 手册 (unity3d.com) Sprite Mask1.Sprite：遮罩图片; 2.Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）; 3.Custom Range：自定义遮罩范围,开启后可以设置遮罩的范围，按照排序层来划分; UnityEngine.SpriteMask - Unity 脚本 API (unity3d.com) Sorting Group 顾名思义，SortingGroup是排序分组的意思,它的主要作用就是对多个精灵图片进行分组排序,Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样,主要作用是对于需要分层的2D游戏用于整体排序。 排序组 - Unity 手册 (unity3d.com) Rendering.SortingGroup - Unity 脚本 API (unity3d.com) Sprite Atlas精灵图集制作 在工程设置面板中打开功能:Edit——&gt;Project Setting——&gt;Editor（Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)）；Disabled：默认设置，不会打包图集；Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包；Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集； 1.打图集面板参数相关 1.Type：图集类型 Master：主图集 Include in Build：选中可以在当前构建中包含图集 Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转 Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度 Padding：图集中各图片的间隔像素 Variant：变体类型的图集 Master Atlas：关联的主图集（图集类型必须是Master） Include in Build：选中可以在当前构建中包含图集 Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果(变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可) 2.Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它 3.Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启 4.SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。 5.Filter Mode：纹理在3D变化拉伸时如何进行过滤 Point：纹理靠近时变为块状 Bilinear：纹理靠近时变得模糊 Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊 6.Objects for Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片 7.Default: Max Texture Size：纹理的最大尺寸，像素为单位 Format：指定纹理的内部表示，在不同平台上会有不同的参数 Compression：纹理压缩类型(质量越高占用内存越多，不压缩质量最好)不压缩、低质量、普通质量、高质量； Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快 Compressor Quality：压缩质量，质量越高纹理越大，耗时越长 精灵图集 - Unity 手册 (unity3d.com) 2.API使用 知识点一 代码控制 GameObject obj = new GameObject(); SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;(); //加载图集资源 SpriteAtlas spriteAtlas = Resources.Load&lt;SpriteAtlas&gt;(\"MyAtlas\"); //加载图集资源中的某一张小图 sr.sprite = spriteAtlas.GetSprite(\"dead1\"); U2D.SpriteAtlas - Unity 脚本 API (unity3d.com) 2D物理系统刚体1.刚体类型参数说明: 1.Dynamic：动态类型（受重力和力的影响移动和旋转） Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质，如果不设置，将使用在Physics 2D窗口中设置的默认材质 物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质 Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项； Use Auto Mass：是否使用自动质量 Mass：质量 Linear Dray：影响位置移动的阻力系数 Angular Drag：影响旋转移动的阻力系数 Gravity Scale：受重力影响的程度 Collision Detection：碰撞检测算法 Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过 Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况 Sleeping Mode：对象处于静止状态时进入睡眠模式 Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大 Start Awake：最初处于唤醒状态 Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒 Interpolate：物理更新间隔之间的插值运算 None：不应用移动平滑 Interpolate：根据前一帧进行平滑处理 Extrapolate：根据后一帧位置进行平滑处理 Constraints：约束限制，可以让某一个轴不受力影响位移或者旋转 2.Kinematic：运动学类型，不受力的影响，只能通过代码让其动起来，能和Dynamic 2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数，因此它没有了质量莫摩擦系数等属性，因此它的性能能消耗较低，主要会通过代码来处理其移动旋转； Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞，如果Use FullKinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞； Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它，如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞 3.Static：静态类型完全不动的需要检测碰撞的对象，相当于是无限质量不可移动的对象，它的性能消耗最小，它只能和Dynamic 2D刚体碰撞（和只加碰撞体的区别），和它类似的有只加碰撞器而不加刚体的物体，它们会和刚体物体产生碰撞，但是自己不会动； 2D 刚体 - Unity 手册 (unity3d.com) 2.刚体API说明: 知识点一 刚体API(参考刚体3D) //加力 Rigidbody2D rigid = this.GetComponent&lt;Rigidbody2D&gt;(); rigid.AddForce(new Vector2(0, 100)); //速度 rigid.velocity = new Vector2(1, 0); UnityEngine.Rigidbody2D - Unity 脚本 API (unity3d.com) 碰撞体1.碰撞体参数相关: 1.圆形碰撞器（Circle）: Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性 Is Trigger：是否是触发器 Used By Effector：是否被附加的2D效应器使用 Offset：圆心偏移位置 Radius：圆形的半径 2.盒状碰撞器(Box): `Used by Composite：如果勾选，则该碰撞器将附加到2D复合碰撞器使用（勾选后一些属性只能在复合碰撞器中配置） Auto Tiling：如果渲染器组件的Draw Mode设置为Tiled模式，勾选该选项，当改变精灵大小时将自动更新碰撞器尺寸； Size：矩形的宽高 Edge Radius：使四个顶点为圆角 3.多边形碰撞器(Polygon) Points：多边形顶点虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了，都通过Edit Collider编辑，或者让Unity自动识别创建 4.边界碰撞器(Edge地形)：边界碰撞器的编辑主要还是通过Edit Collider一般不会手动去通过数值加点 5. 5.胶囊碰撞器(Capsule) Size：胶囊的宽高 Direction：是竖直胶囊还是水平胶囊 6.复合碰撞器(Composite必须配合刚体使用) Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型 Outlines：空心轮廓，类似边界碰撞器 Polygons：实心多边形，类似多边形碰撞器 Generation Type：生成类型，复合碰撞器在何时生成新几何体 Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体 Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮 Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值 2D 碰撞体 - Unity 手册 (unity3d.com) 2.碰撞器API：碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致： 知识点一 碰撞检测函数 private void OnCollisionEnter2D(Collision2D collision) private void OnCollisionExit2D(Collision2D collision) private void OnCollisionStay2D(Collision2D collision) private void OnTriggerEnter2D(Collider2D collision) private void OnTriggerExit2D(Collider2D collision) private void OnTriggerStay2D(Collider2D collision) 物理材质物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质物理材质参数相关： Friction：摩擦系数，为0表示没有摩擦力 Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹） 恒定力（了解即可）恒定力（Constant Force）参数说明： Force：物理更新时施加于2D刚体上的线性力 Relative Force：物理更新时施加的线性力（相对刚体对象坐标系） Torque：物理更新时施加于2D刚体的扭矩力 效应器(Effector)效应器参数相关: 1.区域效应器（Area）：在一个区域内让游戏对象受到力和扭矩力的作用(作浮力和电梯传送带) Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象 Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度 Force Angle：施加力的角度 Force Magnitude：施加力的大小 Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化 ForceTarget：效应器在目标对象上施加力的作用点 Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转） Rigidbody：以刚体的当前质心（不会产生扭矩力） Drag：阻力 Angular Drag：扭矩阻力 2.浮力效应器（Buoyancy）：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动 Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮，密度和流体相同的碰撞体会浮在流体中 Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移 Linear Drag：影响对象在水中移动的阻力系数 Angular Drag：影响对象在水中旋转的阻力系数 Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力 Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小 Flow Variation：随机改变流体力的值 3.点效应器：模拟磁铁 吸引或者排斥的效果 Force Magnitude：施加力的大小 Force Variation：施加力的大小变化 Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放 Force Source：力源来自哪个位置，从该点计算距离。 Collider：碰撞器的位置 Rigidbody：刚体的位置 Force Target：作用力目标位置，用改点计算位置 Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力 Rigidbody：刚体的位置，不会产生扭矩力 Force Mode：计算力的模式 Constant：忽略源和目标之间相隔的距离 Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小 Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力 4.平台效应器（Platform）：2D游戏当中的平台或可往上跳跃的墙壁 Rotational Offset：旋转偏移量，控制平台角度偏移 Use One Way：是否使用单向碰撞行为 Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为 Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞 Use Side Friction：是否应该在平台两侧使用摩擦 Use Side Bounce：是否应该在平台两侧使用弹性 Side Arc：用于定义左右两侧平台的响应弧度 5.表面效应器（Surface）：模拟传送带 Speed：表面保持的速度 Speed Variation：速度的随机增加值 Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力 Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转 Use Friction：是否使用摩擦力 Use Bounce：是否使用弹力 2D 效应器 - Unity 手册 (unity3d.com) SpriteShape SpriteShape是精灵形状的意思（在Package Manager中导入相关工具），它主要是方便我们以节约美术资源为前提，制作2D游戏场景地形或者背景的。类型：开放不封闭的图形、封闭的图形； Sprite Shape Profile精灵形状概述文件Sprite Shape Profile精灵形状概述文件配置： Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸 Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式） Offset：纹理偏移量 Angle Ranges：角度范围（ 这里的设置主要用于封闭图形在不同角度范围内使用的图片不同，可以达到一个封闭效果） Start：起始角度 End：结束角度 Order：Sprite相交时的优先级，优先级高的显示在前面 Sprites：指定角度范围内的精灵列表，在该角度范围内，可以选择使用的图片资源 Corners：指定角显示的精灵图片，主要用于封闭图形，外部四个角用的图片，内部四个角用的图片 Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器Sprite Shape Renderer - Unity 手册 (unity3d.com) 参数相关： 1.Sprite Shape Renderer精灵形状渲染器：该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息 Color：颜色 Mask Interaction：遮罩相互作用规则设置 Fill Material和Edge Material：填充材质和边缘材质 Sorting Layer和Order in Layer：排序相关 2.Sprite Shape Controller精灵形状控制器： Profile：使用的精灵形状概述文件 Detail：精灵形状的质量（高中低三种质量） Is Open Ended：是否是开放的，不封闭的 Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸，开启后只有宽度够才会平铺，如果宽度不够会拉伸，不开启始终平铺，但是可能会出现裁剪效果，一般根据你的实际效果进行选择； Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量 Enable Tangents：是否启用切线计算功能（如果你的着色器中需要切线信息参与计算，则勾选） Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片 Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上 Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小 Worldspace UV：根据世界控件的UV填充纹理 启用编辑状态后： Tangent Mode ：切线模式（从左至右依次是） 顶点模式-点两侧不构成曲线 切线模式-点两侧构成曲线，并且可以控制切线弧度 左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度 Position：选中点的局部坐标位置 Height：控制点左右两侧精灵图片的高度 Corner：是否使用角度图片 Disabled：不使用角度图片 Automatic：自动 Sprite Variant：选择使用的精灵图片 Snapping：是否开启捕捉设置控制点 Tilemap(过后再来学)动画基础Animation动画窗口面板左侧（说明）： 顶部从左至右： 1.预览模式（开关） 2.录制模式（开关）打开后预览模式默认开启 3.回到动画开头 4.上一关键帧（快捷键：键盘逗号） 5.播放动画（快捷键：键盘Alt+逗号） 6.下一关键帧（快捷键：键盘句号） 7.回到动画结尾（快捷键：键盘Alt+句号） 8.当前处于第几帧 底部Dopesheet：关键帧模式 底部Curves：曲线模式 中部从左至右： 按选择筛选 添加关键帧 添加事件 面板左侧（操作）： 多出一个可以选择当前动画的下拉列表：可以在这里创建新动画和切换动画 多出一个可以添加变化属性的按钮：在这里你可以任意添加你想要在动画中变化的脚本变量 面板右侧（说明）： 动画时间轴面板：当编辑动画时，会在该面板上编辑关键帧等信息 右侧面板（操控）： 时间轴可以拖动（注意）：时间轴上的单位为n秒n帧，一格代表一帧（并不是秒） 选择关键帧右键： Add Key：添加关键帧 Delete Key：删除关键帧 Clamped Auto：切线模式，自动设置切线 Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画 Free Smooth：自由设置切线 Flat：切线设置为水平 Broken：单独控制左右曲线切线 Free：自由设置 Linear：直线 Constant：常量切换 Weighted：权重切换 使用 Animation 视图 - Unity 手册 (unity3d.com) Animation老动画组件 在创建动画之前为对象添加Animation组件之后再制作动画，这时制作出的动画和之前的动画格式是有区别的。Animation组件参数相关： Animation组件：默认播放的动画 Animations：该动画组件可以控制的所有动画 Play AutoMatically：是否一开始就自动播放默认动画 Animate Physics：动画是否与物理交互 Culling Type：决定什么时候不播放动画 Always Animate：始终播放 Based On Renderers：基于默认动画姿势剔除 老动画Animation文件参数相关： Default：读取设置得更高的默认重复模式 Once：播放一次就停止 Loop：从头到尾不停循环播放 PingPong：从头到尾从尾到头不停播放 ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同； 老Animation组件API 知识点一 代码控制播放 //1.播放动画 animation.Play(\"1\"); //2.淡入播放,自动产生过渡效果 //当你要播放的动画的开始状态 和当前的状态 不一样时 //就会产生过渡效果 animation.CrossFade(\"3\"); //3.前一个播完再播放下一个 animation.PlayQueued(\"2\"); animation.CrossFadeQueued(\"2\"); //4.停止播放所有动画 animation.Stop(); //5.是否在播放某个动画 if( animation.IsPlaying(\"1\") ) //6.播放模式设置 animation.wrapMode = WrapMode.Loop; //7.其它（了解即可，新动画系统中会详细讲解） //层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果） //设置层级 animation[\"1\"].layer = 1; //设置权重 animation[\"1\"].weight = 1; //混合模式 叠加还是混合 animation[\"1\"].blendMode = AnimationBlendMode.Additive; //设置混组相关骨骼信息 animation[\"\"].AddMixingTransform(); UnityEngine.Animation - Unity 脚本 API (unity3d.com) Animator动画控制器面板1.左侧面板 Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的 Parameters：参数页签，为动画状态机添加控制状态切换的参数 眼睛图标：显隐左侧面板 2.右侧面板： 网格化布局区域（主要用于编辑状态之前的切换关系）；1.窗口中的每一个矩形表示一个状态；2.窗口中的每一个箭头表示一个切换条件； 矩形说明： 默认三大矩形： 绿色Entry矩形：进入状态机流程 红色Exit矩形：退出状态机流程 Any State：任意状态，代表状态机中的任意状态 人为添加矩形： 橙色矩形：一开始的默认状态动画，和Entry相连，表示一开始播放的动画 灰色矩形：自己添加的某一种动作状态 Animator Controller - Unity 手册 (unity3d.com) Animator新动画组件Animator组件参数相关： Controller：对应的动画控制器（状态机） Avatar：对应的替身配置信息（之后讲解3D模型时详细讲解） Apply Root Motion：是否启用动画位移更新 UpdateMode：更新模式（一般不修改它）: Normal：正常更新 Animate Physics：物理更新 Unscaled Time：不受时间缩放影响； Culling Mode：裁剪剔除模式： Always Animate：始终播放动画，即使在屏幕外也不剔除； Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入； Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用； 新动画文件(.ani)界面参数: Loop Time：是否是循环动画（在动画结尾时重新开始） Loop Pose：无缝循环运动 Cycle Offset：循环动画在其他时间开始时的周期偏移 Animator组件API 知识点一 Animator中的API //我们用代码控制状态机切换主要使用的就是Animator提供给我们的API //我们知道一共有四种切换条件 int float bool trigger //所以对应的API也是和这四种类型有关系的 animator = this.GetComponent&lt;Animator&gt;(); //1.通过状态机条件切换动画 animator.SetFloat(\"条件名\", 1.2f); animator.SetInteger(\"条件名\", 5); animator.SetBool(\"条件名\", true); animator.SetTrigger(\"条件名\"); animator.GetFloat(\"条件名\"); animator.GetInteger(\"条件名\"); animator.GetBool(\"条件名\"); //2.直接切换动画 除非特殊情况 不然一般不使用 animator.Play(\"状态名\"); UnityEngine.Animator - Unity 脚本 API (unity3d.com) 2D动画序列帧动画骨骼动画-2DAnimation骨骼动画-Spine3D模型导入相关模型导出：在 Unity 外部创建资源（模型导出） - Unity 手册 Model模型页签Model模型页签说明 1.Scene场景相关设置： *Scale Factor：当模型中的比例不符合项目中的预期比例时，可以修改此值来改变该模型的全局比例Unity的物理系统希望游戏世界中的1米在导入模型文件中为1个单位； *Convert Units：启用可将模型文件中定义的模型比例转换为Unity的比例，不同的格式的比例如下，.fbx .max .jas = 0.01，.3ds = 0.1，.mb .ma .lxo .dxf .blend .dae = 1； Import BlendShapes：是否允许Unity随网格一起导入混合形状，当导入包含混合形状的网格时，将使用Skinned MeshRenderer组件（注意：1.导入混合形状发现需要在FBX文件中具有平滑组；2.如果想要导入具有法线的混合形状；把下方的Blend Shape Normals属性设置为Import，将使用FBX文件的发现，或者把下方的Blend Shape Normals属性设置为Calculate，Unity使用相同的逻辑来计算网格和混合形状上的法线）； Import Visibility：是否导入可见性，开启后可以从FBX文件中读取可见性属性。，比如模型动作里 有些动作是要隐藏模型形象的，开启后才会生效，一些3D建模软件对可见性属性不支持或者有限制，比如Maya和Blender就对可见性有限制，所以一般这个选项要根据你使用的建模软件决定（一般可以不勾选）； Import Cameras：是否导入摄像机； *Preserve Hierarchy：始终创建一个显示预制体根，通常在导入的时候，FBX会将模型中的空根节点进行优化去掉它，但是如果多个FBX文件中包含同一层级的空跟对象，可以勾选它来保留他们；主要作用是：比如有两个fbx文件，1包含骨骼和网格，2只包含骨骼动画。如果不启用它导入2，那么Unity将剥离根节点，会让层级不匹配让动画不能正常播放； Sort Hierarchy By Name：在层级窗口中根据名字排序子物体，如果不启用，会保留FBX文件中定义的层级顺序； 2.Meshes网格相关设置： *Mesh Compression-网格压缩，设置压缩比级减小网格的文件大小，提高压缩比会降低网格的精度，调整该参数可以优化游戏包的大小： Off：不使用压缩 Low：低压缩比 Medium：中等压缩比 High：高压缩比 *Read/Write Enabled：是否开启读写网格信息，如果开启，Unity将网格数据传给GPU后，在CPU中还会保留可寻址内存，意味着我们可以通过代码访问网格数据进行处理，如果不开启，Unity将网格数据传个GPU后，会将CPU中的可寻址内存中网格数据删除，我们无法再得到网格数据，开启时，会增加内存占用，关闭时，可以节约运行时内存使用量（何时开启？；1.需要在代码中读取或写入网格数据；2.需要运行时合并网格；3.需要使用网格碰撞器时；4.需要运行时使用NavMesh构建组件来烘焙NavMesh时）； Optimize Mesh-确定三角形在网格中列出的顺序以提高GPU性能： Nothing：无优化 Everything：对顶点以及多边形顶点索引进行重新排序 Polygon Order：仅对多边形重新排序 Vertex Order：仅对顶点重新排序 *Generate Colliders：生成碰撞器，启用后会自动附加网格碰撞器的情况下导入你的网格，建议不移动的环境几何体可以开启它，但是需要移动的几何体建议不要开启它； 3.Geometry几何体相关设置： *Keep Quads：保留四边形，启用后，Unity不会将4个顶点的多边形转为三角形，当使用曲面细分着色器时可能需要启用此选项，因为四边形的曲面周色漆比多边形的效率更高； *Weld Vertices：合并在空间中共享相同位置的顶点，前提是这些顶点总体上共享相同的属性（UV，法线，切线等等）（开启后相当于会通过减少网格的总数量来优化网格的顶点计数）；一般都开启，除非你想有意保留这些重复顶点，之后想通过代码去获取他们来进行处理； Index Format：网格索引缓冲区的大小（一般都选择16bits，Auto可以会默认选择16bits，只有在必要时使用32bit，16bits即通用又节约内存）； Legacy Blend Shape Normals：启用后会基于Smoothing Angle值来计算法线； Normals-定义如何计算法线： Import：从文件中导入法线，如果文件中不包含发现信息，将使用Calculate模式计算法线 Calculate：根据Normals Mode、Smoothness Source和Smoothing Angle属性来计算发现 None：不计算法线 Blend Shape Normal：定义如何为混合形状计算法线，只有当Legacy Blend Shape Normals禁用时出现 Normals Mode：计算法线的模式，只有当上方的Normals设置为Import和Calculate才会出现 Unweighted Legacy：2017.1版本之前计算法线的方式，如果是在该版本之前导入的所有FBX模型，默认设置为该模式 Unweighted：法线不加权重 Area Weighted：法线按照图面面积加权重 Angle Weighted：法线按照每个图面上的顶角加权重 Area And Angle Weighted：法线按照每个图面上的图面面积和顶角加权重，这是默认选项 Smoothness Source-如何确定平滑，哪些边应该平滑，哪些应该粗糙，只有当Legacy Blend Shape Normals 禁用时出现： Prefer Smoothing Groups：尽可能使用模型文件中的平滑组 From Smoothing Groups：仅使用模型文件中的平滑组 From Angle：使用Smoothing Angle值来确定哪些边应该是平滑的 None：不拆分硬边的任何顶点 Smoothing Angle：控制是否为硬边拆分顶点，通常，值越大，产生的顶点越少，仅当Normals设置为Calculate时才可用（注意：此设置仅用于非常光滑的或者非常复杂的模型，否则，最好在3D建模软件中手动平滑然后导入，始终建议建模的时候就做好，更加准确）； Tangents-定义如何导入或计算顶点切线，仅当Normals设置为Calculate或Import时，此属性才可用： Import：如果Normals设置为Import，则从FBX文件中导入顶点切线，如果网格没有切线，那么将无法使用法线贴图着色器 Calculate Legacy：使用旧版算法计算切线 Calculate Legacy With Split Tangents：使用旧版算法计算切线，并在UV图表上进行拆分。如果网格上的接缝碰坏了法线贴图光照，请使用此属性 Calculate Mikktspace：使用米克特空间计算切线 None：不导入顶点切线，网格没有切线，则无法使用法线贴图着色器 Swap UVs：在网格中交换UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项 Generate Lightmap UVs：为光照贴图创建第二个UV通道 Model 选项卡 - Unity 手册 (unity3d.com) Rig操纵骨骼页签Animation Type-动画类型说明: 1.None-不存在动画:主要用于一些环境静态模型 2.Humanoid-人形模型,一般情况下，有头和四肢（一个头两条腿两只手）为人形,人形模型需要使用Avatar化身系统,绑定人主要关节的映射关系: Avatar Definition：选择获取Avatar定义的位置 No Avatar：没有化身系统信息 Create From This Model：根据此模型创建Avatar化身信息 Copy from Other Avatar：指向另一个模型上设置的Avatar化身信息 Source：复制另一个具有相同骨架的Avatar化身信息以导入其动画剪辑,使用Copy From Other Avatar时才有 Configure...：打开Avatar化身配置,使用Create From This Model时才有 Skin Weights：设置影响单个顶点的最大骨骼数量 Standard（4 Bones）：使用最多4个骨骼来产生影响。默认值，处于对性能考虑，建议使用此设 Custom：设置自定义的最大骨骼数，选择后会出现下方的两个选项 Max Bones/Vertex：定义每个顶点的最大估个数，值越大性能消耗越大 Max Bone Weight：设置考虑骨骼权重的最低阈值，权重计算时将忽略小于此值的内容 Optimize Game Objects：在Avatar化身系统和Animator动画组件中删除和存储所导入角色的游戏对象骨骼层级信息。如果启用会出现下方的Extra Transforms to Expose选项。角色将使用Unity动画系统的内部骨架，可以提高动画角色的性能 Extra Transforms to Expose：要公开的骨骼层级，在下方打钩将公开该骨骼层级信息 放大镜：通过名称搜索对应骨骼信息 Toggle All：全选或者反选 Collapse All：全部折叠 Expand All：全部展开 3.Generic-通用模型，非人形模型,不是标准的人形模型，可以是任意形状，可能有8只腿两个头等等,这种模型主要需要设置骨骼根节点: Root Node：选择用于此Avatar的根节点的骨骼（仅当选择Create From This Model才会出现） 4.Legacy-旧版动画类型与Unity3.x及更早版本导入和使用动画一般不使用: Generation：动画导入方法 Don't Import：不导入动画 第2~4个选项：已禁用，勿使用 Store in Root（New）：导入动画将其存储在模型的根节点中 Avatar设置说明： 1.Mapping设置-我们需要在这个页签对模型关节进行映射设置，因为人物动画无非就是改变这些关节的角度： 部位设置：身体，头部，左右手，关节映射信息设置 Mapping选项： Clear：清空映射 AutoMap：自动映射 Load：从文件中读取 Save：保存映射信息 Pose选项： Reset：重置姿势 Sample Bind-Pose：绑定姿势示例 Enforce T-Pose：强制T姿势 2.Muscles&amp;Settings设置： Muscle Group Preview-肌肉群预览：可以在这里预览在不同姿势的旋转变化，用来观察之前的关联映射关系是否合理，主要起到预览作用； Per-Muscle Settings-肌肉设置：，用于设置各骨骼在旋转时的范围限制，因为如果不设置限制，在一些极限角度时会非常奇怪，我们可以在这里单独设置限制范围； Additional Settings-高级设置：可以设置手脚的扭转和伸展值，一般不会修改他们，其中Translation DoF比较重要，如果启用，将启用人形角色的移动动画，如果禁用，Unity仅使用旋转对骨骼进行动画化，但是启用后，会提升性能消耗，因为动画需要执行额外步骤来重定向人形动画，除非动画包含角色某些骨骼的动画式移动才会启用，一般情况下禁用即可； Rig 选项卡 - Unity 手册 (unity3d.com) Animation动画页签1.如何导入外部创建的模型资源：在 Unity 外部创建资源 - Unity 手册 2.使用多个模型文件来导入动画：提取动画剪辑 - Unity 手册 动画基础信息设置Import Constraints-从此资源导入约束：启用后，Unity会自动添加相应的约束组件将其关联到正确的游戏对象 Import Animation-从此资源导入动画：如果禁用，下面的都没有，并且不会导入任何动画； Bake Animations：通过反向动力学（IK）或模拟创建的动画以便推进运动关键帧，仅用于Maya、3Dmax和Cinema4D文件 Anim.Compression：导入动画时使用的压缩类型 Off：禁用动画压缩，在导入时Unity不会减少关键帧数量，效果最好性能较低，文件较大，运行时内存占用也大。通常不建议使用 Keyframe Reduction：减少冗余关键帧，仅适用于Generic通用动画类型 Keyframe Reduction and Compression：减少关键帧并在文件中存储动画时压缩关键帧，会影响文件大小，但是内存大小和Keyframe Reduction相同，仅适用于Legacy旧版动画类型 Optimal：让Unity决定如何压缩，仅适用Generic通用和Humanoid人形动画类型 Rotation Error：设置旋转曲线压缩容错度（百分比），原始旋转值和减小值之间的最小角度 Position Error：设置位置曲线压缩容错度（百分比） Scale Error：设置缩放曲线压缩容错度（百分比） （如果原始值和消减值之间的差小于原始值乘以容错百分比，会删除关键帧）这些内容仅在Keyframe Reduction或Optimal压缩时可用； Animated Custom Properties：导入你指定为自定义用户属性的任何FBX属性 动画剪辑选择列表：在这里我们可以看到所有的动画剪辑可以通过+或-来新增剪辑或者删除所选的剪辑，在这里选择一个动画剪辑后，我们可以在下方编辑具体的相关属性信息 动画剪辑属性基本设置动画剪辑属性: 1.动画剪辑名称:可编辑修改 2.时间轴:Start动画剪辑的开始帧,End动画剪辑的结束帧,我们可以在时间轴中定义每个动画剪辑的帧范围; 3.动画重要信心设置: Loop Time：播放动画剪辑时是否循环播放，到结尾时重新开始 Loop Pose：无缝循环运动 Loop Match：循环匹配 Cycle Offset：循环动画在其他时间开始时的周期偏移 Root Transform Rotation：根位置的角度相关 Bake Into Pose：将根旋转烘焙到骨骼移动，禁用此选项将存储为根运动 Based Upon：根旋转的基础 Original：保持源文件中的原始旋转 Root Node Rotation：使用根节点的旋转（仅适用Generic通用动画类型） Body Orientation：保持上半身朝前（仅适用于Humanoid人形动画类型） Offset：根旋转偏移（单位：度） Root Transform Position（Y）：根垂直位置（Y轴方向） Bake Into Pose：将垂直根运动烘焙到骨骼移动。禁用此选项将会存储为根运动 Based Upon（at Start）：垂直方向根位置的基础 Original：保持源文件中的垂直位置 Root Node Position：使用垂直根位置（仅适用Generic通用动画类型） Center Of Mass：保持质心与根位置对其（仅适用Humanoid人形动画类型） Feet（推荐）：保持双脚与根变换位置对齐（仅适用Humanoid人形动画类型） Offset：垂直根位置偏移 Root Transform Position（XZ）：根水平位置（XZ平面） Bake Into Pose：将水平根运动烘焙到骨骼移动。禁用此选项将会存储为根运动 Based Upon：水平根位置的基础 Original：保持源文件中的水平位置 Root Node Position：使用水平根位置（仅适用Generic通用动画类型） Center Of Mass：保持与根位置对其（仅适用Humanoid人形动画类型） Mirror：在此剪辑中进行左右镜像（仅Humanoid人形动画类型才显示） Additive Reference Pose：启用后可以设置附加动画层基础参考姿势的帧。在时间轴中可以看到蓝色标记，附加动画层：在动画控制器（状态机）中可以添加新的动画层： Pose Frame：当启用参考姿势帧时，该项就是选择的具体是哪一帧 动画剪辑属性其它设置其它设置说明: 1.Curves:曲线可以配合Animator作为参数，通过加入曲线值可以利用他标记重要的点,可以修改曲线的名字，名字就类似参数名,可以通过加减来添加或删除曲线信息;(曲线中的值X轴代表标准化时（0~1）代表动画的开始和结尾;Y轴的值可以根据需求自己设置也可以使用下方提供的预设曲线) 2.Events动画事件(不推荐延迟严重):类似之前我们学习的Animation窗口中的动画事件可以在这里为动画剪辑添加一个事件，当动画播放到事件处时会自动找对象脚本中的同名函数,当我们希望在动画某一时刻进行逻辑处理时非常常用,比如某一时刻进行伤害判断 3.Mask动画遮罩:主要作用是当播放该动画时，可以指定哪一部分或者哪些骨骼排除在外不受动作影响,Humanoid（人形动画的快捷设置）,我们分别可以控制,头、左右臂、左右手、左右腿、根等,点击他们让他们变成红色，就代表做该动作时不影响该部位,Transform（明确指定哪些骨骼关节点不受影响） 4.Motion:当导入的动画剪辑包含根运动时,我们可以在这里手动设置特定骨骼关节点作为我们的根运动节点,展开后看到的都是骨骼关节节点 5.Inport Messages:当我们导入动画出现问题，看到黄色的警告符号时,你可以将 Generate Retargeting Quality Report 选中,Unity会帮我们生成更多的有关重定向问题的具体信息,我们便可以看到具体的一些问题(只有看到警告动画不正确时才启用，可以帮助我们排查问题); Animation 选项卡 - Unity 手册 (unity3d.com) Materials材质纹理页签材质纹理页签说明： Material Creation Mode-定义希望Unity如何为模型生成或导入材质： None：不使用此模型中嵌入的任何材质，改用Unity的默认漫反射材质 Standard：导入时，Unity使用默认规则来生成材质 Import via MaterialDescription（Experimental）：导入时，Unity使用FBX文件中嵌入的材质描述来生成材质；（与Standard相比，该方法结果更准确，并且支持更广泛的材质类型。） sRGB Albedo Colors：是否在伽马空间中使用反射率颜色，对于使用线性颜色控件的项目，禁用此选项； Location：定义如何访问材质和纹理 Use Embedded Materials：将导入的材质保持在导入的资源中 Use External Materials（Legacy）：将导入的材质提取为外部资源。旧版材质处理方式，适用于2017.1或更早的Unity版本创建的项目 Extract Textures/Materials：当选择Use Embedded Materials后会出现的内容。这两个按钮可以提取导入的资源中嵌入的所有材质和纹理。 Naming：定义材质的命名规则 By Base Texture Name：使用导入材质的漫反射纹理名称来命名材质。如果未将漫反射纹理分配给材质，Unity将使用导入材质的名称 From Model's Material：使用导入材质的名称来命名材质 Model Name + Model's Material：使用模型文件的名称与导入材质的名称相结合来命名材质 Search：定义在使用Naming选项定义的名称时查找现有材质的位置规则 Local Materials Folder：在本地Materials材质子文件夹（模型文件所在的同一文件夹）中查找现有材质 Recursive-Up：在所有父文件夹（一直向上追溯到Assets文件夹）中所有Materials子文件夹中查找现有材质 Project-Wide：在所有Unity项目文件夹中查找现有材质 重新映射的材质:如果找到了，Unity会自动关联,如果没有找到，我们可以手动进行关联; Materials 选项卡 - Unity 手册 (unity3d.com) 3D动画Animator Controller - Unity 手册 (unity3d.com) 3D动画使用状态参数状态参数说明 Motion：分配给此状态的动画剪辑 Speed：动画的默认速度 Multiplier：控制速度的乘数，如果要使用需要勾选的Parameter选中配合的参数float类型 Motion Time：运动的时间，如果要使用需要勾选的Parameter选中配合的参数float类型 Mirror：是否为状态生成镜像，仅适用于人形动画，如果要配合参数使用选中旁边的Parameter关联参数，参数是bool类型 Cycle Offset：循环偏移时间，如果要配合参数使用选中旁边的Parameter关联参数，参数是float类型 Foot IK：是否遵循Foot IK，适用于人形人形动画 Write Defaults：AnimatorStates 是否为其运动执行未动画化的属性写回默认值。 Solo：仅播放该过渡 Mute：禁用过渡 Solo和Mute如果一起选择，Mute优先执行 Add Behaviour：添加状态机行为脚本，之后会专门讲解 连线参数连线参数 改名框：可以在这里为动画过渡改名，如果不改，对应的名字就是，\"某一状态名\"-&gt;\"某一状态名\"； Has Exit Time：是否有退出时间，如果勾选，当切换动画时，动画一定是播放到下方的Exit Time（百分比）的时间时才过渡到下一个动画 Exit Time：退出时间，当选择上方的Has Exit Time时，该值决定了过渡生效的确切时间。该值可以大于1，如果小于1，比如0.85，表示当动画播放到了85%的动画时，就会过渡。如果大于1，比如4.5，那么动画将循环4.5次后过渡到下一个动画 Fixed Duration：选中后，下方的Trnaition Duration过渡持续时间将以秒为单位解读过渡时间，如果不选中，则以百分比解读过渡时间 Transition Duration(s/%)：过渡持续时间，相当于从该状态切换到下一状态的过渡动画持续的时间，对应下方两个蓝色箭头包裹区域 Transition Offset：过渡到目标状态的起始播放的时间偏移。如果是0则从目标状态开头开始播放，如果是0.5则从目标状态的一半开始播放，你可以理解为切入下一个状态的切入点； Interruption Source：该过渡中断的情况 None：不在添加任何过渡 Current State：将当前状态过渡排队 Next State：使下一个状态的过渡进行排队 Current State Then Next State：将当前状态的过渡和下一个状态的过渡都依次排队 Next State Thne Current State：将下一状态的过渡和当前状态的过渡依次排队 Ordered Interruption：当前过渡是否可在不考虑顺序的情况下被其它过渡中断 选中时，找到有效过渡或当前过渡时，会中断 不选中时，找到有效过渡，会中断 Conditions：过渡条件（如果没有过渡条件，只会考虑Exit Time） AnyState和动作之间连线 Can Transition To self：是否可以过渡到自己 Preview source state：预览各种过渡状态，可以查看从任意状态切换到当前状态的过渡效果； 动画分层和遮罩动画分层设置： Weight：权重，当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例 Mask：动画遮罩，该层动画全部都会受该遮罩的影响 Blending：混合方式 Override：覆盖方式，播放该层动画时忽略其他层信息 Additive：叠加方式，会和其它层动画叠加播放 Sync：是否同步其它层，主要用于直接从另一个层复制状态过来，在该层中进行修改，适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑（选择后会多一个Source Layer表示你要复制哪一层的状态） Timing：当选中Sync同步其它层时，该参数激活，选中，会采用折中方案调整同步层上的动画时长（基于权重计算），不选中，动画时长将使用原始层做为母版 IK Pass：反向动力学，之后讲解IK的时候再讲解 动画混合1.2D Simple Directional 2D简单定向模式 运动表示不同方向时使用 比如向前、后、左、右走；2.2D Freeform Directional 2D自由形式定向模式 同上 运动表示不同方向时使用 但是可以在同一方向上有多个运动 比如向前跑和走；3.2D Freeform Cartesian 2D自由形式笛卡尔坐标模式 运动不表示不同方向时使用 比如向前走不拐弯 向前跑不拐弯 向前走右转 向前跑右转；4.Direct直接模式 自由控制每个节点权重，一般做表情动作等；5.1D混合是用一个参数控制动画的混合，之所以叫1D是因为一个参数可以看做是1维线性的； 动画IK控制知识点一 什么是IK？ //在骨骼动画中，构建骨骼的方法被称为正向动力学 //它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变 //用我们人体举例子 //当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子 //而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思 //它和正向动力学恰恰相反 //它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转 //用我们人体举例子 //当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动 //用父子骨骼理解的话就是子带动了父 知识点二 如何进行IK控制 //1.在状态机的层级设置中 开启 IK 通道 //2.继承MonoBehavior的类中 // Unity定义了一个IK回调函数:OnAnimatorIK // 我们可以在该函数中调用Unity提供的IK相关API来控制IK //3.Animator中的IK相关API //头部IK相关 //weight:LookAt全局权重0~1 //bodyWeight:LookAt时身体的权重0~1 //headWeight:LookAt时头部的权重0~1 //eyesWeight:LookAt时眼镜的权重0~1 //clampWeight:0表示角色运动时不受限制，1表示角色完全固定无法执行LookAt，0.5表示只能够移动范围的一半 SetLookAtWeight 设置头部IK权重 SetLookAtPosition 设置头部IK看向位置 SetIKPositionWeight 设置IK位置权重 SetIKRotationWeight 设置IK旋转权重 SetIKPosition 设置IK对应的位置 SetIKRotation 设置IK对应的角度 AvatarIKGoal枚举 四肢末端IK枚举 知识点三 关于OnAnimatorIK和OnAnimatorMove两个函数的理解 //我们可以简单理解这两个函数是两个和动画相关的特殊生命周期函数 //他们在Update之后LateUpdate之前调用 //他们会在每帧的状态机和动画处理完后调用 OnAnimatorIK在OnAnimatorMove之前调用 OnAnimatorIK中主要处理 IK运动相关逻辑 OnAnimatorMove主要处理 动画移动以修改根运动的回调逻辑 //他们存在的目的只是多了一个调用时机，当每帧的动画和状态机逻辑处理完后再调用 动画目标匹配知识点一 什么是动画目标匹配 //动画目标匹配主要指的是 //当游戏中角色要以某种动作移动，该动作播放完毕后，人物的手或者脚必须落在某一个地方 //比如：角色需要跳过踏脚石或者跳跃并抓住房梁 //那么这时我们就需要动作目标匹配来达到想要的效果 知识点二 如何实现动画目标匹配 //Unity中的Animator提供了对应的函数来完成该功能 //使用步骤是 //1.找到动作关键点位置信息（比如起跳点，落地点，简单理解就是真正可能产生位移的动画表现部分） //2.将关键信息传入MatchTargetAPI中 //参数一：目标位置 //参数二：目标角度 //参数三：匹配的骨骼位置 //参数四：位置角度权重 //参数五：开始位移动作的百分比 //参数六：结束位移动作的百分比 animator.MatchTarget(targetPos.position, targetPos.rotation, AvatarTarget.RightFoot, new MatchTargetWeightMask(Vector3.one, 1), 0.4f, 0.64f); 知识点三 注意 //调用匹配动画的时机有一些限制 //1.必须保证动画已经切换到了目标动画上 //2.必须保证调用时动画并不是处于过度阶段而真正在播放目标动画 //如果发现匹配不正确，往往都是这两个原因造成的 //3.需要开启Apply Root Motion 状态机行为脚本识点一 状态机行为脚本是什么？ //状态机行为脚本时一类特殊的脚本,继承指定的基类 //它主要用于关联到状态机中的状态矩形上 //我们可以按照一定规则编写脚本 //当进入、退出、保持在某一个特定状态时我们可以进行一些逻辑处理 //简单解释就是为Animator Controller状态机窗口中的某一个状态添加一个脚本 //利用这个脚本我们可以做一些特殊功能 //比如 //1.进入或退出某一状态时播放声音 //2.仅在某些状态下检测一些逻辑，比如是否接触地面等等 //3.激活和控制某些状态相关的特效 知识点二 如何使用状态机脚本 //1.新建一个脚本继承StateMachineBehaviour基类 //2.实现其中的特定方法进行状态行为监听 // OnStateEnter 进入状态时，第一个Update中调用 // OnStateExit 退出状态时，最后一个Update中调用 // OnStateIK OnAnimatorIK后调用 // OnStateMove OnAnimatorMove后调用 // OnStateUpdate 除第一帧和最后一帧，每个Update上调用 // OnStateMachineEnter 子状态机进入时调用，第一个Update中调用 // OnStateMachineExit 子状态机退出时调用，最后一个Update中调用 角色控制器知识点一· 角色控制器的使用 //关键参数 //是否接触了地面 if ( cc.isGrounded ) //关键方法 //受重力作用的移动 cc.SimpleMove(Vector3.forward * 10 * Time.deltaTime); //不受重力作用的移动 cc.Move(Vector3.forward * 10 * Time.deltaTime); //当角色控制器想要判断和别的碰撞器产生碰撞时 使用该函数 private void OnControllerColliderHit(ControllerColliderHit hit) { print(hit.collider.gameObject.name); } UnityEngine.CharacterController - Unity 脚本 API (unity3d.com) 导航寻路","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"}]},{"title":"Unity基础","slug":"03002-Unity基础","date":"2019-09-25T13:00:00.000Z","updated":"2022-03-03T07:46:31.422Z","comments":true,"path":"posts/1538.html","link":"","permalink":"https://wwy.wwywy.com/posts/1538.html","excerpt":"","text":"3D数学数学计算Mathf公共类Math：是C#中封装好的用于数学计算的工具)类) —— 位于System命名空间中；Mathf：是Unity中封装好的用于数学计算的工具)结构体) —— 位于UnityEngine命名空间中，Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法，使用Mathf中的方法用于Unity游戏开发中的数学计算即可； API 知识点三 Mathf中的常用方法——一般计算一次 //1.π - PI print(Mathf.PI); //2.取绝对值 - Abs print(Mathf.Abs(-10)); print(Mathf.Abs(-20)); print(Mathf.Abs(1)); //3.向上取整 - CeilToInt float f = 1.3f; int i = (int)f; print(i); print(Mathf.CeilToInt(f)); print(Mathf.CeilToInt(1.00001f)); //4.向下取整 - FloorToInt print(Mathf.FloorToInt(9.6f)); //5.钳制函数 - Clamp print(Mathf.Clamp(10, 11, 20)); print(Mathf.Clamp(21, 11, 20)); print(Mathf.Clamp(15, 11, 20)); //6.获取最大值 - Max print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8)); print(Mathf.Max(1, 2)); //7.获取最小值 - Min print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123)); print(Mathf.Min(1.1f, 0.4f)); //8.一个数的n次幂 - Pow print(\"一个数的n次方\" + Mathf.Pow(4, 2)); print(\"一个数的n次方\" + Mathf.Pow(2, 3)); //9.四舍五入 - RoundToInt print(\"四舍五入\" + Mathf.RoundToInt(1.3f)); print(\"四舍五入\" + Mathf.RoundToInt(1.5f)); //10.返回一个数的平方根 - Sqrt print(\"返回一个数的平方根\" + Mathf.Sqrt(4)); print(\"返回一个数的平方根\" + Mathf.Sqrt(16)); print(\"返回一个数的平方根\" + Mathf.Sqrt(64)); //11.判断一个数是否是2的n次方 - IsPowerOfTwo print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(4)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(8)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(3)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(1)); //12.判断正负数 - Sign print(\"判断正负数\" + Mathf.Sign(0)); print(\"判断正负数\" + Mathf.Sign(10)); print(\"判断正负数\" + Mathf.Sign(-10)); print(\"判断正负数\" + Mathf.Sign(3)); print(\"判断正负数\" + Mathf.Sign(-2)); 知识点四 Mathf中的常用方法——一般不停计算 //插值运算 - Lerp //Lerp函数公式 result = Mathf.Lerp(start, end, t); //t为插值系数，取值范围为 0~1 result = start + (end - start)*t //插值运算用法一 //每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置 start = Mathf.Lerp(start, 10, Time.deltaTime); //插值运算用法二 //每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果 time += Time.deltaTime; result = Mathf.Lerp(start, 10, time); UnityEngine.Mathf - Unity 脚本 API (unity3d.com) 三角函数1.角度和弧度都是度量角的单位：角度：1°弧度：1 radian圆一周的角度：360°圆一周的弧度：2π radian 2.角度和弧度的转换关系：π rad = 180°1 rad = (180 / π)°=&gt; 1 rad = 180 / 3.14 ≈ 57.3°；1°= (π / 180) rad =&gt; 1°= 3.14 / 180 ≈ 0.01745 rad；由此可以得出弧度 * 57.3 = 对应角度角度 * 0.01745 = 对应弧 3.角度弧度相关API： 知识点一 弧度、角度相互转化 //弧度转角度 float rad = 1; float anger = rad * Mathf.Rad2Deg; //角度转弧度 anger = 1; rad = anger * Mathf.Deg2Rad; 知识点二 三角函数)可以让物体做曲线运动) //注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 知识点三 反三角函数 //注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 rad = Mathf.Asin(0.5f); print(rad * Mathf.Rad2Deg); rad = Mathf.Acos(0.5f); print(rad * Mathf.Rad2Deg); 坐标系说明1.世界坐标系：原点：世界的中心点轴向：世界坐标系的三个轴向是固定的 2.物体坐标系：原点：物体的中心点)建模时决定)轴向：物体右方为x轴正方向物体上方为y轴正方向物体前方为z轴正方向 3.屏幕坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向最大宽高：Screen.widthScreen.height 4.视口坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向特点：左下角为)0,0)右上角为)1,1)和屏幕坐标类似，将坐标单位化 汇总 知识点一 世界坐标系 //目前学习的和世界坐标系相关的 //this.transform.position; //this.transform.rotation; //this.transform.eulerAngles; //this.transform.lossyScale(全局缩放大小，只能得); //修改他们 会是相对世界坐标系的变化 知识点二 物体坐标系 //相对父对象的物体坐标系的位置 本地坐标 相对坐标 //this.transform.localPosition; //this.transform.localEulerAngles; //this.transform.localRotation; //this.transform.localScale; //修改他们 会是相对父对象物体坐标系的变化 知识点三 屏幕坐标系 //Input.mousePosition //Screen.width; //Screen.height; 知识点四 视口坐标系 //摄像机上的 视口范围 坐标转换相关 //世界转本地 //this.transform.InverseTransformDirection //this.transform.InverseTransformPoint //this.transform.InverseTransformVector //本地转世界 //this.transform.TransformDirection //this.transform.TransformPoint //this.transform.TransformVector //世界转屏幕 //Camera.main.WorldToScreenPoint //屏幕转世界 //Camera.main.ScreenToWorldPoint //世界转视口 //Camera.main.WorldToViewportPoint //视口转世界 //Camera.main.ViewportToWorldPoint //视口转屏幕 //Camera.main.ViewportToScreenPoint //屏幕转视口 //Camera.main.ScreenToViewportPoint; Vector3向量UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 向量模长和单位向量1.标量：有数值大小，没有方向 2.向量：有数值大小，有方向的矢量 3.两点决定一向量：A点：(Xa,Ya,Za)B点：(Xb,Yb,Zb)从A指向B的向量为AB向量B-A = (Xb-Xa, Yb-Ya, Zb-Za)从B指向A的向量为BA向量A-B = (Xa-Xb, Ya-Yb, Za-Zb)口诀：终点减起点 4.零向量和负向量：零向量(0,0,0)零向量是唯一一个大小为0的向量负向量(x,y,z)的负向量为(-x,-y,-z)负向量和原向量大小相等负向量和原向量方向相反 5.向量的模长：向量的模长就是向量的长度向量是由两个点算出，所以向量的模长就是两个点的距离模长公式：A向量(x,y,z)模长 = √x² + y² + z² 6.单位向量：模长为1的向量为单位向量任意一个向量经过归一化就是单位向量只需要方向，不想让模长影响计算结果时使用单位向量归一化公式：A向量(x,y,z)模长 = √x² + y² + z²单位向量 = (x/模长, y/模长, z/模长) 7.向量模长和单位向量相关API： 知识点一 向量 //三维向量 - Vector3 //Vector3有两种几何意义 //1.位置 —— 代表一个点 print(this.transform.position); //2.方向 —— 代表一个方向 print(this.transform.forward); print(this.transform.up); Vector3 v = new Vector3(1, 2, 3); Vector2 v2 = new Vector2(1, 2); 知识点二 两点决定一向量 //A和B此时 几何意义 是两个点 Vector3 A = new Vector3(1, 2, 3); Vector3 B = new Vector3(5, 1, 5); //求向量 //此时 AB和 BA 他们的几何意义 是两个向量 Vector3 AB = B - A; Vector3 BA = A - B; 知识点三 零向量和负向量 print(Vector3.zero); print(Vector3.forward); print(-Vector3.forward); 知识点四 向量的模长 //Vector3中提供了获取向量模长的成员属性 //magnitude print(AB.magnitude); Vector3 C = new Vector3(5, 6, 7); print(C.magnitude); print(Vector3.Distance(A, B)); 知识点五 单位向量 //Vector3中提供了获取单位向量的成员属性 //normalized print(AB.normalized); print(AB / AB.magnitude); 总结 //模长相当于可以得到 两点之间的距离 单位向量 主要是用来进行移动计算的 它不会影响我们想要的移动效果 向量加减乘除1.向量加法：向量A + 向量B = (Xa + Xb, Ya + Yb)；位置+位置：两个位置相加没有任何几何意义向量+向量：两个向量相加得到一个新向量；向量 + 向量 = 向量)向量相加，首尾相连)位置+向量：位置加向量得到一个新位置；位置 + 向量 = 位置；向量 + 位置 = 位置)位置和向量相加=平移位置) 2.向量减法向量A - 向量B = (Xa - Xb, Ya - Yb, Za);位置-位置：两个位置相减得到一个新向量；位置 - 位置 = 向量)两点决定一向量，终点 - 起点)；向量-向量：两个向量相减得到一个新向量；向量 - 向量 = 向量)向量相减，头连头，尾指尾，A - B = B头指A头)；位置-向量：位置减向量相当于 加负向量；位置 + (-向量)=位置)位置减向量 = 平移位置)；向量-位置：向量减位置没有任何几何意义 3.向量乘除向量只会和标量进行乘除法运算向量A标量a = (xa, ya, za);向量A/标量a = (x/a, y/a, z/a);向量 *or/ 标量 = 向量;向量 *or/ 正数，方向不变，放大缩小模长;向量 *or/ 负数，方向相反，放大缩小模长;向量 * 0，得到零向量; 4.知识点： 知识点一 向量加法 //this.transform.position += new Vector3(1, 2, 3); this.transform.Translate(Vector3.forward * 5); 知识点二 向量减法 //this.transform.position -= new Vector3(1, 2, 3); this.transform.Translate(-Vector3.forward * 5); 知识点三 向量乘除标量 this.transform.localScale *= 2; this.transform.localScale /= 2; 向量点乘1.点乘计算公式：向量A·向量B = XaXb + YaYb + Za*Zb=标量；点乘可以得到一个向量：在自己向量上投影的长度)我们可以用这个规律判断敌方的大致方位)；点乘结果 &gt; 0 两个向量夹角为锐角；点乘结果 = 0 两个向量夹角为直角；点乘结果 &lt; 0 两个向量夹角为钝； 2.公式推导：Cosβ = 直角边 / 单位向量B模长直角边 = Cosβ * 单位向量B模长)直角边 = 单位向量A · 单位向量B);↓Cosβ * 单位向量B模长 = 单位向量A · 单位向量B;↓Cosβ = 单位向量A · 单位向量B;↓推出结果：β = Acos(单位向量A · 单位向量B); 3.点乘API 知识点一 通过点乘判断对象方位)判断前后) //Vector3 提供了计算点乘的方法 Debug.DrawRay(this.transform.position, this.transform.forward, Color.red); Debug.DrawRay(this.transform.position, target.position - this.transform.position, Color.red); //得到两个向量的点乘结果 //向量 a 点乘 AB 的结果 float dotResult = Vector3.Dot(this.transform.forward, target.position - this.transform.position); if( dotResult &gt;= 0 ) { print(\"它在我前方\"); } else { print(\"它在我后方\"); } 知识点二 通过点乘推导公式算出夹角)判断夹角，但是夹角为0-180之间，不能判断左右) //步骤 //1.用单位向量算出点乘结果 dotResult = Vector3.Dot(this.transform.forward, (target.position - this.transform.position).normalized); //2.用反三角函数得出角度 print(\"角度-\" + Mathf.Acos(dotResult) * Mathf.Rad2Deg); //Vector3中提供了 得到两个向量之间夹角的方法 print(\"角度2-\" + Vector3.Angle(this.transform.forward, target.position - this.transform.position)); 向量叉乘1.叉乘计算公式：向量A x 向量B = (YaZb - ZaYb,ZaXb - XaZb,XaYb - YaX)=向量； 2.几何意义A x B 得到的向量同时垂直A和B；A x B 向量垂直于A和B组成的平面；A x B = -(B x A)； 3.叉乘API 知识点一 叉乘计算 print(Vector3.Cross(A.position, B.position)); 知识点二 叉乘几何意义 //假设向量 A和B 都在 XZ平面上 //向量A 叉乘 向量 B //y大于0 证明 B在A右侧 //y小于0 证明 B在A左侧 Vector3 C = Vector3.Cross(A.position, B.position); if( C.y &gt; 0) { print(\"B在A的右侧\"); } else { print(\"B在A的左侧\"); } 向量插值运算插值API: 知识点一 线性插值 //公式result = start + (end - start) * t //1.先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置 A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); //2.匀速 每帧改变时间 当t&gt;=1时 得到结果 //这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 //应该相当于Vector3.MoveToWards() if(nowTarget != target.position) { nowTarget = target.position; time = 0; startPos = B.position; } time += Time.deltaTime; B.position = Vector3.Lerp(startPos, nowTarget, time); 知识点二 球形插值 //做弧线运动，可以做弓箭射击，太阳东升西落 C.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up*0.1f, time*0.01f); Quaternion四元数UnityEngine.Quaternion - Unity 脚本 API (unity3d.com) 为什么使用四元数1.欧拉角)transform.eulerAngles)：由三个角度(x,y,z)组成，遵守heading-pitch-bank旋转序列约定)heading:物体绕自身的对象坐标系的Y轴，旋转的角度；pitch:物体绕自身的对象坐标系的X轴，旋转的角度；bank:物体绕自身的对象坐标系的Z轴，旋转的角度)；1.1.优点：直观、易理解；存储空间小)三个数表示)；可以进行从一个方向到另一个方向旋转大于180度的角度；1.2缺点：同一旋转的表示不唯一；万向节死锁； 2.万向节死锁：当某个特定轴达到某个特殊值时，绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度；Unity中X轴达到90度时，会产生万向节死锁； 四元数是什么1.轴-角对：在3D空间中，任意旋转都可以表示，绕着某个轴旋转一个旋转角得到； 2.四元数：对于给定旋转，假设为绕着n轴，旋转β度，n轴为(x,y,z)；四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z]； 3.四元数基本API 知识点一 四元数 Quaternion //四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z] //计算原理 //Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); //提供的轴角对 初始化 四元数的方法 Quaternion q = Quaternion.AngleAxis(60, Vector3.right); 知识点二 四元数和欧拉角转换 //1.欧拉角转四元数 Quaternion q2 = Quaternion.Euler(60, 0, 0); GameObject obj2 = GameObject.CreatePrimitive(PrimitiveType.Cube); obj2.transform.rotation = q2; //2.四元数转欧拉角 print(q2.eulerAngles); 知识点三 四元数弥补的欧拉角缺点 //1.同一旋转的表示不唯一 四元数旋转后 转换后的欧拉角 始终是 -180~180度 //2.万向节死锁 通过四元数旋转对象可以避免万向节死锁 //必备知识点：四元数相乘代表旋转四元数 this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up); 四元数常用方法知识点一 单位四元数 print(Quaternion.identity); //testObj.rotation = Quaternion.identity; Instantiate(testObj, Vector3.zero, Quaternion.identity); 知识点二 插值运算 //在四元数中Lerp和Slerp只有一些细微差别 //由于算法不同,Slerp的效果会好一些 //Lerp的效果相比Slerp更快但是如果旋转范围较大效果较差,所以建议使用Slerp进行插值运算 //无限接近 先快后慢 A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime); //匀速变化 time&gt;=1到达目标 time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 识点三 LookRotation //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position); //lookA.rotation = q; lookA.MyLookAt(lookB); 四元数计算知识点一 四元数相乘 //两个四元数相乘得到一个新的四元数,代表两个旋转量的叠加,相当于旋转(旋转相对的坐标系 是物体自身坐标系) Quaternion q = Quaternion.AngleAxis(20, Vector3.up); this.transform.rotation *= q; 知识点二 四元数乘向量 //四元数乘向量返回一个新向量,可以将指定向量旋转对应四元数的旋转量,相当于直接旋转向量 Vector3 v = Vector3.forward; v = Quaternion.AngleAxis(45, Vector3.up) * v; Mono重要内容延迟(延时)函数知识点一 什么是延迟函数 //延迟函数顾名思义 //就是会延时执行的函数 //我们可以自己设定延时要执行的函数和具体延时的时间 //是MonoBehaviour基类中实现好的方法 知识点二 延迟函数的使用 1.延迟函数 //Invoke //参数一：函数名 字符串 //参数二：延迟时间 秒为单位 Invoke(\"DelayDoSomething\", 1); //注意： //1-1.延时函数第一个参数传入的是函数名字符串 //1-2.延时函数没办法传入参数 只有包裹一层 //1-3.函数名必须是该脚本上申明的函数 2.延迟重复执行函数 //InvokeRepeating //参数一：函数名字符串 //参数二：第一次执行的延迟时间 //参数三：之后每次执行的间隔时间 InvokeRepeating(\"DelayRe\", 5, 1); //注意： //它的注意事项和延时函数一致 3.取消延迟函数 //3-1取消该脚本上的所有延时函数执行 CancelInvoke(); //3-2指定函数名取消 //只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消 CancelInvoke(\"DelayDoSomething\"); 4.判断是否有延迟函数 if( IsInvoking()) { print(\"存在延迟函数\"); } if( IsInvoking(\"DelayDoSomething\") ) { print(\"存在延迟函数DelayDoSomething\"); } 知识点三 延迟函数受对象失活销毁影响 //脚本依附对象失活 或者 脚本自己失活 //延迟函数可以继续执行 不会受到影响的 //脚本依附对象销毁或者脚本移除 //延迟函数无法继续执行 协同程序1.Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容(注意：Unity中的多线程 要记住关闭);2.协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿,继承MonoBehavior的类都可以使用协程;3.协程只有当组件单独失活时不受影响，其它情况协程会停止4.API 知识点一 协程的使用 //继承MonoBehavior的类 都可以开启 协程函数 //第一步：申明协程函数 // 协程函数2个关键点 // 1-1返回值为IEnumerator类型及其子类 // 1-2函数中通过 yield return 返回值; 进行返回 //第二步：开启协程函数 //协程函数 是不能够 直接这样去执行的！！！！！！！ //这样执行没有任何效果 //MyCoroutine(1, \"123\"); //常用开启方式 //IEnumerator ie = MyCoroutine(1, \"123\"); //StartCoroutine(ie); Coroutine c1 = StartCoroutine( MyCoroutine(1, \"123\") ); Coroutine c2 = StartCoroutine( MyCoroutine(1, \"123\")); Coroutine c3 = StartCoroutine( MyCoroutine(1, \"123\")); //第三步：关闭协程 //关闭所有协程 //StopAllCoroutines(); //关闭指定协程 //StopCoroutine(c1); 知识点二 yield return 不同内容的含义 //1.下一帧执行 //yield return 数字; //yield return null; //在Update和LateUpdate之间执行 //2.等待指定秒后执行 //yield return new WaitForSeconds(秒); //在Update和LateUpdate之间执行 //3.等待下一个固定物理帧更新时执行 //yield return new WaitForFixedUpdate(); //在FixedUpdate和碰撞检测相关函数之后执行 //4.等待摄像机和GUI渲染完成后执行 //yield return new WaitForEndOfFrame(); //在LateUpdate之后的渲染相关处理完毕后之后 //5.一些特殊类型的对象 比如异步加载相关函数返回的对象 //之后讲解 异步加载资源 异步加载场景 网络加载时再讲解 //一般在Update和LateUpdate之间执行 //6.跳出协程 //yield break; 协同程序原理1.协程的本质 就是利用 C#的迭代器函数”分步执行”的特点+协程调度逻辑 实现的一套分时执行函数的规则; 2.代码实现： 知识点一 协程的本质 //协程可以分成两部分 //1.协程函数本体 //2.协程调度器 //协程本体就是一个能够中间暂停返回的函数 //协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数 //Unity只实现了协程调度部分 //协程的本体本质上就是一个 C#的迭代器方法 知识点二 协程本体是迭代器方法的体现 //1.协程函数本体 //如果我们不通过 开启协程方法执行协程 //Unity的协程调度器是不会帮助我们管理协程函数的 IEnumerator ie = Test(); //但是我们可以自己执行迭代器函数内容 ie.MoveNext();//会执行函数中内容遇到 yield return为止的逻辑 print(ie.Current);//得到 yield return 返回的内容 //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //TestClass tc = ie.Current as TestClass; //print(tc.time); //MoveNext 返回值 代表着 是否到了结尾)这个迭代器函数 是否执行完毕) //2.协程调度器 //继承MonoBehavior后 开启协程 //相当于是把一个协程函数)迭代器)放入Unity的协程调度器中帮助我们管理进行执行 //具体的yield return 后面的规则 也是Unity定义的一些规则 #Resources资源动态加载 Unity中的特殊文件夹知识点一 工程路径获取 //注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用 //我们不会在实际发布游戏后 还使用该路径 //游戏发布过后 该路径就不存在了 print(Application.dataPath); 知识点二 Resources 资源文件夹 //路径获取： //一般不获取 //只能使用Resources相关API进行加载 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Resources\"); //注意： //需要我们自己将创建 //作用： //资源文件夹 //1-1.需要通过Resources相关API动态加载的资源需要放在其中 //1-2.该文件夹下所有文件都会被打包出去 //1-3.打包时Unity会对其压缩加密 //1-4.该文件夹打包后只读 只能通过Resources相关API加载 知识点三 StreamingAssets 流动资源文件夹 //路径获取： print(Application.streamingAssetsPath); //注意： //需要我们自己将创建 //作用： //流文件夹 //2-1.打包出去不会被压缩加密，可以任由我们摆布 //2-2.移动平台只读，PC平台可读可写 //2-3.可以放入一些需要自定义动态加载的初始资源 知识点四 persistentDataPath 持久数据文件夹 //路径获取： print(Application.persistentDataPath); //注意： //不需要我们自己将创建 //作用： //固定数据文件夹 //3-1.所有平台都可读可写 //3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中 知识点五 Plugins 插件文件夹 //路径获取： //一般不获取 //注意： //需要我们自己将创建 //作用： //插件文件夹 //不同平台的插件相关文件放在其中 //比如IOS和Android平台 知识点六 Editor 编辑器文件夹 //路径获取： //一般不获取 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Editor\"); //注意： //需要我们自己将创建 //作用： //编辑器文件夹 //5-1.开发Unity编辑器时，编辑器相关脚本放在该文件夹中 //5-2.该文件夹中内容不会被打包出去 知识点七 默认资源文件夹 Standard Assets //路劲过去： //一般不获取 //注意： //需要我们自己将创建 //作用： //默认资源文件夹 //一般Unity自带资源都放在这个文件夹下 //代码和资源优先被编译 UnityEngine.Application - Unity 脚本 API (unity3d.com) Resources同步加载知识点一 常用资源类型 //1.预设体对象——GameObject)要实例化) //2.音效文件——AudioClip //3.文本文件——TextAsset //4.图片文件——Texture //5.其它类型——需要什么用什么类型 知识点二 资源同步加载 普通方法 //在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 //打包时 Resources文件夹 里的内容 都会打包在一起 //1.预设体对象 想要创建在场景上 记住实例化 // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj = Resources.Load(\"Cube\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj); // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj2 = Resources.Load(\"Sphere\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj2); //2.音效资源 //第一步：就是加载数据 Object obj3 = Resources.Load(\"Music/BKMusic\"); //第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可 audioS.clip = obj3 as AudioClip; audioS.Play(); //3.文本资源 //文本资源支持的格式 //.txt //.xml //.bytes //.json //.html //.csv //..... TextAsset ta = Resources.Load(\"Txt/Test\") as TextAsset; //文本内容 print(ta.text); //字节数据组 //print(ta.bytes); //4.图片 tex = Resources.Load(\"Tex/TestJPG\") as Texture; GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);)(画出图片) //5.其它类型 需要什么类型 就用什么类型就行 //6.问题：资源同名怎么办 //Resources.Load加载同名资源时 无法准确加载出你想要的内容 //可以使用另外的API //6-1加载指定类型的资源 //tex = Resources.Load(\"Tex/TestJPG\", typeof(Texture)) as Texture; ta = Resources.Load(\"Tex/TestJPG\", typeof(TextAsset)) as TextAsset; //print(ta.text); //6-2加载指定名字的所有资源 Object[] objs = Resources.LoadAll(\"Tex/TestJPG\"); 知识点三 资源同步加载 泛型方法 TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(\"Tex/TestJPG\"); print(ta2.text); tex = Resources.Load&lt;Texture&gt;(\"Tex/TestJPG\"); Resources异步加载知识点一 Resources异步加载方法 //注意： //异步加载 不能马上得到加载的资源 至少要等一帧 //1.通过异步加载中的完成事件监听 使用加载的资源 //这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载 //ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); //马上进行一个 资源下载结束 的一个事件函数监听 //rq.completed += LoadOver; print(Time.frameCount); //这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的 //一定要等加载结束过后 才能使用 //rq.asset ×××××××××××× //2.通过协程 使用加载的资源 StartCoroutine(Load()); IEnumerator Load() { //迭代器函数 当遇到yield return时 就会 停止执行之后的代码 //然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时 ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); print(Time.frameCount); //第一部分 //Unity 自己知道 该返回值 意味着你在异步加载资源 //yield return rq; //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码 print(Time.frameCount); //判断资源是否加载结束 while(!rq.isDone) { //打印当前的 加载进度 (0-1浮点型值) print(rq.progress); yield return null; } tex = rq.asset as Texture; } 总结： //1.完成事件监听异步加载 //好处：写法简单 //坏处：只能在资源加载结束后 进行处理 //“线性加载” //2.协程异步加载 //好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新 //坏处：写法稍麻烦 //“并行加载” //注意： //理解为什么异步加载不能马上加载结束，为什么至少要等1帧 //理解协程异步加载的原理 Resources卸载资源知识点一 Resources重复加载资源会浪费内存吗？ //其实Resources加载一次资源过后 //该资源就一直存放在内存中作为缓存 //第二次加载时发现缓存中存在该资源 //会直接取出来进行使用 //所以 多次重复加载不会浪费内存 //但是 会浪费性能)每次加载都会去查找取出，始终伴随一些性能消耗) 知识点二 如何手动释放掉缓存中的资源 //1.卸载指定资源 //Resources.UnloadAsset 方法 //注意： //该方法 不能释放 GameObject对象 因为它会用于实例化对象 //它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等 //一般情况下 我们很少单独使用它 //GameObject obj = Resources.Load&lt;GameObject&gt;(\"Cube\"); //即使是没有实例化的 GameObject对象也不能进行卸载 //Resources.UnloadAsset(obj); //2.卸载未使用的资源 //注意： //一般在过场景时和GC一起使用 Resources.UnloadUnusedAssets(); GC.Collect(); UnityEngine.Resources - Unity 脚本 API (unity3d.com) 场景切换 需要把要加载的场景Build Settings中。 知识点一 场景同步切换 //在切换场景时 //Unity会删除当前场景上所有对象 //并且去加载下一个场景的相关信息 //如果当前场景 对象过多或者下一个场景对象过多 //这个过程会非常的耗时 会让玩家感受到卡顿 SceneManager.LoadScene(\"Lesson20Test\"); 知识点二 场景异步切换 //场景异步加载和资源异步加载 几乎一致 有两种方式 //1.通过事件回调函数 异步加载 //AsyncOperation ao = SceneManager.LoadSceneAsync(\"Lesson20Test\"); //当场景异步加载结束后 就会自动调用该事件函数 我们如果希望在加载结束后 做一些事情 那么久可以在该函数中 //写处理逻辑 //ao.completed += (a) =&gt; //{ // print(\"加载结束\"); //}; //ao.completed += LoadOver; //2.通过协程异步加载 //需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了 //所以 协程中的部分逻辑 可能是执行不了的 //解决思路 //让处理场景加载的脚本依附的对象 过场景时 不被移除 //该脚本依附的对象 过场景时 不会被 移除 DontDestroyOnLoad(this.gameObject); StartCoroutine(LoadScene(\"Lesson20Test\")); IEnumerator LoadScene(string name) { //第一步 //异步加载场景 AsyncOperation ao = SceneManager.LoadSceneAsync(name); //Unity内部的 协程协调器 发现是异步加载类型的返回对象 那么就会等待 //等待异步加载结束后 才会继续执行 迭代器函数中后面的步骤 print(\"异步加载过程中 打印的信息\"); //协程的好处 是异步加载场景时 我可以在加载的同时 做一些别的逻辑 //yield return ao; //第二步 print(\"异步加载结束后 打印的信息\"); //比如 我们可以在异步加载过程中 去更新进度条 //第一种 就是利用 场景异步加载 的进度 去更新 但是 不是特别准确 一般也不会直接用 //while(!ao.isDone) //{ // print(ao.progress); // yield return null; //} //离开循环后 就会认为场景加载结束 //可以把进度条顶满 然后 隐藏进度条 //第二种 就是根据你游戏的规则 自己定义 进度条变化的条件 yield return ao; //场景加载结束 更新20%进度 //接着去加载场景中 的其它信息 //比如 //动态加载怪物 //这时 进度条 再更新20% //动态加载 场景模型 //这时 就认为 加载结束了 进度条顶满 //隐藏进度条 } SceneManagement.SceneManager - Unity 脚本 API (unity3d.com) 画线功能Linerenderer组件知识点一 LineRenderer是什么 //LineRenderer是Unity提供的一个用于画线的组件 //使用它我们可以在场景中绘制线段 //一般可以用于 //1绘制攻击范围 //2武器红外线 //3辅助功能 //4其它画线功能 知识点二ineRender代码相关 //动态添加一个线段 GameObject line = new GameObject(); line.name = \"Line\"; LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;(); //首尾相连 lineRenderer.loop = true; //开始结束宽 lineRenderer.startWidth = 0.02f; lineRenderer.endWidth = 0.02f; //开始结束颜色 lineRenderer.startColor = Color.white; lineRenderer.endColor = Color.red; //设置材质 m = Resources.Load&lt;Material&gt;(\"M\"); lineRenderer.material = m; //设置点 //一定注意 设置点 要 先设置点的个数 lineRenderer.positionCount = 4; //接着就设置 对应每个点的位置 lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0), new Vector3(0,0,5), new Vector3(5,0,5)}); lineRenderer.SetPosition(3, new Vector3(5, 0, 0)); //是否使用世界坐标系 //决定了 是否随对象移动而移动 lineRenderer.useWorldSpace = false; //让线段受光影响 会接受光数据 进行着色器计算 lineRenderer.generateLightingData = true; UnityEngine.LineRenderer - Unity 脚本 API (unity3d.com) 核心系统UnityEngine.Physics - Unity 脚本 API (unity3d.com) 物理系统之范围检测知识点二 如何进行范围检测 //必备条件：想要被范围检测到的对象 必须具备碰撞器 //注意点： //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的 //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已 //范围检测API //1.盒状范围检测 //参数一：立方体中心点 //参数二：立方体三边大小 //参数三：立方体角度 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) print(LayerMask.NameToLayer(\"UI\")); Collider[] colliders = Physics.OverlapBox( Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up), 1 &lt;&lt; LayerMask.NameToLayer(\"UI\") | 1 &lt;&lt; LayerMask.NameToLayer(\"Default\"), QueryTriggerInteraction.UseGlobal); //0000 0001 //0010 0000 //重要知识点： //关于层级 //通过名字得到层级编号 LayerMask.NameToLayer //我们需要通过编号左移构建二进制数 //这样每一个编号的层级 都是 对应位为1的2进制数 //我们通过 位运算 可以选择想要检测层级 //好处 一个int 就可以表示所有想要检测的层级信息 //层级编号是 0~31 刚好32位 //是一个int数 //每一个编号 代表的 都是二进制的一位 //0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1 //1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2 //2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4 //3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8 //4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16 //5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32 //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapBoxNonAlloc() if(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) //2.球形范围检测 //参数一：中心点 //参数二：球半径 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer(\"Default\")); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapSphereNonAlloc if( Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0 ) //3.胶囊范围检测 //参数一：半圆一中心点 //参数二：半圆二中心点 //参数三：半圆半径 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer(\"UI\"), QueryTriggerInteraction.UseGlobal); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapCapsuleNonAlloc if ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders ) != 0 ) 物理系统之射线检测知识点一 射线对象 //1.3D世界中的射线 //假设有一条 //起点为坐标(1,0,0) //方向为世界坐标Z轴正方向的射线 //注意： //理解参数含义 //参数一：起点 //参数二：方向)一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量) //目前只是申明了一个射线对象 对于我们来说 没有任何的用处 Ray r = new Ray(Vector3.right, Vector3.forward); //Ray中的参数 print(r.origin);//起点 print(r.direction);//方向 //2.摄像机发射出的射线 // 得到一条从屏幕位置作为起点 // 摄像机视口方向为 方向的射线 Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition); 知识点三 碰撞检测函数 //Physics类中提供了很多进行射线检测的静态函数 //他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了 //注意： //射线检测也是瞬时的 //执行代码时进行一次射线检测 //1.最原始的射线检测 // 准备一条射线 Ray r3 = new Ray(Vector3.zero, Vector3.forward); // 进行射线检测 如果碰撞到对象 返回true //参数一：射线 //参数二: 检测的最大距离 超出这个距离不检测 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：bool 当碰撞到对象时 返回 true 没有 返回false if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向 if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //2.获取相交的单个物体信息 //物体信息类 RaycastHit RaycastHit hitInfo; //参数一：射线 //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中 //参数三：距离 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal if( Physics.Raycast(r3, out hitInfo, 1000, 1&lt;&lt;LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) ) { //碰撞器信息 print(\"碰撞到物体的名字\" + hitInfo.collider.gameObject.name); //碰撞到的点 print(hitInfo.point); //法线信息 print(hitInfo.normal); //得到碰撞到对象的位置 print(hitInfo.transform.position); //得到碰撞到对象 离自己的距离 print(hitInfo.distance); //RaycastHit 该类 对于我们的意义 //它不仅可以得到我们碰撞到的对象信息 //还可以得到一些 碰撞的点 距离 法线等等的信息 } //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //3.获取相交的多个物体 //可以得到碰撞到的多个对象 //如果没有 就是容量为0的数组 //参数一：射线 //参数二：距离 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //之前的参数一射线 通过两个点传入 hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种函数 返回的碰撞的数量 通过out得到数据 if(Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) &gt; 0 ) UnityEngine.Ray - Unity 脚本 API (unity3d.com) UnityEngine.RaycastHit - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"}]},{"title":"Unity入门","slug":"03001-Unity入门","date":"2019-08-30T13:00:00.000Z","updated":"2022-03-03T07:46:51.352Z","comments":true,"path":"posts/1537.html","link":"","permalink":"https://wwy.wwywy.com/posts/1537.html","excerpt":"","text":"将之前的笔记整理下来 Unity概叙 Unity是一个游戏开发的集成工具，降低了游戏开发的门槛，提高了开发效率。 工程文件夹Assets：工程资源文件夹(美术资源脚本)Library:库文件夹Logs:日志文件夹obj:编译中间文件Packages:包配置信息ProjectSettings:工程设置信息 Unity界面基础Inspector检查窗口：用于设置游戏对象具体信息Console控制台窗口：用于显示调试信息，报错、警告、打印信息等Scene场景窗口：所有游戏对象所在地Hierarchy层级窗口：所有游戏的对象名单Game游戏窗口：玩家看到的游戏画面Project工程窗口：所有游戏资源和脚本内容 Scence场景和Hierarchy层级窗口Hierarchy 我们可以在Hierarchy窗口中创建或拖入各种游戏对象。Hierarchy层级窗口快捷键：F2：对象改名Ctrl+C：复制Ctrl+V：粘贴Ctrl+D：克隆一个Delete：删除 Scence 我们可以在Scene窗口中查看所有游戏对象设置所有游戏对象。窗口上方工具条内容：1.渲染模式2.2D、3D视图切换3.光源、音效、特效显示开启4.辅助线显示5.辅助功能，控制场景上提示图标等6.搜索7.场景轴向 关于Unity中的3D世界坐标轴：红色为X轴正向绿色为Y轴正向蓝色为Z轴正向 以屏幕为参照物：垂直屏幕向内为Z正方向平行屏幕向右为X正方向平行屏幕向上为Y正方向 场景中的操作：左键相关： 鼠标单击：选中单个物体 鼠标框选：选中多个物体 Ctrl+鼠标单击：多选物体 长按ALT键+鼠标左键+移动鼠标：相对观察视口中心点旋转 选中物体之后，按F键：居中显示物体(或者在层级窗口中双击对象) 右键相关： 鼠标右键按下+移动鼠标：旋转视口 鼠标右键按下+WASD：漫游场景 鼠标右键按下+WASD+Shift：快速漫游场景长按ALT键+鼠标右键+移动鼠标：相对屏幕中心点拉近拉远 中键相关：滚动鼠标中间：相对屏幕中心点拉近拉远鼠标中间按下+移动鼠标：平移观察视口长按ALT键+滚动鼠标中间：鼠标指哪就朝哪拉近拉 Game游戏和Project工程Game 游戏画面窗口，玩家能看到的画面内容. Project 工程资源窗口，所有的工程资源都会在该窗口中显示，显示的内容为Assets文件夹中的所有内容. Project工程窗口关键功能:1.窗口设置2.创建相关资源文件3.查找4.按资源类型查找5.按名字查找 资源类型:图片格式：jpg、png、tga模型格式：fbx、max、maya音效：wav、mp3、ogg文本：txt、json、bytes视频：mp4 Inspector检查和Console控制台Inspector 查看场景中游戏对象关联的C#脚本信息. Console 用于查看调试信息的窗口报错、警告、测试打印都可以显示在其中,默认未开启可以在Window——&gt;General中开启或者使用快捷键：Ctrl+Shift+C，该窗口将显示代码编译过程中或者游戏运行过程中的报错、警告、测试信息主要用于查错和调试用。 Console控制台窗口：1.清空控制台2.相同内容折叠显示3.运行时清空4.构建时清空5.报错暂停运行6.是否显示错误信息7.是否显示警告信息8.是否显示打印信息 工具栏和父子关系工具栏从左到右：1.文件操作：新建工程，新建场景，工程打包等等2.编辑操作：对象编辑操作相关，工程设置，引擎设置相关3.资源操作：基本等同于Project窗口中右键相关功能4.对象操作：基本等同于Hierarchy窗口中右键相关功能5.脚本操作：Unity自带的脚本，可以添加各系统中的脚本7.窗口：可以打开Unity各核心系统的窗口9.帮助：检查更新，查看版本等等功能 File中的重要选项：BuildSetting(工程发布打包)Edit中的重要选项：Project Setting(工程各系统设置)、Preferences(首选项，可以设置编程软件)、GameObject中的重要选项：MoveToView、Align With View、Align View to Selected(几种快捷设置位置的功能) 父子关系 对象之间产生父子关系后，如何相互影响？爸爸干嘛，儿子干嘛；儿子干嘛，爸爸不管。Scene上方作用：pivot：以本身为中心点；center：以整体为中心点；local：以本身旋转为朝向；global：以世界坐标为朝向； Unity工作原理 使用它时是处于运行中的，我们是在一个运行中的软件里制作游戏的，Unity开发的本质就是在Unity引擎的基础上,利用反射和引擎提供的各种功能进行的拓展开发。 反射机制和游戏场景反射机制的体现：除了Transform这个表示位置的标配剧本外，我们可以为这个演员(GameObject)关联各种剧本(C#脚本)，让它按照我们剧本中(代码逻辑中)的命令来处理事情，而为演员添加剧本的这个过程，就是在利用反射new一个新的剧本对，象和演员(GameObject)对象进行关联，让其按我们的命令做事； 利用反射举例体现：1.修改Inspector面板中Transform的内容：已知对象，类名，变量名，通过反射为该对象设置变量值；2.新建一个脚本后，添加给一个指定的GameObject对象：已知类名，可以获取所有公共成员，故可以在Inspector面板上创建各公共字段信息 游戏场景的本质：游戏场景文件后缀为.unity，它的本质就是一个配置文件，Unity有一套自己识别处理它的机制，但是本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象； 预设物和资源包的导入导出后缀名：.prefab，Prefabs放该类型文件;预制物删除变红处理：点击预制物右键Unpack Prefab;Project右键：导入导出包(.unitypackage); Unity脚本基础默认脚本内容：Editor\\Data\\Resources\\ScriptTemplates 脚本基本规则1.创建规则： 1.不在VS中创建脚本了 2.可以放在Assets文件夹下的任何位置(建议同一文件夹管理) 3.类名和文件名必须一致,不然不能挂载(因为反射机制创建对象，会通过文件名去找Type) 4.建议不要使用中文名命名 5.没有特殊需求 不用管命名空间 6.创建的脚本默认继承MonoBehavior 2.MonoBehavior基类： 1.创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 2.继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 3.继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 4.继承了MonoBehavior的脚本可以在一个对象上挂多个(如果没有加DisallowMultipleComponent特性) 5.继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 3.不继承MonoBehavior的类 1.不继承Mono的类 不能挂载在GameObject上 2.不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 3.不继承Mono的类 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据) 4.不继承Mono的类 不用保留默认出现的几个函数 生命周期函数总结：这些生命周期函数 如果你不打算在其中写逻辑 那就不要使用这些命周期函数。我们要知道，虽然建议大家不在继承MonoBehavior的类中写构造函数；但是不意味着我们不能写，当我们在继承MonoBehavior的类中写无参构造函数时，你会发现在编辑模式下或者运行后，只要该脚本挂载在场景中，那么该无参构造函数是会被自动执行的。因为Unity的工作原理中提到的反射机制，Unity实际上通过反射帮助我们实例化了该脚本对象，既然要实例化那么肯定是需要new的，只不过Unity中不需要我们自己new继承了MonoBehavior的类，只要挂载后Unity帮助我们做了这件事。那么为什么不建议大家写构造函数呢？1.Unity的规则就是，继承MonoBehavior的脚本不能new只能挂载2.生命周期函数的Awake是类似构造函数的存在，当对象出生就会自动调用3.写构造函数反而在结构上会破坏Unity设计上的规范 打印方式：普通：Debug.Log(“123”);报错：Debug.LogError(“出错了！！！！！”);警告：Debug.LogWarning(“警告！！！”); Inspector窗口可编辑变量知识点一: 私有和保护无法显示编辑，公共的可以显示编辑；知识点二 ：[SerializeField]让私有的和保护的也可以被显示；知识点三：[HideInInspector]公共的也不让其显示编辑；知识点四：[System.Serializable] 让自定义类型可以被访问；//加在类前，而字典怎么都不行知识点七： 辅助特性1.[Header(“分组说明”)] ：分组说明特性，为成员分组；2.[Tooltip(“说明内容”)] //悬停注释，为变量添加说明；3.[Space()]：间隔特性，让两个字段间出现间隔4.[Range(最小值, 最大值)] //修饰数值的滑条范围；5.[TextArea(3, 4)] ：滚动条显示字符串，默认不写参数就是超过3行显示滚动条；6.[ContextMenuItem(“显示按钮名”, “方法名”)] ：为变量添加快捷方法，参数1 显示按钮名，参数2 方法名 不能有参数；7.[Multiline(4)] ：多行显示字符串 默认不写参数显示3行8.[ContextMenu(“测试函数”)] ：方法添加特性能够在Inspector中执行 继承自MonoBehavior重要内容重要成员1.获取依附的GameObject：this.gameObject;2.获取依附的GameObject的位置信息：-print(this.transform.position);//位置-print(this.transform.eulerAngles);//角度-print(this.transform.lossyScale);//缩放大小3.获取脚本是否激活： this.enabled； 重要方法1:得到依附对象上挂载的其它脚本 //1.得到自己挂载的单个脚本,获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空 this.GetComponent(\"脚本名\"); //2.得到自己挂载的多个脚本 this.GetComponents&lt;泛形类型&gt;(); //3.得到子对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) //函数是有一个参数的 默认不传 是false 意思就是 如果子对象失活 是不会去找这个对象上是否有某个脚本的 //如果传true 及时 失活 也会找 //得子对象 挂载脚本 单个 this.GetComponentInChildren&lt;泛形类型&gt;(true); this.GetComponentsInChildren&lt;泛形类型&gt;(true); //4.得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) this.GetComponentInParent&lt;泛形类型&gt;(); this.GetComponentsInParent&lt;泛形类型&gt;(); //5.尝试获取脚本 //提供了一个更加安全的 获取单个脚本的方法 如果得到了 会返回true //然后在来进行逻辑处理即可 this.TryGetComponent&lt;泛形类型&gt;(out 赋值变量) Unity重要组件和APIGameObject最小单位直接实例化：new GameObject(“实体名”，typeof(要添加的组件名)…….) ； 注意事项：1.建议使用Destroy方法，它是异步的，不会马上删除对象，只是给对象加一个标识，一般情况下下一帧才会把对象从内存一处。；2.如果继承自mono，可以省略GameObject字段；3.对象失活也是可以用一些方式获取的；4.广播方法效率很低，不建议使用； 知识点一 GameObject中的成员变量 //名字 print(this.gameObject.name); this.gameObject.name = \"Lesson4唐老狮改名\"; print(this.gameObject.name); //是否激活 print(this.gameObject.activeSelf); //是否是静态 print(this.gameObject.isStatic); //层级 print(this.gameObject.layer); //标签 print(this.gameObject.tag); transform this.transform 上一节课讲解的 通过Mono去得到的依附对象的GameObject的位置信息 //他们得到的信息是一样 都是依附的GameObject的位置信息 print(this.gameObject.transform.position); 知识点二 GameObject中的静态方法 //创建自带几何体 //只要得到了一个GameObject对象 我就可以得到它身上挂在的任何脚本信息 //通过obj.GetComponent来得去 GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.name = \"唐老狮创建的立方体\"; //查找对象相关的知识 //两种找单个对象的共同点: //1.无法找到失活的对象的 // 只能找到 激活的对象 //2.如果场景中 存在多个满足条件的对象 // 我们无法准确确定找到的是谁 //1查找单个对象 //通过对象名查找 //这个查找效率比较低下 因为他会在场景中的所有对象去查找 //没有找到 就会返回null GameObject obj2 = GameObject.Find(\"唐老狮\"); //通过tag来查找对象 GameObject obj3 = GameObject.FindWithTag(\"Player\"); //和上面的方法一样，名字不一样而已 GameObject obj3 = GameObject.FindGameObjectWithTag(\"Player\"); //得到某一个单个对象 目前有2种方式了 //1.是public从外部面板拖 进行关联 //2.通过API去找 //2查找多个对象 //找多个对象的API 只能是通过tag去找多个 通过名字 是没有找多个的方法的 //通过tag找到多个对象 //它也是 只能找到 激活对象 无法找到失活对象 GameObject obj3 = GameObject.FindGameObjectsWithTag(\"Player\"); //还有几个查找对象相关是用的比较少的方法 是GameObject父类 Object提供的方法 //引出额外知识点 Unity中的Object和C#中的万物之父的区别 //Unity里面的Object 不是指的万物之父object //Unity里的Object 命名空间在UnityEngine中的 Object类 也是集成万物之父的一个自定义类 //C#中的Object 命名空间是在System中的 //它可以找到场景中挂载的某一个脚本对象 //效率更低 上面的GameObject.Find 和通过FindWithTag找 只是遍历对象 //这个方法 不仅要遍历对象 还要遍历对象上挂载的脚本 Lesson4 o = GameObject.FindObjectOfType&lt;Lesson4&gt;(); print(o.gameObject.name); //实例化对象(克隆对象)的方法 //实例化(克隆)对象 它的作用 是根据一个GameObject对象 创建出一个和它一模一样的对象 GameObject obj5 = GameObject.Instantiate(myObj); //以后学了更多知识点 就可以在这操作obj5 //如果你继承了 MonoBehavior 其实可以不用写GameObject一样可以使用 //因为 这个方法时Unity里面的 Object基类提供给我们的 所以可以直接用 Instantiate(myObj); //删除对象的方法 GameObject.Destroy(myObj2); //第二个参数 代表延迟几秒钟删除 GameObject.Destroy(obj5, 5); Destroy不仅可以删除对象 还可以删除脚本 GameObject.Destroy(this); //删除对象有两种作用 //1.是删除指定的一个游戏对象 //2.是删除一个指定的脚本对象 //注意：这个Destroy方法 不会马上移除对象 只是给这个对象加了一个移除标识 // 一般情况下 它会在下一帧时把这个对象移除并从内存中移除 //如果没有特殊需求 就是一定要马上移除一个对象的话 //建议使用上面的 Destroy方法 因为 是异步的 降低卡顿的几率 //下面这个方法 就是立即把对象 从内存中移除了 GameObject.DestroyImmediate(myObj); //如果是继承MonoBehavior的类 不用写GameObject Destroy(myObj2); DestroyImmediate(myObj); //过场景不移除 //默认情况 在切换场景时 场景中对象都会被自动删除掉 //如果你希望某个对象 过场景不被移除 //下面这句代码 就是不想谁过场景被移除 就传谁 //一般都是传 依附的GameObject对象 //比如下面这句代码的意思 就是自己依附的GameObject对象 过场景不被删除 GameObject.DontDestroyOnLoad(this.gameObject); //如果继承MOnoBehavior也可以直接写 DontDestroyOnLoad(this.gameObject); 知识点三 GameObject中的成员方法 //创建空物体 //new一个GameObject就是在创建一个空物体 GameObject obj6 = new GameObject(); GameObject obj7 = new GameObject(\"唐老狮创建的空物体\"); GameObject obj8 = new GameObject(\"顺便加脚本的空物体\", typeof(Lesson2),typeof(Lesson1)); //为对象添加脚本 //继承MOnoBehavior的脚本 是不能够去new //如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上 //直接使用GameObject提供的方法即可 Lesson1 les1 = obj6.AddComponent(typeof(Lesson1)) as Lesson1; //用泛型更方便 Lesson2 les2 = obj6.AddComponent&lt;Lesson2&gt;(); //通过返回值 可以得到加入的脚本信息 //来进行一些处理 //得到脚本的成员方 和继承Mono的类得到脚本的方法 一模一样 //标签比较 //下面两种比较的方法 是一样的 if(this.gameObject.CompareTag(\"Player\")) { print(\"对象的标签 是 Player\"); } if(this.gameObject.tag == \"Player\") { print(\"对象的标签 是 Player\"); } //设置激活失活 //false 失活 true 激活 obj6.SetActive(false); obj7.SetActive(false); obj8.SetActive(false); //次要的成员方法 了解即可 不建议使用 //强调 //下面讲的方法 都不建议大家使用 效率比较低 //通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法 //通知自己 执行什么行为 //命令自己 去执行这个TestFun这个函数 会在自己身上挂在的所有脚本去找这个名字的函数 //它会去找到 自己身上所有的脚本 有这个名字的函数去执行 this.gameObject.SendMessage(\"TestFun\"); this.gameObject.SendMessage(\"TestFun2\", 199); //广播行为 让自己和自己的子对象执行 this.gameObject.BroadcastMessage(\"函数名\"); //向父对象和自己发送消息 并执行 this.gameObject.SendMessageUpwards(\"函数名\"); UnityEngine.GameObject - Unity 脚本 API (unity3d.com) Time时间相关作用：主要 用于游戏中参与位移、记时、时间暂停等；重要内容: //知识点一 时间缩放比例 //时间停止 Time.timeScale = 0; //回复正常 Time.timeScale = 1; //2倍速 Time.timeScale = 2; //知识点二 帧间隔时间 //帧间隔时间 主要是用来计算位移 //路程 = 时间*速度 //根据需求 选择参与计算的间隔时间 //如果希望 游戏暂停时就不动的 那就使用 Time.deltaTime; //如果希望 不受暂停影响 Time.unscaledDeltaTime; //帧间隔时间：最近的一帧 用了多长时间(秒) //受scale影响 print(\"帧间隔时间\" + Time.deltaTime); //不受scale影响的帧间隔时间 print(\"不受scale影响的帧间隔时间\" + Time.unscaledDeltaTime); 知识点三 游戏开始到现在的时间 //它主要用来计时 单机游戏中计时 //受scale影响 print(\"游戏开始到现在的时间:\" + Time.time); //不受scale影响 print(\"不受scale影响的游戏开始到现在的时间:\" + Time.unscaledTime); 知识点四 物理帧间隔时间 FixedUpdate //受scale影响 Time.fixedDeltaTime; //不受scale影响 Time.fixedUnscaledDeltaTime; 知识点五 帧数 //从开始到现在游戏跑了多少帧(次循环) print(Time.frameCount); UnityEngine.Time - Unity 脚本 API (unity3d.com) Transform-位置和位移Vector3常用： //常用变量 print(Vector3.zero);//000 print(Vector3.right);//100 print(Vector3.left);//-100 print(Vector3.forward);//001 print(Vector3.back);//00-1 print(Vector3.up);//010 print(Vector3.down);//0-10 //常用方法 (后续加) //计算两个点之间的距离的方法 print(Vector3.Distance(v1, v12)); //返回float 两个向量之间的角度(以度为单位) Vector3.Angle(); UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 位置(注意：位置的赋值不能直接改变x，y，z 只能整体改变)位移方式： //知识点一：位置 //相对世界坐标系 this.gameObject.transform； //相对父对象 this.transform.localPosition； //世界正朝向 Vector3.forwad; //本身正朝向 transform.forward； //知识点二 位移 //坐标系下的位移计算公式：路程 = 方向 * 速度 * 时间 //方式一 自己计算 //想要变化的 就是 position //用当前的位置 + 我要动多长距离 得出最终所在的位置 this.transform.position = this.transform.position + this.transform.up * 1 * Time.deltaTime; //因为我用的是 this.transform.forward 所以它始终会朝向相对于自己的面朝向去动 this.transform.position += this.transform.forward * 1 * Time.deltaTime; //方向非常重要 因为 它决定了你的前进方向 this.transform.position += Vector3.forward * 1 * Time.deltaTime; //方式二 API //参数一：表示位移多少 路程 = 方向 * 速度 * 时间 //参数二：表示 相对坐标系 默认 该参数 是相对于自己坐标系的 //1相对于世界坐标系的 Z轴 动 始终是朝 世界坐标系 的 Z轴正方向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); //2相对于世界坐标的 自己的面朝向去动 始终朝自己的面朝向移动 this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World); //3相对于自己的坐标系 下的 自己的面朝向向量移动 (一定不会这样让物体移动) XXXXXXX this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.Self); //4相对于自己的坐标系 下的 Z轴正方向移动 始终朝自己的面朝向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self); UnityEngine.Transform - Unity 脚本 API (unity3d.com) Tramsfrom-角度和旋转知识点一 角度相关 相对世界坐标角度：transform.eulerAngles； 相对父对象角度：transform.localEulerAngles； 知识点二 旋转相关 //自己计算(省略 和位置一样 不停改变角度即可) //API计算 //自转 //每个轴 具体转多少度 //第一个参数 相当于 是旋转的角度 每一帧 //第二个参数 默认不填 就是相对于自己坐标系 进行的旋转 this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime); this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World); //相对于某个轴 转多少度 //参数一：是相对哪个轴进行转动 //参数二：是转动的 角度 是多少 //参数三：默认不填 就是相对于自己的坐标系 进行旋转 // 如果填 可以填写相对于 世界坐标系进行旋转 this.transform.Rotate(Vector3.right, 10 * Time.deltaTime); this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World); //相对于某一个点转 //参数一：相当于哪一个点 转圈圈 //参数二：相对于那一个点的 哪一个轴转圈圈 //参数三：转的度数 旋转速度 * 时间 this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime); Transfrom-缩放和看向知识点一 缩放 //相对世界坐标系 print(this.transform.lossyScale); //相对本地坐标系(父对象) print(this.transform.localScale); //注意： //1.同样缩放不能只改xyz 只能一起改(相对于世界坐标系的缩放大小只能得 不能改) //所以 我们一般要修改缩放大小 都是改的 相对于父对象的 缩放大小 localScale this.transform.localScale = new Vector3(3, 3, 3); //2.Unity没有提供关于缩放的API //之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有 //如果你想要 让 缩放 发生变化 只能自己去写(自己算) this.transform.localScale += Vector3.one * Time.deltaTime; 知识点二 看向 //让一个对象的面朝向 可以一直看向某一个点或者某一个对象 //看向一个点 相对于世界坐标系的 this.transform.LookAt(Vector3.zero); //看向一个对象 就传入一个对象的 Transform信息 this.transform.LookAt(lookAtObj); Transfrom-父子关系知识点一 获取和设置父对象 //获取父对象 print(this.transform.parent.name); //设置父对象 断绝父子关系 this.transform.parent = null; //设置父对象 认爸爸 this.transform.parent = GameObject.Find(\"Father2\").transform; //通过API来进行父子关系的设置 this.transform.SetParent(null);//断绝父子关系 this.transform.SetParent(GameObject.Find(\"Father2\").transform);//认爸爸 //参数一：我的父亲 //参数二：是否保留世界坐标的 位置 角度 缩放 信息 // true 会保留 世界坐标下的状态 和 父对象 进行计算 得到本地坐标系的信息 // false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 this.transform.SetParent(GameObject.Find(\"Father3\").transform, false); 知识点二 抛妻弃子 //就是和自己的所有儿子 断绝关系 没有父子关系了 this.transform.DetachChildren(); 知识点三 获取子对象 //按名字查找儿子 //找到儿子的 transform信息 //Find方法 是能够找到 失活的对象的 ！！！！！ GameObject相关的 查找 是不能找到失活对象的 print(this.transform.Find(\"Cube (1)\").name); //他只能找到自己的儿子 找不到自己的孙子 ！！！！！！ print(this.transform.Find(\"GameObject\").name); //虽然它的效率 比GameObject.Find相关 要高一些 但是 前提是你必须知道父亲是谁 才能找 //遍历儿子 //如何得到有多少个儿子 //1.失活的儿子也会算数量 //2.找不到孙子 所以孙子不会算数量 print(this.transform.childCount); //通过索引号 去得到自己对应的儿子 //如果编号 超出了儿子数量的范围 那会直接报错的 //返回值 是 transform 可以得到对应儿子的 位置相关信息 this.transform.GetChild(0); 知识点四 儿子的操作 //判断自己的爸爸是谁 //一个对象 判断自己是不是另一个对象的儿子 if(son.IsChildOf(this.transform)) { print(\"是我的儿子\"); } //得到自己作为儿子的编号 print(son.GetSiblingIndex()); //把自己设置为第一个儿子 son.SetAsFirstSibling(); //把自己设置为最后一个儿子 son.SetAsLastSibling(); //把自己设置为指定个儿子 //就算你填的数量 超出了范围(负数或者更大的数) 不会报错 会直接设置成最后一个编号 son.SetSiblingIndex(1); Transfrom-坐标转换知识点一 世界坐标转本地坐标 print(Vector3.forward); //世界坐标系 转本地坐标系 可以帮助我们大概判断一个相对位置 //世界坐标系的点 转换 为相对本地坐标系的点 //受到缩放影响 print(\"转换后的点 \" + this.transform.InverseTransformPoint(Vector3.forward)); //世界坐标系的方向 转换 为相对本地坐标系的方向 //不受缩放影响 print(\"转换后的方向\" + this.transform.InverseTransformDirection(Vector3.forward)); //受缩放影响 print(\"转换后的方向(受缩放影响)\" + this.transform.InverseTransformVector(Vector3.forward)); 知识点二 本地坐标转世界坐标 //本地坐标系的点 转换 为相对世界坐标系的点 受到缩放影响 print(\"本地 转 世界 点\" + this.transform.TransformPoint(Vector3.forward)); //本地坐标系的方向 转换 为相对世界坐标系的方向 //不受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformDirection(Vector3.forward)); //受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformVector(Vector3.forward)); Input输入相关//知识点一 鼠标在屏幕位置 Input.mousePosition //知识点二 检测鼠标输入 //鼠标按下一瞬间 进入 //0左键 1右键 2中键 Input.GetMouseButtonDown(0) //中键滚动 //返回值的 y -1往下滚 0没有滚 1往上滚 //它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值 print(Input.mouseScrollDelta); //知识点三 检测键盘输入 //传入字符串的重载 //这里传入的 字符串 不能是大写的 不然会报错 //只能传入小写字符串 Input.GetKeyDown(\"q\") //推荐枚举型 Input.GetKey(KeyCode.W) //知识点四 检测默认轴输入 //我们学习鼠标 键盘输入 主要是用来 //控制玩家 比如 旋转 位移等等 //所以Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转 //键盘AD按下时 返回 -1到1之间的变换 //相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转 float h = Input.GetAxis(\"Horizontal\"); //键盘SW按下时 返回 -1到1之间的变换 //得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转 print(Input.GetAxis(\"Vertical\")); //鼠标横向移动时 -1 到 1 左 右 print(Input.GetAxis(\"Mouse X\")); //鼠标竖向移动时 -1 到 1 下 上 print(Input.GetAxis(\"Mouse Y\")); //我们默认的 GetAxis方法 是有渐变的 会总 -1~0~1之间 渐变 会出现小数 //GetAxisRaw方法 和 GetAxis使用方式相同 //只不过 它的返回值 只会是 -1 0 1 不会有中间值 //知识点三 其它的监听 //是否有任意键或鼠标长按 if(Input.anyKey) //是否有任意键或鼠标按下 if(Input.anyKeyDown) //这一帧的键盘输入 print(Input.inputString); //手柄输入相关 //得到连接的手柄的所有按钮名字 string[] strs = Input.GetJoystickNames(); //某一个手柄键按下 if( Input.GetButtonDown(\"Jump\") ) //某一个手柄键抬起 if (Input.GetButtonUp(\"Jump\")) //某一个手柄键长按 if (Input.GetButton(\"Jump\")) //移动设备触摸相关 if(Input.touchCount &gt; 0) { Touch t1 = Input.touches[0]; //位置 print(t1.position); //相对上次位置的变化 print(t1.deltaPosition); } //是否启用多点触控 Input.multiTouchEnabled = false; //陀螺仪(重力感应) //是否开启陀螺仪 必须开启 才能正常使用 Input.gyro.enabled = true; //重力加速度向量 print(Input.gyro.gravity); //旋转速度 print(Input.gyro.rotationRate); //陀螺仪 当前的旋转四元数 //比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响 //手机怎么动 它怎么动 print(Input.gyro.attitude); UnityEngine.Input - Unity 脚本 API (unity3d.com) Screen屏幕相关//知识点一 静态属性 //常用 //当前屏幕分辨率 Resolution r = Screen.currentResolution; print(\"当前屏幕分辨率的宽\" + r.width + \"高\" + r.height); //屏幕窗口当前宽高 //这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高 //一般写代码 要用窗口宽高 做计算时 就用他们 print(Screen.width); print(Screen.height); //屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; //不常用 //运行时是否全屏模式 Screen.fullScreen = true; //窗口模式 //独占全屏FullScreenMode.ExclusiveFullScreen //全屏窗口FullScreenMode.FullScreenWindow //最大化窗口FullScreenMode.MaximizedWindow //窗口模式FullScreenMode.Windowed Screen.fullScreenMode = FullScreenMode.Windowed; //移动设备屏幕转向相关 //允许自动旋转为左横向 Home键在左 Screen.autorotateToLandscapeLeft = true; //允许自动旋转为右横向 Home键在右 Screen.autorotateToLandscapeRight = true; //允许自动旋转到纵向 Home键在下 Screen.autorotateToPortrait = true; //允许自动旋转到纵向倒着看 Home键在上 Screen.autorotateToPortraitUpsideDown = true; //指定屏幕显示方向 Screen.orientation = ScreenOrientation.Landscape; 知识点二 静态方法 //设置分辨率 一般移动设备不使用 Screen.SetResolution(1920, 1080, false); UnityEngine.Screen - Unity 脚本 API (unity3d.com) Camera摄像机相关1.*Clear Flags： 如何清除背景： skybox天空盒(3D) Solid Color颜色填充(2D) Depth only 只画该层，背景透明(叠加渲染) Don't Clear 不移除，覆盖渲染 2.*Culling Mask 选择性渲染部分层级：可以指定只渲染对应层级的对象 3.*Projection 2.1Perspective 透视模式 FOV Axis：视场角 轴-决定了光学仪器的视野范围 Field of view：视口大小 Physical Camera：物理摄像机、勾选后可以模拟真实世界中、摄像机、焦距、传感器尺寸、透镜移位等等 Focal Length：焦距 Sensor Type：传感器类型 Sensor Size：传感器尺寸 Lens Shift：透镜移位 Gate Fit：闸门配合 2.2orthographic 正交摄像机(一般用于2D游戏制作) Size：摄制范围 4.*Clipping Planes： 裁剪平面距离(近和远) 5.Viewport Rect： 视口范围屏幕上将绘制该摄像机视图的位置： 主要用于双摄像机游戏 0~1 相当于宽高百分比 6.*Depth: 渲染顺序上的深度(多个摄像机，越小的越先渲染，大的覆盖小的) 7.Redering path: 渲染路径 8.*Target Texture: 渲染纹理: 可以把摄像机画面渲染到一张图上:主要用于制作小地图(摄像机渲染到这张图上) 在Project右键创建 Render Texture 9.*Occlusion Culling: 是否启用剔除遮挡(性能优化) 10.Allow HDR: 是否允许高动态范围渲染 11.Allow MSAA: 是否允许抗锯齿 12.Allow Dynamic Resolution: 是否允许动态分辨率呈现 13.Target Display: 用于哪个显示器:主要用来开发有多个屏幕的平台游戏 摄像机 - Unity 手册 (unity3d.com) 代码相关： 知识点一 重要静态成员 //1.获取摄像机 //如果用之前的知识 来获取摄像机 //主摄像机的获取 //如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机 print(Camera.main.name); //获取摄像机的数量 print(Camera.allCamerasCount); //得到所有摄像机 Camera[] allCamera = Camera.allCameras; print(allCamera.Length); //2.渲染相关委托 //摄像机剔除前处理的委托函数 Camera.onPreCull += (c) =&gt; { }; //摄像机 渲染前处理的委托 Camera.onPreRender += (c) =&gt; { }; //摄像机 渲染后 处理的委托 Camera.onPostRender += (c) =&gt; { }; 知识点二 重要成员 //1.界面上的参数 都可以在Camera中获取到 //比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置 Camera.main.depth = 10; //2.世界坐标转屏幕坐标 //转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远 //我们会用这个来做的功能 最多的 就是头顶血条相关的功能 Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position); print(v); //3.屏幕坐标转世界坐标 //只所以改变Z轴 是因为 如果不改 Z默认为0 //转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点 //如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点 Vector3 v = Input.mousePosition; v.z = 5; obj.position = Camera.main.ScreenToWorldPoint(v); //print(Camera.main.ScreenToWorldPoint(v)); UnityEngine.Camera - Unity 脚本 API (unity3d.com) 核心系统光源系统基础Light组件1.*Type:光源类型 Spot:聚光灯 Range:发光范围距离 Spot Angle:光锥角度 Directional:方向光(环境光) Point:点光源 Area:面光源(烘焙下用) 2.*Color: 颜色 3.*Mode:光源模式 Realtime: 实时光源 每帧实时计算，效果好，性能消耗大 Baked: 烘焙光源 事先计算好，无法动态变化 Mixed: 混合光源 预先计算+实时运算 4.*Intensity: 光源亮度 5.Indirect Multiplier: 改变间接光的强度 低于1，每次反弹会使光更暗大于1，每次反弹会使光更亮 6.*Shadow Type: NoShadows:关闭阴影 HardShadows:生硬阴影 SoftShadows:柔和阴影 7.RealtimeShadows Strength:阴影暗度 0~1之间，越大越黑 Resolution:阴影贴图渲染分辨率，越高越逼真，消耗越高 Bias:阴影推离光源的距离 Normal Bias:阴影投射面沿法线收缩距离 Near Panel:渲染阴影的近裁剪面 8.*Cookie: 投影遮罩(用图制作光照的样子) 9.Cookie Size： 大小设置 10.Draw Halo: 球形光环开关(光晕) 11.*Flare: 耀斑(工程文件可以自己右键创建该类型文件，想再Game显示，摄像机添加Flare Layer脚本) 12.Render Mode:渲染模式 Auto:运行时确定 Important:以像素质量为单位进行渲染，效果逼真，消耗大 Not Important:以快速模式进行渲染 13.*Culling Mask:剔除遮罩层，决定哪些层的对象受到该光源影响 光源 - Unity 手册 (unity3d.com) UnityEngine.Light - Unity 脚本 API (unity3d.com) 光窗口1.Environment-环境相关设置 Skybox Material-天空盒材质：可以改变天空盒(创建天空盒创建一个材质球将种类设置为skybox) Sun Source-太阳来源：不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting-环境光设置： Source-环境光光源颜色： Skybox：天空和材质作为环境光颜色 Gradient：可以为天空、地平线、地面单独选择颜色和他们之间混合 Intensity Multiplier-环境光亮度； Ambient Mode-全局光照模式只有启用了实时全局和全局烘焙时才有用： Realtime(已弃用) Baked 2.OtherSettings-其它设置： Fog-雾开关(性能消耗)： Color-雾颜色： Mode-雾计算模式： Linear-随距离线性增加： Start：离摄像机多远开始有雾 End：离摄像机多远完全遮挡 Exponential-随距离指数增加：-Density-强度； Exponential Qquare-随距离比指数更快的增加-Density：强度； Halo Texture：光源周围挥着光环的纹理 Halo Strength：光环可见性 Flare Fade Speed：耀斑淡出时间最初出现之后淡出的时间； Flare Strength：耀斑可见性 Spot Cookie：聚光灯默认剪影纹理 Lighting 窗口 - Unity 手册 (unity3d.com) 物理系统之碰撞检测Rigidbody组件重点：碰撞产生的必要条件，两个物体都有碰撞器，至少一个物体有刚体。 1.RigidBody组件信息： Mass：质量(默认为千克)质量越大惯性越大； Drag：空气阻力根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力； Angular Drag：根据扭矩旋转对象时影响对象的空气阻力大小。0 表示没有空气阻力； Use Gravity：是否受重力影响 Is Kinematic：如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用； Interpolate-(物理帧时间长时使用)插值运算，让刚体物体移动更平滑： None：不应用插值运算； Interpolate：根据前一帧的变换来平滑变换； Extrapolate：差值运算，根据下一帧的估计变换来平滑变换； Constraints-约束，对刚体运动的限制： Freeze Position：有选择地停止刚体沿世界 X、Y 和 Z 轴的移动； Freeze Rotation：有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转； Collision Detection(碰撞检测模式)-用于防止快速移动的对象穿过其它对象而不检测碰撞： Discrete(离散检测)：对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞(这是默认值)； Continuous(连续检测)：对动态碰撞体(具有刚体)使用离散碰撞检测，并对静态碰撞体(没有刚体)使用连续碰撞检测；设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。(此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置)，其他刚体将使用离散碰撞检测。 Continuous Speculative(连续推测检测)：对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 刚体 - Unity 手册 (unity3d.com) API: //知识点一 刚体自带添加力的方法 //给刚体加力的目标就是 //让其有一个速度 朝向某一个方向移动 //1.首先应该获取刚体组件 rigidBody = this.GetComponent&lt;Rigidbody&gt;(); //2.添加力 //相对世界坐标 //世界坐标系 Z轴正方向加了一个里 //加力过后 对象是否停止移动 是由阻力决定的 //如果阻力为0 那给了一个力过后 始终 是不会停止运动 rigidBody.AddForce(Vector3.forward * 10); //如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动 rigidBody.AddForce(this.transform.forward * 10); //相对本地坐标 rigidBody.AddRelativeForce(Vector3.forward * 10); //3.添加扭矩力，让其旋转 //相对世界坐标 rigidBody.AddTorque(Vector3.up * 10); //相对本地坐标 rigidBody.AddRelativeTorque(Vector3.up * 10); //4.直接改变速度 //这个速度方向 是相对于 世界坐标系的 //如果要直接通过改变速度 来让其移动 一定要注意这一点 rigidBody.velocity = Vector3.forward * 5; //5.模拟爆炸效果 //模拟爆炸的力 一定是 所有希望产生爆炸效果影响的对象 //都需要得到他们的刚体 来执行这个方法 才能都有效果 rigidBody.AddExplosionForce(100, Vector3.zero, 10); //知识点二 力的几种模式 //第二个参数 力的模式 主要的作用 就是 计算方式不同而已 //由于4中计算方式的不同 最终的移动速度就会不同 rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration); //动量定理 //Ft = mv // v = Ft/m; //F:力 //t：时间 //m:质量 //v:速度 //1.Acceleration //给物体增加一个持续的加速度，忽略其质量 //v = Ft/m //F:(0,0,10) //t:0.02s //m:默认为1 //v = 10*0.02/ 1 = 0.2m/s //每物理帧移动0.2m/s*0.02 = 0.004m //2.Force //给物体添加一个持续的力，与物体的质量有关 //v = Ft/m //F:(0,0,10) //t:0.02s //m:2kg //v = 10*0.02/ 2 = 0.1m/s //每物理帧移动0.1m/s*0.02 = 0.002m //3.Impulse //给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:2kg //v = 10*1/ 2 = 5m/s //每物理帧移动5m/s*0.02 = 0.1m //4.VelocityChange //给物体添加一个瞬时速度，忽略质量，忽略时间 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:默认为1 //v = 10*1/ 1 = 10m/s //每物理帧移动10m/s*0.02 = 0.2m //知识点三 力场脚本(Unity封装好了的组件) ConstantForce组件 //补充 刚体的休眠 //获取刚体是否处于休眠状态 如果是 if (rigidBody.IsSleeping()) { //就唤醒它 rigidBody.WakeUp(); } UnityEngine.Rigidbody - Unity 脚本 API (unity3d.com) 碰撞器碰撞器面板说明： 1.3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 2.共同参数： Is Trigger：是否是触发器，如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略，主要用于进行没有物理效果的碰撞检测； Material：物理材质(工程右键可以创建一个物理材质.material文件)，可以确定碰撞体和其它对象碰撞时的交互(表现)方式。 Center：碰撞体在对象局部空间中的中心点位置 3.常用碰撞器： BoxCollider-盒状碰撞器-Size：碰撞体在X、Y、Z方向上的大小； Sphere Collider-球状碰撞器-Radius：球形碰撞体的半径大小； Capsule Collider-胶囊碰撞器： Radius：胶囊体的半径 Height：胶囊体的高度 Direction：胶囊体在对象局部空间中的轴向 4.异形物体使用多种碰撞器组合：刚体对象的子对象碰撞器信息参与碰撞检测； 5.不常用碰撞器： Mesh Collider-网格碰撞器： Convex：勾选此复选框可启用 Convex。如果启用此属性，该 Mesh Collider 将与其他 Mesh Collider 发生碰撞。Convex Mesh Collider 最多 255 个三角形。 Cooking Options-启用或禁用影响物理引擎对网格处理方式的网格烹制选项： -None：禁用下方列出的所有 Cooking Options -Everything：启用下方列出的所有 Cooking Options。 -Cook for Faster Simulation：使物理引擎烹制网格以加快模拟速度。启用此设置后，这会运行一些额外步骤，以保证生成的网格对于运行时性能是最佳的。这会影响物理查询和接触生成的性能。禁用此设置后，物理引擎会使用更快的烹制速度，并尽可能快速生成结果。因此，烹制的 Mesh Collider 可能不是最佳的。 -Enable Mesh Cleaning：使物理引擎清理网格。启用此设置后，烹制过程会尝试消除网格的退化三角形以及其他几何瑕疵。此过程生成的网格更适合于在碰撞检测中使用，往往可生成更准确的击中点。 -Weld Colocated Vertices：使物理引擎在网格中删除相等的顶点。启用此设置后，物理引擎将合并具有相同位置的顶点。这对于运行时发生的碰撞反馈十分重要。 Mesh：引用需要用于碰撞的网格。 Wheel Collider-环状 碰撞器： Mass：车轮的质量 Radius：车轮的半径 Wheel Damping Rate：这是应用于车轮的阻尼值 Suspension Distance：车轮悬架的最大延伸距离(在局部空间中测量)。悬架始终向下延伸穿过局部 Y 轴。 Force App Point Distance：此参数定义车轮上的受力点。此距离应该是距车轮底部静止位置的距离(沿悬架行程方向)，以米为单位。当 forceAppPointDistance = 0 时，受力点位于静止的车轮底部。较好的车辆会使受力点略低于车辆质心。 Suspension Spring：悬架尝试通过增加弹簧力和阻尼力来到达目标位置 (Target Position) -Spring：弹簧力尝试到达目标位置。值越大，悬架达到目标位置就越快 -Damper：抑制悬架速度。值越大，悬架弹簧移动就越慢 -Target Position：悬架沿悬架距离 (Suspension Distance) 的静止距离。1 对应于完全展开的悬架，0 对应于完全压缩的悬架。默认值为 0.5，与常规汽车的悬架行为匹配。 Forward Friction-车轮向前滚动时轮胎摩擦的特性；Sideways Friction车轮侧向滚动时轮胎摩擦的特性—： -Extremum Slip：曲线的极值点。 -Extremum Value：曲线的极值点。 -Asymptote Slip：曲线的渐近点。 -Asymptote Value：曲线的渐近点。 -Stiffness：Extremum Value 和 Asymptote Value 的乘数(默认值为 1)。改变摩擦力的刚度。将此值设置为零将完全禁用车轮的所有摩擦力。通常在运行时修改刚度以使用脚本来模拟各种地面材质。 注意事项：不必通过转动或滚动 WheelCollider 对象来控制汽车；附加了 WheelCollider 的对象应始终相对于汽车本身固定； Terrain Collider-地形碰撞器 Terrain Data：地形数据 Enable Tree Colliders：选中此属性时，将启用树碰撞体 碰撞体 - Unity 手册 (unity3d.com) 物理材质物理材质参数说明 Dynamic Friction：已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止(除非用很大的力或重力推动对象) Static Friction：当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness：表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine-两个碰撞对象的摩擦力的组合方式： -Average：对两个摩擦值求平均值。 -Minimum：使用两个值中的最小值。 -Maximum：使用两个值中的最大值。 -Multiply：两个摩擦值相乘。 unce Combine：两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同 碰撞检测函数注意：碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用. //知识点一 物理碰撞检测响应函数 //碰撞触发接触时会 自动执行这个函数 private void OnCollisionEnter(Collision collision) { //Collision类型的 参数 包含了 碰到自己的对象的相关信息 //关键参数 //1.碰撞到的对象碰撞器的信息 //collision.collider //2.碰撞对象的依附对象(GameObject) //collision.gameObject //3.碰撞对象的依附对象的位置信息 //collision.transform //4.触碰点数相关 //collision.contactCount //接触点 具体的坐标 //ContactPoint[] pos = collision.contacts; //只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息 print(this.name + \"被\" + collision.gameObject.name + \"撞到了\"); } //碰撞结束分离时 会自动执行的函数 private void OnCollisionExit(Collision collision) { print(this.name + \"被\" + collision.gameObject.name + \"结束碰撞了\"); } //两个物体相互接触摩擦时 会不停的调用该函数 private void OnCollisionStay(Collision collision) { print(this.name + \"一直在和\" + collision.gameObject.name + \"接触\"); } //知识点二 触发器检测响应函数 //触发开始的函数 当第一次接触时 会自动调用 protected virtual void OnTriggerEnter(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"触发了\"); } //触发结束的函数 当水乳相融的状态结束时 会调用一次 private void OnTriggerExit(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"结束水乳相融的状态了\"); } //当两个对象 水乳相融的时候 会不停调用 private void OnTriggerStay(Collider other) { print(this.name + \"和\" + other.gameObject.name + \"正在水乳相融\"); } 音效系统音频文件导入1.导入参数设置 常用格式：wav、mp3、ogg、aiff； 音频文件属性设置 Force To Mono：多声道转单声道； Normalize：强制为单声道时，混合过程中被标准化； Load In Background：在后台加载，不阻塞主线程； Ambisonic：立体混响声 ，非常适合 360 度视频和 XR 应用程序，如果音频文件包含立体混响声编码的音频，请启用此选项； LoadType-加载类型： Decompress On Load：不压缩形式存在内存，加载块，但是内存占用高(适用于小音效文件)； Compress in memory：压缩形式存在内存，加载慢，内存小(仅适用于较大音效文件) Streaming：以流形式存在，使用时解码。内存占用最小，cpu消耗高(性能换内存) Preload Audio Data：预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format-压缩方式： PCM：音频以最高质量存储 Vorbis：相对PCM压缩的更小，根据质量决定 ADPCM：包含噪音，会被多次播放的声音，如碰撞声 Quality：音频质量，确定要应用于压缩剪辑的压缩量。(不适用于 PCM/ADPCM/HEVAG 格式) Sample Rate Setting-PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率： Preserve Sample Rate：此设置可保持采样率不变(默认值)； Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率； Override Sample Rate：此设置允许手动覆盖采样率，因此可有效地将其用于丢弃频率内容； 音频源和音频监听组件组件面板说明： AudioSource-音频源： AudioClip：声音剪辑文件(音频文件) Output：默认将直接输出到场景中的音频监听器，可以更改为输出到混音器(音乐游戏可能会用)； Mute：静音开关； Bypass Effect：开关滤波器效果； Bypass Listener Effects：快速开关所有监听器； Bypass Reverb Zones：快速开关所有混响区 Play On Awake：对象创建时就播放音乐，也就是开关启动游戏就播放； Loop：循环 Priority：优先级(越大越不容易被其他音效覆盖) Volume：音量大小 Pitch：音高 Stereo Pan：2D声音立体声位置。相当于左右声道 Spatial Blend：音频受3D空间的影响程度(设置是2d游戏还是3d音效) Reverb Zone Mix：到混响区的输出信号量 3D Sound Settings-和Spatial Blend参数成正比应用： Doppler Level：多普勒效果等级 Spread：扩散角度设置为3D立体声还是多声道 Volume Rolloff-声音衰减速度： Logarithmic Rolloff：靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff：与音频源的距离越远，听到的声音越小。 Custom Rolloff：音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance：最小距离内，声音保持最大响度；最大距离外，声音开始减弱； AudioListener-音频监听脚本； 音频源 - Unity 手册 (unity3d.com) 音频源代码控制//知识点一 代码控制播放停止 //播放音效 audioSource.Play(); //延迟播放 填写的是秒数 audioSource.PlayDelayed(5); //停止音效 audioSource.Stop(); //暂停 audioSource.Pause(); //停止暂停 和暂停后 Play效果是一样的 都会继续播放现在的音效 audioSource.UnPause(); 知识点二 如何检测音效播放完毕 //如果你希望某一个音效播放完毕后 想要做什么事情 //那就可以在Update生命周期函数中 不停的去检测 它的 该属性 //如果是false就代表播放完毕了 audioSource.isPlaying 知识点三 如何动态控制音效播放 //1.直接在要播放音效的对象上挂载脚本 控制播放 //2.实例化挂载了音效源脚本的对象 //这种方法 其实用的比较少 //Instantiate(obj); //3.用一个AudioSource来控制播放不同的音效 //AudioSource aus = this.gameObject.AddComponent&lt;AudioSource&gt;(); //aus.clip = clip; //aus.Play(); //潜在知识点 //一个GameObject可以挂载多个 音效源脚本AudioSource //使用时要注意 如果要挂载多个 那一定要自己管理他们 控制他们的播放 停止 不然 我们没有办法准确的获取 //谁是谁 UnityEngine.AudioClip - Unity 脚本 API (unity3d.com) 麦克风输入相关知识点一 获取设备麦克风信息 string[] strs = Microphone.devices; 知识点二 开始录制 //参数一：设备名 传空使用默认设备 //参数二：超过录制长度后 是否重头录制 //参数三：录制时长 //参数四：采样率 clip = Microphone.Start(null, false, 10, 44100); 知识点三 结束录制 Microphone.End(null); 知识点四 获取音频数据用于存储或者传输 //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[clip.channels * clip.samples]; clip.GetData(f, 0); print(f.Length); UnityEngine.Microphone - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"}]},{"title":"C#进阶","slug":"02004-C#进阶","date":"2019-08-02T13:00:00.000Z","updated":"2022-03-03T07:45:23.352Z","comments":true,"path":"posts/1028.html","link":"","permalink":"https://wwy.wwywy.com/posts/1028.html","excerpt":"","text":"CLR中简单数据结构类命名空间：System.Collections； ArrayList语法:new ArrayList();建议：本质是一个自动扩容的object数值，存在装箱拆箱，尽量少用；C# 动态数组(ArrayList) |菜鸟教程 (runoob.com) Stack(栈)语法：new Stack();建议：存在装箱拆箱；C# 堆栈(Stack) | 菜鸟教程 (runoob.com) Queue(队列)语法：new Queue();建议：存在装箱拆箱；C# 队列(队列) |菜鸟教程 (runoob.com) Hashtable(哈希表)定义：又叫散列表，是基于键的哈希代码组织起来的键值对，主要用来提高数据查询效率；语法：new Hashtable();迭代器遍历法: IDictionaryEnumerator me=哈希表对象名.GetEnumerator(); while(me.MoveNext()){ } 建议：存在装箱拆箱；C# 哈希表(Hashtable) |菜鸟教程 (runoob.com) CLR中的泛形命名空间：System.Collections.Generic 泛形定义：通过类型参数来实现代码操作多种类型；原理：相当于占位符，定义类或者方法是用替代符代替变量类型，当真正使用时再指定具体类型； 泛形约束关键字：where，可以多个使用;种类：6种如下：1.值类型 where 泛形字母:struct；2.引用类型 where 泛形字母:class；3.存在无参公共构造函数 where 泛形字母:new()；4.某个类本身或者派生类 where 泛形字母:类名；5.每个接口的派生 where 泛形字母:接口名；6.另一个泛形类型或者派生类型 where 泛形字母:另一个泛形字母； List定义：表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。语法：new List&lt;&gt;();List 类 (System.Collections.Generic) | Microsoft Docs Dictionary定义：表示键和值的集合。语法：new Dictionart&lt;键,值&gt;();Dictionary 类 (System.Collections.Generic) | Microsoft Docs LinkedList定义：表示双重链接列表。语法：new LinkedList&lt;&gt;();LinkedList 类 (System.Collections.Generic) | Microsoft Docs 泛形队列定义：表示对象的先进先出泛形集合。语法：new Queue&lt;&gt;();Queue 类 (System.Collections.Generic) | Microsoft Docs 泛形栈定义：表示相同指定类型的实例可变大小的后进先出 (LIFO) 集合。语法：new Stack&lt;&gt;();Stack 类 (System.Collections.Generic) | Microsoft Docs 委托和事件委托定义：C# 中的委托(Delegate)类似于 C 或 C++ 中函数的指针,本质时一个类。委托(Delegate) 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变，专门用来装载函数的容器。语法： //定义 访问修饰符 delegate 返回值类型 委托名&lt;泛形类型&gt;(参数列表) //实例化 委托名 变量名=new 委托名(); //赋值,参数要一致 变量名[+或-]=方法名() //使用 委托变量名(对应参数): 系统自带的委托：Action&lt;泛形类型,……泛形类型&gt;和Func&lt;泛形类型,…..返回值&gt;;(d都支持16个泛形类型) 事件定义:让委托使用更加安全，事件是一种特殊的变量类型语法：访问修饰符 event 委托类型 事件名和委托区别：不能再类外部赋值(可以加减)，不能在类外部调用，只能在类内部封装调用； 匿名函数定义：没有名字的函数，要配合委托和事件使用；缺点：没有名字，无法通过+-移除；语法： Action a=delegate(参数列表){ } Lambad表达式定义：可以理解成是匿名函数的简写； (参数列表)=&gt;{ } 多线程和任务前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存 多线程(Thread)命名空间：using System.Threading语法: //启动线程，将要执行的代码逻辑封装到一个函数语句块中 Thread 线程名=new Thread(委托方法); //启动线程 线程名.start(); //设置为后台线程,当进程结束后台线程结束 线程名.IsBackground=true; //关闭释放一个死循环进程，有俩中方法 //为线程死循环加一个标志变量 //通过线程提供的方法(在.net core版本会无法中止报错),可以加异常捕捉 线程名.Abort(); //线程休眠 线程名.Sleep(时间/ms); C# 多线程 | 菜鸟教程 (runoob.com) 共享数据问题：多线程操作同一内存区域可能出现问题，可以通过加锁的形式避免问题 lock(同一引用类型变量){ } 线程池(ThreadPoll)命名空间：using System.Threading定义:ThreadPoll是线程池(享元设计模式)，其目的是为了减少开启新线程消耗的资源(使用线程池中的空闲线程，不必在开启新线程，以及统一管理线程(线程池中的线程执行完毕后，回归到线程池里，等待新任务).优缺点：ThreadPoll性能优于Thread，但是Thread和ThreadPoll对线程的控制都不是很好，例如线程等待(线程执行一段时间无响应后，直接停止线程，释放资源 等 都没有直接的API来控制 只能通过硬编码来实现，同时ThreadPool使用的是线程池全局队列，全局队列中的线程依旧会存在竞争共享资源的情况，从而影响性能。语法： //快速启动 ThreadPool.QueueUserWorkItem(委托方法); //获取线程池中辅助线程的最大数量(workerThreadsMax)和线程池中异步I/O线程的最大数量(completionPortThreadsMax) ThreadPool.GetMaxThreads(out int workerThreadsMax, out int completionPortThreadsMax); //获取线程池中辅助线程的最小数量(workerThreadsMin)和线程池中异步I/O线程的最小数量(completionPortThreadsMin) ThreadPool.GetMinThreads(out int workerThreadsMin, out int completionPortThreadsMin); //设置最大线程数量 和 设置最小线程数量，在进程内是全局的。在一个地方设置了，后面所有的请求中都是这个数量了 //委托异步调用、Task、Parallel、async/await 都使用的是线程池的线程； new Thread()不受限制，但是会占用线程池的数量。 ThreadPool.SetMaxThreads(12, 12);//不能低于当前电脑的线程数；比如四核八线程，就不能低于8，否则无效 ThreadPool.SetMinThreads(1, 1); //线程等待，需要使用ManualResetEvent来完成 ManualResetEvent mre = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem((obj) =&gt; { DoSomething(\"\"); mre.Set(); } ); mre.WaitOne()； 任务(Task)命名空间：using System.Threading.Tasks特点：Task是基于任务的异步编程模型,Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。建议：使用Task的时候应该尽量结合async和await关键字来使用。避免使用.Result 和 .Wait()来阻塞等待;.Result 和 .Wait()会占用线程资源，直到任务完成；而await的基于异步回调的，不会浪费CPU资源；async和await是语法糖，本质上其实是ContinueWith()。基本语法： //Task使用方式1 Task task1 = new Task(() =&gt; { DoSomething(\"张三\"); }); task1.Start(); //Task使用方式2 var taskFactory = Task.Factory; Task&lt;int&gt; t1 = taskFactory.StartNew&lt;int&gt;(() =&gt; { DoSomething(\"王五\"); return 1; }); Task t2 = taskFactory.StartNew(() =&gt; { DoSomething(\"赵六\"); }); Task t3 = taskFactory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"所有线程都完成了，就会调用这个函数， 不会阻塞主线程\"); }); Task t4 = taskFactory.ContinueWhenAny(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"任意一个线程完成了，就会调用这个函数， 不会阻塞主线程\"); }); //Task使用方式3 Task&lt;int&gt; task = Task.Run&lt;int&gt;(() =&gt; { DoSomething(\"李四\"); return 1; }); int temp = task.Result; //阻塞执行完毕并获取结果，不建议使用这种方式 task.Wait(); //阻塞，直到子线程执行完毕，不建议使用这种方式 await task; //阻塞，直到子线程执行完毕。 但是主线程(调用方)将继续往下执行，await task后面的代码等同于封装在ContinueWith()里面 //Task其它使用方式 //Task.Delay(2000)不阻塞当前线程，一般配合ContinueWith使用，在ContinueWith里面的子线程将等待2秒之后执行 //Thread.Sleep(2000)是阻塞当前线程 Task task3 = Task.Delay(2000).ContinueWith((t) =&gt; { }); //等待所有线程完成 Task.WaitAll(new Task[] { task1, t1 }); //等待任意一个线程完成 Task.WaitAny(new Task[] { task1, t1 }); //线程回调 task1.ContinueWith((o) =&gt; { Console.WriteLine(\"线程回调，task1执行完毕之后执行这里。\"); } //Task取消任务 CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; ManualResetEvent resetEvent = new ManualResetEvent(true); //定义任务 Task task = new Task(async () =&gt; { while (true) { if (token.IsCancellationRequested) { return; } // 初始化为true时执行WaitOne不阻塞 resetEvent.WaitOne(); // Doing something....... // 模拟等待100ms await Task.Delay(100); } }, token); //任务开始 task.Start(); //任务暂停 resetEvent.Reset(); //任务继续 resetEvent.Set(); //取消Task tokenSource.Cancel(); async/await语法使用案例： static void Main(string[] args) { string content = GetContentAsync(Environment.CurrentDirectory + @\"/test.txt\").Result; //调用同步方法 //string content = GetContent(Environment.CurrentDirectory + @\"/test.txt\"); Console.WriteLine(content); Console.ReadKey(); } //异步读取文件内容 async static Task&lt;string&gt; GetContentAsync(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //ReadAync方法异步读取内容，不阻塞线程 Console.WriteLine(\"开始读取文件\"); int len = await fs.ReadAsync(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } //同步读取文件内容 static string GetContent(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //Read方法同步读取内容，阻塞线程 int len = fs.Read(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } 预处理器指令什么是编译器源语言程序：某种程序设计语言写的，像c#、c、c++、java等；目标语言程序：计算机可以识别的二进制数程序；编译器：是一种翻译程序(编译原理 )，将源语言程序翻译成目标语言程序； 什么是预处理器指令定义：指导编译器，在实际编译开始时对信息进行预处理，都是以#开始，不是指令，所以不以；结束； 常见的预处理器指令//写在脚本最前面，配合if指令或特性使用1.#define：定义一个符号，类似一个没有值的变量2.#undef：取消define定义的符号3.#if、#elif、#else、#endif：和if语法规则一样，用于告诉编译器进行编译代码的流程控制；4.#warning、#error：告诉编译器是报警告还是报错； 反射和特性程序集：由编译器编译(.exe或者.dll)，供编译执行的中间产物；元数据：数据的数据； 反射概念：程序正在运行时可以查看其他程序集或者自己的元数据这就叫反射；type定义：类的信息类，是访问元数据的主要方式，反射的技术；语法：获取的type指向的内存都是一样的 //1.通过object.GetType()获取对象的Type Type t1=object.GetType(); //2.通过typeof关键字获取类的Type Type t2=typeof(int); //3.通过类名获取，但是必须有命名空间 Type p3=Type.GetType(\"System.Int32\"); //程序集获取 t1.Assembly; //获取类的所有公共成员 MemberInfo[] infos=t1.GetMembers(); //获取类所有构造函数并调用 ConstructorInfo[] ctors=t1.GetConstructors(); //获取构造函数传入 Type数组 数组中按顺序是参数类型，执行构造函数传入 object数组 表示按顺序传入的参数； //得到无参构造 ConstructorInfo info =t1.GetConstructor(new Type[]); info.Invoke(null) as 类名; //得到有参构造 ConstructorInfo info =t1.GetConstructor(new Type[]{typeof(int)}); info.Invoke(new object[]{2}) as 类名; //得到所有成员变量 FieldInfo[] fieldINfos=t1.GetFields(); //得到指定名称的公共成员变量 FieldInfo infoj=t1.GetField(\"变量名\")； //通过反射获取变量值 infoj.GetValue(类实例); //通过反射设置变量值 infoj.SetValue(类实例,要赋的值)； //获得类的公共成员方法 MethodInfo[] methods=t1.GetMethods(); //获取指定方法 MethodInfo method=t1.GetMethod(\"方法名\"，new Type[]{反射参数类型同上}); method.Invoke(参数)； 特性定义：本质是个类，可以利用特性类为元数据添加额外信息，之后可以用反射获取这些额外信息，类、变量、函数前都可以添加；自定义特性：继承特性基类 Attribute(使用自定义特性时类名后面会省略Attribute这几个字);语法 //1.定义特性 class 特性类名：Attribute{ } //2.特性使用 [特性名(参数列表)] //类、函数、变量上一行 //3.判断是否使用了某个特性 //参数一：特性的类型 参数二：是否搜索继承链(属性和时间忽略) if(类type类型.IsDefind(typeof(特性类型)，false)){} //4.获取Type元数据中的所有特性 t.GetCustomAttributes(ture); //5.为特性类加特性，限制自定义特性 //参数一：AttributeTargets--特性可以用在哪里 //参数二：AllowMultiple--是否允许多个特性在同一个目标上 //参数三：Inherited--特性是否能被派生类和重写成员继承 [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple=true,Inherited=true)] //6.系统自带特性 //6.1过时特性 [Obsolete(\"过时特性，后面是ture直接报错，否则警告\"，false)] //6.2调用者信息特性 用处不大，省略，用工具就可以了 //6.3条件编译特性 //和#define配套使用，必须有该参数名的预指令符号才会执行修饰成员 using System.Runtime.CompilerServices [Conditional(\"Fun\")] //6.4外部Dll包函数特性 //用来标记非.Net的函数，表明在一个外部的DLL中定义，用来调用c或者c++得DLL包写好的方法 using System.Runtime.InteropServices [DllImport(\"程序集全名\")] public static extern int 外部DLL元数据函数名() 其他补充lock和using语句块lock定义：确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。注意：1.lock不能锁定空值，但Null是不需要被释放的。2.lock不能锁定string类型，虽然它也是引用类型的。因为字符串类型被CLR“暂留”。即整个程序中任何给定字符串都只有一个实例，具有相同内容的字符串都代表着同一个实例。因此，只要在应用程序进程中的任何位置处具有相同内容的字符串上放置了锁，就将锁定应用程序中与该字符串具有相同内容的字符串。因此，最好锁定不会被暂留的私有或受保护成员。 using作用：1.自动释放，避免缓存，内存溢出2.简化try catch 得到在此定义域内自动释放所新建的对象，以简化代码； 协变逆变协变：out逆变：in作用一：用out修饰的泛形只能作为返回值，用in修饰的泛形只能作为参数作用二：用out和in修饰的泛形委托可以i互相装载(有父子关系的委托) //结合里氏替换原则理解 //协变 父类总是能被子类替代 TestOut&lt;Son&gt; os=()=&gt;{ } TestOut&lt;Father&gt; of=os;//参数必须声明out of();//实际上os装的函数返回的是Son的 //逆变 子类装父类委托 TestIn&lt;Father&gt; of=()=&gt;{ } TestIn&lt;Son&gt; os=of;//参数必须声明in os();//实际上os装的函数返回的是Father的 迭代器(iterator)概念：又称为光标(cursor)，是程序设计的软件设计模式，是可以在遍历访问的接口，设计人员无需关心容器的内存细节，能用foreach遍历的类，都实现了迭代器；关键接口：IEnumerator(迭代器实现),IEnumerable(foreach实现，有方法即可);命名空间：using System.Collections;yield return：是c#提供的语法糖(糖衣语法)，可以将复杂逻辑简单化，增加程序可读性，yield关键字可以理解为暂时返回，保留当前状态； 特殊语法# 隐藏类型var 可以用来表示任何类型的变量，一般用来临时变量，但是不能再更改类型。 # 设置对象初始值 可以直接通过大括号来进行赋值。 # 设置集合初始值 可以直接通过大括号来进行赋值。 # 匿名类型 var变量可声明为自定义的匿名类型，但是只能有变量。语法 var v=new {age=10,name=\"小明}; # 可空类型//1.数值类型使用，声明时再值类型后面加？可以赋值为空 int? lue=null; //又如 int[] os=null; int? x=os?[0]; //2.引用类型使用，相当于一种语法糖，自动判断是否为空,例如判断委托是否为不为空才执行 o?Invoke(); //3.判断值类型是否为空 值变量名.HasValue； //4.安全获取值类型默认值(可以指定默认值) 值变量名.GetValueOrDefault(默认值); # 空和并操作符定义：左边值？？右边值，左边为null返回右边值，否则左边； # 内插字符串 用关键字$，类似于Format拼接字符串。语法 Console.WriteLine($\"你好，{name}”); # 单句逻辑简略写法 逻辑语句只有一句代码的话可以省略{}，而属性只有一句getset可以写成get=&gt;返回值;set=&gt;变量名=要赋的值，方法同理。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"C#核心","slug":"02003-C#核心","date":"2019-07-15T13:00:00.000Z","updated":"2022-03-03T07:45:15.887Z","comments":true,"path":"posts/1027.html","link":"","permalink":"https://wwy.wwywy.com/posts/1027.html","excerpt":"","text":"面向对象基本概念其他编程方式：面向过程编程；三大特征：封装+继承+多态；七大原则：1.单一原则：一个类只处理自己应该处理的。应该各司其职，例如把每个移动技能都尽量写出一个类，方便修改。2.开闭原则：新功能尽量是加处理而不是改代码。继承就是最明显的开闭原则，不要修改模板的内容，例如定义属性要用方法定义， getset，方便修改，修改类时或者改别人的方法，不清楚逻辑的就再写一个类。3.依赖倒置原则：不依赖于具体实现，要依赖抽象(接口)。要依赖于抽象，不要依赖于具体实现，可以先了解需求，再画图，最后变成代码。4.接口隔离原则：一个接口一个行为。接口里的单一原则，需要分的事件要分清楚。5.里氏替换原则：用父类容器装载子类，任何地方子类都能替换父类。不要修改别人的代码，可以继承他的代码去重写(注：多态：父类的指针指向子类，而调用子类的方法)6.合成复用原则：尽量用组合复用的形式。继承关系中，父类要可以解决子类共同的问题，子类时解决特与的问题，能用现有的类，就别再自己创建类。7.迪米特法则：一个类尽量减少对别的类引用。又叫最少知识原则，减少耦合性，类自己能解决的，尽量不要牵扯别的类，比如A类引用B类的方法，但是B类方法参数改了，A类也要改。 面向对象三特征-封装一般类定义： 类和对象class 类名{ 类名 对象名=new 类名; } 类一般成员和封装成员变量：成员变量是声明在类中的变量，可以是任意类型；成员方法(函数)：类的成员函数是一个在类定义中有它的定义或原型的函数;访问修饰符种类：public(接口成员、命名空间、枚举默认)、private(类成员)、protected、internal(类、结构、接口、委托默认)； 构造函数构造函数：类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行，构造函数的名称与类的名称完全相同，它没有任何返回类型默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，以下是它的特殊写法： public 类名(参数1，参数2):this(参数1){ //默认会先调用无参构造(this)或者父类构造函数(换成base) } ##析构函数析构函数：类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行，析构函数的名称是在类的名称前加上一个波浪形(~)作为前缀，它不返回值，也不带任何参数，析构函数用于在结束程序(比如关闭文件、释放内存等)之前释放资源，就是当引用类型的堆被回收时被调用，析构函数不能继承或重载。 垃圾回收机制定义:简称GC，当堆(Heap)中的变量没有被任何对象引用时，就会被自动回收；算法：引用计数、标记清除、标记整理、复制集合；注意事项：GC只负责堆的垃圾回收,而栈(stack)的内存时系统自动管理的，值类型有自己的生命周期，会自动分配和释放；原理：C#会把堆中的内存分为0代内存、1代内存、2代内存(代是分代算法，代系数越大速度越慢，内存越大)，新分配的对象会配置在0代内存，每次分配都可能会进行垃圾回收释放内存(0代内存或者1代内存满时)，垃圾回收机制确认堆中的垃圾，首先会标记对象，发现是否有引用，标记后可达对象，未标记未不可达对象(垃圾)，然后就将对象压缩堆(挂起执行托管代码线程)释放垃圾，搬迁可达对象地址到下一代内存(到第二代内存不会在搬迁)，大对象(83kb以上)总认为是第二代内存。手动触发代码：GC.Collect();一般Loading过场景调用 成员属性语法： 访问修饰符 属性类型 属性名{ 访问修饰符 get{}//自动属性可以省略{} 访问修饰符 set{}//自动属性可以省略{} } 索引器概念:让对象可以像数组一样通过索引访问元素，索引器可以重载；语法： 访问修饰符 返回值 this[参数1、参数2]{ get{} set{} } 静态类和静态成员static静态类：不能被实例化，只能有静态成员；静态变量：当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本；静态函数：这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在；静态构造函数：不能使用访问修饰符，不能有参数，使用静态类或者普通类的成员时会自动且仅调用一次； 拓展方法特点：一定是写在静态类，一定是静态函数，第一个参数为拓展目标，第一个参数用this修饰；语法： 访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数1，参数2){ } 运算符重载概念：使用operator关键字让自定义类和结构体可以使用运算符；特点：一定是公告静态方法，返回值在operator前(条件运算要成对出现，一个符号可以多个重载，不能使用ref和out);语法： public static 返回类型 operator 运算符(参数列表){ } 不可重载的运算符:逻辑与&amp;&amp; 、逻辑非||、索引符[]、强转符号()、点.、三目运算符?:、赋值符号=； 内部类和分部类内部类定义:在一个类中再声明一个类，使用时要外部类点出自己；分部类：用partial把类分成几部分,注意访问修饰符要一样;分部方法:用partial将方法声明和实现分离，强制私有，只能在分部类声明，不能有返回值，不能用out关键字； 面向对象三特征-继承继承基本规则语法： class 类名 ：被继承的类{ } 里氏替换原则概念:任何父类出现的地方，子类都可以替代语法: 父类 变量名=new 子类()； ###is关键字定义:判断一个对象是否为指定类对象，返回bool值语法:对象 is 类名 ###as关键字定义:将一个对象转换为指定类对象，没有返回null语法:对象 as 类名 继承中的构造函数特点:实例化时先执行父类构造函数,再执行子类构造函数； 万物之父和装箱拆箱万物之父关键字:object装箱:例如object存储值类型发生，把值类型从栈中迁移到堆中，变成引用类型；拆箱:例如把object转为值类型发生，把引用类型从堆中迁移到栈中，变成值类型； 密封类概念:使用sealed关键字使类无法再被继承； 面向对象三特征-多态vob关键字：virtual(虚函数)和override(重写); 抽象类和抽象方法关键字：abstract(抽象函数)；特点：抽象类不能被实例化，但是遵守里氏替换原则，抽象方法没有方法体； 接口关键字:interface；特点：不包含成员变量，只有抽象方法、属性、索引器、事件，成员不能被实现，不能是私有成员，类可以继承多个接口，接口也遵守里氏替换原则；作用：不作为实体基类,但是可以作为一个行为基类;命名规则:帕斯卡命名法前面加I; ###显示实现接口作用：当实现俩个接口后，其中有相同方法时；语法：用接口名点出方法名; 密封方法关键字:sealed修饰不能再被重写； 面向对象相关知识点命名空间特点：命名空间可以包裹命名空间;语法： namespace 命名空间名{ } 万物之父中的方法静态方法Equals:判断俩个对象是否相等,值类型比较数值，引用类型比较地址;静态方法RefereceEquals：判断俩个对象引用是否相等，主要用于应用类型，值类型返回始终false;普通方法GetType():获取对象运行时的类型(反射相关);普通方法MemberwiseClone：拷贝对象,引用对象指向相同地址;虚方法Equals:相当于RefereceEquals,但是在种类中ValueType中重写了,可以用来比较值相等；虚方法GetHashCode：获取对象哈希值(对象唯一编码，但是也可能u不同对象哈希码一样)；虚方法ToString：返回对象代表的字符串; string注意事项：string大部分方法需要赋值再使用，因为会实例化一个新的字符串；字符串名[]：字符串索引器;(静态)string.Format()：字符串拼接(替代);字符串名.IndexOf()：正向查找字符位置;字符串名.LastIndexOf()：反向查找字符位置;字符串名.Remove()：移除指定位置的字符;字符串名.Replace()：替换指定字符串;字符串名.ToUpper()：字符串全部大写；字符串名.ToLower()：字符串全部小写;字符串名.Substring()：字符串截取；字符串名.Split()：字符串切割； StringBuilder作用：修改字符串而不创建新的对象字符串.Capacity:获取容量；字符串.Append:增；字符串.AppendFormat():拼接；字符串.Insert():插入；字符串.Remove():删；字符串.Clear():清空；索引-字符串[]:用来查和改；str.Replace():替换； 字符串拼接的方式直接通过+拼接 会有性能问题，字符串少还好，越多GC越严重。 通过StringBuilder拼接字符串 字符串数量越多性能相对直接+拼接方法越高。 通过StringBuffer拼接字符串 区别：线程安全版的StringBuilder，但是性能不如StringBuilder; string.Format原理：其底层本质还是StringBuilder来实现的； $方式拼接字符串原理：是string.Format简化版，C#6.0新增操作；语法： string str = $\"my name is{name}, I'm {age} years old\"; 知识拓展多脚本文件.cs：源码文件.sln：解决方案入口文件.dll：编译文件 UML定义：统一建模语言，是面向对象设计的建模语言；理解：可以通过一些UML可视化软件(visio)就可以生成代码；","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"C#基础","slug":"02002-C#基础","date":"2019-07-02T13:00:00.000Z","updated":"2022-03-03T07:45:07.118Z","comments":true,"path":"posts/1026.html","link":"","permalink":"https://wwy.wwywy.com/posts/1026.html","excerpt":"","text":"将之前的笔记记录在博客上 复杂数据类型特点：数据(变量)集合、自定义； 枚举 枚举是一个被命名的整形常量集合,可以声明再命名空间、类和结构体中。 枚举声明enum 变量名{ 名1,//枚举中默认是0下面累加 名2=4,//可以赋值,下面数值接着从此开始 名3 } 枚举的类型转换1.枚举和int互转后是数值的转换2.枚举转换成string是枚举名3.string转换成枚举,必须有这个字符串名的枚举名,实例如下： Enum.Parse(typeof(声明枚举类型名),\"Other\"); 数组 数组是储存一组相同的数值集合,下标从0开始。 一维数组声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1,2,3,4……(第数组长度-1个) }；获取长度：数组名.length; 二维数组声明：变量类型【,】 二维数组名=new 变量类型【行,列】{ { 1,1,1… },{ 1,1,1…. },{ 1,1,1…. }… };获取长度:数组名.length(维度); 交叉数组 即数组的数组。 结构体public struct 结构体名{ 变量类型 变量名 构造函数(可选) 函数 } 结构体和类相同点：1.两者都拥有成员,包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。2.两者的成员都有其各自的存取范围。例如,可以将某一个成员声明为Public,而将另一个成员声明为Private。3.两者都可以实现接口。4.两者都可以公开一个默认属性,然而前提是这个属性至少要取得一个自变量。5.两者都可以声明和触发事件,而且两者都可以声明委托(Delegate)。6.两者都是container类型,这表示它们可以包含其他数据类型作为成员。 区别：1.结构是实值类型(Value Types),而类则是引用类型(Reference Types)。2.结构使用栈存储(Stack Allocation),而类使用堆存储(Heap Allocation)。3.所有结构成员默认都是Public,而类的变量和常量数则默认位Private,不过其他类成员默认都是Public。4.结构成员不能被声明位Protected,而类成员可以。5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化,但是类变量声明可以。6.结构不能声明默认的构造函数,也就是不拥有参数的非共享构造函数,但是类则无此限制。7.二者都可以拥有共享构造函数,结构的共享构造函数不能带有参数,但是类的共享构造函数则可以带或者不带参数。8.结构不允许声明析构函数(Destructor),类则无此限制。9.结构的实例(Instance)声明,不允许对包含的变量进行初始化设定,类则可以在声明类的实例时,同时进行变量初始化。1.结构是隐式继承自ValueType类,而且不能继承任何其他类型,类则可以继续自ValueType以外的任何类。11.结构是无法被继承的,类则可以。12.结构永远不会终止,因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止,当内存回收进程检测到没有任何作用的类时,它就会调用类的Finalize方法。13.结构不需要构造函数,类则需要构造函数。14.结构只能在一种情况下使用非共享构造函数,那就是非共享构造函数会接受参数。但是类则无此限制,它可以使用带参数或不带参数的非共享构造函数。15.每一个结构都具有无参数的隐含公共构造函数,此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上,由于结构是数值类型的,因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的,而且对象变量可引用不同的类实例,在此方面的区别,会对使用将结构和类造成如下的影响：16.结构变量会隐式的使用结构的无参数构造函数来初始化成员,这就意味语句 Struct S = new Struct()。17.当您将一个结构变量赋值给另一个,或者将结构实例传递到程序变量时,所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个,或者将对象变量传递给程序时,则只是复制指针。18.您可以将Null值赋值给结构变量,但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化,但是您还是可以调用变量的方法并访问其数据成员。相反的,如果您将对象变量设定为Null,您就会中断它与任何类型实例的关联,而且除非您再将另一个实例赋值给它,否则无法通过变量访问任何成员。19.您可以在不同时间将不同的类的实例赋值给同一个对象变量,而且在同一时间可有好几个对象变量引用相同的类实例,如果您对类成员值做了改变,则其他指向相同实例的对象变量也会发生改变。然而,结构成员则会封装在他们自己的实例中,变更结构成员值并不会对其他任何结构变量的成员造成影响,甚至也不会影响相同结构声明的其他实例。20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。 如何选择结构还是类:1.堆栈的空间有限,对于大量的逻辑的对象,创建类要比创建结构好一些2.结构表示如点、矩形和颜色这样的轻量对象,例如,如果声明一个含有 1000 个点对象的数组,则将为引用每个对象分配附加的内存。在此情况下,结构的成本较低。3.在表现抽象和多级别的对象层次时,类是最好的选择。4.大多数情况下该类型只是一些数据时,结构时最佳的选择。 值类型和引用类型值类型 其他类型、结构体；存储位置：栈空间–系统分配,自动回收,小而快特点：在赋值时,把内容拷贝给对方,它变我不变,内存地址不变。 引用类型 string、数组、类存储位置：手动申请和释放,大而慢特点：在赋值时,让俩者指向一个值,它变我也变,指向堆中相同内存地址。 特殊引用类型string string在赋值时也会再分配一个内存空间。 函数 函数可以写在类中和结构体中。 函数基础基本语法：static 返回类型 函数名(参数类型 参数名1….){ 代码逻辑；return 返回值 } ref和out 在函数内部传入,里面变了,外面也变了。声明：函数参数的修饰符；区别：ref传入的参数必须初始化,out传入的变量必须在内部赋值； 变长参数和参数默认值变长参数声明：params 变量类型[] 变量名；参数默认值：可选参数,在方法声明时就进行赋值,可选参数必须写在普通参数后面； 函数重载定义：重载和返回值无关,和参数类型、个数、顺序有关； 递归函数定义：就是让函数自己调用自己,但是需要留出出口,否则就是死循环","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"C#入门","slug":"02001-C#入门","date":"2019-06-18T13:00:00.000Z","updated":"2022-03-03T07:45:39.061Z","comments":true,"path":"posts/1025.html","link":"","permalink":"https://wwy.wwywy.com/posts/1025.html","excerpt":"","text":"将之前的笔记记录在博客上 C#基础知识主流语言的应用领域C: 嵌入式硬件开发C++: 游戏客户端、服务器、软件C#: 游戏客户端、服务器、软件、网站 Java: 安卓、服务器、软件、网站JavaScript: H5游戏、网站、服务器PHP: 网站、服务器Python: 网站、服务器、辅助开发 SQL: 数据库Go: 服务器Objective-C: 苹果(mac、ios)相关Swift: 苹果(mac、ios)相关 开发环境搭建IDE是什么IDE(Integrated Development Environment )集成开发环境它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代码命令，听从你的指令和你进行交流。 常用的IDE(集成开发环境)软件Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;Android Studio: 谷歌推出，主要用于开发安卓应用;Xcode:苹果推出，主要用于开发苹果应用; 第一个应用程序理解写代码这件事通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算机通过这些命令来执行一些行为，从而实现一些特定的需求。比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能够动起来 注释的三种方式1.两杠注释:用于注释一行信息2.星号注释:用于注释多行信息3.三杠注释:用于注释类、命名空间等 快捷注释的方法1.上方工具栏2.快捷键CTRL + K + C 注释CTRL + K + U 取消注释 折叠代码由#region #endregion配对出现 控制台输入打印语句Console.Write():输出 Console.WriteLine:换行输出 Console.ReadKey:检测用户按下 Console.ReadLine:用户输入回车 变量变量类型有符号的整形变量sbyte: -128-127(字节占1);short: -32768-32767(字节占2);int: -21亿-21亿多(字节占4);long: -9百万兆-9百万兆(字节占8); 无符号的整数变量byte:0-255(字节占1);ushort: 0-65535(字节占2);uint: 0-42亿多(字节占4);ulong: 0-18百万兆(字节占8); 浮点型float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;double:(字节占8) 存储15-17位有效数字;decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; 特殊类型bool:非真即假(字节占1);char:存储单个字符(字节占2);string:存储多个字符，没有上限(长度可变); 变量的本质 数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000通过sizeof获取变量占用的内存空间(例如:sizeof(int);;1byte=8bit;1kb=1024byte;1mb=1024kb;1gb=1024mb;1tb=1024gb; 进制转换(整数，左侧第一位表示符号)十进制转二进制:不停除2;二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0); 命名规则1.不能重名;2.不能以数字开头;3.不能是关键字;4.不能有特殊符号(下划线除外); 驼峰命名法(变量)、帕斯卡命名法(函数、类) 常量关键字const，必须初始化，不能被修改。 转义字符 是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行 固定写法常用的转义字符':单引号;\":双引号\\n:换行\\:斜杠 不常用的转义字符\\t:制表符(空一个tab键)\\b:光标退格\\0:空字符\\a:警告音 取消转义字符 在字符串前面加一个@(例如@”\\你好\") 类型转换 不同变量类型之间的相互转换 隐式转换 不同类型之间的自动转换，大范围转小范围 相同大类型之间的转换 特殊类型不存在隐式转换 不同大类型之间的转换无符号和有符号之间 有符号的变量不能隐式转换无符号的; 无符号的变量隐式转换有符号的前提是范围一定是涵盖的; 浮点数和整数之间 浮点数可以转任何类型整数; 整数不能转换浮点型(不能存小数); 特殊类型和其他类型 char类型可以隐式转换成整数和浮点型(ASCII码); bool和string不能和其他类型互相转换; 显示转换 手动转换。 括号强转 小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。 Parse法 把字符串类型转换成对应类型，前提能转换，否则报错。语法:变量类型.Parse(“字符串”) Convert法 更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。语法:Convert.To目标类型(变量或者常量) 其他类型转string作用:拼接打印;语法:变量.ToString(); 异常捕获 避免程序报错造成卡死 try{ }catch{ }finally{ } 运算符算数运算符赋值运算符:=算数运算符:+ - * / %复合运算符:+= -+ *= /= %=自增运算符:a++(先用再加) ++a(先加再用) 运算符的优先级1.乘除大于加减;2.括号优先; 字符串拼接方法一:+号拼接;方法二:string.Format(“{0}”，18);控制台打印拼接:支持类似方法二; 条件运算符 只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。条件运算符:&gt; &lt; == != &gt;= &lt;=; 逻辑运算符逻辑运算符:&amp;&amp; || ! 运算符优先级 ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。 位运算符位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)位或:|(有1则1)异或:^(对位运算，相同为0，不同为1)位取反:~(0变1，1变0，反码补码问题)左右移:&lt;&lt;(左移几位，右边加几个0) &gt;&gt;(右移几位，右边去几个数) 三目运算符语法:空位(bool类型)？空位:空位; 条件分支语句if语句if(){ }else if(){ }else{ } switch语句switch(){ case 变量: break; default: break; } 循环语句while循环while(循环跳出条件){ } do-while循环do{ }while(); for循环for(int i=1;i&lt;条件;i++){ } foreach循环foreach(var i in 集合需要继承自一个接口){ } 知识补充控制台相关1.Console.Readkey().Keycahr-可以保存输入的字符;2.Console.Clear()-清空控制台;3.Console.SetWindowSize(宽，高);4.Console.SetBufferSize(宽，高)-缓冲区大小;5.Console.SetCursorPosition(x，y)-设置光标的位置6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear8.Console.CursorVisiable=false-设置光标显隐9.Environment.Exit(0)-关闭控制台 随机数语法:Random 变量名=new Random();生成非负数:变量名.Next(最小到最大，范围不包括最大);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]}],"categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"大学知识/CS基础/数据结构和算法","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"编译原理","slug":"大学知识/CS基础/编译原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"计算机组成原理","slug":"大学知识/CS基础/计算机组成原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"计算机网络技术","slug":"大学知识/CS基础/计算机网络技术","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"人工智能","slug":"大学知识/CS基础/人工智能","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"第三方库","slug":"Game-Play/第三方库","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"},{"name":"计算机操作系统","slug":"大学知识/CS基础/计算机操作系统","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"编程语言/Lua","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"同步技术","slug":"Game-Play/同步技术","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/"},{"name":"其他","slug":"其他","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"UnityEditor","slug":"游戏引擎/Unity/UnityEditor","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"编译原理","slug":"编译原理","permalink":"https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"计算机网络技术","slug":"计算机网络技术","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"人工智能","slug":"人工智能","permalink":"https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"第三方库","slug":"第三方库","permalink":"https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"定点数数学库","slug":"定点数数学库","permalink":"https://wwy.wwywy.com/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"},{"name":"确定性物理库","slug":"确定性物理库","permalink":"https://wwy.wwywy.com/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"},{"name":"ET","slug":"ET","permalink":"https://wwy.wwywy.com/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"换装","slug":"换装","permalink":"https://wwy.wwywy.com/tags/%E6%8D%A2%E8%A3%85/"},{"name":"Animancer","slug":"Animancer","permalink":"https://wwy.wwywy.com/tags/Animancer/"},{"name":"Playable","slug":"Playable","permalink":"https://wwy.wwywy.com/tags/Playable/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"FairyGUI","slug":"FairyGUI","permalink":"https://wwy.wwywy.com/tags/FairyGUI/"},{"name":"Excel","slug":"Excel","permalink":"https://wwy.wwywy.com/tags/Excel/"},{"name":"Lua","slug":"Lua","permalink":"https://wwy.wwywy.com/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://wwy.wwywy.com/tags/AssetBundle/"},{"name":"Markdown","slug":"Markdown","permalink":"https://wwy.wwywy.com/tags/Markdown/"},{"name":"UnityEditor","slug":"UnityEditor","permalink":"https://wwy.wwywy.com/tags/UnityEditor/"},{"name":"MVC","slug":"MVC","permalink":"https://wwy.wwywy.com/tags/MVC/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"https://wwy.wwywy.com/tags/PlayerPrefs/"},{"name":"二进制","slug":"二进制","permalink":"https://wwy.wwywy.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"Json","slug":"Json","permalink":"https://wwy.wwywy.com/tags/Json/"},{"name":"XML","slug":"XML","permalink":"https://wwy.wwywy.com/tags/XML/"},{"name":"UGUI","slug":"UGUI","permalink":"https://wwy.wwywy.com/tags/UGUI/"},{"name":"GUI","slug":"GUI","permalink":"https://wwy.wwywy.com/tags/GUI/"},{"name":"ScriptableObject","slug":"ScriptableObject","permalink":"https://wwy.wwywy.com/tags/ScriptableObject/"},{"name":"InputSystem","slug":"InputSystem","permalink":"https://wwy.wwywy.com/tags/InputSystem/"},{"name":"Addressables","slug":"Addressables","permalink":"https://wwy.wwywy.com/tags/Addressables/"},{"name":"Timeline","slug":"Timeline","permalink":"https://wwy.wwywy.com/tags/Timeline/"},{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]}