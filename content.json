{"meta":{"title":"憨憨","subtitle":"憨憨の博客","description":"故事总需要个起点","author":"憨憨","url":"http://wwy010518.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-01-22T04:07:31.290Z","comments":false,"path":"about/index.html","permalink":"http://wwy010518.github.io/about/index.html","excerpt":"","text":"憨憨“ 不要惧怕别人的偏见、认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：憨憨的个人空间 QQ：3179342661 座右铭：保持初心，漫步远方"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"http://wwy010518.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"http://wwy010518.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"http://wwy010518.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"http://wwy010518.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"http://wwy010518.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"http://wwy010518.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"http://wwy010518.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"相册","date":"2022-01-22T03:16:54.165Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"http://wwy010518.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"http://wwy010518.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"http://wwy010518.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://wwy010518.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"Unity角色换装","slug":"03020-Unity角色换装","date":"2022-02-18T13:00:00.000Z","updated":"2022-02-18T12:41:00.176Z","comments":true,"path":"posts/1552.html","link":"","permalink":"http://wwy010518.github.io/posts/1552.html","excerpt":"","text":"待写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"换装","slug":"换装","permalink":"http://wwy010518.github.io/tags/%E6%8D%A2%E8%A3%85/"}]},{"title":"Unity插件 - Animancer插件使用","slug":"03015-Unity插件 - Animancer插件使用","date":"2022-01-29T13:00:00.000Z","updated":"2022-01-29T04:18:18.182Z","comments":true,"path":"posts/1549.html","link":"","permalink":"http://wwy010518.github.io/posts/1549.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"Animancer","slug":"Animancer","permalink":"http://wwy010518.github.io/tags/Animancer/"},{"name":"Playable","slug":"Playable","permalink":"http://wwy010518.github.io/tags/Playable/"}]},{"title":"ET6.0框架笔记","slug":"04001-ET6.0框架笔记","date":"2022-01-24T13:00:00.000Z","updated":"2022-02-20T15:36:51.155Z","comments":true,"path":"posts/2049.html","link":"","permalink":"http://wwy010518.github.io/posts/2049.html","excerpt":"","text":"ET6.0框架介绍项目的初步运行1.运行Unity客户端项目，并且打开编程软件进行初步编译；2.打开服务端项目，第一次打开编译Client下的Mono文件夹；3.重新编译整个解决方案；4.客户端F5生成代码； ET通讯登录实例：1.通过NetKcpComponent组件创建Session会话连接；2.Session（由ET框架管理）会话的Id和TChannel进行绑定；3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器； ET的多线程和分布式第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构 登录实例（接上）：1.网关负载均衡服务器随机分配网关配置；2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；4.游戏客户端和游戏网关建立正式连接；5.登录进Map服务器注意：C就是客户端，R是网关负载均衡服务器，G是网关； ET的ECS组件编程ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）； 遵守的编程原则：1.实体即组件、组件即实体；2.编写一个实体或者组件，绝不继承除Entity外的任何父类；3.不使用任何虚函数，使用逻辑分发替代；4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误； 其他原则：1.系统命名必须是实体名+System；2.系统必须是静态类；3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件； //1.实体或者组件 public class Computer: Entity,IAwake,IUpdate,IDestroy public class MouseComponent : Entity, IAwake //2.系统 public static class ComputerSystem //需要使用拓展方法 public static void Start(this Computer self) Log.Debug(\"计算机启动\"); //这里可以调用身上的组件 self.GetComponent&lt;PCCaseComponent&gt;().StartPower(); self.GetComponent&lt;MonitorsComponent&gt;().DisPlay(); //3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上 Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;(); computer.AddComponent&lt;PCCaseComponent&gt;(); computer.AddComponent&lt;MonitorsComponent&gt;(); computer.AddComponent&lt;KeyBoardComponent&gt;(); computer.AddComponent&lt;MouseComponent&gt;(); computer.Start(); ET中ECS编程的生命周期 ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。 //1.生命周期函数类 public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt; public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt; public class ComputerDestroySystem : DestroySystem&lt;Computer&gt; ET的逻辑分发OOP面向对象的缺点：继承层次过深时，牵一发而动全身； ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承； ET的Scene层级树Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id； 客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）: 服务端Scene的层级关系: 服务端机器人Scene的层级关系 ET的Excel配置工具1.配置文件从第三行第三列开始写，跟VBA宏有关；2.第一个类型字段名必须是Id；3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；4.加#是注释，仅给策划使用，不会添加到游戏数据中；5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\\Assets\\Bundles\\Config下；可以查看文本形式在Bin\\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；7.行是可以空行的，可以用来分类注释，目测加#；8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；9.配置工具支持的导表类型可以在Tools\\Apps\\EXcelExporter文件下的Convert静态类中定义或查看；10.数组类型默认在配置文件中加英文,配置; //1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型 //获取单个 UnitConfig config = UnitConfigCategory.Instance.Get(1001) //获取所有 var configs = UnitConfigCategory.Instance.GetAll() ET中的事件系统1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意； //1.定义事件，添加事件,必须EventType命名空间下进行定义 public struct InstallComputer { //定义参数 public Computer computer; } //2.调用事件，触发事件 //同步Publish Game.EventSystem.Publish(new EventType.InstallComputer() { computer = computer }); //同步PublishAnycs await Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }); //异步PublishAnycs Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine(); //3.编写事件触发逻辑 public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt; { //必须添加async protected async override ETTask Run(InstallComputer arg) { Computer computer = arg.computer; computer.AddComponent&lt;PCCaseComponent&gt;(); computer.AddComponent&lt;MonitorsComponent&gt;(); computer.AddComponent&lt;KeyBoardComponent&gt;(); computer.AddComponent&lt;MouseComponent&gt;(); await ETTask.CompletedTask; } }","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"http://wwy010518.github.io/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"ET","slug":"ET","permalink":"http://wwy010518.github.io/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"计算机操作系统原理笔记","slug":"01001-计算机操作系统","date":"2022-01-08T13:00:00.000Z","updated":"2022-01-24T15:05:15.066Z","comments":true,"path":"posts/513.html","link":"","permalink":"http://wwy010518.github.io/posts/513.html","excerpt":"","text":"1 操作系统绪论1.1 操作系统概念定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。 特征：并发、共享、虚拟、异步。 1.2 操作系统发展历程手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。 1.2.1单道批处理原理：计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。 特征：内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。 1.2.2多道批处理原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。 特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。 1.2.3分时系统特征：多路性、独立性、及时性、交互性。 1.2.4实时系统特征：多路性、独立性、及时性、交互性、可靠性。 2 操作系统用户界面2.1 作业定义：分用户和系统角度去理解 a) 用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业； b) 系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL) 2.2 一般用户输入输出方式2.2.1联机输入输出方式2.2.2脱机输入输出方式2.2.3直接耦合方式2.2.4Spooling系统原理：todo。 特点：系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。 2.2.5网络联机方式2.3 系统调用定义：系统调用是操作系统留给编程人员的唯一接口。 原理：todo 2.3.1系统调用指令int和trap指令进行系统调用。 call和jmp指令进入普通过程调用(子调用)。 3 进程管理3.1 进程的概念组成：进程=程序+数据+进程控制块(进程状态信息PCB) 定义：进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 目的：对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性； 优缺点：引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。 3.2 进程和程序的区别a) 进程是动态的，程序是静态的； b) 进程是暂时的，程序是永久的； c) 组成不同，进程的组成包括程序； d) 对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序； e) 进程可以并行，具有独立性、异步性。 f) 进程是竞争计算机资源的基本单位。 3.3 进程控制块(PCB)进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。 3.3.1描述信息3.3.2控制信息3.3.3资源管理信息3.3.4CPU保护现场结构3.4 进程上下文切换原因：进程中断、超时、进程调用。 步骤： a) 保存被切换进程的正文部分到有关存储区。 b) 进程有关调度和资源分配程序执行，选取新的进程。 c) 新进程正文部分从存储区取出，激活选中进程执行。 3.5 进程的状态和进程转换3.5.1进程状态初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止)) 3.5.2进程状态转换3.6 进程控制3.6.1进程创建和撤销3.6.2进程阻塞和唤醒3.6.3进程的挂起和激活3.7 进程互斥和同步3.7.1临界区和临界资源临界资源是一次仅允许一个进程使用的共享资源。 临界区是每个进程访问临界资源的那段代码。 3.7.2信号量和PV原语信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。 信号量的数值仅能由P、V原语操作改变。 3.7.3互斥的概念定义：不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。 3.7.4同步的概念定义：对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。 3.8 进程通信Todo 3.9 死锁问题3.9.1死锁的概念定义： 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。 起因：并发进程的资源竞争 条件：同时具备互斥条件、不剥夺条件、部分分配、环路条件。 3.9.2死锁的解决方案3.9.2.1 死锁预防3.9.2.2 死锁避免最具代表性的避免算法-银行家算法 3.9.2.3 死锁的检测和恢复3.10 线程3.10.1 线程的基本概念定义：引入线程后，线程是操作系统调度和分配的基本单位。 组成：线程=？+线程控制块(TCB) 3.10.2 线程状态和线程控制块(TCB)线程状态：执行状态、就绪状态、阻塞(等待)状态 线程控制块数据结构包括： a) 线程标识符 b) 一组寄存器 c) 线程执行状态 d) 优先级 e) 线程专有存储区 f) 信号屏蔽 g) 堆栈指针 3.10.3 线程和进程的区别从以下六点讨论 a) 调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。 b) 并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。 c) 拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。 d) 独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。 e) 系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。 f) 支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。 4 处理机调度4.1 调度层级一个作业提交后，往往会经历三种层级（加线程四种） 4.1.1作业调度又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。 4.1.1.1 周转时间相关周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间 平均周转时间=所有作业周转时间之和/总作业数 带权周转时间=作业周转时间/作业执行时间 平均带权周转时间=所有带权作业周转时间之和/总作业数 4.1.1.2 响应时间，截止时间和系统吞吐量响应时间是提交请求和返回该请求的响应之间使用的时间截止时间是某任务必须开始执行或者必须完成的最迟时间吞吐量是对单位时间内完成的工作量的量度 4.1.2交换调度又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存 4.1.3进程调度又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式 4.1.3.1 非抢占方式一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。 4.1.3.2 抢占方式系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程 a) 优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU b) 短作业优先原则：就绪的短进程有权抢占长进程的CPU c) 时间片原则：一个时间片用完后，系统重新进行进程调度 4.1.4线程调度Todo 4.2 作业和进程的关系系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。 4.3 调度算法宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。 ​ 微观调度：轮转法、优先级法、多级反馈轮转法。 5 存储管理5.1 存储器结构由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。 5.1.1寄存器寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。 5.1.2高速缓存它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。 5.1.3主存输器简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。 5.1.4磁盘缓存目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。 5.2 程序的处理阶段主要有编译，链接，装入，下面主要讲链接和装入。 5.2.1程序的链接源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。链接又可分为静态链接，装入时动态链接，运行时动态链接。 5.2.2程序的装入分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。 5.3 地址变换5.3.1静态地址重定向原理：Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。 5.3.2动态地址重定位关系：MA(物理地址)=BR(基址地址)+VR(虚拟地址)。 原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。 5.4 分区存储管理分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。 5.4.1固态分区法原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。 优点:易于实现，开销小。 缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。 5.4.2动态分区法原理：动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。 优点：没有内碎片； 缺点：有外碎片； 算法：根据情况有以下俩种，着重介绍三种 a) 基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法 b) 基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法 5.4.2.2 最先适应法5.4.2.3 最佳适应法5.4.2.4 最坏适应法5.4.3页式管理（离散分配）基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。 5.4.3.1 静态页式管理原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。 5.4.3.2 动态页式管理5.4.4段式和段页式管理基本思想：todo 5.4.4.1 段式管理原理：todo 5.4.4.2 段页式管理原理：todo 5.4.5覆盖和交换技术5.5 虚拟存输器5.5.1虚拟存储的实现方式虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式： 5.5.1.1 分页请求系统在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。 硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上 5.5.1.2 请求分段系统在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页” 5.5.2页面置换算法5.5.2.1 随机淘汰算法随机地选择某个用户地页面并将其换出。 5.5.2.2 最佳置换算法（理想型淘汰算法OPT）其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。 5.5.2.3 先进先出置换算法（FIFO）总是先淘汰最先进入内存的页面。 5.5.2.4 最近最久未使用算法（LRU）选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。 5.5.2.5 最少使用置换算法（LFU）在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。 5.5.2.6 Clock置换算法是一种LRU算法每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面； 6 文件系统6.1 文件系统基本概念目的：文件系统地出现是为了更好地管理软件资源 文件系统的定义：操作系统中与管理文件有关的软件和数据称为文件系统 文件的定义：文件时一段程序和数据的集合 文件的分类：按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。 6.2 文件的逻辑结构和存取方式6.2.1逻辑结构字符流的无结构文件：管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。 记录式的有结构文件：把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。 6.2.1.1 连续结构6.2.1.2 多重结构6.2.1.3 转置结构6.2.1.4 顺序结构6.2.2逻辑存储方法6.2.2.1 顺序存输方法6.2.2.2 随机存输方法6.2.2.3 按关键字存输方法多用于复杂文件系统。 6.2.3逻辑搜索方式文件的获取是要找到文件内容所在的逻辑地址 6.2.3.1 线性搜索法6.2.3.2 散列法6.2.3.3 二分搜索法6.3 文件的物理结构和存储设备6.3.1文件物理结构6.3.1.1 连续文件连续文件采用连续分配方式： 特点：为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。优点：顺序访问容易; 顺序访问速度快;缺点：要求有连续的存储空间; 必须事先知道文件的长度; 6.3.1.2 串联文件串联文件采用链接分配 特点：文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；优点：没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。缺点：存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间; 6.3.1.3 索引文件索引文件采用索引分配 特点：每个文件都有自己的索引块，这是一个磁盘块地址的数组。 6.3.2文件存储设备存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。 6.3.2.1 顺序存取存储设备—磁带特点：只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。 影响因素：信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。 6.3.2.2 直接存取存储设备—磁盘6.4 文件存储空间管理文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。 6.4.1空闲目录管理6.4.2空闲链块法6.4.3位示图6.5 文件目录管理从文件管理角度看，一个文件包括文件说明和文件体。 6.5.1文件目录的种类6.5.1.1 单级文件目录在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。 6.5.1.2 两级文件目录目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB； 6.5.1.3 树形结构目录多级目录结构又称为树型目录结构；主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点； 6.5.2文件目录的共享从系统管理的方式来看，有三种方法可以实现文件共享 6.5.2.1 绕道法6.5.2.2 链接法6.5.2.3 基本文件目录表（BFD）6.5.3目录管理文件目录管理应该存放在磁盘，其他的没理解todo 6.6 文件存取控制用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。 6.6.1存取控制矩阵6.6.2存取控制表6.6.3口令方式6.6.4密码方式密码方式是保密性最好的验证方式。 7 设备管理7.1 设备的分类在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。 7.2 数据传输控制方式设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。 7.2.1程序直接控制方式由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。 7.2.2中断方式I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。 7.2.3DMA方式在外围设备和内存之间开辟直接的数据交换通道。 7.2.4通道控制方式以内存为中心，实现设备和内存直接交换数据的控制的方式。 7.3 中断技术原理：中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。 过程：判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点 7.3.1中断技术的分类中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。 7.3.1.1 外中断一般是来自处理机和内存外部的中断 7.3.1.2 内中断（陷阱）一般是来自处理机和内存内部的中断 7.3.1.3 软中断是通信进程之间模拟硬中断的一种信号通信方式 7.4 缓冲技术目的：缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。 分类：缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。 7.4.1缓冲池的结构缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。 7.4.2缓冲池管理Todo","categories":[{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Unity相关_FairyGUI","slug":"03006-Unity相关_FairyGUI ","date":"2021-12-12T13:00:00.000Z","updated":"2022-02-11T13:38:53.395Z","comments":true,"path":"posts/1542.html","link":"","permalink":"http://wwy010518.github.io/posts/1542.html","excerpt":"","text":"FairyGUI概叙FairyGUI基础FairyGUI基本元件FairyGUI控件普通文本字体处理富文本输入文本组控制器关联系统标签按钮单选和多选框进度条滑动条滚动条滚动容器列表下拉框Unity中的使用必备组件拓展类分辨率自适应坐标系统输入处理事件机制拖拽相关插入其他对象DrawCall优化FairyGUI进阶分支多国语言树窗口弹出功能曲面UI动效其他功能","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity相关_基于Lua的热更新解决方案","slug":"03008-Unity相关_基于Lua的热更新解决方案","date":"2021-10-28T13:00:00.000Z","updated":"2022-01-29T04:14:48.411Z","comments":true,"path":"posts/03008.html","link":"","permalink":"http://wwy010518.github.io/posts/03008.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"http://wwy010518.github.io/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://wwy010518.github.io/tags/AssetBundle/"}]},{"title":"Markdown语法格式（.md后缀-使用typora）","slug":"00001-Markdown语法格式","date":"2021-09-28T13:00:00.000Z","updated":"2022-01-24T06:26:54.746Z","comments":true,"path":"posts/1.html","link":"","permalink":"http://wwy010518.github.io/posts/1.html","excerpt":"","text":"Markdown语法格式标题：#标题1 （大） ##标题2 ###标题3 ####标题4 （小） 以此类推 最高标题6 代码块：​```代码块名称(可以输入各种语言java、c++、html等) 加粗：//加粗 **加粗** //代码高亮显示 ==高亮== //删除线 ~~删除线~~ //斜体 *斜体内容* 引用：//引用语法 &gt;作者：泽 &gt;&gt;作者：泽 &gt;&gt;&gt;作者：泽 分割线：//分割线 --- *** 图片插入：//在线图片与本地图片 ![照片名子]（/image/me.png） 超链接：//超链接语法 [超链接名字]（https://gihub.com/yerenping） 列表：//无需列表 - 目录1 -后加空格 - 目录2 - 目录3 //有序列表 1+. +名称 表格：右键》插入》表格 用代码过于复杂不推荐使用","categories":[{"name":"其他","slug":"其他","permalink":"http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://wwy010518.github.io/tags/Markdown/"}]},{"title":"UnityEditor","slug":"03016-UnityEditor","date":"2021-07-09T13:00:00.000Z","updated":"2022-02-18T11:13:50.204Z","comments":true,"path":"posts/1550.html","link":"","permalink":"http://wwy010518.github.io/posts/1550.html","excerpt":"","text":"待写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"UnityEditor","slug":"游戏引擎/Unity/UnityEditor","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"UnityEditor","slug":"UnityEditor","permalink":"http://wwy010518.github.io/tags/UnityEditor/"}]},{"title":"常用排序算法","slug":"01002-常用排序算法","date":"2021-06-30T13:00:00.000Z","updated":"2022-01-24T15:05:02.801Z","comments":true,"path":"posts/514.html","link":"","permalink":"http://wwy010518.github.io/posts/514.html","excerpt":"","text":"列举一些常用的排序算法 #冒泡排序 /// &lt;summary&gt; /// 冒泡排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void BubbleSort(int[] array, int count) { //设置标识符，如果为false意为当前数组为有序，不需要再排序了 bool shouldSorted = true; for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++) { shouldSorted = false; for (int j = count - 1; j &gt; i; j--) { if (array[j - 1] &gt; array[j]) { shouldSorted = true; Utilities.Swap(ref array[j - 1], ref array[j]); } } } } #选择排序 /// &lt;summary&gt; /// 选择排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void SelectSort(int[] array, int count) { int min; for (int i = 0; i &lt; count - 1; i++) { min = i; for (int j = i + 1; j &lt; count; j++) { if (array[min] &gt; array[j]) { min = j; } } if (min != i) { Utilities.Swap(ref array[min], ref array[i]); } } } #插入排序 /// &lt;summary&gt; /// 插入排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void InserSort(int[] array, int count) { int guard; //哨兵，用于暂存需要交换的值 for (int i = 0; i &lt; count - 1; i++) { if (array[i] &gt; array[i + 1]) { guard = array[i + 1]; int j; for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--) { array[j + 1] = array[j]; //赋值操作（依次后移） } array[j + 1] = guard; } } } #希尔排序 /// &lt;summary&gt; /// 希尔排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void ShellSort(int[] array, int count) { int i, j, guard; int increment = count; do { increment = increment / 3 + 1; //增量序列 for (i = increment + 1; i &lt; count; i++) { if (array[i] &lt; array[i - increment]) { guard = array[i]; //暂存在哨兵处 for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment) { array[j + increment] = array[j]; //记录后移，查找插入位置 } array[j + increment] = guard; //插入 } } } while (increment &gt; 1); } #堆排序 /// &lt;summary&gt; /// 堆排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void HeapSort(int[] array, int count) { for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆 { HeapAdjust(array, i, count - 1); } for (int i = count - 1; i &gt; 0; i--) { Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换 HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆 } } /// &lt;summary&gt; /// 堆排序_构造大顶堆函数 /// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义 /// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"startIndex\"&gt;起始位置&lt;/param&gt; /// &lt;param name=\"endIndex\"&gt;结束位置&lt;/param&gt; public static void HeapAdjust(int[] array, int startIndex, int endIndex) { int temp; temp = array[startIndex]; for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选 { if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1]) { ++i; //i为关键字中较大记录的下标 } if (temp &gt; array[i]) { break; //rc应插入在位置s上 } array[startIndex] = array[i]; startIndex = i; } array[startIndex] = temp; //插入 } #归并排序 /// &lt;summary&gt; /// 归并排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void MergeSort(int[] array, int count) { int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果 int k = 1; while (k &lt; count) { MergePass(array, tempArray, k, count); //array归并到tempArray k = 2 * k; //子序列长度加倍 MergePass(tempArray, array, k, count); //tempArray归并到array k = 2 * k; //子序列长度加倍 } } /// &lt;summary&gt; /// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"srChildLength\"&gt;SR中子序列长度&lt;/param&gt; /// &lt;param name=\"arrayLength\"&gt;原数组长度&lt;/param&gt; public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength) { int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数 while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, hasMergeCount + 2 * srChildLength - 2); //两两归并 hasMergeCount += 2 * srChildLength; } if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1); } else //若最后只剩下单个子序列 { for (int j = hasMergeCount - 1; j &lt; arrayLength; j++) { tr[j] = sr[j]; } } } /// &lt;summary&gt; /// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"sr1StartIndex\"&gt;SR数组子序列1起始位置&lt;/param&gt; /// &lt;param name=\"sr1EndIndex\"&gt;SR数组子序列1结束位置&lt;/param&gt; /// &lt;param name=\"sr2EndIndex\"&gt;SR数组子序列2结束位置&lt;/param&gt; private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex) { int sr2StartIndex, currentProcess; //currentProcess为当前进度 for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex; sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex; currentProcess++) //两个SR有一个被榨干后就要退出循环 { if (sr[sr1StartIndex] &lt; sr[sr2StartIndex]) { tr[currentProcess] = sr[sr1StartIndex++]; } else { tr[currentProcess] = sr[sr2StartIndex++]; } } if (sr1StartIndex &lt;= sr1EndIndex) { for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++) { tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR } } if (sr2StartIndex &lt;= sr2EndIndex) { for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++) { tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR } } } #快速排序 /// &lt;summary&gt; /// 快速排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void QuickSort(int[] array, int count) { QSort(array, 0, count - 1); } /// &lt;summary&gt; /// 快速排序_递归调用 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; private static void QSort(int[] array, int low, int high) { int pivot; while (low &lt; high) { pivot = Partition(array, low, high); QSort(array, low, pivot - 1); //尾递归，可以减少一次递归堆栈深度 low = pivot + 1; } } /// &lt;summary&gt; /// 获取枢轴数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static int Partition(int[] array, int low, int high) { int pivotkey; int m = low + (high - low) / 2; //下面是三数取中优化 //交换左端与右端数据，保证左端较小 if (array[low] &gt; array[high]) { Utilities.Swap(ref array[low],ref array[high]); } //交换中间与右端数据，保证中间较小 if (array[m] &gt; array[high]) { Utilities.Swap(ref array[m],ref array[high]); } //交换中间与左端数据，保证左端较小 if (array[m] &gt; array[low]) { Utilities.Swap(ref array[low],ref array[m]); } //默认选取当前数组的第一个值作为枢轴值 pivotkey = array[low]; //枢轴备份 int pivotkeyback = pivotkey; while (low &lt; high) { while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey) { high--; } array[low] = array[high]; while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey) { low++; } array[high] = array[low]; } //将枢轴数值替换回array[low] array[low] = pivotkeyback; //返回当前枢轴下标 return low; } #各种排序时空复杂度n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存","categories":[{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"CS基础/数据结构和算法","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"游戏MVC系列框架","slug":"04003-游戏MVC系列框架","date":"2020-12-15T13:00:00.000Z","updated":"2022-02-19T14:13:49.214Z","comments":true,"path":"posts/2051.html","link":"","permalink":"http://wwy010518.github.io/posts/2051.html","excerpt":"","text":"MVC基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑; 流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据; 总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架； 不使用MVC的逻辑： public class PlayerLevPanel : MonoBehaviour { public Button btnLevUp; public Button btnClose; //展示UI面板 public static void ShowMe() { //todo } //隐藏UI面板 public static void HideMe() { //todo } void Start() { //2.监听事件 btnClose.onClick.AddListener(ClickClose); btnLevUp.onClick.AddListener(ClickLevUp); } public void ClickClose() { Debug.Log(\"关闭\"); HideMe(); } public void ClickLevUp() { Debug.Log(\"升级\"); //存储数据 //同步更新面板上的数据 UpdateInfo(); //更新主面板的内容 MainPanel.Panel.UpdateInfo(); } //3.更新面板 public void UpdateInfo() { //更新数据 } } 不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发； 使用MVC：Model层：负责增删查改获取界面上需要的数据 public class PlayerLevModel{ //定义数据 private int lev; //外界只能获取字段 public int Lev { get { return lev; } } //通知外部更新的事件 //通过它和外部建立联系 而不是直接获取外部的面板 private event UnityAction&lt;PlayerLevModel&gt; updateEvent; //在外部第一次获取这个数据 如何获取 //通过单例模式 来达到数据的唯一性 和数据的获取 private static PlayerLevModel data = null; public static PlayerLevModel Data { get { if( data == null ) { data = new PlayerLevModel(); data.Init(); } return data; } } //数据相关的操作 // 初始化 public void Init() { lev = PlayerPrefs.GetInt(\"PlayerLev\", 1); } } public void LevUp() { //升级 改变内容 lev += 1; //改变过后保存 SaveData(); } public void SaveData() { //把这些数据内容 存储到本地 PlayerPrefs.SetInt(\"PlayerLev\", lev); UpdateInfo(); } public void AddEventListener(UnityAction&lt;PlayerModel&gt; function) { updateEvent += function; } public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function) { updateEvent -= function; } //通知外部更新外部数据的方法 private void UpdateInfo() { //找到对应的 使用数据的脚本 去更新数据 updateEvent?Invoke(this); } 视图层：负责获取控件，更新控件信息 public class PlayerLevView : MonoBehaviour{ //1.找控件 public Button btnClose; public Button btnLevUp; //2.提供面板更新的相关方法给外部 public void UpdateInfo(PlayerModel data) { txtLev.text = \"LV.\" + data.Lev; } } 控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新） public class PlayerLevController : MonoBehaviour{ //视图实例，这里视图和控制在一个物体上 private PlayerLevView roleView; private static PlayerLevController controller = null; //控制层单例 public static PlayerLevController Controller { get { return controller; } } public static void ShowMe() { if (controller == null) { //实例化面板对象 //设置它的父对象 为Canvas } //如果是隐藏的形式hide 在这要显示 controller.gameObject.SetActive(true); } public static void HideMe() { if (controller != null) { //方式一 直接删 //方式二 设置可见为隐藏 } } void Start() { //这里视图和控制在一个物体上 roleView = this.GetComponent&lt;RoleView&gt;(); //第一次更新面板 roleView.UpdateInfo(PlayerLevModel.Data); roleView.btnClose.onClick.AddListener(ClickCloseBtn); roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn); //告知数据模块 当更新时 通知哪个函数做处理 PlayerModel.Data.AddEventListener(UpdateInfo); } private void ClickCloseBtn() { HideMe(); } private void ClickLevUpBtn() { //通过数据模块 进行升级 达到数据改变 PlayerLevModel.Data.LevUp(); } private void UpdateInfo( PlayerModel data ) { if( roleView != null ) { roleView.UpdateInfo(data); } } private void OnDestroy() { PlayerLevModel.Data.RemoveEventListener(UpdateInfo); } } 好处：1.各司其职，互不干涉 —— 编程思路更清晰2.有利开发中的分工 —— 多人协同开发时，同步并行3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率缺点：1.增加了程序文件的体量 —— 脚本由一变三2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大） MV*的概念MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变； 所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。 MVP 切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部. Model层:不变 View层:不能直接传入Model模型来更新 Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入； MVVM（MP） MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细； 了解的话可以看看这些第三方MVVM框架：loxodon-Framework:vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)uMVVM:MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com) 所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心； MVE E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可； 商业框架PureMVC官网：PureMVC 框架PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；Model（数据模型）：关联Proxy(代理)对象，负责处理数据；View（界面）：关联Mediator(中介)对象，负责处理界面；Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；Notification：通知，负责传递信息；","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"http://wwy010518.github.io/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"MVC","slug":"MVC","permalink":"http://wwy010518.github.io/tags/MVC/"}]},{"title":"游戏程序基础框架","slug":"04002-游戏程序基础框架","date":"2020-11-20T13:00:00.000Z","updated":"2022-02-19T13:48:55.810Z","comments":true,"path":"posts/2050.html","link":"","permalink":"http://wwy010518.github.io/posts/2050.html","excerpt":"","text":"单例管理者基类不继承自Mono1.利用单例模式和泛形去实现模块管理者基类； public class SingletonBase&lt;T&gt; where T:new() { private static T instance; public static T GetInstance() { if (instance == null) instance = new T(); return instance; } } 继承自Mono1.直接实例化通过生成游戏对象并且附加脚本；2.Awake实例化的话要保证单例的唯一性； public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour { private static T instance; public static T GetInstance() { if (instance == null) { GameObject go = new GameObject { name = typeof(T).Name, }; instance = go.AddComponent&lt;T&gt;(); DontDestroyOnLoad(go); } return instance; } protected virtual void Awake() { if (instance == null) { instance = this as T; DontDestroyOnLoad(gameObject); } } } 事件管理者1.观察者模式，利用了泛形和委托（事件）2.这里的事件字典只能对付小游戏，大型游戏仍是不够 public interface IEventInfo { } public class EventInfo : IEventInfo { public event UnityAction actions; public EventInfo(UnityAction action) { actions += action; } public void EventTrigger() { actions?.Invoke(); } } public class EventInfo&lt;T&gt; : IEventInfo { public event UnityAction&lt;T&gt; actions; public EventInfo(UnityAction&lt;T&gt; action) { actions += action; } public void EventTrigger(T Info) { actions?.Invoke(Info); } } public class EventMgr : SingletonBase&lt;EventMgr&gt; { //暂时只定义一个字典进行储存，小游戏够用了 private Dictionary&lt;string, IEventInfo&gt; eventDic = new Dictionary&lt;string, IEventInfo&gt;(); public void AddListenter(string name,UnityAction action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions += action; else eventDic.Add(name,new EventInfo(action)); } public void AddListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions += action; else eventDic.Add(name, new EventInfo&lt;T&gt;(action)); } public void RemoveListenter(string name, UnityAction action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions -= action; } public void RemoveListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions -= action; } public void EventTrigger(string name) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).EventTrigger(); } public void EventTrigger&lt;T&gt;(string name,T info) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).EventTrigger(info); } public void Clear() { eventDic.Clear(); } } Mono根节点1.可以创建一个全局唯一的Mono节点使用2.实现游戏入口继承自该节点即可，但是实现Awake单例 public class MonoRoot : SingletonMono&lt;MonoRoot&gt; { private event UnityAction updateActions; protected override void Awake() { base.Awake(); } protected virtual void Update() { updateActions?.Invoke(); } public void AddUpdateListenter(UnityAction updateAction) { updateActions += updateAction; } public void RemoveUpdateListenter(UnityAction updateAction) { updateActions -= updateAction; } } 资源加载管理者1.资源加载有同步加载和异步加载，异步加载用协程实现2.资源加载管理者包括场景切换，以及配置文件加载 public class ResMgr : SingletonBase&lt;ResMgr&gt; { #region 资源加载 private Dictionary&lt;string,Object&gt; ObjCacheDic=new Dictionary&lt;string, Object&gt;(); public T LoadObj&lt;T&gt;(string path , bool isIns=true , bool isCache= true ) where T : Object { T obj; if (ObjCacheDic.TryGetValue(path, out Object cacheObj)) obj = cacheObj as T; else { obj = Resources.Load&lt;T&gt;(path); if (isCache) ObjCacheDic.Add(path, obj); }; if (obj is GameObject &amp;&amp; isIns) return GameObject.Instantiate(obj); else return obj; } public void LoadObjAsyn&lt;T&gt;(string path,UnityAction&lt;T&gt; callback, bool isIns = true, bool isCache = true) where T : Object { if (ObjCacheDic.TryGetValue(path, out Object obj)) { if (obj is GameObject &amp;&amp; isIns) callback(GameObject.Instantiate(obj) as T); else callback(obj as T); } else MonoRoot.GetInstance().StartCoroutine(ReallyLoadObjAsyn(path, callback, isIns, isCache)); } public IEnumerator ReallyLoadObjAsyn&lt;T&gt;(string path, UnityAction&lt;T&gt; callback, bool isIns, bool isCache) where T : Object { ResourceRequest r = Resources.LoadAsync&lt;T&gt;(path); yield return r; if(isCache) ObjCacheDic.Add(path, r.asset); if (r.asset is GameObject &amp;&amp; isIns) callback(GameObject.Instantiate(r.asset) as T); else callback(r.asset as T); } #endregion #region 场景切换 public void LoadScene(string name, UnityAction fun) { //场景同步加载 SceneManager.LoadScene(name); //加载完成过后 才会去执行fun fun(); } public void LoadSceneAsyn(string name, UnityAction fun) { MonoRoot.GetInstance().StartCoroutine(ReallyLoadSceneAsyn(name, fun)); } public IEnumerator ReallyLoadSceneAsyn(string name, UnityAction fun) { AsyncOperation op = SceneManager.LoadSceneAsync(name); while (!op.isDone) { //这里可以去做一些事情，例如更新进度条 //EventMgr.GetInstance().EventTrigger(\"更新进度条\", op.progress); yield return op.progress; } //加载完成过后 才会去执行fun fun(); } #endregion } 缓存池管理者1.用一个类类型去包装缓存队列，这个类里面应该封装了获取和设置缓存对象的方法2.缓存池目前只支持预制物的缓存 public class PoolMgr :SingletonBase&lt;PoolMgr&gt; { private Dictionary&lt;string, PoolData&gt; poolDic=new Dictionary&lt;string, PoolData&gt;(); private GameObject poolRoot; public void GetObj(string name, UnityAction&lt;GameObject&gt; callBack) { if(poolDic.TryGetValue(name, out PoolData poolData) &amp;&amp; poolData.Count &gt; 0) { callBack(poolData.GetObj()); } else { //创建资源应使用资源路径 ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(name, (go) =&gt;{ go.name = name; callBack(go); }); } } public void PushObj(string name,GameObject obj) { if(poolRoot=null)poolRoot=new GameObject(\"PoolRoot\"); if(poolDic.TryGetValue(name,out PoolData poolData)) poolData.PushObj(obj); else poolDic.Add(name, new PoolData(obj,poolRoot)); } public void Clear() { poolDic.Clear(); poolRoot = null; } } public class PoolData { private GameObject parentRoot; private Queue&lt;GameObject&gt; objQue; public PoolData(GameObject obj,GameObject poolObj) { parentRoot = new GameObject($\"{obj.name}Root\"); parentRoot.transform.parent = poolObj.transform; objQue = new Queue&lt;GameObject&gt;(); } public int Count { get { return objQue.Count; } } public void PushObj(GameObject obj) { //存起来 objQue.Enqueue(obj); //失活 让其隐藏 obj.SetActive(false); //设置父对象 obj.transform.parent = parentRoot.transform; } public GameObject GetObj() { //取出第一个 GameObject obj = objQue.Dequeue(); //激活 让其显示 obj.SetActive(true); //断开了父子关系 obj.transform.parent = null; return obj; } } 输入管理者1.输入管理者耦合事件监听和Mono根节点 public class InputMgr : SingletonBase&lt;InputMgr&gt; { private bool isStart = false; public InputMgr() { MonoMgr.GetInstance().AddUpdateListener(UpdateIpt); } public void StartOrEndCheck(bool isOpen) { isStart = isOpen; } private void CheckKeyCode(KeyCode key) { //事件中心模块 分发按下抬起事件 if (Input.GetKeyDown(key)) EventCenter.GetInstance().EventTrigger(\"某键按下\", key); //事件中心模块 分发按下抬起事件 if (Input.GetKeyUp(key)) EventCenter.GetInstance().EventTrigger(\"某键抬起\", key); } private void UpdateIpt() { //没有开启输入检测 就不去检测 直接return if (!isStart) return; CheckKeyCode(KeyCode.W); CheckKeyCode(KeyCode.S); CheckKeyCode(KeyCode.A); CheckKeyCode(KeyCode.D); } } 音效管理者1.一般音效资源应该做缓存池处理 public class MusicMgr : MonoBehaviour { private bool isMute = false; //背景音乐源 private AudioSource bkSource; //背景音乐大小 private float bkValue = 1; //一般音乐列表 private List&lt;AudioSource&gt; sourceLst = new List&lt;AudioSource&gt;(); //背景音乐大小 private float soundValue = 1; //音乐源节点 private GameObject musicRoot; public MusicMgr() { MonoMgr.GetInstance().AddUpdateListener(UpdateMsc); } //音乐播放完就回收 private void UpdateMsc() { for (int i = sourceLst.Count - 1; i &gt;= 0; --i) { if (!sourceLst[i].isPlaying) { GameObject.Destroy(sourceLst[i]); sourceLst.RemoveAt(i); } } } public void PlayBkMusic(string name) { if(!musicRoot) musicRoot=new GameObject(\"MusicRoot\"); if (bkSource) bkSource = musicRoot.AddComponent&lt;AudioSource&gt;(); //异步加载背景音乐 加载完成后 播放 ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;(\"Music/BK/\" + name, (clip) =&gt; { bkSource.clip = clip; bkSource.loop = true; bkSource.volume = bkValue; bkSource.Play(); }); } public void PauseBKMusic() { bkSource?.Pause(); } public void StopBKMusic() { bkSource?.Stop(); } public void ChangeBKValue(float v) { bkValue = v; if (bkSource == null) bkSource.volume = bkValue; } public void PlaySound(string name, bool isLoop=false, GameObject parent=null, UnityAction&lt;AudioSource&gt; callBack = null) { if (!musicRoot) musicRoot = new GameObject(\"MusicRoot\"); //当音效资源异步加载结束后 再添加一个音效 ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;(\"Music/Sound/\" + name, (clip) =&gt; { AudioSource source; if (parent) source=parent.AddComponent&lt;AudioSource&gt;(); else source = musicRoot.AddComponent&lt;AudioSource&gt;(); source.clip = clip; source.loop = isLoop; source.volume = soundValue; source.Play(); sourceLst.Add(source); if (callBack != null) callBack(source); }); } public void ChangeSoundValue(float value) { soundValue = value; for (int i = 0; i &lt; sourceLst.Count; ++i) sourceLst[i].volume = value; } public void StopSound(AudioSource source) { if (sourceLst.Contains(source)) { sourceLst.Remove(source); source.Stop(); GameObject.Destroy(source); } } } UI管理者和UI面板基类面板基类public class BasePanel : MonoBehaviour { //通过里式转换原则 来存储所有的控件 private Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt; controlDic = new Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt;(); protected virtual void Awake() { FindChildrenControl&lt;Button&gt;(); FindChildrenControl&lt;Image&gt;(); FindChildrenControl&lt;Text&gt;(); FindChildrenControl&lt;Toggle&gt;(); FindChildrenControl&lt;Slider&gt;(); FindChildrenControl&lt;ScrollRect&gt;(); FindChildrenControl&lt;InputField&gt;(); } public virtual void ShowMe() { } public virtual void HideMe() { } protected virtual void OnClick(string btnName) { } protected virtual void OnValueChanged(string toggleName, bool value) { } protected T GetControl&lt;T&gt;(string controlName) where T : UIBehaviour { if (controlDic.ContainsKey(controlName)) { for (int i = 0; i &lt; controlDic[controlName].Count; ++i) { if (controlDic[controlName][i] is T) return controlDic[controlName][i] as T; } } return null; } private void FindChildrenControl&lt;T&gt;() where T : UIBehaviour { T[] controls = this.GetComponentsInChildren&lt;T&gt;(); for (int i = 0; i &lt; controls.Length; ++i) { string objName = controls[i].gameObject.name; if (controlDic.ContainsKey(objName)) controlDic[objName].Add(controls[i]); else controlDic.Add(objName, new List&lt;UIBehaviour&gt;() { controls[i] }); //如果是按钮控件 if (controls[i] is Button) { (controls[i] as Button).onClick.AddListener(() =&gt; { OnClick(objName); }); } //如果是单选框或者多选框 else if (controls[i] is Toggle) { (controls[i] as Toggle).onValueChanged.AddListener((value) =&gt; { OnValueChanged(objName, value); }); } } } } UI管理者public class UIMgr : SingletonBase&lt;UIMgr&gt; { public Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;(); private Transform bot; private Transform mid; private Transform top; private Transform system; //记录我们UI的Canvas父对象 方便以后外部可能会使用它 public RectTransform canvas; public UIMgr() { //创建Canvas 让其过场景的时候 不被移除 GameObject obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;(\"UI/Canvas\"); canvas = obj.transform as RectTransform; GameObject.DontDestroyOnLoad(obj); //找到各层 bot = canvas.Find(\"Bot\"); mid = canvas.Find(\"Mid\"); top = canvas.Find(\"Top\"); system = canvas.Find(\"System\"); //创建EventSystem 让其过场景的时候 不被移除 obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;(\"UI/EventSystem\"); GameObject.DontDestroyOnLoad(obj); } /// &lt;summary&gt; /// 通过层级枚举 得到对应层级的父对象 /// &lt;/summary&gt; /// &lt;param name=\"layer\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Transform GetLayerFather(EUIayer layer) { switch (layer) { case EUIayer.Bot: return this.bot; case EUIayer.Mid: return this.mid; case EUIayer.Top: return this.top; case EUIayer.System: return this.system; } return null; } /// &lt;summary&gt; /// 显示面板 /// &lt;/summary&gt; /// &lt;typeparam name=\"T\"&gt;面板脚本类型&lt;/typeparam&gt; /// &lt;param name=\"panelName\"&gt;面板名&lt;/param&gt; /// &lt;param name=\"layer\"&gt;显示在哪一层&lt;/param&gt; /// &lt;param name=\"callBack\"&gt;当面板预设体创建成功后 你想做的事&lt;/param&gt; public void ShowPanel&lt;T&gt;(string panelName, EUIayer layer = EUIayer.Mid, UnityAction&lt;T&gt; callBack = null) where T : BasePanel { if (panelDic.ContainsKey(panelName)) { panelDic[panelName].ShowMe(); // 处理面板创建完成后的逻辑 if (callBack != null) callBack(panelDic[panelName] as T); //避免面板重复加载 如果存在该面板 即直接显示 调用回调函数后 直接return 不再处理后面的异步加载逻辑 return; } ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(\"UI/\" + panelName, (obj) =&gt; { //把他作为 Canvas的子对象 //并且 要设置它的相对位置 //找到父对象 你到底显示在哪一层 Transform father = bot; switch (layer) { case EUIayer.Mid: father = mid; break; case EUIayer.Top: father = top; break; case EUIayer.System: father = system; break; } //设置父对象 设置相对位置和大小 obj.transform.SetParent(father); obj.transform.localPosition = Vector3.zero; obj.transform.localScale = Vector3.one; (obj.transform as RectTransform).offsetMax = Vector2.zero; (obj.transform as RectTransform).offsetMin = Vector2.zero; //得到预设体身上的面板脚本 T panel = obj.GetComponent&lt;T&gt;(); // 处理面板创建完成后的逻辑 if (callBack != null) callBack(panel); panel.ShowMe(); //把面板存起来 panelDic.Add(panelName, panel); }); } /// &lt;summary&gt; /// 隐藏面板 /// &lt;/summary&gt; /// &lt;param name=\"panelName\"&gt;&lt;/param&gt; public void HidePanel(string panelName) { if (panelDic.ContainsKey(panelName)) { panelDic[panelName].HideMe(); GameObject.Destroy(panelDic[panelName].gameObject); panelDic.Remove(panelName); } } /// &lt;summary&gt; /// 得到某一个已经显示的面板 方便外部使用 /// &lt;/summary&gt; public T GetPanel&lt;T&gt;(string name) where T : BasePanel { if (panelDic.ContainsKey(name)) return panelDic[name] as T; return null; } /// &lt;summary&gt; /// 给控件添加自定义事件监听 /// &lt;/summary&gt; /// &lt;param name=\"control\"&gt;控件对象&lt;/param&gt; /// &lt;param name=\"type\"&gt;事件类型&lt;/param&gt; /// &lt;param name=\"callBack\"&gt;事件的响应函数&lt;/param&gt; public static void AddCustomEventListener(UIBehaviour control, EventTriggerType type, UnityAction&lt;BaseEventData&gt; callBack) { EventTrigger trigger = control.GetComponent&lt;EventTrigger&gt;(); if (trigger == null) trigger = control.gameObject.AddComponent&lt;EventTrigger&gt;(); EventTrigger.Entry entry = new EventTrigger.Entry(); entry.eventID = type; entry.callback.AddListener(callBack); trigger.triggers.Add(entry); } } /// &lt;summary&gt; /// UI层级 /// &lt;/summary&gt; public enum EUIayer { Bot, Mid, Top, System, }","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"http://wwy010518.github.io/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"Unity相关_数据持久化","slug":"03007-Unity相关_数据持久化","date":"2020-05-24T13:00:00.000Z","updated":"2022-02-11T13:39:15.443Z","comments":true,"path":"posts/1543.html","link":"","permalink":"http://wwy010518.github.io/posts/1543.html","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}]},{"title":"Unity相关_UGUI","slug":"03005-Unity相关_UGUI","date":"2020-01-24T13:00:00.000Z","updated":"2022-02-15T10:06:49.315Z","comments":true,"path":"posts/1541.html","link":"","permalink":"http://wwy010518.github.io/posts/1541.html","excerpt":"","text":"六大基础组件1.Canvas对象上依附的：Canvas：画布组件，主要用于渲染UI控件Canvas Scaler：画布分辨率自适应组件，主要用于分辨率自适应Graphic Raycaster：射线事件交互组件，主要用于控制射线响应相关RectTransform：UI对象位置锚点控制组件，主要用于控制位置和对其方式 2.EventSystem对象上依附的：EventSystem和Standalone Input Module：玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作 Canvas画布组件1.Screen Space - Overlay：屏幕空间，覆盖模式，UI始终在前； Pixel Perfect：是否开启无锯齿精确渲染（性能换效果） SortOrder：排序层编号（用于控制多个Canvas时的渲染先后顺序） TargetDisplay：目标设备（在哪个显示设备上显示） Additional Shader Channels：其他着色器通道，决定着色器可以读取哪些数据 2.Screen Space - Camera(不推荐设置成主摄像机)：屏幕空间，摄像机模式，3D物体可以显示在UI之前； RenderCamera：用于渲染UI的摄像机（如果不设置将类似于覆盖模式） Plane Distance：UI平面在摄像机前方的距离，类似整体Z轴的感觉 Sorting Layer：所在排序层 Order in Layer：排序层的序号 3.World Space：世界空间，3D模式； Event Camera：用于处理UI事件的摄像机（如果不设置，不能正常注册UI事件） 画布 - Unity 手册 (unity3d.com) CanvasScaler画布缩放控制器组件 CanvasScaler意思是画布缩放控制器，它是用于分辨率自适应的组件，它主要负责在不同分辨率下UI控件大小自适应，它并不负责位置，位置由之后的RectTransform组件负责； 1.屏幕分辨率（UI画布宽高*缩放系数 = 屏幕分辨率）：当前设备的分辨率，编辑器下Game窗口中可以查看到；2.参考分辨率：在其中一种适配模式中出现的关键参数，参与分辨率自适应的计算；3.画布宽高和缩放系数：分辨率自适应会改变的参数，通过屏幕分辨率和参考分辨率计算而来；4.分辨率大小自适应：通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数，该结果会影响所有UI控件的缩放大小； 画布缩放器 (Canvas Scaler) - Unity 手册 (unity3d.com) 缩放模式 根据屏幕尺寸进行缩放，随着屏幕尺寸变化来放大缩小（游戏开发中常用）； 1.Reference Resolution：参考分辨率（美术同学出图的标准分辨率）； 缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算； 2.Screen Match Mode：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式； Expand：水平或垂直拓展画布区域，会根据宽高比的变化来放大缩小画布，可能有黑边(缩放系数 = Mathf.Min(屏幕宽/参考分辨率宽，屏幕高/参考分辨率高)); Shrink：水平或垂直裁剪画布区域，会根据宽高比的变化来放大缩小画布，可能会裁剪(缩放系数 = Mathf.Max(屏幕宽/参考分辨率宽，屏幕高/参考分辨率高)); Match Width Or Height：以宽高或者二者的平均值作为参考来缩放画布区(在取平均值之前，我们先取相对宽度和高度的对数,float logWidth = Mathf.Log(屏幕宽 / 参考分辨率宽, 2);float logHeight = Mathf.Log(屏幕高 / 参考分辨率高, 2);,在对数空间中变换是为了获得更好的性能以及更准确的结果,float logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);scaleFactor = Mathf.Pow(2, logWeightedAverage);); 恒定像素模式 无论屏幕大小如何，UI始终保持相同像素大小。 1.Scale Factor：缩放系数，按此系数缩放画布中的所有UI元素； 2.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素），图片设置中的Pixels Per Unit设置，会和该参数一起参与计算； 计算公式：UI原始尺寸 = 图片大小（像素）/ (Pixels Per Unit / Reference Pixels Per Unit） 恒定物理模式 无论屏幕大小和分辨率如何，UI元素始终保持相同物理大小（DPI：（Dots Per Inch，每英寸点数）图像每英寸长度内的像素点数）。 1.Physical Unit：物理单位，使用的物理单位种类 2.Fallback Screen DPI：备用DPI，当找不到设备DPI时，使用此值 3.Default Sprite DPI：默认图片DP 单位种类 与1英寸的关系： Centimeters（厘米cm） 2.54 Millimeters（毫米mm） 25.4 Inches（英寸） 1 Points（点） 72 Picas（皮卡） 计算公式：根据DPI算出新的Reference Pixels Per Unit （单位参考像素） 新单位参考像素 =单位参考像素 * Physical Unit / Default Sprite DPI 再使用模式一：恒定像素模式的公式进行计算 原始尺寸 =图片大小（像素）/ (Pixels Per Unit / 新单位参考像素) ##3D模式 当Canvas的渲染模式设置为，世界空间3D渲染模式时，这时Canvas Scaler 的缩放模式会强制变为，World 3D世界模式； 1.Dynamic Pixels Per Unit：UI中动态创建的位图（例如文本）中，单位像素数（类似密度） 2.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单 位为100像素） Graphic Raycaster图像射线投射器 Graphic Raycaster意思是图形射线投射器,它是用于检测UI输入事件的射线发射器,它主要负责通过射线检测玩家和UI元素的交互,判断是否点击到了UI元素; 1.Ignore Reversed Graphics：是否忽略反转图形 2.Blocking Objects：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效） 3.Blocking Mask：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效） 图形射线投射器 - Unity 手册 (unity3d.com) RectTransform RectTransform意思是矩形变换，它继承于Transform，是专门用于处理UI元素位置大小相关的组件，Transform组件只处理位置、角度、缩放，RectTransform在此基础上加入了矩形相关，将UI元素当做一个矩形来处理，加入了中心点、锚点、长宽等属性，其目的是更加方便的控制其大小以及分辨率自适应中的位置适应； 1.Pivot：轴心(中心)点，取值范围0~1 2.Anchors(相对父矩形锚点)： 3.Min是矩形锚点范围X和Y的最小值 4.Max是矩形锚点范围X和Y的最大值 取值范围都是0~1 5.Pos(X,Y,Z)：轴心点(中心点)相对锚点的位置 6.Width/Height：矩形的宽高 7.Left/Top/Right/Bottom：矩形边缘相对于锚点的位置；当锚点分离时会出现这些内容 8.Rotation：围绕轴心点旋转的角度 9.Scale：缩放大小 10.Blueprint Mode（蓝图模式）:启用后，编辑旋转和缩放不会影响矩形，只会影响显示内容 11.Raw Edit Mode（原始编辑模式）:启用后，改变轴心和锚点值不会改变矩形位置 矩形变换 - Unity 手册 (unity3d.com) EventSystem Event System意思是事件系统，它是用于管理玩家的输入事件并分发给各UI控件，它是事件逻辑处理模块，所有的UI事件都通过EventSystem组件中轮询检测并做相应的执行，它类似一个中转站，和许多模块一起共同协作，如果没有它，所有点击、拖曳等等行为都不会被响应； 1.First Selected：首先选择的游戏对象，可以设置游戏一开始的默认选择 2.Send Navigation Events：是否允许导航事件（移动/按下/取消） 3.Drag Threshold：拖拽操作的阈值（移动多少像素算拖拽） 事件系统管理器 - Unity 手册 (unity3d.com) Standalone Input Module Standalone Input Module意思是独立输入模块，它主要针对处理鼠标/键盘/控制器/触屏（新版Unity）的输入，输入的事件通过EventSystem进行分发，它依赖于EventSystem组件，他们两缺一不可； 1.Horizontal Axis：水平轴按钮对应的热键名（该名字对应Input管理器） 2.Vertical Axis：垂直轴按钮对应的热键名（该名字对应Input管理器） 3.Submit Button：提交（确定）按钮对应的热建名（该名字对应Input管理器） 4.Cancel Button：取消按钮对应的热建名（该名字对应Input管理器） 5.Input Actions Per Second：每秒允许键盘/控制器输入的数量 6.Repeat Delay：每秒输入操作重复率生效前的延迟时间 7.ForceModule Active：是否强制模块处于激活状态 独立输入模块 - Unity 手册 (unity3d.com) 三大基础控件Text 是UGUI中用于显示文本的关键组件，可以加OutLine组件和Shadow组件配合。 Text参数: Text：文本显示内容 Font：字体 FontStyle：字体样式 Normal：普通 Bold：加粗 Italic：斜体 Bold And Italic：加粗 + 斜体 Font Size：字体大小 Line Spacing：行之间的垂直间距 Rich Text：是否开启富文本 Alignment：对其方式 Align By Geometry：使用字形集合形状范围进行水平对其，而不是字形指标 Horizontal Overflow：处理文本太宽无法放入矩形范围内时的处理方式 Wrap：包裹模式-字体始终在矩形范围内，会自动换行 Overflow：溢出模式-字体可以溢出矩形框 Vertical Overflow：处理文本太高无法放入矩形范围内时的处理方式 Truncate：截断模式-字体始终在矩形范围内，超出部分裁剪 Overflow：溢出模式-字体可以溢出矩形框 Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整字体大小 MinSize：最小多小 MaxSize：最大多大 富文本: 加粗&lt;b&gt;文本内容&lt;/b&gt; 斜体&lt;i&gt;文本内容&lt;/i&gt; 大小&lt;size=50&gt;文本内容&lt;/size&gt; 颜色: &lt;color=#ff0000ff&gt;文本内容&lt;/size&gt; &lt;color=red&gt;文本内容&lt;/size&gt; 文本 (Text) - Unity 手册 (unity3d.com) Image 是UGUI中用于显示精灵图片的关键组件，除了背景图等大图，一般都使用Image来显示UI中的图片元素。Image参数 Source Image：图片来源（图片类型必须是”精灵“类型） Color：图像的颜色 Material：图像的材质（一般不修改，会使用UI的默认材质） Raycast Target：是否作为射线检测的目标（如果不勾选将不会响应射线检测） Maskable：是否能被遮罩（之后结合遮罩相关知识点进行讲解） Image Type：图片类型 Simple-普通模式，均匀缩放整个图片 Sliced-切片模式，9宫格拉伸，只拉伸中央十字区域 Pixels Per UnitMultiplier：每单位像素乘数 Fill Center：中心填充 Tiled-平铺模式，重复平铺中央部分 Filled-填充模式 Fill Method：填充方式 Fill Origin：填充原点 Fill Amount：填充量 Clockwise：顺时针方向 Use Sprite Mesh：使用精灵网格，勾选的话Unity会帮我们生成图片网格 Preserve Aspect：确保图像保持其现有尺寸 Set Native Size：设置为图片资源的原始大小 图像 (Image) - Unity 手册 (unity3d.com) RawImage 它和Image的区别是 一般RawImage用于显示大图(背景图，不需要打入图集的图片，网络下载的图等等)。 原始图像 (Raw Image) - Unity 手册 (unity3d.com) 组合控件Button按钮控件 是UGUI中用于处理玩家按钮相关交互的关键组件。参数： Interactable：是否接受输入 Transition：响应用户输入的过渡效果 None：没有状态变化效果 ColorTint：用颜色表示不同状态的变化 TargetGraphic：控制的目标图形 Normal Color：正常状态颜色 Highlighted Color：鼠标进入时显示高亮颜色 Pressed Color：按下颜色 Selected Color：选中的颜色 Disabled Color：禁用时的颜色 Color Multiplier：颜色倍增器，过渡颜色乘以该值 FadeDuration：衰减持续时间，从一个状态进入另一个状态时需要的时间 Sprite Swap：用图片表示不同状态的变化 Highlighted Sprite：鼠标进入时图片 Pressed Sprite：按下时图片 Selected Color：选中时的颜色 Disabled Sprite：禁用时显示的图片 Animation：用动画表示不同状态的变化 Normal Trigger：正常动画触发器 Highlighted Trigger：鼠标进入状态时触发器 Pressed Trigger：按下时触发器 Selected Trigger：选中时触发器 Disabled Trigger：禁用时触发器 Navigation：导航模式，可以设置UI元素如何在播放模式中控制导航 None：无键盘导航 Horizontal：水平导航 Verticval：垂直导航 Automatic：自动导航 Explicit：指定周边控件进行导航 Visualize:可以在场景窗口看到导航连线 OnClick：单击（按下再抬起）执行的函数列表(btn.onClick.AddListenter(事件);) 按钮 (Button) - Unity 手册 (unity3d.com) Toggle开关控件 是UGUI中用于处理玩家单选框多选框相关交互的关键组件，可以通过配合ToggleGroup组件制作为单选框，默认创建的Toggle由4个对象组成，父对象——Toggle组件依附，子对象——背景图（必备）、选中图（必备）、说明文字（可选）。 Toggle参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) IsOn：当前是否处于打开状态 Toggle Transition：在开关值变化时的过渡方式 None：无任何过渡，直接显示隐藏 Fade：淡入淡出 Graphic：用于表示选中状态的图片 Group：单选框分组(需要挂载Toggle Group组件) Allow Switch Off：是否允许不选中任何一个单选框（注意：单选框分组组件可以挂载在任何对象上，只需要将其和一组的单选框关联即可） OnValueChanged：开关状态变化时执行的函数列表（ tog.onValueChanged.AddListener(事件);） 开关 (Toggle) - Unity 手册 (unity3d.com) InputField文本输入控件 是UGUI中用于处理玩家文本输入相关交互的关键组件，默认创建的InputField由3个对象组成，父对象——InputField组件依附对象 以及 同时在其上挂载了一个Image作为背景图，子对象——文本显示组件（必备）、默认显示文本组件（必备）。 InputField参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) TextComponent：用于关联显示输入内容的文本组件 Text：输入框的起始默认值 Character Limit：可以输入字符长度的最大值（0默认无限） Content Type：输入的字符类型限制 Standard：标准模式；可以输入任何字符 Autocorrected：自动更正模式；跟踪未知单词，向用户建议合适的替换候选词 Integer Number：整数模式；用户只能输入整数 Decimal Number：十进制数模式；用于只能输入数字包括小数 Alphanumeric：字母数字模式；只能输入字母和数字 Name：名字模式；自动将每个单子首字母大写 Email Address：邮箱地址模式；允许最多输入一个@符号组成的字符和数字字符串 Password：密码模式；用星号隐藏输入的字符，允许使用字符 Pin：别针模式；用星号隐藏输入的字符，只允许输入整数 Custom：自定义模式；允许自定义行类型，输入类型，键盘类型和字符验证 Line Type：行类型，定义文本格式 Single Line：只允许单行显示 Multi Line Submit：允许使用多行。仅在需要时使用新的一行 Multi Line NewLine：允许使用多行。用户可以按回车键空行 Placeholder：关联用于显示初始内容文本控件 Caret Blink Rate：光标闪烁速率 Caret Width：光标宽 Custom Caret Color：自定义光标颜色 Selection Color：批量选中的背景颜色 Hide Mobile Input：隐藏移动设备屏幕上键盘，仅适用于IOS Read Only：只读，不能改 OnValueChanged：滑动条值改变时执行的函数列表 input.onValueChanged.AddListener(事件） input.onEndEdit.AddListener(事件） 输入字段 (Input Field) - Unity 手册 (unity3d.com) Slider滑动条控件 Slider是滑动条组件，默认创建的Slider由4组对象组成，父对象——Slider组件依附的对象，子对象——背景图、进度图、滑动块三组对象。 Slider参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) FillRect：用于填充的进度条图形 Handle Rect：用于滑动的滑动块图形 Direction：滑动条值增加的方向 Left To Right：从左到右 Right To Left：从右到左 Bottom To Top：从下到上 Top To Bottom：从上到下 Min Value 和 Max Value：最小值和最大值，滑动滚动条时值从最小到最大之间变化（左右、上下极值） Whole Numbers：是否约束为整数值变化 Value：当前滑动条代表的数值 OnValueChanged：滑动条值改变时执行的函数列表（ s.onValueChanged.AddListener(事件)） 滑动条 (Slider) - Unity 手册 (unity3d.com) ScrollBar滚动条控件 是UGUI中用于处理滚动条相关交互的关键组件，默认创建的Scrollbar由2组对象组成，父对象——Scrollbar组件依附的对象，子对象——滚动块对象，一般情况下我们不会单独使用滚动条 ，都是配合ScrollView滚动视图来使用。 ScrollBar参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) Handle Rect：关联滚动块图形对象 Direction：滑动条值增加的方向 Left To Right：从左到右 Right To Left：从右到左 Bottom To Top：从下到上 Top To Bottom：从上到下 Value：滚动条初始位置值（0~1） Value：滚动块在条中的比例大小（0~1） Number Of Steps：允许可以滚动多少次（不同滚动位置的数量） OnValueChanged：滚动条值改变时执行的函数列表（ sb.onValueChanged.AddListener(事件)） 滚动条 (Scrollbar) - Unity 手册 (unity3d.com) ScrollView滚动视图控件 是UGUI中用于处理滚动视图相关交互的关键组件，默认创建的ScrollRect由4组对象组成，父对象——ScrollRect组件依附的对象 还有一个Image组件 最为背景图，子对象——Viewport控制滚动视图可视范围和内容显示、Scrollbar Horizontal 水平滚动条、Scrollbar Vertical 垂直滚动条。 ScrollRect参数: Content：控制滚动视图显示内容的父对象，它的尺寸有多大(滚动视图就能拖多远) Horizontal：启用水平滚动 Vertical：启用垂直滚动 Movement Type：滚动视图元素的运动类型。主要控制拖动时的反馈效果 Unrestricted（一般不使用）：不受限制，随便拖动 Elastic（常用）：回弹效果，当滚出边缘后，会弹回边界 Elasticity：回弹系数，控制回弹效果。值越大回弹越慢 Clamped：夹紧效果，始终限制在范围内，没有回弹效果 Inertia：移动惯性，如果开启，松开鼠标后会有一定的移动惯性 Deceleration Rate：减速率（0~1），0没有惯性，1不会停止 Scroll Sensitivity：滚轮（鼠标中间）和触摸板（笔记本）的滚动事件敏感性 Viewport：关联滚动视图内容视口对象 Horizontal Scrollbar：关联水平滚动条 Visibility：是否在不需要时自动隐藏等模式 Permanent：一直显示滚动条 Auto Hide：自动隐藏滚动条 Auto Hide And Expand Viewport：自动隐藏滚动条并且自动拓展内容视口 Spacing：滚动条和视口之间的间隔空间 OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener(事件)） Dropdow下拉列表控件 是UGUI中用于处理下拉列表相关交互的关键组件，默认创建的DropDown由4组对象组成，父对象——DropDown组件依附的对象 还有一个Image组件 作为背景图，子对象——Label是当前选项描Arrow右侧小箭头、Template下拉列表选单。 Dropdow参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) Template：关联下拉列表对象 Caption Text：关联显示当前选择内容的文本组件 Caption Image：关联显示当前选择内容的图片组件 Item Text：关联下拉列表选项用的文本控件 Item Image：关联下拉列表选项用的图片控件 Value：当前所选选项的索引值 Alpha Fada Speed：下拉列表窗口淡入淡出的速度 Options：存在的选项列表 OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener(事件)） 下拉选单 (Dropdown) - Unity 手册 (unity3d.com) 进阶知识图集制作 打图集注意的是在游戏场景插入同图集的图会打断批处理，即使在同一个图集也不行，所以要额外注意UI元素的排列顺序。 事件监听接口EventTrigger事件触发器屏幕坐标转UI相对坐标遮罩Mask模型和粒子显示在UI之前异形按钮自动布局组件画布组Canvas Group","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity相关_GUI","slug":"03004-Unity相关_GUI","date":"2020-01-10T13:00:00.000Z","updated":"2022-02-11T13:33:05.601Z","comments":true,"path":"posts/1540.html","link":"","permalink":"http://wwy010518.github.io/posts/1540.html","excerpt":"","text":"GUI概叙基础控件重要参数文本按钮单选框多选框输入框拖动条图像绘制和框复合控件工具栏和选择网格滚动视图和分组窗口自定义整体样式","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity进阶","slug":"03009-Unity进阶","date":"2019-11-13T13:00:00.000Z","updated":"2022-01-29T04:14:29.045Z","comments":true,"path":"posts/03009.html","link":"","permalink":"http://wwy010518.github.io/posts/03009.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity核心","slug":"03003-Unity核心","date":"2019-10-05T13:00:00.000Z","updated":"2022-02-11T13:18:55.188Z","comments":true,"path":"posts/1539.html","link":"","permalink":"http://wwy010518.github.io/posts/1539.html","excerpt":"","text":"2D相关图片导入设置Unity支持的图片格式BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大; TIF:基本不损失图片信息的图片格式，缺点是体积大; JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道; PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道; TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道; PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面; 其它:还支持,EXR、GIF、HDR、IFF、PICT等等,其中Unity最常用的图片格式是JPG、PNG、TGA三种格式; 纹理类型设置（Texture Type）1.Default-默认纹理，大部分导入的模型贴图都是该类型 sRGB(Color Texture)：启用可以将纹理存储在伽马空间(见下图一)中（对每一个像素做一次幂函数运算） Alpha Source：指定如何生成纹理的Alpha通道 None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道 Input Texture Alpha：输入纹理中的Alpha From Gray Scale：从输入纹理RGB值的平均值生成Alpha Alpha Is Transparency：启用可以避免边缘上的过滤瑕疵 2.Normal map-法线贴图格式： 法线贴图说明：就是在原物体的凹凸表面的每个点上均作法线法线就是垂直于某个点的切线的方向向量 Create From Grayscale：启用此属性可以从灰度高度贴图创建法线贴图 Bumpiness：控制凹凸程度，值越大凹凸感越强 Filtering：如何计算凹凸值 Smooth：使用标准算法生成法线贴图 Sharp：生成比标准模式更锐利的法线贴图 3.Editor GUI and Legacy GUI：一般在编辑器中或者GUI上使用的纹理 4.Sprite（2D and UI）：2D游戏或者UGUI中使用的格式 Sprite Mode：图像中提取精灵图形的方式 Single：按原样使用精灵图像 Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片 Polygon：网格精灵模式 Pixels Per Unit：世界空间中的一个距离单位对应多少像素 MeshType：网格类型；只有Single和Multiple模式才支持 Full Rect：创建四边形，将精灵显示在四边形上 Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状；任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是； Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小 Pivot：精灵图片的轴心点，Single模式才有此选项，对应九宫格布局的九个点，还可以自定义 Generate Physics Shape：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状，只有Single 和Multiple模式才可使用 Sprite Editor：编辑Sprite，需要安装2D Sprite包，之后单独讲解 5.Cursor：自定义光标 6.Cookie：光源剪影格式 Light Type：应用的光源类型，一般点光源的剪影需要设置为立方体纹理，方向光和聚光灯的剪影设置为2D纹理； Spotlight：聚光灯类型，需要边缘纯黑色纹理 Directional：方向光，平铺纹理 Point：点光源，需要设置为立方体形状 7.Lightmap：光照贴图格式 8.Single Channel：纹理只需要单通道的格式 Channel：希望将纹理处理为Alpha还是Red通道 Alpha：使用Alpha通道，不允许进行压缩 Red：使用红色通道; 图一：线性和伽马颜色空间说明 纹理形状（Texture Shape）1.2D：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上; 2.Cube：立方体贴图，主要用于天空盒和反射探针 Mapping：如何将纹理投影到游戏对象上 Auto：根据纹理信息创建布局 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像 Latitude-Longitude Layout：将纹理映射到2D维度/经度 Mirrored Ball：将纹理映射到类似球体的立方体贴图上 Convolution Type：纹理的过滤类型 None：无过滤 Specular：将立方体作为反射探针 Diffuse：将纹理进行过滤表示辐照度，可作为光照探针 Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误； 纹理高级设置 高级设置主要是纹理的一些尺寸规则、读写规则、以及MipMap相关设置 1.Non-Power of 2：如果纹理尺寸非2的幂如何处理(为什么纹理要设置为2的N次方：因为图形学规则，纹理必须是2的幂尺寸) None：纹理尺寸大小保持不变 To nearest：将纹理缩放到最接近2的幂的大小（注意：PVRTC格式要求纹理为正方形） To larger：将纹理缩放到最大尺寸大小值的2的幂的大小 To smaller：将纹理缩放到最小尺寸大小值的2的幂的大小 2.Read/Write Enabled：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启） 3.Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存 Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap 4.Generate Mip Maps：允许生成MipMap(开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片,在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率); Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘 Mip Map Filtering：优化图像质量的过滤方法 Box：随着尺寸减小，级别更加平滑 Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法 Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率 Alpha Cutoff Value：覆盖率参考值 Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色 纹理平铺拉伸设置Wrap Mode：平铺纹理时的方式 Repeat：在区块中重复纹理 Clamp：拉伸纹理的边缘 Mirror：在每个整数边界上镜像纹理以创建重复图案 Mirror Once：镜像纹理一次，然后将拉伸边缘纹理 Per-axis：单独控制如何在U轴和V轴上包裹纹理 Filter Mode：纹理在通过3D变化拉伸时如何进行过度 Point：纹理在靠近时变为块状 Bilinear：纹理在靠近时变得模糊 Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊 Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高 纹理平台打包设置（非常重要）1.Max Size：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内 2.Resize Algorithm：当纹理尺寸大于指定的Max Size时，使用的缩小算法 Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法 Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多 Format：纹理格式（各平台支持的格式有所不同，如果选择Automatic，会根据平台使用默认设置） 都支持的格式:下图一 移动端和网页端特有格式：下图二 不同平台单独进行设置： IOS：选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。 Andorid：推荐如下图三 由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包； 构建一个以 OpenGL ES 3 为目标的 APK，访问 Android 的 Player Settings，菜单：Edit &gt; Project Settings &gt;Player Settings，然后选择 Android 类别），向下滚动到 Graphics APIs 部分，确保 OpenGL ES 2 不在列表中，构建 APK，（菜单：File &gt; Build Settings，然后单击 Build）； 构建一个以 OpenGL ES 2 为目标的单独 APK，访问 Android Player Settings，向下滚动到 Graphics APIs 部分，在列表中添加 OpenGL ES 2，并删除 OpenGL ES 3 和 Vulkan，构建 APK。 3.Compression：选择纹理的压缩类型，帮助Unity正确选择压缩格式，会根据平台和压缩格式的可用性进行压缩； None：不压缩纹理 Low Quality：以低质量格式压缩纹理 Normal Quality：以标准格式压缩纹理 High Quality：以高质量格式压缩纹理 4.Use Crunch Compression：启用后，使用Crunch压缩，Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快； Compressor Quality:压缩质量条，质量越高意味着纹理越大，压缩事件越长。 5.Split Alpha Channel：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。 6.Override ETC2 fallback：不支持ETC2压缩的设备上，使用的格式。 图一：都支持的格式图二：移动端和网页端特有格式图三：移动端和网页端特有格式 SpriteSprite Editor1.Single图片编辑： 右下角设置窗口： Name：名字 Position：在图片中的偏移位置和宽高 Border：边框，用于设置九宫格的4条边 Pivot：轴心（中心）点位置 Pivot Unit Mode：轴心点单位模式 Normalized：标准化模式，0~1 Pixels：像素模式 Custom Pivot：自定义轴心点 （OutLine）自定义边缘线和(Physics)自定义物理形状： Snap：将控制点贴近在最近的像素 Outline Tolerance：轮廓点的复杂性和准确性，0~1值越大轮廓点越多，越准确 Generate：生成网格轮廓 //1.Sprite Editor // 基础图片设置（右下角窗口） // 主要用于设置单张图片的基础属性 //2.Custom Outline（决定渲染区域） // 自定义边缘线设置，可以自定义精灵网格的轮廓形状 // 默认情况下不修改都是在矩形网格上渲染,边缘外部透明区域会被渲染，浪费性能 // 使用自定义轮廓，可以调小透明区域，提高性能 //3.Custom Physics Shape（决定碰撞判断区域） // 自定义精灵图片的物理形状，主要用于设置需要物理碰撞判断的2D图形 // 它决定了之后产生碰撞检测的区域 //4.Secondary Textures(为图片添加特殊效果) // 次要纹理设置，可以将其它纹理和该精灵图片关联 // 着色器可以得到这些辅助纹理然后用于做一些效果处理 // 让精灵应用其它效果 2.Multiple图集元素分割： 自动分割(Automatic)： Pivot：单张图片轴心点位置 Custom Pivot：自定义轴心点 Method：如何处理现有对象 Delete Existing：替换掉已经选择的任何矩形 Smart：尝试创建新矩形同时保留或调整现有矩形 Safe：添加新矩形而不更改任何已经存在的矩形 按单元格大小分割(Grid By Cell Size)： Pixel Size：单元格宽高 Offset：偏移位置 Padding：和边缘的偏移位置 Keep Empty Rects：是否保留空矩形 按单元格大小分割(Grid By Cell Count) 增加参数Column &amp; Row：行列数 3.Polygon多边形编辑： Sprite Editor - Unity 手册 (unity3d.com) Sprite Renderer 所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的。 参数讲解: 1.Sprite：渲染的精灵图片 2.Color：定义着色，一般没有特殊需求不会修改 3.Filp：水平或竖直翻转精灵图片 4.Draw Mode：绘制模式，当尺寸变化时的缩放方式 Simple：简单模式，缩放时整个图像一起缩放 Sliced：切片模式，9宫格切片模式，十字区域缩放，4个角不变化,一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect） Tiled：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect） Continuous：当尺寸变化时，中间部分将均匀平铺 Adaptive：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺 5.Mask Interaction：与精灵遮罩交互时的方式 None：不与场景中任何精灵遮罩交互 Visible inside Mask：精灵遮罩覆盖的地方可见，而遮罩外部不可见 Visible Outside Mask：精灵遮罩外部的地方可见，而遮罩覆盖处不可见 6.Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改 7.Material：材质，可以使用一些自定义材质来显示一些特殊效果,一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse 8.Additional Settings：高级设置 Sorting Layer：排序层选择 Order in Layer：层级序列号，数值越大约会显示在前面 Sprite Renderer - Unity 手册 (unity3d.com) API： 知识点一 代码设置 GameObject obj = new GameObject(); SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;(); //动态的改变图片 sr.sprite = Resources.Load&lt;Sprite&gt;(\"dead1\"); //动态的加载 图集中的图 Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;(\"RobotBoyIdleSprite\"); sr.sprite = sprs[10]; UnityEngine.SpriteRenderer - Unity 脚本 API (unity3d.com) Sprite Creator 我们可以利用Sprite Editor的多边形工具创造出各种多边形,Unity也为我们提供了现成的一些多边形,它的主要作用是2D游戏的替代资源,在等待美术出资源时我们可以用他们作为替代品,有点类似Unity提供的自带几何体(在Project窗口右键创建各种形状的Sprite精灵图片). Sprite Creator - Unity 手册 (unity3d.com) Sprite Mask1.Sprite：遮罩图片; 2.Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）; 3.Custom Range：自定义遮罩范围,开启后可以设置遮罩的范围，按照排序层来划分; UnityEngine.SpriteMask - Unity 脚本 API (unity3d.com) Sorting Group 顾名思义，SortingGroup是排序分组的意思,它的主要作用就是对多个精灵图片进行分组排序,Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样,主要作用是对于需要分层的2D游戏用于整体排序。 排序组 - Unity 手册 (unity3d.com) Rendering.SortingGroup - Unity 脚本 API (unity3d.com) Sprite Atlas精灵图集制作 在工程设置面板中打开功能:Edit——&gt;Project Setting——&gt;Editor（Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)）；Disabled：默认设置，不会打包图集；Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包；Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集； 1.打图集面板参数相关 1.Type：图集类型 Master：主图集 Include in Build：选中可以在当前构建中包含图集 Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转 Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度 Padding：图集中各图片的间隔像素 Variant：变体类型的图集 Master Atlas：关联的主图集（图集类型必须是Master） Include in Build：选中可以在当前构建中包含图集 Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果(变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可) 2.Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它 3.Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启 4.SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。 5.Filter Mode：纹理在3D变化拉伸时如何进行过滤 Point：纹理靠近时变为块状 Bilinear：纹理靠近时变得模糊 Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊 6.Objects for Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片 7.Default: Max Texture Size：纹理的最大尺寸，像素为单位 Format：指定纹理的内部表示，在不同平台上会有不同的参数 Compression：纹理压缩类型(质量越高占用内存越多，不压缩质量最好)不压缩、低质量、普通质量、高质量； Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快 Compressor Quality：压缩质量，质量越高纹理越大，耗时越长 精灵图集 - Unity 手册 (unity3d.com) 2.API使用 知识点一 代码控制 GameObject obj = new GameObject(); SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;(); //加载图集资源 SpriteAtlas spriteAtlas = Resources.Load&lt;SpriteAtlas&gt;(\"MyAtlas\"); //加载图集资源中的某一张小图 sr.sprite = spriteAtlas.GetSprite(\"dead1\"); U2D.SpriteAtlas - Unity 脚本 API (unity3d.com) 2D物理系统刚体1.刚体类型参数说明: 1.Dynamic：动态类型（受重力和力的影响移动和旋转） Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质，如果不设置，将使用在Physics 2D窗口中设置的默认材质 物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质 Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项； Use Auto Mass：是否使用自动质量 Mass：质量 Linear Dray：影响位置移动的阻力系数 Angular Drag：影响旋转移动的阻力系数 Gravity Scale：受重力影响的程度 Collision Detection：碰撞检测算法 Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过 Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况 Sleeping Mode：对象处于静止状态时进入睡眠模式 Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大 Start Awake：最初处于唤醒状态 Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒 Interpolate：物理更新间隔之间的插值运算 None：不应用移动平滑 Interpolate：根据前一帧进行平滑处理 Extrapolate：根据后一帧位置进行平滑处理 Constraints：约束限制，可以让某一个轴不受力影响位移或者旋转 2.Kinematic：运动学类型，不受力的影响，只能通过代码让其动起来，能和Dynamic 2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数，因此它没有了质量莫摩擦系数等属性，因此它的性能能消耗较低，主要会通过代码来处理其移动旋转； Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞，如果Use FullKinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞； Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它，如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞 3.Static：静态类型完全不动的需要检测碰撞的对象，相当于是无限质量不可移动的对象，它的性能消耗最小，它只能和Dynamic 2D刚体碰撞（和只加碰撞体的区别），和它类似的有只加碰撞器而不加刚体的物体，它们会和刚体物体产生碰撞，但是自己不会动； 2D 刚体 - Unity 手册 (unity3d.com) 2.刚体API说明: 知识点一 刚体API(参考刚体3D) //加力 Rigidbody2D rigid = this.GetComponent&lt;Rigidbody2D&gt;(); rigid.AddForce(new Vector2(0, 100)); //速度 rigid.velocity = new Vector2(1, 0); UnityEngine.Rigidbody2D - Unity 脚本 API (unity3d.com) 碰撞体1.碰撞体参数相关: 1.圆形碰撞器（Circle）: Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性 Is Trigger：是否是触发器 Used By Effector：是否被附加的2D效应器使用 Offset：圆心偏移位置 Radius：圆形的半径 2.盒状碰撞器(Box): `Used by Composite：如果勾选，则该碰撞器将附加到2D复合碰撞器使用（勾选后一些属性只能在复合碰撞器中配置） Auto Tiling：如果渲染器组件的Draw Mode设置为Tiled模式，勾选该选项，当改变精灵大小时将自动更新碰撞器尺寸； Size：矩形的宽高 Edge Radius：使四个顶点为圆角 3.多边形碰撞器(Polygon) Points：多边形顶点虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了，都通过Edit Collider编辑，或者让Unity自动识别创建 4.边界碰撞器(Edge地形)：边界碰撞器的编辑主要还是通过Edit Collider一般不会手动去通过数值加点 5. 5.胶囊碰撞器(Capsule) Size：胶囊的宽高 Direction：是竖直胶囊还是水平胶囊 6.复合碰撞器(Composite必须配合刚体使用) Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型 Outlines：空心轮廓，类似边界碰撞器 Polygons：实心多边形，类似多边形碰撞器 Generation Type：生成类型，复合碰撞器在何时生成新几何体 Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体 Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮 Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值 2D 碰撞体 - Unity 手册 (unity3d.com) 2.碰撞器API：碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致： 知识点一 碰撞检测函数 private void OnCollisionEnter2D(Collision2D collision) private void OnCollisionExit2D(Collision2D collision) private void OnCollisionStay2D(Collision2D collision) private void OnTriggerEnter2D(Collider2D collision) private void OnTriggerExit2D(Collider2D collision) private void OnTriggerStay2D(Collider2D collision) 物理材质物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质物理材质参数相关： Friction：摩擦系数，为0表示没有摩擦力 Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹） 恒定力（了解即可）恒定力（Constant Force）参数说明： Force：物理更新时施加于2D刚体上的线性力 Relative Force：物理更新时施加的线性力（相对刚体对象坐标系） Torque：物理更新时施加于2D刚体的扭矩力 效应器(Effector)效应器参数相关: 1.区域效应器（Area）：在一个区域内让游戏对象受到力和扭矩力的作用(作浮力和电梯传送带) Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象 Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度 Force Angle：施加力的角度 Force Magnitude：施加力的大小 Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化 ForceTarget：效应器在目标对象上施加力的作用点 Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转） Rigidbody：以刚体的当前质心（不会产生扭矩力） Drag：阻力 Angular Drag：扭矩阻力 2.浮力效应器（Buoyancy）：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动 Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮，密度和流体相同的碰撞体会浮在流体中 Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移 Linear Drag：影响对象在水中移动的阻力系数 Angular Drag：影响对象在水中旋转的阻力系数 Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力 Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小 Flow Variation：随机改变流体力的值 3.点效应器：模拟磁铁 吸引或者排斥的效果 Force Magnitude：施加力的大小 Force Variation：施加力的大小变化 Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放 Force Source：力源来自哪个位置，从该点计算距离。 Collider：碰撞器的位置 Rigidbody：刚体的位置 Force Target：作用力目标位置，用改点计算位置 Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力 Rigidbody：刚体的位置，不会产生扭矩力 Force Mode：计算力的模式 Constant：忽略源和目标之间相隔的距离 Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小 Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力 4.平台效应器（Platform）：2D游戏当中的平台或可往上跳跃的墙壁 Rotational Offset：旋转偏移量，控制平台角度偏移 Use One Way：是否使用单向碰撞行为 Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为 Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞 Use Side Friction：是否应该在平台两侧使用摩擦 Use Side Bounce：是否应该在平台两侧使用弹性 Side Arc：用于定义左右两侧平台的响应弧度 5.表面效应器（Surface）：模拟传送带 Speed：表面保持的速度 Speed Variation：速度的随机增加值 Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力 Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转 Use Friction：是否使用摩擦力 Use Bounce：是否使用弹力 2D 效应器 - Unity 手册 (unity3d.com) SpriteShape SpriteShape是精灵形状的意思（在Package Manager中导入相关工具），它主要是方便我们以节约美术资源为前提，制作2D游戏场景地形或者背景的。类型：开放不封闭的图形、封闭的图形； Sprite Shape Profile精灵形状概述文件Sprite Shape Profile精灵形状概述文件配置： Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸 Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式） Offset：纹理偏移量 Angle Ranges：角度范围（ 这里的设置主要用于封闭图形在不同角度范围内使用的图片不同，可以达到一个封闭效果） Start：起始角度 End：结束角度 Order：Sprite相交时的优先级，优先级高的显示在前面 Sprites：指定角度范围内的精灵列表，在该角度范围内，可以选择使用的图片资源 Corners：指定角显示的精灵图片，主要用于封闭图形，外部四个角用的图片，内部四个角用的图片 Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器Sprite Shape Renderer - Unity 手册 (unity3d.com) 参数相关： 1.Sprite Shape Renderer精灵形状渲染器：该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息 Color：颜色 Mask Interaction：遮罩相互作用规则设置 Fill Material和Edge Material：填充材质和边缘材质 Sorting Layer和Order in Layer：排序相关 2.Sprite Shape Controller精灵形状控制器： Profile：使用的精灵形状概述文件 Detail：精灵形状的质量（高中低三种质量） Is Open Ended：是否是开放的，不封闭的 Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸，开启后只有宽度够才会平铺，如果宽度不够会拉伸，不开启始终平铺，但是可能会出现裁剪效果，一般根据你的实际效果进行选择； Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量 Enable Tangents：是否启用切线计算功能（如果你的着色器中需要切线信息参与计算，则勾选） Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片 Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上 Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小 Worldspace UV：根据世界控件的UV填充纹理 启用编辑状态后： Tangent Mode ：切线模式（从左至右依次是） 顶点模式-点两侧不构成曲线 切线模式-点两侧构成曲线，并且可以控制切线弧度 左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度 Position：选中点的局部坐标位置 Height：控制点左右两侧精灵图片的高度 Corner：是否使用角度图片 Disabled：不使用角度图片 Automatic：自动 Sprite Variant：选择使用的精灵图片 Snapping：是否开启捕捉设置控制点 Tilemap(过后再来学)动画基础Animation动画窗口面板左侧（说明）： 顶部从左至右： 1.预览模式（开关） 2.录制模式（开关）打开后预览模式默认开启 3.回到动画开头 4.上一关键帧（快捷键：键盘逗号） 5.播放动画（快捷键：键盘Alt+逗号） 6.下一关键帧（快捷键：键盘句号） 7.回到动画结尾（快捷键：键盘Alt+句号） 8.当前处于第几帧 底部Dopesheet：关键帧模式 底部Curves：曲线模式 中部从左至右： 按选择筛选 添加关键帧 添加事件 面板左侧（操作）： 多出一个可以选择当前动画的下拉列表：可以在这里创建新动画和切换动画 多出一个可以添加变化属性的按钮：在这里你可以任意添加你想要在动画中变化的脚本变量 面板右侧（说明）： 动画时间轴面板：当编辑动画时，会在该面板上编辑关键帧等信息 右侧面板（操控）： 时间轴可以拖动（注意）：时间轴上的单位为n秒n帧，一格代表一帧（并不是秒） 选择关键帧右键： Add Key：添加关键帧 Delete Key：删除关键帧 Clamped Auto：切线模式，自动设置切线 Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画 Free Smooth：自由设置切线 Flat：切线设置为水平 Broken：单独控制左右曲线切线 Free：自由设置 Linear：直线 Constant：常量切换 Weighted：权重切换 使用 Animation 视图 - Unity 手册 (unity3d.com) Animation老动画组件 在创建动画之前为对象添加Animation组件之后再制作动画，这时制作出的动画和之前的动画格式是有区别的。Animation组件参数相关： Animation组件：默认播放的动画 Animations：该动画组件可以控制的所有动画 Play AutoMatically：是否一开始就自动播放默认动画 Animate Physics：动画是否与物理交互 Culling Type：决定什么时候不播放动画 Always Animate：始终播放 Based On Renderers：基于默认动画姿势剔除 老动画Animation文件参数相关： Default：读取设置得更高的默认重复模式 Once：播放一次就停止 Loop：从头到尾不停循环播放 PingPong：从头到尾从尾到头不停播放 ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同； 老Animation组件API 知识点一 代码控制播放 //1.播放动画 animation.Play(\"1\"); //2.淡入播放,自动产生过渡效果 //当你要播放的动画的开始状态 和当前的状态 不一样时 //就会产生过渡效果 animation.CrossFade(\"3\"); //3.前一个播完再播放下一个 animation.PlayQueued(\"2\"); animation.CrossFadeQueued(\"2\"); //4.停止播放所有动画 animation.Stop(); //5.是否在播放某个动画 if( animation.IsPlaying(\"1\") ) //6.播放模式设置 animation.wrapMode = WrapMode.Loop; //7.其它（了解即可，新动画系统中会详细讲解） //层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果） //设置层级 animation[\"1\"].layer = 1; //设置权重 animation[\"1\"].weight = 1; //混合模式 叠加还是混合 animation[\"1\"].blendMode = AnimationBlendMode.Additive; //设置混组相关骨骼信息 animation[\"\"].AddMixingTransform(); UnityEngine.Animation - Unity 脚本 API (unity3d.com) Animator动画控制器面板1.左侧面板 Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的 Parameters：参数页签，为动画状态机添加控制状态切换的参数 眼睛图标：显隐左侧面板 2.右侧面板： 网格化布局区域（主要用于编辑状态之前的切换关系）；1.窗口中的每一个矩形表示一个状态；2.窗口中的每一个箭头表示一个切换条件； 矩形说明： 默认三大矩形： 绿色Entry矩形：进入状态机流程 红色Exit矩形：退出状态机流程 Any State：任意状态，代表状态机中的任意状态 人为添加矩形： 橙色矩形：一开始的默认状态动画，和Entry相连，表示一开始播放的动画 灰色矩形：自己添加的某一种动作状态 Animator Controller - Unity 手册 (unity3d.com) Animator新动画组件Animator组件参数相关： Controller：对应的动画控制器（状态机） Avatar：对应的替身配置信息（之后讲解3D模型时详细讲解） Apply Root Motion：是否启用动画位移更新 UpdateMode：更新模式（一般不修改它）: Normal：正常更新 Animate Physics：物理更新 Unscaled Time：不受时间缩放影响； Culling Mode：裁剪剔除模式： Always Animate：始终播放动画，即使在屏幕外也不剔除； Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入； Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用； 新动画文件(.ani)界面参数: Loop Time：是否是循环动画（在动画结尾时重新开始） Loop Pose：无缝循环运动 Cycle Offset：循环动画在其他时间开始时的周期偏移 Animator组件API 知识点一 Animator中的API //我们用代码控制状态机切换主要使用的就是Animator提供给我们的API //我们知道一共有四种切换条件 int float bool trigger //所以对应的API也是和这四种类型有关系的 animator = this.GetComponent&lt;Animator&gt;(); //1.通过状态机条件切换动画 animator.SetFloat(\"条件名\", 1.2f); animator.SetInteger(\"条件名\", 5); animator.SetBool(\"条件名\", true); animator.SetTrigger(\"条件名\"); animator.GetFloat(\"条件名\"); animator.GetInteger(\"条件名\"); animator.GetBool(\"条件名\"); //2.直接切换动画 除非特殊情况 不然一般不使用 animator.Play(\"状态名\"); UnityEngine.Animator - Unity 脚本 API (unity3d.com) 2D动画序列帧动画骨骼动画-2DAnimation骨骼动画-Spine3D模型导入相关模型导出：在 Unity 外部创建资源（模型导出） - Unity 手册 Model模型页签Model模型页签说明 1.Scene场景相关设置： *Scale Factor：当模型中的比例不符合项目中的预期比例时，可以修改此值来改变该模型的全局比例Unity的物理系统希望游戏世界中的1米在导入模型文件中为1个单位； *Convert Units：启用可将模型文件中定义的模型比例转换为Unity的比例，不同的格式的比例如下，.fbx .max .jas = 0.01，.3ds = 0.1，.mb .ma .lxo .dxf .blend .dae = 1； Import BlendShapes：是否允许Unity随网格一起导入混合形状，当导入包含混合形状的网格时，将使用Skinned MeshRenderer组件（注意：1.导入混合形状发现需要在FBX文件中具有平滑组；2.如果想要导入具有法线的混合形状；把下方的Blend Shape Normals属性设置为Import，将使用FBX文件的发现，或者把下方的Blend Shape Normals属性设置为Calculate，Unity使用相同的逻辑来计算网格和混合形状上的法线）； Import Visibility：是否导入可见性，开启后可以从FBX文件中读取可见性属性。，比如模型动作里 有些动作是要隐藏模型形象的，开启后才会生效，一些3D建模软件对可见性属性不支持或者有限制，比如Maya和Blender就对可见性有限制，所以一般这个选项要根据你使用的建模软件决定（一般可以不勾选）； Import Cameras：是否导入摄像机； *Preserve Hierarchy：始终创建一个显示预制体根，通常在导入的时候，FBX会将模型中的空根节点进行优化去掉它，但是如果多个FBX文件中包含同一层级的空跟对象，可以勾选它来保留他们；主要作用是：比如有两个fbx文件，1包含骨骼和网格，2只包含骨骼动画。如果不启用它导入2，那么Unity将剥离根节点，会让层级不匹配让动画不能正常播放； Sort Hierarchy By Name：在层级窗口中根据名字排序子物体，如果不启用，会保留FBX文件中定义的层级顺序； 2.Meshes网格相关设置： *Mesh Compression-网格压缩，设置压缩比级减小网格的文件大小，提高压缩比会降低网格的精度，调整该参数可以优化游戏包的大小： Off：不使用压缩 Low：低压缩比 Medium：中等压缩比 High：高压缩比 *Read/Write Enabled：是否开启读写网格信息，如果开启，Unity将网格数据传给GPU后，在CPU中还会保留可寻址内存，意味着我们可以通过代码访问网格数据进行处理，如果不开启，Unity将网格数据传个GPU后，会将CPU中的可寻址内存中网格数据删除，我们无法再得到网格数据，开启时，会增加内存占用，关闭时，可以节约运行时内存使用量（何时开启？；1.需要在代码中读取或写入网格数据；2.需要运行时合并网格；3.需要使用网格碰撞器时；4.需要运行时使用NavMesh构建组件来烘焙NavMesh时）； Optimize Mesh-确定三角形在网格中列出的顺序以提高GPU性能： Nothing：无优化 Everything：对顶点以及多边形顶点索引进行重新排序 Polygon Order：仅对多边形重新排序 Vertex Order：仅对顶点重新排序 *Generate Colliders：生成碰撞器，启用后会自动附加网格碰撞器的情况下导入你的网格，建议不移动的环境几何体可以开启它，但是需要移动的几何体建议不要开启它； 3.Geometry几何体相关设置： *Keep Quads：保留四边形，启用后，Unity不会将4个顶点的多边形转为三角形，当使用曲面细分着色器时可能需要启用此选项，因为四边形的曲面周色漆比多边形的效率更高； *Weld Vertices：合并在空间中共享相同位置的顶点，前提是这些顶点总体上共享相同的属性（UV，法线，切线等等）（开启后相当于会通过减少网格的总数量来优化网格的顶点计数）；一般都开启，除非你想有意保留这些重复顶点，之后想通过代码去获取他们来进行处理； Index Format：网格索引缓冲区的大小（一般都选择16bits，Auto可以会默认选择16bits，只有在必要时使用32bit，16bits即通用又节约内存）； Legacy Blend Shape Normals：启用后会基于Smoothing Angle值来计算法线； Normals-定义如何计算法线： Import：从文件中导入法线，如果文件中不包含发现信息，将使用Calculate模式计算法线 Calculate：根据Normals Mode、Smoothness Source和Smoothing Angle属性来计算发现 None：不计算法线 Blend Shape Normal：定义如何为混合形状计算法线，只有当Legacy Blend Shape Normals禁用时出现 Normals Mode：计算法线的模式，只有当上方的Normals设置为Import和Calculate才会出现 Unweighted Legacy：2017.1版本之前计算法线的方式，如果是在该版本之前导入的所有FBX模型，默认设置为该模式 Unweighted：法线不加权重 Area Weighted：法线按照图面面积加权重 Angle Weighted：法线按照每个图面上的顶角加权重 Area And Angle Weighted：法线按照每个图面上的图面面积和顶角加权重，这是默认选项 Smoothness Source-如何确定平滑，哪些边应该平滑，哪些应该粗糙，只有当Legacy Blend Shape Normals 禁用时出现： Prefer Smoothing Groups：尽可能使用模型文件中的平滑组 From Smoothing Groups：仅使用模型文件中的平滑组 From Angle：使用Smoothing Angle值来确定哪些边应该是平滑的 None：不拆分硬边的任何顶点 Smoothing Angle：控制是否为硬边拆分顶点，通常，值越大，产生的顶点越少，仅当Normals设置为Calculate时才可用（注意：此设置仅用于非常光滑的或者非常复杂的模型，否则，最好在3D建模软件中手动平滑然后导入，始终建议建模的时候就做好，更加准确）； Tangents-定义如何导入或计算顶点切线，仅当Normals设置为Calculate或Import时，此属性才可用： Import：如果Normals设置为Import，则从FBX文件中导入顶点切线，如果网格没有切线，那么将无法使用法线贴图着色器 Calculate Legacy：使用旧版算法计算切线 Calculate Legacy With Split Tangents：使用旧版算法计算切线，并在UV图表上进行拆分。如果网格上的接缝碰坏了法线贴图光照，请使用此属性 Calculate Mikktspace：使用米克特空间计算切线 None：不导入顶点切线，网格没有切线，则无法使用法线贴图着色器 Swap UVs：在网格中交换UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项 Generate Lightmap UVs：为光照贴图创建第二个UV通道 Model 选项卡 - Unity 手册 (unity3d.com) Rig操纵骨骼页签Animation Type-动画类型说明: 1.None-不存在动画:主要用于一些环境静态模型 2.Humanoid-人形模型,一般情况下，有头和四肢（一个头两条腿两只手）为人形,人形模型需要使用Avatar化身系统,绑定人主要关节的映射关系: Avatar Definition：选择获取Avatar定义的位置 No Avatar：没有化身系统信息 Create From This Model：根据此模型创建Avatar化身信息 Copy from Other Avatar：指向另一个模型上设置的Avatar化身信息 Source：复制另一个具有相同骨架的Avatar化身信息以导入其动画剪辑,使用Copy From Other Avatar时才有 Configure...：打开Avatar化身配置,使用Create From This Model时才有 Skin Weights：设置影响单个顶点的最大骨骼数量 Standard（4 Bones）：使用最多4个骨骼来产生影响。默认值，处于对性能考虑，建议使用此设 Custom：设置自定义的最大骨骼数，选择后会出现下方的两个选项 Max Bones/Vertex：定义每个顶点的最大估个数，值越大性能消耗越大 Max Bone Weight：设置考虑骨骼权重的最低阈值，权重计算时将忽略小于此值的内容 Optimize Game Objects：在Avatar化身系统和Animator动画组件中删除和存储所导入角色的游戏对象骨骼层级信息。如果启用会出现下方的Extra Transforms to Expose选项。角色将使用Unity动画系统的内部骨架，可以提高动画角色的性能 Extra Transforms to Expose：要公开的骨骼层级，在下方打钩将公开该骨骼层级信息 放大镜：通过名称搜索对应骨骼信息 Toggle All：全选或者反选 Collapse All：全部折叠 Expand All：全部展开 3.Generic-通用模型，非人形模型,不是标准的人形模型，可以是任意形状，可能有8只腿两个头等等,这种模型主要需要设置骨骼根节点: Root Node：选择用于此Avatar的根节点的骨骼（仅当选择Create From This Model才会出现） 4.Legacy-旧版动画类型与Unity3.x及更早版本导入和使用动画一般不使用: Generation：动画导入方法 Don't Import：不导入动画 第2~4个选项：已禁用，勿使用 Store in Root（New）：导入动画将其存储在模型的根节点中 Avatar设置说明： 1.Mapping设置-我们需要在这个页签对模型关节进行映射设置，因为人物动画无非就是改变这些关节的角度： 部位设置：身体，头部，左右手，关节映射信息设置 Mapping选项： Clear：清空映射 AutoMap：自动映射 Load：从文件中读取 Save：保存映射信息 Pose选项： Reset：重置姿势 Sample Bind-Pose：绑定姿势示例 Enforce T-Pose：强制T姿势 2.Muscles&amp;Settings设置： Muscle Group Preview-肌肉群预览：可以在这里预览在不同姿势的旋转变化，用来观察之前的关联映射关系是否合理，主要起到预览作用； Per-Muscle Settings-肌肉设置：，用于设置各骨骼在旋转时的范围限制，因为如果不设置限制，在一些极限角度时会非常奇怪，我们可以在这里单独设置限制范围； Additional Settings-高级设置：可以设置手脚的扭转和伸展值，一般不会修改他们，其中Translation DoF比较重要，如果启用，将启用人形角色的移动动画，如果禁用，Unity仅使用旋转对骨骼进行动画化，但是启用后，会提升性能消耗，因为动画需要执行额外步骤来重定向人形动画，除非动画包含角色某些骨骼的动画式移动才会启用，一般情况下禁用即可； Rig 选项卡 - Unity 手册 (unity3d.com) Animation动画页签1.如何导入外部创建的模型资源：在 Unity 外部创建资源 - Unity 手册 2.使用多个模型文件来导入动画：提取动画剪辑 - Unity 手册 动画基础信息设置Import Constraints-从此资源导入约束：启用后，Unity会自动添加相应的约束组件将其关联到正确的游戏对象 Import Animation-从此资源导入动画：如果禁用，下面的都没有，并且不会导入任何动画； Bake Animations：通过反向动力学（IK）或模拟创建的动画以便推进运动关键帧，仅用于Maya、3Dmax和Cinema4D文件 Anim.Compression：导入动画时使用的压缩类型 Off：禁用动画压缩，在导入时Unity不会减少关键帧数量，效果最好性能较低，文件较大，运行时内存占用也大。通常不建议使用 Keyframe Reduction：减少冗余关键帧，仅适用于Generic通用动画类型 Keyframe Reduction and Compression：减少关键帧并在文件中存储动画时压缩关键帧，会影响文件大小，但是内存大小和Keyframe Reduction相同，仅适用于Legacy旧版动画类型 Optimal：让Unity决定如何压缩，仅适用Generic通用和Humanoid人形动画类型 Rotation Error：设置旋转曲线压缩容错度（百分比），原始旋转值和减小值之间的最小角度 Position Error：设置位置曲线压缩容错度（百分比） Scale Error：设置缩放曲线压缩容错度（百分比） （如果原始值和消减值之间的差小于原始值乘以容错百分比，会删除关键帧）这些内容仅在Keyframe Reduction或Optimal压缩时可用； Animated Custom Properties：导入你指定为自定义用户属性的任何FBX属性 动画剪辑选择列表：在这里我们可以看到所有的动画剪辑可以通过+或-来新增剪辑或者删除所选的剪辑，在这里选择一个动画剪辑后，我们可以在下方编辑具体的相关属性信息 动画剪辑属性基本设置动画剪辑属性: 1.动画剪辑名称:可编辑修改 2.时间轴:Start动画剪辑的开始帧,End动画剪辑的结束帧,我们可以在时间轴中定义每个动画剪辑的帧范围; 3.动画重要信心设置: Loop Time：播放动画剪辑时是否循环播放，到结尾时重新开始 Loop Pose：无缝循环运动 Loop Match：循环匹配 Cycle Offset：循环动画在其他时间开始时的周期偏移 Root Transform Rotation：根位置的角度相关 Bake Into Pose：将根旋转烘焙到骨骼移动，禁用此选项将存储为根运动 Based Upon：根旋转的基础 Original：保持源文件中的原始旋转 Root Node Rotation：使用根节点的旋转（仅适用Generic通用动画类型） Body Orientation：保持上半身朝前（仅适用于Humanoid人形动画类型） Offset：根旋转偏移（单位：度） Root Transform Position（Y）：根垂直位置（Y轴方向） Bake Into Pose：将垂直根运动烘焙到骨骼移动。禁用此选项将会存储为根运动 Based Upon（at Start）：垂直方向根位置的基础 Original：保持源文件中的垂直位置 Root Node Position：使用垂直根位置（仅适用Generic通用动画类型） Center Of Mass：保持质心与根位置对其（仅适用Humanoid人形动画类型） Feet（推荐）：保持双脚与根变换位置对齐（仅适用Humanoid人形动画类型） Offset：垂直根位置偏移 Root Transform Position（XZ）：根水平位置（XZ平面） Bake Into Pose：将水平根运动烘焙到骨骼移动。禁用此选项将会存储为根运动 Based Upon：水平根位置的基础 Original：保持源文件中的水平位置 Root Node Position：使用水平根位置（仅适用Generic通用动画类型） Center Of Mass：保持与根位置对其（仅适用Humanoid人形动画类型） Mirror：在此剪辑中进行左右镜像（仅Humanoid人形动画类型才显示） Additive Reference Pose：启用后可以设置附加动画层基础参考姿势的帧。在时间轴中可以看到蓝色标记，附加动画层：在动画控制器（状态机）中可以添加新的动画层： Pose Frame：当启用参考姿势帧时，该项就是选择的具体是哪一帧 动画剪辑属性其它设置其它设置说明: 1.Curves:曲线可以配合Animator作为参数，通过加入曲线值可以利用他标记重要的点,可以修改曲线的名字，名字就类似参数名,可以通过加减来添加或删除曲线信息;(曲线中的值X轴代表标准化时（0~1）代表动画的开始和结尾;Y轴的值可以根据需求自己设置也可以使用下方提供的预设曲线) 2.Events动画事件(不推荐延迟严重):类似之前我们学习的Animation窗口中的动画事件可以在这里为动画剪辑添加一个事件，当动画播放到事件处时会自动找对象脚本中的同名函数,当我们希望在动画某一时刻进行逻辑处理时非常常用,比如某一时刻进行伤害判断 3.Mask动画遮罩:主要作用是当播放该动画时，可以指定哪一部分或者哪些骨骼排除在外不受动作影响,Humanoid（人形动画的快捷设置）,我们分别可以控制,头、左右臂、左右手、左右腿、根等,点击他们让他们变成红色，就代表做该动作时不影响该部位,Transform（明确指定哪些骨骼关节点不受影响） 4.Motion:当导入的动画剪辑包含根运动时,我们可以在这里手动设置特定骨骼关节点作为我们的根运动节点,展开后看到的都是骨骼关节节点 5.Inport Messages:当我们导入动画出现问题，看到黄色的警告符号时,你可以将 Generate Retargeting Quality Report 选中,Unity会帮我们生成更多的有关重定向问题的具体信息,我们便可以看到具体的一些问题(只有看到警告动画不正确时才启用，可以帮助我们排查问题); Animation 选项卡 - Unity 手册 (unity3d.com) Materials材质纹理页签材质纹理页签说明： Material Creation Mode-定义希望Unity如何为模型生成或导入材质： None：不使用此模型中嵌入的任何材质，改用Unity的默认漫反射材质 Standard：导入时，Unity使用默认规则来生成材质 Import via MaterialDescription（Experimental）：导入时，Unity使用FBX文件中嵌入的材质描述来生成材质；（与Standard相比，该方法结果更准确，并且支持更广泛的材质类型。） sRGB Albedo Colors：是否在伽马空间中使用反射率颜色，对于使用线性颜色控件的项目，禁用此选项； Location：定义如何访问材质和纹理 Use Embedded Materials：将导入的材质保持在导入的资源中 Use External Materials（Legacy）：将导入的材质提取为外部资源。旧版材质处理方式，适用于2017.1或更早的Unity版本创建的项目 Extract Textures/Materials：当选择Use Embedded Materials后会出现的内容。这两个按钮可以提取导入的资源中嵌入的所有材质和纹理。 Naming：定义材质的命名规则 By Base Texture Name：使用导入材质的漫反射纹理名称来命名材质。如果未将漫反射纹理分配给材质，Unity将使用导入材质的名称 From Model's Material：使用导入材质的名称来命名材质 Model Name + Model's Material：使用模型文件的名称与导入材质的名称相结合来命名材质 Search：定义在使用Naming选项定义的名称时查找现有材质的位置规则 Local Materials Folder：在本地Materials材质子文件夹（模型文件所在的同一文件夹）中查找现有材质 Recursive-Up：在所有父文件夹（一直向上追溯到Assets文件夹）中所有Materials子文件夹中查找现有材质 Project-Wide：在所有Unity项目文件夹中查找现有材质 重新映射的材质:如果找到了，Unity会自动关联,如果没有找到，我们可以手动进行关联; Materials 选项卡 - Unity 手册 (unity3d.com) 3D动画Animator Controller - Unity 手册 (unity3d.com) 3D动画使用状态参数状态参数说明 Motion：分配给此状态的动画剪辑 Speed：动画的默认速度 Multiplier：控制速度的乘数，如果要使用需要勾选的Parameter选中配合的参数float类型 Motion Time：运动的时间，如果要使用需要勾选的Parameter选中配合的参数float类型 Mirror：是否为状态生成镜像，仅适用于人形动画，如果要配合参数使用选中旁边的Parameter关联参数，参数是bool类型 Cycle Offset：循环偏移时间，如果要配合参数使用选中旁边的Parameter关联参数，参数是float类型 Foot IK：是否遵循Foot IK，适用于人形人形动画 Write Defaults：AnimatorStates 是否为其运动执行未动画化的属性写回默认值。 Solo：仅播放该过渡 Mute：禁用过渡 Solo和Mute如果一起选择，Mute优先执行 Add Behaviour：添加状态机行为脚本，之后会专门讲解 连线参数连线参数 改名框：可以在这里为动画过渡改名，如果不改，对应的名字就是，\"某一状态名\"-&gt;\"某一状态名\"； Has Exit Time：是否有退出时间，如果勾选，当切换动画时，动画一定是播放到下方的Exit Time（百分比）的时间时才过渡到下一个动画 Exit Time：退出时间，当选择上方的Has Exit Time时，该值决定了过渡生效的确切时间。该值可以大于1，如果小于1，比如0.85，表示当动画播放到了85%的动画时，就会过渡。如果大于1，比如4.5，那么动画将循环4.5次后过渡到下一个动画 Fixed Duration：选中后，下方的Trnaition Duration过渡持续时间将以秒为单位解读过渡时间，如果不选中，则以百分比解读过渡时间 Transition Duration(s/%)：过渡持续时间，相当于从该状态切换到下一状态的过渡动画持续的时间，对应下方两个蓝色箭头包裹区域 Transition Offset：过渡到目标状态的起始播放的时间偏移。如果是0则从目标状态开头开始播放，如果是0.5则从目标状态的一半开始播放，你可以理解为切入下一个状态的切入点； Interruption Source：该过渡中断的情况 None：不在添加任何过渡 Current State：将当前状态过渡排队 Next State：使下一个状态的过渡进行排队 Current State Then Next State：将当前状态的过渡和下一个状态的过渡都依次排队 Next State Thne Current State：将下一状态的过渡和当前状态的过渡依次排队 Ordered Interruption：当前过渡是否可在不考虑顺序的情况下被其它过渡中断 选中时，找到有效过渡或当前过渡时，会中断 不选中时，找到有效过渡，会中断 Conditions：过渡条件（如果没有过渡条件，只会考虑Exit Time） AnyState和动作之间连线 Can Transition To self：是否可以过渡到自己 Preview source state：预览各种过渡状态，可以查看从任意状态切换到当前状态的过渡效果； 动画分层和遮罩动画分层设置： Weight：权重，当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例 Mask：动画遮罩，该层动画全部都会受该遮罩的影响 Blending：混合方式 Override：覆盖方式，播放该层动画时忽略其他层信息 Additive：叠加方式，会和其它层动画叠加播放 Sync：是否同步其它层，主要用于直接从另一个层复制状态过来，在该层中进行修改，适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑（选择后会多一个Source Layer表示你要复制哪一层的状态） Timing：当选中Sync同步其它层时，该参数激活，选中，会采用折中方案调整同步层上的动画时长（基于权重计算），不选中，动画时长将使用原始层做为母版 IK Pass：反向动力学，之后讲解IK的时候再讲解 动画混合1.2D Simple Directional 2D简单定向模式 运动表示不同方向时使用 比如向前、后、左、右走；2.2D Freeform Directional 2D自由形式定向模式 同上 运动表示不同方向时使用 但是可以在同一方向上有多个运动 比如向前跑和走；3.2D Freeform Cartesian 2D自由形式笛卡尔坐标模式 运动不表示不同方向时使用 比如向前走不拐弯 向前跑不拐弯 向前走右转 向前跑右转；4.Direct直接模式 自由控制每个节点权重，一般做表情动作等；5.1D混合是用一个参数控制动画的混合，之所以叫1D是因为一个参数可以看做是1维线性的； 动画IK控制知识点一 什么是IK？ //在骨骼动画中，构建骨骼的方法被称为正向动力学 //它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变 //用我们人体举例子 //当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子 //而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思 //它和正向动力学恰恰相反 //它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转 //用我们人体举例子 //当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动 //用父子骨骼理解的话就是子带动了父 知识点二 如何进行IK控制 //1.在状态机的层级设置中 开启 IK 通道 //2.继承MonoBehavior的类中 // Unity定义了一个IK回调函数:OnAnimatorIK // 我们可以在该函数中调用Unity提供的IK相关API来控制IK //3.Animator中的IK相关API //头部IK相关 //weight:LookAt全局权重0~1 //bodyWeight:LookAt时身体的权重0~1 //headWeight:LookAt时头部的权重0~1 //eyesWeight:LookAt时眼镜的权重0~1 //clampWeight:0表示角色运动时不受限制，1表示角色完全固定无法执行LookAt，0.5表示只能够移动范围的一半 SetLookAtWeight 设置头部IK权重 SetLookAtPosition 设置头部IK看向位置 SetIKPositionWeight 设置IK位置权重 SetIKRotationWeight 设置IK旋转权重 SetIKPosition 设置IK对应的位置 SetIKRotation 设置IK对应的角度 AvatarIKGoal枚举 四肢末端IK枚举 知识点三 关于OnAnimatorIK和OnAnimatorMove两个函数的理解 //我们可以简单理解这两个函数是两个和动画相关的特殊生命周期函数 //他们在Update之后LateUpdate之前调用 //他们会在每帧的状态机和动画处理完后调用 OnAnimatorIK在OnAnimatorMove之前调用 OnAnimatorIK中主要处理 IK运动相关逻辑 OnAnimatorMove主要处理 动画移动以修改根运动的回调逻辑 //他们存在的目的只是多了一个调用时机，当每帧的动画和状态机逻辑处理完后再调用 动画目标匹配知识点一 什么是动画目标匹配 //动画目标匹配主要指的是 //当游戏中角色要以某种动作移动，该动作播放完毕后，人物的手或者脚必须落在某一个地方 //比如：角色需要跳过踏脚石或者跳跃并抓住房梁 //那么这时我们就需要动作目标匹配来达到想要的效果 知识点二 如何实现动画目标匹配 //Unity中的Animator提供了对应的函数来完成该功能 //使用步骤是 //1.找到动作关键点位置信息（比如起跳点，落地点，简单理解就是真正可能产生位移的动画表现部分） //2.将关键信息传入MatchTargetAPI中 //参数一：目标位置 //参数二：目标角度 //参数三：匹配的骨骼位置 //参数四：位置角度权重 //参数五：开始位移动作的百分比 //参数六：结束位移动作的百分比 animator.MatchTarget(targetPos.position, targetPos.rotation, AvatarTarget.RightFoot, new MatchTargetWeightMask(Vector3.one, 1), 0.4f, 0.64f); 知识点三 注意 //调用匹配动画的时机有一些限制 //1.必须保证动画已经切换到了目标动画上 //2.必须保证调用时动画并不是处于过度阶段而真正在播放目标动画 //如果发现匹配不正确，往往都是这两个原因造成的 //3.需要开启Apply Root Motion 状态机行为脚本识点一 状态机行为脚本是什么？ //状态机行为脚本时一类特殊的脚本,继承指定的基类 //它主要用于关联到状态机中的状态矩形上 //我们可以按照一定规则编写脚本 //当进入、退出、保持在某一个特定状态时我们可以进行一些逻辑处理 //简单解释就是为Animator Controller状态机窗口中的某一个状态添加一个脚本 //利用这个脚本我们可以做一些特殊功能 //比如 //1.进入或退出某一状态时播放声音 //2.仅在某些状态下检测一些逻辑，比如是否接触地面等等 //3.激活和控制某些状态相关的特效 知识点二 如何使用状态机脚本 //1.新建一个脚本继承StateMachineBehaviour基类 //2.实现其中的特定方法进行状态行为监听 // OnStateEnter 进入状态时，第一个Update中调用 // OnStateExit 退出状态时，最后一个Update中调用 // OnStateIK OnAnimatorIK后调用 // OnStateMove OnAnimatorMove后调用 // OnStateUpdate 除第一帧和最后一帧，每个Update上调用 // OnStateMachineEnter 子状态机进入时调用，第一个Update中调用 // OnStateMachineExit 子状态机退出时调用，最后一个Update中调用 角色控制器知识点一· 角色控制器的使用 //关键参数 //是否接触了地面 if ( cc.isGrounded ) //关键方法 //受重力作用的移动 cc.SimpleMove(Vector3.forward * 10 * Time.deltaTime); //不受重力作用的移动 cc.Move(Vector3.forward * 10 * Time.deltaTime); //当角色控制器想要判断和别的碰撞器产生碰撞时 使用该函数 private void OnControllerColliderHit(ControllerColliderHit hit) { print(hit.collider.gameObject.name); } UnityEngine.CharacterController - Unity 脚本 API (unity3d.com) 导航寻路","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity基础","slug":"03002-Unity基础","date":"2019-09-25T13:00:00.000Z","updated":"2022-02-11T12:49:35.924Z","comments":true,"path":"posts/1538.html","link":"","permalink":"http://wwy010518.github.io/posts/1538.html","excerpt":"","text":"3D数学数学计算Mathf公共类Math：是C#中封装好的用于数学计算的工具)类) —— 位于System命名空间中；Mathf：是Unity中封装好的用于数学计算的工具)结构体) —— 位于UnityEngine命名空间中，Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法，使用Mathf中的方法用于Unity游戏开发中的数学计算即可； API 知识点三 Mathf中的常用方法——一般计算一次 //1.π - PI print(Mathf.PI); //2.取绝对值 - Abs print(Mathf.Abs(-10)); print(Mathf.Abs(-20)); print(Mathf.Abs(1)); //3.向上取整 - CeilToInt float f = 1.3f; int i = (int)f; print(i); print(Mathf.CeilToInt(f)); print(Mathf.CeilToInt(1.00001f)); //4.向下取整 - FloorToInt print(Mathf.FloorToInt(9.6f)); //5.钳制函数 - Clamp print(Mathf.Clamp(10, 11, 20)); print(Mathf.Clamp(21, 11, 20)); print(Mathf.Clamp(15, 11, 20)); //6.获取最大值 - Max print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8)); print(Mathf.Max(1, 2)); //7.获取最小值 - Min print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123)); print(Mathf.Min(1.1f, 0.4f)); //8.一个数的n次幂 - Pow print(\"一个数的n次方\" + Mathf.Pow(4, 2)); print(\"一个数的n次方\" + Mathf.Pow(2, 3)); //9.四舍五入 - RoundToInt print(\"四舍五入\" + Mathf.RoundToInt(1.3f)); print(\"四舍五入\" + Mathf.RoundToInt(1.5f)); //10.返回一个数的平方根 - Sqrt print(\"返回一个数的平方根\" + Mathf.Sqrt(4)); print(\"返回一个数的平方根\" + Mathf.Sqrt(16)); print(\"返回一个数的平方根\" + Mathf.Sqrt(64)); //11.判断一个数是否是2的n次方 - IsPowerOfTwo print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(4)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(8)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(3)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(1)); //12.判断正负数 - Sign print(\"判断正负数\" + Mathf.Sign(0)); print(\"判断正负数\" + Mathf.Sign(10)); print(\"判断正负数\" + Mathf.Sign(-10)); print(\"判断正负数\" + Mathf.Sign(3)); print(\"判断正负数\" + Mathf.Sign(-2)); 知识点四 Mathf中的常用方法——一般不停计算 //插值运算 - Lerp //Lerp函数公式 result = Mathf.Lerp(start, end, t); //t为插值系数，取值范围为 0~1 result = start + (end - start)*t //插值运算用法一 //每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置 start = Mathf.Lerp(start, 10, Time.deltaTime); //插值运算用法二 //每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果 time += Time.deltaTime; result = Mathf.Lerp(start, 10, time); UnityEngine.Mathf - Unity 脚本 API (unity3d.com) 三角函数1.角度和弧度都是度量角的单位：角度：1°弧度：1 radian圆一周的角度：360°圆一周的弧度：2π radian 2.角度和弧度的转换关系：π rad = 180°1 rad = (180 / π)°=&gt; 1 rad = 180 / 3.14 ≈ 57.3°；1°= (π / 180) rad =&gt; 1°= 3.14 / 180 ≈ 0.01745 rad；由此可以得出弧度 * 57.3 = 对应角度角度 * 0.01745 = 对应弧 3.角度弧度相关API： 知识点一 弧度、角度相互转化 //弧度转角度 float rad = 1; float anger = rad * Mathf.Rad2Deg; //角度转弧度 anger = 1; rad = anger * Mathf.Deg2Rad; 知识点二 三角函数)可以让物体做曲线运动) //注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 知识点三 反三角函数 //注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 rad = Mathf.Asin(0.5f); print(rad * Mathf.Rad2Deg); rad = Mathf.Acos(0.5f); print(rad * Mathf.Rad2Deg); 坐标系说明1.世界坐标系：原点：世界的中心点轴向：世界坐标系的三个轴向是固定的 2.物体坐标系：原点：物体的中心点)建模时决定)轴向：物体右方为x轴正方向物体上方为y轴正方向物体前方为z轴正方向 3.屏幕坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向最大宽高：Screen.widthScreen.height 4.视口坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向特点：左下角为)0,0)右上角为)1,1)和屏幕坐标类似，将坐标单位化 汇总 知识点一 世界坐标系 //目前学习的和世界坐标系相关的 //this.transform.position; //this.transform.rotation; //this.transform.eulerAngles; //this.transform.lossyScale(全局缩放大小，只能得); //修改他们 会是相对世界坐标系的变化 知识点二 物体坐标系 //相对父对象的物体坐标系的位置 本地坐标 相对坐标 //this.transform.localPosition; //this.transform.localEulerAngles; //this.transform.localRotation; //this.transform.localScale; //修改他们 会是相对父对象物体坐标系的变化 知识点三 屏幕坐标系 //Input.mousePosition //Screen.width; //Screen.height; 知识点四 视口坐标系 //摄像机上的 视口范围 坐标转换相关 //世界转本地 //this.transform.InverseTransformDirection //this.transform.InverseTransformPoint //this.transform.InverseTransformVector //本地转世界 //this.transform.TransformDirection //this.transform.TransformPoint //this.transform.TransformVector //世界转屏幕 //Camera.main.WorldToScreenPoint //屏幕转世界 //Camera.main.ScreenToWorldPoint //世界转视口 //Camera.main.WorldToViewportPoint //视口转世界 //Camera.main.ViewportToWorldPoint //视口转屏幕 //Camera.main.ViewportToScreenPoint //屏幕转视口 //Camera.main.ScreenToViewportPoint; Vector3向量UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 向量模长和单位向量1.标量：有数值大小，没有方向 2.向量：有数值大小，有方向的矢量 3.两点决定一向量：A点：(Xa,Ya,Za)B点：(Xb,Yb,Zb)从A指向B的向量为AB向量B-A = (Xb-Xa, Yb-Ya, Zb-Za)从B指向A的向量为BA向量A-B = (Xa-Xb, Ya-Yb, Za-Zb)口诀：终点减起点 4.零向量和负向量：零向量(0,0,0)零向量是唯一一个大小为0的向量负向量(x,y,z)的负向量为(-x,-y,-z)负向量和原向量大小相等负向量和原向量方向相反 5.向量的模长：向量的模长就是向量的长度向量是由两个点算出，所以向量的模长就是两个点的距离模长公式：A向量(x,y,z)模长 = √x² + y² + z² 6.单位向量：模长为1的向量为单位向量任意一个向量经过归一化就是单位向量只需要方向，不想让模长影响计算结果时使用单位向量归一化公式：A向量(x,y,z)模长 = √x² + y² + z²单位向量 = (x/模长, y/模长, z/模长) 7.向量模长和单位向量相关API： 知识点一 向量 //三维向量 - Vector3 //Vector3有两种几何意义 //1.位置 —— 代表一个点 print(this.transform.position); //2.方向 —— 代表一个方向 print(this.transform.forward); print(this.transform.up); Vector3 v = new Vector3(1, 2, 3); Vector2 v2 = new Vector2(1, 2); 知识点二 两点决定一向量 //A和B此时 几何意义 是两个点 Vector3 A = new Vector3(1, 2, 3); Vector3 B = new Vector3(5, 1, 5); //求向量 //此时 AB和 BA 他们的几何意义 是两个向量 Vector3 AB = B - A; Vector3 BA = A - B; 知识点三 零向量和负向量 print(Vector3.zero); print(Vector3.forward); print(-Vector3.forward); 知识点四 向量的模长 //Vector3中提供了获取向量模长的成员属性 //magnitude print(AB.magnitude); Vector3 C = new Vector3(5, 6, 7); print(C.magnitude); print(Vector3.Distance(A, B)); 知识点五 单位向量 //Vector3中提供了获取单位向量的成员属性 //normalized print(AB.normalized); print(AB / AB.magnitude); 总结 //模长相当于可以得到 两点之间的距离 单位向量 主要是用来进行移动计算的 它不会影响我们想要的移动效果 向量加减乘除1.向量加法：向量A + 向量B = (Xa + Xb, Ya + Yb)；位置+位置：两个位置相加没有任何几何意义向量+向量：两个向量相加得到一个新向量；向量 + 向量 = 向量)向量相加，首尾相连)位置+向量：位置加向量得到一个新位置；位置 + 向量 = 位置；向量 + 位置 = 位置)位置和向量相加=平移位置) 2.向量减法向量A - 向量B = (Xa - Xb, Ya - Yb, Za);位置-位置：两个位置相减得到一个新向量；位置 - 位置 = 向量)两点决定一向量，终点 - 起点)；向量-向量：两个向量相减得到一个新向量；向量 - 向量 = 向量)向量相减，头连头，尾指尾，A - B = B头指A头)；位置-向量：位置减向量相当于 加负向量；位置 + (-向量)=位置)位置减向量 = 平移位置)；向量-位置：向量减位置没有任何几何意义 3.向量乘除向量只会和标量进行乘除法运算向量A标量a = (xa, ya, za);向量A/标量a = (x/a, y/a, z/a);向量 *or/ 标量 = 向量;向量 *or/ 正数，方向不变，放大缩小模长;向量 *or/ 负数，方向相反，放大缩小模长;向量 * 0，得到零向量; 4.知识点： 知识点一 向量加法 //this.transform.position += new Vector3(1, 2, 3); this.transform.Translate(Vector3.forward * 5); 知识点二 向量减法 //this.transform.position -= new Vector3(1, 2, 3); this.transform.Translate(-Vector3.forward * 5); 知识点三 向量乘除标量 this.transform.localScale *= 2; this.transform.localScale /= 2; 向量点乘1.点乘计算公式：向量A·向量B = XaXb + YaYb + Za*Zb=标量；点乘可以得到一个向量：在自己向量上投影的长度)我们可以用这个规律判断敌方的大致方位)；点乘结果 &gt; 0 两个向量夹角为锐角；点乘结果 = 0 两个向量夹角为直角；点乘结果 &lt; 0 两个向量夹角为钝； 2.公式推导：Cosβ = 直角边 / 单位向量B模长直角边 = Cosβ * 单位向量B模长)直角边 = 单位向量A · 单位向量B);↓Cosβ * 单位向量B模长 = 单位向量A · 单位向量B;↓Cosβ = 单位向量A · 单位向量B;↓推出结果：β = Acos(单位向量A · 单位向量B); 3.点乘API 知识点一 通过点乘判断对象方位)判断前后) //Vector3 提供了计算点乘的方法 Debug.DrawRay(this.transform.position, this.transform.forward, Color.red); Debug.DrawRay(this.transform.position, target.position - this.transform.position, Color.red); //得到两个向量的点乘结果 //向量 a 点乘 AB 的结果 float dotResult = Vector3.Dot(this.transform.forward, target.position - this.transform.position); if( dotResult &gt;= 0 ) { print(\"它在我前方\"); } else { print(\"它在我后方\"); } 知识点二 通过点乘推导公式算出夹角)判断夹角，但是夹角为0-180之间，不能判断左右) //步骤 //1.用单位向量算出点乘结果 dotResult = Vector3.Dot(this.transform.forward, (target.position - this.transform.position).normalized); //2.用反三角函数得出角度 print(\"角度-\" + Mathf.Acos(dotResult) * Mathf.Rad2Deg); //Vector3中提供了 得到两个向量之间夹角的方法 print(\"角度2-\" + Vector3.Angle(this.transform.forward, target.position - this.transform.position)); 向量叉乘1.叉乘计算公式：向量A x 向量B = (YaZb - ZaYb,ZaXb - XaZb,XaYb - YaX)=向量； 2.几何意义A x B 得到的向量同时垂直A和B；A x B 向量垂直于A和B组成的平面；A x B = -(B x A)； 3.叉乘API 知识点一 叉乘计算 print(Vector3.Cross(A.position, B.position)); 知识点二 叉乘几何意义 //假设向量 A和B 都在 XZ平面上 //向量A 叉乘 向量 B //y大于0 证明 B在A右侧 //y小于0 证明 B在A左侧 Vector3 C = Vector3.Cross(A.position, B.position); if( C.y &gt; 0) { print(\"B在A的右侧\"); } else { print(\"B在A的左侧\"); } 向量插值运算插值API: 知识点一 线性插值 //公式result = start + (end - start) * t //1.先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置 A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); //2.匀速 每帧改变时间 当t&gt;=1时 得到结果 //这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 //应该相当于Vector3.MoveToWards() if(nowTarget != target.position) { nowTarget = target.position; time = 0; startPos = B.position; } time += Time.deltaTime; B.position = Vector3.Lerp(startPos, nowTarget, time); 知识点二 球形插值 //做弧线运动，可以做弓箭射击，太阳东升西落 C.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up*0.1f, time*0.01f); Quaternion四元数UnityEngine.Quaternion - Unity 脚本 API (unity3d.com) 为什么使用四元数1.欧拉角)transform.eulerAngles)：由三个角度(x,y,z)组成，遵守heading-pitch-bank旋转序列约定)heading:物体绕自身的对象坐标系的Y轴，旋转的角度；pitch:物体绕自身的对象坐标系的X轴，旋转的角度；bank:物体绕自身的对象坐标系的Z轴，旋转的角度)；1.1.优点：直观、易理解；存储空间小)三个数表示)；可以进行从一个方向到另一个方向旋转大于180度的角度；1.2缺点：同一旋转的表示不唯一；万向节死锁； 2.万向节死锁：当某个特定轴达到某个特殊值时，绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度；Unity中X轴达到90度时，会产生万向节死锁； 四元数是什么1.轴-角对：在3D空间中，任意旋转都可以表示，绕着某个轴旋转一个旋转角得到； 2.四元数：对于给定旋转，假设为绕着n轴，旋转β度，n轴为(x,y,z)；四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z]； 3.四元数基本API 知识点一 四元数 Quaternion //四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z] //计算原理 //Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); //提供的轴角对 初始化 四元数的方法 Quaternion q = Quaternion.AngleAxis(60, Vector3.right); 知识点二 四元数和欧拉角转换 //1.欧拉角转四元数 Quaternion q2 = Quaternion.Euler(60, 0, 0); GameObject obj2 = GameObject.CreatePrimitive(PrimitiveType.Cube); obj2.transform.rotation = q2; //2.四元数转欧拉角 print(q2.eulerAngles); 知识点三 四元数弥补的欧拉角缺点 //1.同一旋转的表示不唯一 四元数旋转后 转换后的欧拉角 始终是 -180~180度 //2.万向节死锁 通过四元数旋转对象可以避免万向节死锁 //必备知识点：四元数相乘代表旋转四元数 this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up); 四元数常用方法知识点一 单位四元数 print(Quaternion.identity); //testObj.rotation = Quaternion.identity; Instantiate(testObj, Vector3.zero, Quaternion.identity); 知识点二 插值运算 //在四元数中Lerp和Slerp只有一些细微差别 //由于算法不同,Slerp的效果会好一些 //Lerp的效果相比Slerp更快但是如果旋转范围较大效果较差,所以建议使用Slerp进行插值运算 //无限接近 先快后慢 A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime); //匀速变化 time&gt;=1到达目标 time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 识点三 LookRotation //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position); //lookA.rotation = q; lookA.MyLookAt(lookB); 四元数计算知识点一 四元数相乘 //两个四元数相乘得到一个新的四元数,代表两个旋转量的叠加,相当于旋转(旋转相对的坐标系 是物体自身坐标系) Quaternion q = Quaternion.AngleAxis(20, Vector3.up); this.transform.rotation *= q; 知识点二 四元数乘向量 //四元数乘向量返回一个新向量,可以将指定向量旋转对应四元数的旋转量,相当于直接旋转向量 Vector3 v = Vector3.forward; v = Quaternion.AngleAxis(45, Vector3.up) * v; Mono重要内容延迟(延时)函数知识点一 什么是延迟函数 //延迟函数顾名思义 //就是会延时执行的函数 //我们可以自己设定延时要执行的函数和具体延时的时间 //是MonoBehaviour基类中实现好的方法 知识点二 延迟函数的使用 1.延迟函数 //Invoke //参数一：函数名 字符串 //参数二：延迟时间 秒为单位 Invoke(\"DelayDoSomething\", 1); //注意： //1-1.延时函数第一个参数传入的是函数名字符串 //1-2.延时函数没办法传入参数 只有包裹一层 //1-3.函数名必须是该脚本上申明的函数 2.延迟重复执行函数 //InvokeRepeating //参数一：函数名字符串 //参数二：第一次执行的延迟时间 //参数三：之后每次执行的间隔时间 InvokeRepeating(\"DelayRe\", 5, 1); //注意： //它的注意事项和延时函数一致 3.取消延迟函数 //3-1取消该脚本上的所有延时函数执行 CancelInvoke(); //3-2指定函数名取消 //只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消 CancelInvoke(\"DelayDoSomething\"); 4.判断是否有延迟函数 if( IsInvoking()) { print(\"存在延迟函数\"); } if( IsInvoking(\"DelayDoSomething\") ) { print(\"存在延迟函数DelayDoSomething\"); } 知识点三 延迟函数受对象失活销毁影响 //脚本依附对象失活 或者 脚本自己失活 //延迟函数可以继续执行 不会受到影响的 //脚本依附对象销毁或者脚本移除 //延迟函数无法继续执行 协同程序1.Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容(注意：Unity中的多线程 要记住关闭);2.协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿,继承MonoBehavior的类都可以使用协程;3.协程只有当组件单独失活时不受影响，其它情况协程会停止4.API 知识点一 协程的使用 //继承MonoBehavior的类 都可以开启 协程函数 //第一步：申明协程函数 // 协程函数2个关键点 // 1-1返回值为IEnumerator类型及其子类 // 1-2函数中通过 yield return 返回值; 进行返回 //第二步：开启协程函数 //协程函数 是不能够 直接这样去执行的！！！！！！！ //这样执行没有任何效果 //MyCoroutine(1, \"123\"); //常用开启方式 //IEnumerator ie = MyCoroutine(1, \"123\"); //StartCoroutine(ie); Coroutine c1 = StartCoroutine( MyCoroutine(1, \"123\") ); Coroutine c2 = StartCoroutine( MyCoroutine(1, \"123\")); Coroutine c3 = StartCoroutine( MyCoroutine(1, \"123\")); //第三步：关闭协程 //关闭所有协程 //StopAllCoroutines(); //关闭指定协程 //StopCoroutine(c1); 知识点二 yield return 不同内容的含义 //1.下一帧执行 //yield return 数字; //yield return null; //在Update和LateUpdate之间执行 //2.等待指定秒后执行 //yield return new WaitForSeconds(秒); //在Update和LateUpdate之间执行 //3.等待下一个固定物理帧更新时执行 //yield return new WaitForFixedUpdate(); //在FixedUpdate和碰撞检测相关函数之后执行 //4.等待摄像机和GUI渲染完成后执行 //yield return new WaitForEndOfFrame(); //在LateUpdate之后的渲染相关处理完毕后之后 //5.一些特殊类型的对象 比如异步加载相关函数返回的对象 //之后讲解 异步加载资源 异步加载场景 网络加载时再讲解 //一般在Update和LateUpdate之间执行 //6.跳出协程 //yield break; 协同程序原理1.协程的本质 就是利用 C#的迭代器函数”分步执行”的特点+协程调度逻辑 实现的一套分时执行函数的规则; 2.代码实现： 知识点一 协程的本质 //协程可以分成两部分 //1.协程函数本体 //2.协程调度器 //协程本体就是一个能够中间暂停返回的函数 //协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数 //Unity只实现了协程调度部分 //协程的本体本质上就是一个 C#的迭代器方法 知识点二 协程本体是迭代器方法的体现 //1.协程函数本体 //如果我们不通过 开启协程方法执行协程 //Unity的协程调度器是不会帮助我们管理协程函数的 IEnumerator ie = Test(); //但是我们可以自己执行迭代器函数内容 ie.MoveNext();//会执行函数中内容遇到 yield return为止的逻辑 print(ie.Current);//得到 yield return 返回的内容 //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //TestClass tc = ie.Current as TestClass; //print(tc.time); //MoveNext 返回值 代表着 是否到了结尾)这个迭代器函数 是否执行完毕) //2.协程调度器 //继承MonoBehavior后 开启协程 //相当于是把一个协程函数)迭代器)放入Unity的协程调度器中帮助我们管理进行执行 //具体的yield return 后面的规则 也是Unity定义的一些规则 #Resources资源动态加载 Unity中的特殊文件夹知识点一 工程路径获取 //注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用 //我们不会在实际发布游戏后 还使用该路径 //游戏发布过后 该路径就不存在了 print(Application.dataPath); 知识点二 Resources 资源文件夹 //路径获取： //一般不获取 //只能使用Resources相关API进行加载 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Resources\"); //注意： //需要我们自己将创建 //作用： //资源文件夹 //1-1.需要通过Resources相关API动态加载的资源需要放在其中 //1-2.该文件夹下所有文件都会被打包出去 //1-3.打包时Unity会对其压缩加密 //1-4.该文件夹打包后只读 只能通过Resources相关API加载 知识点三 StreamingAssets 流动资源文件夹 //路径获取： print(Application.streamingAssetsPath); //注意： //需要我们自己将创建 //作用： //流文件夹 //2-1.打包出去不会被压缩加密，可以任由我们摆布 //2-2.移动平台只读，PC平台可读可写 //2-3.可以放入一些需要自定义动态加载的初始资源 知识点四 persistentDataPath 持久数据文件夹 //路径获取： print(Application.persistentDataPath); //注意： //不需要我们自己将创建 //作用： //固定数据文件夹 //3-1.所有平台都可读可写 //3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中 知识点五 Plugins 插件文件夹 //路径获取： //一般不获取 //注意： //需要我们自己将创建 //作用： //插件文件夹 //不同平台的插件相关文件放在其中 //比如IOS和Android平台 知识点六 Editor 编辑器文件夹 //路径获取： //一般不获取 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Editor\"); //注意： //需要我们自己将创建 //作用： //编辑器文件夹 //5-1.开发Unity编辑器时，编辑器相关脚本放在该文件夹中 //5-2.该文件夹中内容不会被打包出去 知识点七 默认资源文件夹 Standard Assets //路劲过去： //一般不获取 //注意： //需要我们自己将创建 //作用： //默认资源文件夹 //一般Unity自带资源都放在这个文件夹下 //代码和资源优先被编译 UnityEngine.Application - Unity 脚本 API (unity3d.com) Resources同步加载知识点一 常用资源类型 //1.预设体对象——GameObject)要实例化) //2.音效文件——AudioClip //3.文本文件——TextAsset //4.图片文件——Texture //5.其它类型——需要什么用什么类型 知识点二 资源同步加载 普通方法 //在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 //打包时 Resources文件夹 里的内容 都会打包在一起 //1.预设体对象 想要创建在场景上 记住实例化 // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj = Resources.Load(\"Cube\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj); // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj2 = Resources.Load(\"Sphere\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj2); //2.音效资源 //第一步：就是加载数据 Object obj3 = Resources.Load(\"Music/BKMusic\"); //第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可 audioS.clip = obj3 as AudioClip; audioS.Play(); //3.文本资源 //文本资源支持的格式 //.txt //.xml //.bytes //.json //.html //.csv //..... TextAsset ta = Resources.Load(\"Txt/Test\") as TextAsset; //文本内容 print(ta.text); //字节数据组 //print(ta.bytes); //4.图片 tex = Resources.Load(\"Tex/TestJPG\") as Texture; GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);)(画出图片) //5.其它类型 需要什么类型 就用什么类型就行 //6.问题：资源同名怎么办 //Resources.Load加载同名资源时 无法准确加载出你想要的内容 //可以使用另外的API //6-1加载指定类型的资源 //tex = Resources.Load(\"Tex/TestJPG\", typeof(Texture)) as Texture; ta = Resources.Load(\"Tex/TestJPG\", typeof(TextAsset)) as TextAsset; //print(ta.text); //6-2加载指定名字的所有资源 Object[] objs = Resources.LoadAll(\"Tex/TestJPG\"); 知识点三 资源同步加载 泛型方法 TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(\"Tex/TestJPG\"); print(ta2.text); tex = Resources.Load&lt;Texture&gt;(\"Tex/TestJPG\"); Resources异步加载知识点一 Resources异步加载方法 //注意： //异步加载 不能马上得到加载的资源 至少要等一帧 //1.通过异步加载中的完成事件监听 使用加载的资源 //这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载 //ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); //马上进行一个 资源下载结束 的一个事件函数监听 //rq.completed += LoadOver; print(Time.frameCount); //这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的 //一定要等加载结束过后 才能使用 //rq.asset ×××××××××××× //2.通过协程 使用加载的资源 StartCoroutine(Load()); IEnumerator Load() { //迭代器函数 当遇到yield return时 就会 停止执行之后的代码 //然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时 ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); print(Time.frameCount); //第一部分 //Unity 自己知道 该返回值 意味着你在异步加载资源 //yield return rq; //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码 print(Time.frameCount); //判断资源是否加载结束 while(!rq.isDone) { //打印当前的 加载进度 (0-1浮点型值) print(rq.progress); yield return null; } tex = rq.asset as Texture; } 总结： //1.完成事件监听异步加载 //好处：写法简单 //坏处：只能在资源加载结束后 进行处理 //“线性加载” //2.协程异步加载 //好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新 //坏处：写法稍麻烦 //“并行加载” //注意： //理解为什么异步加载不能马上加载结束，为什么至少要等1帧 //理解协程异步加载的原理 Resources卸载资源知识点一 Resources重复加载资源会浪费内存吗？ //其实Resources加载一次资源过后 //该资源就一直存放在内存中作为缓存 //第二次加载时发现缓存中存在该资源 //会直接取出来进行使用 //所以 多次重复加载不会浪费内存 //但是 会浪费性能)每次加载都会去查找取出，始终伴随一些性能消耗) 知识点二 如何手动释放掉缓存中的资源 //1.卸载指定资源 //Resources.UnloadAsset 方法 //注意： //该方法 不能释放 GameObject对象 因为它会用于实例化对象 //它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等 //一般情况下 我们很少单独使用它 //GameObject obj = Resources.Load&lt;GameObject&gt;(\"Cube\"); //即使是没有实例化的 GameObject对象也不能进行卸载 //Resources.UnloadAsset(obj); //2.卸载未使用的资源 //注意： //一般在过场景时和GC一起使用 Resources.UnloadUnusedAssets(); GC.Collect(); UnityEngine.Resources - Unity 脚本 API (unity3d.com) 场景切换 需要把要加载的场景Build Settings中。 知识点一 场景同步切换 //在切换场景时 //Unity会删除当前场景上所有对象 //并且去加载下一个场景的相关信息 //如果当前场景 对象过多或者下一个场景对象过多 //这个过程会非常的耗时 会让玩家感受到卡顿 SceneManager.LoadScene(\"Lesson20Test\"); 知识点二 场景异步切换 //场景异步加载和资源异步加载 几乎一致 有两种方式 //1.通过事件回调函数 异步加载 //AsyncOperation ao = SceneManager.LoadSceneAsync(\"Lesson20Test\"); //当场景异步加载结束后 就会自动调用该事件函数 我们如果希望在加载结束后 做一些事情 那么久可以在该函数中 //写处理逻辑 //ao.completed += (a) =&gt; //{ // print(\"加载结束\"); //}; //ao.completed += LoadOver; //2.通过协程异步加载 //需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了 //所以 协程中的部分逻辑 可能是执行不了的 //解决思路 //让处理场景加载的脚本依附的对象 过场景时 不被移除 //该脚本依附的对象 过场景时 不会被 移除 DontDestroyOnLoad(this.gameObject); StartCoroutine(LoadScene(\"Lesson20Test\")); IEnumerator LoadScene(string name) { //第一步 //异步加载场景 AsyncOperation ao = SceneManager.LoadSceneAsync(name); //Unity内部的 协程协调器 发现是异步加载类型的返回对象 那么就会等待 //等待异步加载结束后 才会继续执行 迭代器函数中后面的步骤 print(\"异步加载过程中 打印的信息\"); //协程的好处 是异步加载场景时 我可以在加载的同时 做一些别的逻辑 //yield return ao; //第二步 print(\"异步加载结束后 打印的信息\"); //比如 我们可以在异步加载过程中 去更新进度条 //第一种 就是利用 场景异步加载 的进度 去更新 但是 不是特别准确 一般也不会直接用 //while(!ao.isDone) //{ // print(ao.progress); // yield return null; //} //离开循环后 就会认为场景加载结束 //可以把进度条顶满 然后 隐藏进度条 //第二种 就是根据你游戏的规则 自己定义 进度条变化的条件 yield return ao; //场景加载结束 更新20%进度 //接着去加载场景中 的其它信息 //比如 //动态加载怪物 //这时 进度条 再更新20% //动态加载 场景模型 //这时 就认为 加载结束了 进度条顶满 //隐藏进度条 } SceneManagement.SceneManager - Unity 脚本 API (unity3d.com) 画线功能Linerenderer组件知识点一 LineRenderer是什么 //LineRenderer是Unity提供的一个用于画线的组件 //使用它我们可以在场景中绘制线段 //一般可以用于 //1绘制攻击范围 //2武器红外线 //3辅助功能 //4其它画线功能 知识点二ineRender代码相关 //动态添加一个线段 GameObject line = new GameObject(); line.name = \"Line\"; LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;(); //首尾相连 lineRenderer.loop = true; //开始结束宽 lineRenderer.startWidth = 0.02f; lineRenderer.endWidth = 0.02f; //开始结束颜色 lineRenderer.startColor = Color.white; lineRenderer.endColor = Color.red; //设置材质 m = Resources.Load&lt;Material&gt;(\"M\"); lineRenderer.material = m; //设置点 //一定注意 设置点 要 先设置点的个数 lineRenderer.positionCount = 4; //接着就设置 对应每个点的位置 lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0), new Vector3(0,0,5), new Vector3(5,0,5)}); lineRenderer.SetPosition(3, new Vector3(5, 0, 0)); //是否使用世界坐标系 //决定了 是否随对象移动而移动 lineRenderer.useWorldSpace = false; //让线段受光影响 会接受光数据 进行着色器计算 lineRenderer.generateLightingData = true; UnityEngine.LineRenderer - Unity 脚本 API (unity3d.com) 核心系统UnityEngine.Physics - Unity 脚本 API (unity3d.com) 物理系统之范围检测知识点二 如何进行范围检测 //必备条件：想要被范围检测到的对象 必须具备碰撞器 //注意点： //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的 //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已 //范围检测API //1.盒状范围检测 //参数一：立方体中心点 //参数二：立方体三边大小 //参数三：立方体角度 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) print(LayerMask.NameToLayer(\"UI\")); Collider[] colliders = Physics.OverlapBox( Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up), 1 &lt;&lt; LayerMask.NameToLayer(\"UI\") | 1 &lt;&lt; LayerMask.NameToLayer(\"Default\"), QueryTriggerInteraction.UseGlobal); //0000 0001 //0010 0000 //重要知识点： //关于层级 //通过名字得到层级编号 LayerMask.NameToLayer //我们需要通过编号左移构建二进制数 //这样每一个编号的层级 都是 对应位为1的2进制数 //我们通过 位运算 可以选择想要检测层级 //好处 一个int 就可以表示所有想要检测的层级信息 //层级编号是 0~31 刚好32位 //是一个int数 //每一个编号 代表的 都是二进制的一位 //0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1 //1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2 //2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4 //3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8 //4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16 //5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32 //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapBoxNonAlloc() if(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) //2.球形范围检测 //参数一：中心点 //参数二：球半径 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer(\"Default\")); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapSphereNonAlloc if( Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0 ) //3.胶囊范围检测 //参数一：半圆一中心点 //参数二：半圆二中心点 //参数三：半圆半径 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer(\"UI\"), QueryTriggerInteraction.UseGlobal); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapCapsuleNonAlloc if ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders ) != 0 ) 物理系统之射线检测知识点一 射线对象 //1.3D世界中的射线 //假设有一条 //起点为坐标(1,0,0) //方向为世界坐标Z轴正方向的射线 //注意： //理解参数含义 //参数一：起点 //参数二：方向)一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量) //目前只是申明了一个射线对象 对于我们来说 没有任何的用处 Ray r = new Ray(Vector3.right, Vector3.forward); //Ray中的参数 print(r.origin);//起点 print(r.direction);//方向 //2.摄像机发射出的射线 // 得到一条从屏幕位置作为起点 // 摄像机视口方向为 方向的射线 Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition); 知识点三 碰撞检测函数 //Physics类中提供了很多进行射线检测的静态函数 //他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了 //注意： //射线检测也是瞬时的 //执行代码时进行一次射线检测 //1.最原始的射线检测 // 准备一条射线 Ray r3 = new Ray(Vector3.zero, Vector3.forward); // 进行射线检测 如果碰撞到对象 返回true //参数一：射线 //参数二: 检测的最大距离 超出这个距离不检测 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：bool 当碰撞到对象时 返回 true 没有 返回false if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向 if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //2.获取相交的单个物体信息 //物体信息类 RaycastHit RaycastHit hitInfo; //参数一：射线 //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中 //参数三：距离 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal if( Physics.Raycast(r3, out hitInfo, 1000, 1&lt;&lt;LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) ) { //碰撞器信息 print(\"碰撞到物体的名字\" + hitInfo.collider.gameObject.name); //碰撞到的点 print(hitInfo.point); //法线信息 print(hitInfo.normal); //得到碰撞到对象的位置 print(hitInfo.transform.position); //得到碰撞到对象 离自己的距离 print(hitInfo.distance); //RaycastHit 该类 对于我们的意义 //它不仅可以得到我们碰撞到的对象信息 //还可以得到一些 碰撞的点 距离 法线等等的信息 } //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //3.获取相交的多个物体 //可以得到碰撞到的多个对象 //如果没有 就是容量为0的数组 //参数一：射线 //参数二：距离 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //之前的参数一射线 通过两个点传入 hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种函数 返回的碰撞的数量 通过out得到数据 if(Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) &gt; 0 ) UnityEngine.Ray - Unity 脚本 API (unity3d.com) UnityEngine.RaycastHit - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity入门","slug":"03001-Unity入门","date":"2019-08-30T13:00:00.000Z","updated":"2022-02-11T12:45:35.858Z","comments":true,"path":"posts/1537.html","link":"","permalink":"http://wwy010518.github.io/posts/1537.html","excerpt":"","text":"将之前的笔记整理下来 Unity概叙 Unity是一个游戏开发的集成工具，降低了游戏开发的门槛，提高了开发效率。 工程文件夹Assets：工程资源文件夹(美术资源脚本)Library:库文件夹Logs:日志文件夹obj:编译中间文件Packages:包配置信息ProjectSettings:工程设置信息 Unity界面基础Inspector检查窗口：用于设置游戏对象具体信息Console控制台窗口：用于显示调试信息，报错、警告、打印信息等Scene场景窗口：所有游戏对象所在地Hierarchy层级窗口：所有游戏的对象名单Game游戏窗口：玩家看到的游戏画面Project工程窗口：所有游戏资源和脚本内容 Scence场景和Hierarchy层级窗口Hierarchy 我们可以在Hierarchy窗口中创建或拖入各种游戏对象。Hierarchy层级窗口快捷键：F2：对象改名Ctrl+C：复制Ctrl+V：粘贴Ctrl+D：克隆一个Delete：删除 Scence 我们可以在Scene窗口中查看所有游戏对象设置所有游戏对象。窗口上方工具条内容：1.渲染模式2.2D、3D视图切换3.光源、音效、特效显示开启4.辅助线显示5.辅助功能，控制场景上提示图标等6.搜索7.场景轴向 关于Unity中的3D世界坐标轴：红色为X轴正向绿色为Y轴正向蓝色为Z轴正向 以屏幕为参照物：垂直屏幕向内为Z正方向平行屏幕向右为X正方向平行屏幕向上为Y正方向 场景中的操作：左键相关： 鼠标单击：选中单个物体 鼠标框选：选中多个物体 Ctrl+鼠标单击：多选物体 长按ALT键+鼠标左键+移动鼠标：相对观察视口中心点旋转 选中物体之后，按F键：居中显示物体(或者在层级窗口中双击对象) 右键相关： 鼠标右键按下+移动鼠标：旋转视口 鼠标右键按下+WASD：漫游场景 鼠标右键按下+WASD+Shift：快速漫游场景长按ALT键+鼠标右键+移动鼠标：相对屏幕中心点拉近拉远 中键相关：滚动鼠标中间：相对屏幕中心点拉近拉远鼠标中间按下+移动鼠标：平移观察视口长按ALT键+滚动鼠标中间：鼠标指哪就朝哪拉近拉 Game游戏和Project工程Game 游戏画面窗口，玩家能看到的画面内容. Project 工程资源窗口，所有的工程资源都会在该窗口中显示，显示的内容为Assets文件夹中的所有内容. Project工程窗口关键功能:1.窗口设置2.创建相关资源文件3.查找4.按资源类型查找5.按名字查找 资源类型:图片格式：jpg、png、tga模型格式：fbx、max、maya音效：wav、mp3、ogg文本：txt、json、bytes视频：mp4 Inspector检查和Console控制台Inspector 查看场景中游戏对象关联的C#脚本信息. Console 用于查看调试信息的窗口报错、警告、测试打印都可以显示在其中,默认未开启可以在Window——&gt;General中开启或者使用快捷键：Ctrl+Shift+C，该窗口将显示代码编译过程中或者游戏运行过程中的报错、警告、测试信息主要用于查错和调试用。 Console控制台窗口：1.清空控制台2.相同内容折叠显示3.运行时清空4.构建时清空5.报错暂停运行6.是否显示错误信息7.是否显示警告信息8.是否显示打印信息 工具栏和父子关系工具栏从左到右：1.文件操作：新建工程，新建场景，工程打包等等2.编辑操作：对象编辑操作相关，工程设置，引擎设置相关3.资源操作：基本等同于Project窗口中右键相关功能4.对象操作：基本等同于Hierarchy窗口中右键相关功能5.脚本操作：Unity自带的脚本，可以添加各系统中的脚本7.窗口：可以打开Unity各核心系统的窗口9.帮助：检查更新，查看版本等等功能 File中的重要选项：BuildSetting(工程发布打包)Edit中的重要选项：Project Setting(工程各系统设置)、Preferences(首选项，可以设置编程软件)、GameObject中的重要选项：MoveToView、Align With View、Align View to Selected(几种快捷设置位置的功能) 父子关系 对象之间产生父子关系后，如何相互影响？爸爸干嘛，儿子干嘛；儿子干嘛，爸爸不管。Scene上方作用：pivot：以本身为中心点；center：以整体为中心点；local：以本身旋转为朝向；global：以世界坐标为朝向； Unity工作原理 使用它时是处于运行中的，我们是在一个运行中的软件里制作游戏的，Unity开发的本质就是在Unity引擎的基础上,利用反射和引擎提供的各种功能进行的拓展开发。 反射机制和游戏场景反射机制的体现：除了Transform这个表示位置的标配剧本外，我们可以为这个演员(GameObject)关联各种剧本(C#脚本)，让它按照我们剧本中(代码逻辑中)的命令来处理事情，而为演员添加剧本的这个过程，就是在利用反射new一个新的剧本对，象和演员(GameObject)对象进行关联，让其按我们的命令做事； 利用反射举例体现：1.修改Inspector面板中Transform的内容：已知对象，类名，变量名，通过反射为该对象设置变量值；2.新建一个脚本后，添加给一个指定的GameObject对象：已知类名，可以获取所有公共成员，故可以在Inspector面板上创建各公共字段信息 游戏场景的本质：游戏场景文件后缀为.unity，它的本质就是一个配置文件，Unity有一套自己识别处理它的机制，但是本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象； 预设物和资源包的导入导出后缀名：.prefab，Prefabs放该类型文件;预制物删除变红处理：点击预制物右键Unpack Prefab;Project右键：导入导出包(.unitypackage); Unity脚本基础默认脚本内容：Editor\\Data\\Resources\\ScriptTemplates 脚本基本规则1.创建规则： 1.不在VS中创建脚本了 2.可以放在Assets文件夹下的任何位置(建议同一文件夹管理) 3.类名和文件名必须一致,不然不能挂载(因为反射机制创建对象，会通过文件名去找Type) 4.建议不要使用中文名命名 5.没有特殊需求 不用管命名空间 6.创建的脚本默认继承MonoBehavior 2.MonoBehavior基类： 1.创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 2.继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 3.继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 4.继承了MonoBehavior的脚本可以在一个对象上挂多个(如果没有加DisallowMultipleComponent特性) 5.继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 3.不继承MonoBehavior的类 1.不继承Mono的类 不能挂载在GameObject上 2.不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 3.不继承Mono的类 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据) 4.不继承Mono的类 不用保留默认出现的几个函数 生命周期函数总结：这些生命周期函数 如果你不打算在其中写逻辑 那就不要使用这些命周期函数。我们要知道，虽然建议大家不在继承MonoBehavior的类中写构造函数；但是不意味着我们不能写，当我们在继承MonoBehavior的类中写无参构造函数时，你会发现在编辑模式下或者运行后，只要该脚本挂载在场景中，那么该无参构造函数是会被自动执行的。因为Unity的工作原理中提到的反射机制，Unity实际上通过反射帮助我们实例化了该脚本对象，既然要实例化那么肯定是需要new的，只不过Unity中不需要我们自己new继承了MonoBehavior的类，只要挂载后Unity帮助我们做了这件事。那么为什么不建议大家写构造函数呢？1.Unity的规则就是，继承MonoBehavior的脚本不能new只能挂载2.生命周期函数的Awake是类似构造函数的存在，当对象出生就会自动调用3.写构造函数反而在结构上会破坏Unity设计上的规范 打印方式：普通：Debug.Log(“123”);报错：Debug.LogError(“出错了！！！！！”);警告：Debug.LogWarning(“警告！！！”); Inspector窗口可编辑变量知识点一: 私有和保护无法显示编辑，公共的可以显示编辑；知识点二 ：[SerializeField]让私有的和保护的也可以被显示；知识点三：[HideInInspector]公共的也不让其显示编辑；知识点四：[System.Serializable] 让自定义类型可以被访问；//加在类前，而字典怎么都不行知识点七： 辅助特性1.[Header(“分组说明”)] ：分组说明特性，为成员分组；2.[Tooltip(“说明内容”)] //悬停注释，为变量添加说明；3.[Space()]：间隔特性，让两个字段间出现间隔4.[Range(最小值, 最大值)] //修饰数值的滑条范围；5.[TextArea(3, 4)] ：滚动条显示字符串，默认不写参数就是超过3行显示滚动条；6.[ContextMenuItem(“显示按钮名”, “方法名”)] ：为变量添加快捷方法，参数1 显示按钮名，参数2 方法名 不能有参数；7.[Multiline(4)] ：多行显示字符串 默认不写参数显示3行8.[ContextMenu(“测试函数”)] ：方法添加特性能够在Inspector中执行 继承自MonoBehavior重要内容重要成员1.获取依附的GameObject：this.gameObject;2.获取依附的GameObject的位置信息：-print(this.transform.position);//位置-print(this.transform.eulerAngles);//角度-print(this.transform.lossyScale);//缩放大小3.获取脚本是否激活： this.enabled； 重要方法1:得到依附对象上挂载的其它脚本 //1.得到自己挂载的单个脚本,获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空 this.GetComponent(\"脚本名\"); //2.得到自己挂载的多个脚本 this.GetComponents&lt;泛形类型&gt;(); //3.得到子对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) //函数是有一个参数的 默认不传 是false 意思就是 如果子对象失活 是不会去找这个对象上是否有某个脚本的 //如果传true 及时 失活 也会找 //得子对象 挂载脚本 单个 this.GetComponentInChildren&lt;泛形类型&gt;(true); this.GetComponentsInChildren&lt;泛形类型&gt;(true); //4.得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) this.GetComponentInParent&lt;泛形类型&gt;(); this.GetComponentsInParent&lt;泛形类型&gt;(); //5.尝试获取脚本 //提供了一个更加安全的 获取单个脚本的方法 如果得到了 会返回true //然后在来进行逻辑处理即可 this.TryGetComponent&lt;泛形类型&gt;(out 赋值变量) Unity重要组件和APIGameObject最小单位直接实例化：new GameObject(“实体名”，typeof(要添加的组件名)…….) ； 注意事项：1.建议使用Destroy方法，它是异步的，不会马上删除对象，只是给对象加一个标识，一般情况下下一帧才会把对象从内存一处。；2.如果继承自mono，可以省略GameObject字段；3.对象失活也是可以用一些方式获取的；4.广播方法效率很低，不建议使用； 知识点一 GameObject中的成员变量 //名字 print(this.gameObject.name); this.gameObject.name = \"Lesson4唐老狮改名\"; print(this.gameObject.name); //是否激活 print(this.gameObject.activeSelf); //是否是静态 print(this.gameObject.isStatic); //层级 print(this.gameObject.layer); //标签 print(this.gameObject.tag); transform this.transform 上一节课讲解的 通过Mono去得到的依附对象的GameObject的位置信息 //他们得到的信息是一样 都是依附的GameObject的位置信息 print(this.gameObject.transform.position); 知识点二 GameObject中的静态方法 //创建自带几何体 //只要得到了一个GameObject对象 我就可以得到它身上挂在的任何脚本信息 //通过obj.GetComponent来得去 GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.name = \"唐老狮创建的立方体\"; //查找对象相关的知识 //两种找单个对象的共同点: //1.无法找到失活的对象的 // 只能找到 激活的对象 //2.如果场景中 存在多个满足条件的对象 // 我们无法准确确定找到的是谁 //1查找单个对象 //通过对象名查找 //这个查找效率比较低下 因为他会在场景中的所有对象去查找 //没有找到 就会返回null GameObject obj2 = GameObject.Find(\"唐老狮\"); //通过tag来查找对象 GameObject obj3 = GameObject.FindWithTag(\"Player\"); //和上面的方法一样，名字不一样而已 GameObject obj3 = GameObject.FindGameObjectWithTag(\"Player\"); //得到某一个单个对象 目前有2种方式了 //1.是public从外部面板拖 进行关联 //2.通过API去找 //2查找多个对象 //找多个对象的API 只能是通过tag去找多个 通过名字 是没有找多个的方法的 //通过tag找到多个对象 //它也是 只能找到 激活对象 无法找到失活对象 GameObject obj3 = GameObject.FindGameObjectsWithTag(\"Player\"); //还有几个查找对象相关是用的比较少的方法 是GameObject父类 Object提供的方法 //引出额外知识点 Unity中的Object和C#中的万物之父的区别 //Unity里面的Object 不是指的万物之父object //Unity里的Object 命名空间在UnityEngine中的 Object类 也是集成万物之父的一个自定义类 //C#中的Object 命名空间是在System中的 //它可以找到场景中挂载的某一个脚本对象 //效率更低 上面的GameObject.Find 和通过FindWithTag找 只是遍历对象 //这个方法 不仅要遍历对象 还要遍历对象上挂载的脚本 Lesson4 o = GameObject.FindObjectOfType&lt;Lesson4&gt;(); print(o.gameObject.name); //实例化对象(克隆对象)的方法 //实例化(克隆)对象 它的作用 是根据一个GameObject对象 创建出一个和它一模一样的对象 GameObject obj5 = GameObject.Instantiate(myObj); //以后学了更多知识点 就可以在这操作obj5 //如果你继承了 MonoBehavior 其实可以不用写GameObject一样可以使用 //因为 这个方法时Unity里面的 Object基类提供给我们的 所以可以直接用 Instantiate(myObj); //删除对象的方法 GameObject.Destroy(myObj2); //第二个参数 代表延迟几秒钟删除 GameObject.Destroy(obj5, 5); Destroy不仅可以删除对象 还可以删除脚本 GameObject.Destroy(this); //删除对象有两种作用 //1.是删除指定的一个游戏对象 //2.是删除一个指定的脚本对象 //注意：这个Destroy方法 不会马上移除对象 只是给这个对象加了一个移除标识 // 一般情况下 它会在下一帧时把这个对象移除并从内存中移除 //如果没有特殊需求 就是一定要马上移除一个对象的话 //建议使用上面的 Destroy方法 因为 是异步的 降低卡顿的几率 //下面这个方法 就是立即把对象 从内存中移除了 GameObject.DestroyImmediate(myObj); //如果是继承MonoBehavior的类 不用写GameObject Destroy(myObj2); DestroyImmediate(myObj); //过场景不移除 //默认情况 在切换场景时 场景中对象都会被自动删除掉 //如果你希望某个对象 过场景不被移除 //下面这句代码 就是不想谁过场景被移除 就传谁 //一般都是传 依附的GameObject对象 //比如下面这句代码的意思 就是自己依附的GameObject对象 过场景不被删除 GameObject.DontDestroyOnLoad(this.gameObject); //如果继承MOnoBehavior也可以直接写 DontDestroyOnLoad(this.gameObject); 知识点三 GameObject中的成员方法 //创建空物体 //new一个GameObject就是在创建一个空物体 GameObject obj6 = new GameObject(); GameObject obj7 = new GameObject(\"唐老狮创建的空物体\"); GameObject obj8 = new GameObject(\"顺便加脚本的空物体\", typeof(Lesson2),typeof(Lesson1)); //为对象添加脚本 //继承MOnoBehavior的脚本 是不能够去new //如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上 //直接使用GameObject提供的方法即可 Lesson1 les1 = obj6.AddComponent(typeof(Lesson1)) as Lesson1; //用泛型更方便 Lesson2 les2 = obj6.AddComponent&lt;Lesson2&gt;(); //通过返回值 可以得到加入的脚本信息 //来进行一些处理 //得到脚本的成员方 和继承Mono的类得到脚本的方法 一模一样 //标签比较 //下面两种比较的方法 是一样的 if(this.gameObject.CompareTag(\"Player\")) { print(\"对象的标签 是 Player\"); } if(this.gameObject.tag == \"Player\") { print(\"对象的标签 是 Player\"); } //设置激活失活 //false 失活 true 激活 obj6.SetActive(false); obj7.SetActive(false); obj8.SetActive(false); //次要的成员方法 了解即可 不建议使用 //强调 //下面讲的方法 都不建议大家使用 效率比较低 //通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法 //通知自己 执行什么行为 //命令自己 去执行这个TestFun这个函数 会在自己身上挂在的所有脚本去找这个名字的函数 //它会去找到 自己身上所有的脚本 有这个名字的函数去执行 this.gameObject.SendMessage(\"TestFun\"); this.gameObject.SendMessage(\"TestFun2\", 199); //广播行为 让自己和自己的子对象执行 this.gameObject.BroadcastMessage(\"函数名\"); //向父对象和自己发送消息 并执行 this.gameObject.SendMessageUpwards(\"函数名\"); UnityEngine.GameObject - Unity 脚本 API (unity3d.com) Time时间相关作用：主要 用于游戏中参与位移、记时、时间暂停等；重要内容: //知识点一 时间缩放比例 //时间停止 Time.timeScale = 0; //回复正常 Time.timeScale = 1; //2倍速 Time.timeScale = 2; //知识点二 帧间隔时间 //帧间隔时间 主要是用来计算位移 //路程 = 时间*速度 //根据需求 选择参与计算的间隔时间 //如果希望 游戏暂停时就不动的 那就使用 Time.deltaTime; //如果希望 不受暂停影响 Time.unscaledDeltaTime; //帧间隔时间：最近的一帧 用了多长时间(秒) //受scale影响 print(\"帧间隔时间\" + Time.deltaTime); //不受scale影响的帧间隔时间 print(\"不受scale影响的帧间隔时间\" + Time.unscaledDeltaTime); 知识点三 游戏开始到现在的时间 //它主要用来计时 单机游戏中计时 //受scale影响 print(\"游戏开始到现在的时间:\" + Time.time); //不受scale影响 print(\"不受scale影响的游戏开始到现在的时间:\" + Time.unscaledTime); 知识点四 物理帧间隔时间 FixedUpdate //受scale影响 Time.fixedDeltaTime; //不受scale影响 Time.fixedUnscaledDeltaTime; 知识点五 帧数 //从开始到现在游戏跑了多少帧(次循环) print(Time.frameCount); UnityEngine.Time - Unity 脚本 API (unity3d.com) Transform-位置和位移Vector3常用： //常用变量 print(Vector3.zero);//000 print(Vector3.right);//100 print(Vector3.left);//-100 print(Vector3.forward);//001 print(Vector3.back);//00-1 print(Vector3.up);//010 print(Vector3.down);//0-10 //常用方法 (后续加) //计算两个点之间的距离的方法 print(Vector3.Distance(v1, v12)); //返回float 两个向量之间的角度(以度为单位) Vector3.Angle(); UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 位置(注意：位置的赋值不能直接改变x，y，z 只能整体改变)位移方式： //知识点一：位置 //相对世界坐标系 this.gameObject.transform； //相对父对象 this.transform.localPosition； //世界正朝向 Vector3.forwad; //本身正朝向 transform.forward； //知识点二 位移 //坐标系下的位移计算公式：路程 = 方向 * 速度 * 时间 //方式一 自己计算 //想要变化的 就是 position //用当前的位置 + 我要动多长距离 得出最终所在的位置 this.transform.position = this.transform.position + this.transform.up * 1 * Time.deltaTime; //因为我用的是 this.transform.forward 所以它始终会朝向相对于自己的面朝向去动 this.transform.position += this.transform.forward * 1 * Time.deltaTime; //方向非常重要 因为 它决定了你的前进方向 this.transform.position += Vector3.forward * 1 * Time.deltaTime; //方式二 API //参数一：表示位移多少 路程 = 方向 * 速度 * 时间 //参数二：表示 相对坐标系 默认 该参数 是相对于自己坐标系的 //1相对于世界坐标系的 Z轴 动 始终是朝 世界坐标系 的 Z轴正方向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); //2相对于世界坐标的 自己的面朝向去动 始终朝自己的面朝向移动 this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World); //3相对于自己的坐标系 下的 自己的面朝向向量移动 (一定不会这样让物体移动) XXXXXXX this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.Self); //4相对于自己的坐标系 下的 Z轴正方向移动 始终朝自己的面朝向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self); UnityEngine.Transform - Unity 脚本 API (unity3d.com) Tramsfrom-角度和旋转知识点一 角度相关 相对世界坐标角度：transform.eulerAngles； 相对父对象角度：transform.localEulerAngles； 知识点二 旋转相关 //自己计算(省略 和位置一样 不停改变角度即可) //API计算 //自转 //每个轴 具体转多少度 //第一个参数 相当于 是旋转的角度 每一帧 //第二个参数 默认不填 就是相对于自己坐标系 进行的旋转 this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime); this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World); //相对于某个轴 转多少度 //参数一：是相对哪个轴进行转动 //参数二：是转动的 角度 是多少 //参数三：默认不填 就是相对于自己的坐标系 进行旋转 // 如果填 可以填写相对于 世界坐标系进行旋转 this.transform.Rotate(Vector3.right, 10 * Time.deltaTime); this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World); //相对于某一个点转 //参数一：相当于哪一个点 转圈圈 //参数二：相对于那一个点的 哪一个轴转圈圈 //参数三：转的度数 旋转速度 * 时间 this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime); Transfrom-缩放和看向知识点一 缩放 //相对世界坐标系 print(this.transform.lossyScale); //相对本地坐标系(父对象) print(this.transform.localScale); //注意： //1.同样缩放不能只改xyz 只能一起改(相对于世界坐标系的缩放大小只能得 不能改) //所以 我们一般要修改缩放大小 都是改的 相对于父对象的 缩放大小 localScale this.transform.localScale = new Vector3(3, 3, 3); //2.Unity没有提供关于缩放的API //之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有 //如果你想要 让 缩放 发生变化 只能自己去写(自己算) this.transform.localScale += Vector3.one * Time.deltaTime; 知识点二 看向 //让一个对象的面朝向 可以一直看向某一个点或者某一个对象 //看向一个点 相对于世界坐标系的 this.transform.LookAt(Vector3.zero); //看向一个对象 就传入一个对象的 Transform信息 this.transform.LookAt(lookAtObj); Transfrom-父子关系知识点一 获取和设置父对象 //获取父对象 print(this.transform.parent.name); //设置父对象 断绝父子关系 this.transform.parent = null; //设置父对象 认爸爸 this.transform.parent = GameObject.Find(\"Father2\").transform; //通过API来进行父子关系的设置 this.transform.SetParent(null);//断绝父子关系 this.transform.SetParent(GameObject.Find(\"Father2\").transform);//认爸爸 //参数一：我的父亲 //参数二：是否保留世界坐标的 位置 角度 缩放 信息 // true 会保留 世界坐标下的状态 和 父对象 进行计算 得到本地坐标系的信息 // false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 this.transform.SetParent(GameObject.Find(\"Father3\").transform, false); 知识点二 抛妻弃子 //就是和自己的所有儿子 断绝关系 没有父子关系了 this.transform.DetachChildren(); 知识点三 获取子对象 //按名字查找儿子 //找到儿子的 transform信息 //Find方法 是能够找到 失活的对象的 ！！！！！ GameObject相关的 查找 是不能找到失活对象的 print(this.transform.Find(\"Cube (1)\").name); //他只能找到自己的儿子 找不到自己的孙子 ！！！！！！ print(this.transform.Find(\"GameObject\").name); //虽然它的效率 比GameObject.Find相关 要高一些 但是 前提是你必须知道父亲是谁 才能找 //遍历儿子 //如何得到有多少个儿子 //1.失活的儿子也会算数量 //2.找不到孙子 所以孙子不会算数量 print(this.transform.childCount); //通过索引号 去得到自己对应的儿子 //如果编号 超出了儿子数量的范围 那会直接报错的 //返回值 是 transform 可以得到对应儿子的 位置相关信息 this.transform.GetChild(0); 知识点四 儿子的操作 //判断自己的爸爸是谁 //一个对象 判断自己是不是另一个对象的儿子 if(son.IsChildOf(this.transform)) { print(\"是我的儿子\"); } //得到自己作为儿子的编号 print(son.GetSiblingIndex()); //把自己设置为第一个儿子 son.SetAsFirstSibling(); //把自己设置为最后一个儿子 son.SetAsLastSibling(); //把自己设置为指定个儿子 //就算你填的数量 超出了范围(负数或者更大的数) 不会报错 会直接设置成最后一个编号 son.SetSiblingIndex(1); Transfrom-坐标转换知识点一 世界坐标转本地坐标 print(Vector3.forward); //世界坐标系 转本地坐标系 可以帮助我们大概判断一个相对位置 //世界坐标系的点 转换 为相对本地坐标系的点 //受到缩放影响 print(\"转换后的点 \" + this.transform.InverseTransformPoint(Vector3.forward)); //世界坐标系的方向 转换 为相对本地坐标系的方向 //不受缩放影响 print(\"转换后的方向\" + this.transform.InverseTransformDirection(Vector3.forward)); //受缩放影响 print(\"转换后的方向(受缩放影响)\" + this.transform.InverseTransformVector(Vector3.forward)); 知识点二 本地坐标转世界坐标 //本地坐标系的点 转换 为相对世界坐标系的点 受到缩放影响 print(\"本地 转 世界 点\" + this.transform.TransformPoint(Vector3.forward)); //本地坐标系的方向 转换 为相对世界坐标系的方向 //不受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformDirection(Vector3.forward)); //受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformVector(Vector3.forward)); Input输入相关//知识点一 鼠标在屏幕位置 Input.mousePosition //知识点二 检测鼠标输入 //鼠标按下一瞬间 进入 //0左键 1右键 2中键 Input.GetMouseButtonDown(0) //中键滚动 //返回值的 y -1往下滚 0没有滚 1往上滚 //它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值 print(Input.mouseScrollDelta); //知识点三 检测键盘输入 //传入字符串的重载 //这里传入的 字符串 不能是大写的 不然会报错 //只能传入小写字符串 Input.GetKeyDown(\"q\") //推荐枚举型 Input.GetKey(KeyCode.W) //知识点四 检测默认轴输入 //我们学习鼠标 键盘输入 主要是用来 //控制玩家 比如 旋转 位移等等 //所以Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转 //键盘AD按下时 返回 -1到1之间的变换 //相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转 float h = Input.GetAxis(\"Horizontal\"); //键盘SW按下时 返回 -1到1之间的变换 //得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转 print(Input.GetAxis(\"Vertical\")); //鼠标横向移动时 -1 到 1 左 右 print(Input.GetAxis(\"Mouse X\")); //鼠标竖向移动时 -1 到 1 下 上 print(Input.GetAxis(\"Mouse Y\")); //我们默认的 GetAxis方法 是有渐变的 会总 -1~0~1之间 渐变 会出现小数 //GetAxisRaw方法 和 GetAxis使用方式相同 //只不过 它的返回值 只会是 -1 0 1 不会有中间值 //知识点三 其它的监听 //是否有任意键或鼠标长按 if(Input.anyKey) //是否有任意键或鼠标按下 if(Input.anyKeyDown) //这一帧的键盘输入 print(Input.inputString); //手柄输入相关 //得到连接的手柄的所有按钮名字 string[] strs = Input.GetJoystickNames(); //某一个手柄键按下 if( Input.GetButtonDown(\"Jump\") ) //某一个手柄键抬起 if (Input.GetButtonUp(\"Jump\")) //某一个手柄键长按 if (Input.GetButton(\"Jump\")) //移动设备触摸相关 if(Input.touchCount &gt; 0) { Touch t1 = Input.touches[0]; //位置 print(t1.position); //相对上次位置的变化 print(t1.deltaPosition); } //是否启用多点触控 Input.multiTouchEnabled = false; //陀螺仪(重力感应) //是否开启陀螺仪 必须开启 才能正常使用 Input.gyro.enabled = true; //重力加速度向量 print(Input.gyro.gravity); //旋转速度 print(Input.gyro.rotationRate); //陀螺仪 当前的旋转四元数 //比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响 //手机怎么动 它怎么动 print(Input.gyro.attitude); UnityEngine.Input - Unity 脚本 API (unity3d.com) Screen屏幕相关//知识点一 静态属性 //常用 //当前屏幕分辨率 Resolution r = Screen.currentResolution; print(\"当前屏幕分辨率的宽\" + r.width + \"高\" + r.height); //屏幕窗口当前宽高 //这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高 //一般写代码 要用窗口宽高 做计算时 就用他们 print(Screen.width); print(Screen.height); //屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; //不常用 //运行时是否全屏模式 Screen.fullScreen = true; //窗口模式 //独占全屏FullScreenMode.ExclusiveFullScreen //全屏窗口FullScreenMode.FullScreenWindow //最大化窗口FullScreenMode.MaximizedWindow //窗口模式FullScreenMode.Windowed Screen.fullScreenMode = FullScreenMode.Windowed; //移动设备屏幕转向相关 //允许自动旋转为左横向 Home键在左 Screen.autorotateToLandscapeLeft = true; //允许自动旋转为右横向 Home键在右 Screen.autorotateToLandscapeRight = true; //允许自动旋转到纵向 Home键在下 Screen.autorotateToPortrait = true; //允许自动旋转到纵向倒着看 Home键在上 Screen.autorotateToPortraitUpsideDown = true; //指定屏幕显示方向 Screen.orientation = ScreenOrientation.Landscape; 知识点二 静态方法 //设置分辨率 一般移动设备不使用 Screen.SetResolution(1920, 1080, false); UnityEngine.Screen - Unity 脚本 API (unity3d.com) Camera摄像机相关1.*Clear Flags： 如何清除背景： skybox天空盒(3D) Solid Color颜色填充(2D) Depth only 只画该层，背景透明(叠加渲染) Don't Clear 不移除，覆盖渲染 2.*Culling Mask 选择性渲染部分层级：可以指定只渲染对应层级的对象 3.*Projection 2.1Perspective 透视模式 FOV Axis：视场角 轴-决定了光学仪器的视野范围 Field of view：视口大小 Physical Camera：物理摄像机、勾选后可以模拟真实世界中、摄像机、焦距、传感器尺寸、透镜移位等等 Focal Length：焦距 Sensor Type：传感器类型 Sensor Size：传感器尺寸 Lens Shift：透镜移位 Gate Fit：闸门配合 2.2orthographic 正交摄像机(一般用于2D游戏制作) Size：摄制范围 4.*Clipping Planes： 裁剪平面距离(近和远) 5.Viewport Rect： 视口范围屏幕上将绘制该摄像机视图的位置： 主要用于双摄像机游戏 0~1 相当于宽高百分比 6.*Depth: 渲染顺序上的深度(多个摄像机，越小的越先渲染，大的覆盖小的) 7.Redering path: 渲染路径 8.*Target Texture: 渲染纹理: 可以把摄像机画面渲染到一张图上:主要用于制作小地图(摄像机渲染到这张图上) 在Project右键创建 Render Texture 9.*Occlusion Culling: 是否启用剔除遮挡(性能优化) 10.Allow HDR: 是否允许高动态范围渲染 11.Allow MSAA: 是否允许抗锯齿 12.Allow Dynamic Resolution: 是否允许动态分辨率呈现 13.Target Display: 用于哪个显示器:主要用来开发有多个屏幕的平台游戏 摄像机 - Unity 手册 (unity3d.com) 代码相关： 知识点一 重要静态成员 //1.获取摄像机 //如果用之前的知识 来获取摄像机 //主摄像机的获取 //如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机 print(Camera.main.name); //获取摄像机的数量 print(Camera.allCamerasCount); //得到所有摄像机 Camera[] allCamera = Camera.allCameras; print(allCamera.Length); //2.渲染相关委托 //摄像机剔除前处理的委托函数 Camera.onPreCull += (c) =&gt; { }; //摄像机 渲染前处理的委托 Camera.onPreRender += (c) =&gt; { }; //摄像机 渲染后 处理的委托 Camera.onPostRender += (c) =&gt; { }; 知识点二 重要成员 //1.界面上的参数 都可以在Camera中获取到 //比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置 Camera.main.depth = 10; //2.世界坐标转屏幕坐标 //转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远 //我们会用这个来做的功能 最多的 就是头顶血条相关的功能 Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position); print(v); //3.屏幕坐标转世界坐标 //只所以改变Z轴 是因为 如果不改 Z默认为0 //转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点 //如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点 Vector3 v = Input.mousePosition; v.z = 5; obj.position = Camera.main.ScreenToWorldPoint(v); //print(Camera.main.ScreenToWorldPoint(v)); UnityEngine.Camera - Unity 脚本 API (unity3d.com) 核心系统光源系统基础Light组件1.*Type:光源类型 Spot:聚光灯 Range:发光范围距离 Spot Angle:光锥角度 Directional:方向光(环境光) Point:点光源 Area:面光源(烘焙下用) 2.*Color: 颜色 3.*Mode:光源模式 Realtime: 实时光源 每帧实时计算，效果好，性能消耗大 Baked: 烘焙光源 事先计算好，无法动态变化 Mixed: 混合光源 预先计算+实时运算 4.*Intensity: 光源亮度 5.Indirect Multiplier: 改变间接光的强度 低于1，每次反弹会使光更暗大于1，每次反弹会使光更亮 6.*Shadow Type: NoShadows:关闭阴影 HardShadows:生硬阴影 SoftShadows:柔和阴影 7.RealtimeShadows Strength:阴影暗度 0~1之间，越大越黑 Resolution:阴影贴图渲染分辨率，越高越逼真，消耗越高 Bias:阴影推离光源的距离 Normal Bias:阴影投射面沿法线收缩距离 Near Panel:渲染阴影的近裁剪面 8.*Cookie: 投影遮罩(用图制作光照的样子) 9.Cookie Size： 大小设置 10.Draw Halo: 球形光环开关(光晕) 11.*Flare: 耀斑(工程文件可以自己右键创建该类型文件，想再Game显示，摄像机添加Flare Layer脚本) 12.Render Mode:渲染模式 Auto:运行时确定 Important:以像素质量为单位进行渲染，效果逼真，消耗大 Not Important:以快速模式进行渲染 13.*Culling Mask:剔除遮罩层，决定哪些层的对象受到该光源影响 光源 - Unity 手册 (unity3d.com) UnityEngine.Light - Unity 脚本 API (unity3d.com) 光窗口1.Environment-环境相关设置 Skybox Material-天空盒材质：可以改变天空盒(创建天空盒创建一个材质球将种类设置为skybox) Sun Source-太阳来源：不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting-环境光设置： Source-环境光光源颜色： Skybox：天空和材质作为环境光颜色 Gradient：可以为天空、地平线、地面单独选择颜色和他们之间混合 Intensity Multiplier-环境光亮度； Ambient Mode-全局光照模式只有启用了实时全局和全局烘焙时才有用： Realtime(已弃用) Baked 2.OtherSettings-其它设置： Fog-雾开关(性能消耗)： Color-雾颜色： Mode-雾计算模式： Linear-随距离线性增加： Start：离摄像机多远开始有雾 End：离摄像机多远完全遮挡 Exponential-随距离指数增加：-Density-强度； Exponential Qquare-随距离比指数更快的增加-Density：强度； Halo Texture：光源周围挥着光环的纹理 Halo Strength：光环可见性 Flare Fade Speed：耀斑淡出时间最初出现之后淡出的时间； Flare Strength：耀斑可见性 Spot Cookie：聚光灯默认剪影纹理 Lighting 窗口 - Unity 手册 (unity3d.com) 物理系统之碰撞检测Rigidbody组件重点：碰撞产生的必要条件，两个物体都有碰撞器，至少一个物体有刚体。 1.RigidBody组件信息： Mass：质量(默认为千克)质量越大惯性越大； Drag：空气阻力根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力； Angular Drag：根据扭矩旋转对象时影响对象的空气阻力大小。0 表示没有空气阻力； Use Gravity：是否受重力影响 Is Kinematic：如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用； Interpolate-(物理帧时间长时使用)插值运算，让刚体物体移动更平滑： None：不应用插值运算； Interpolate：根据前一帧的变换来平滑变换； Extrapolate：差值运算，根据下一帧的估计变换来平滑变换； Constraints-约束，对刚体运动的限制： Freeze Position：有选择地停止刚体沿世界 X、Y 和 Z 轴的移动； Freeze Rotation：有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转； Collision Detection(碰撞检测模式)-用于防止快速移动的对象穿过其它对象而不检测碰撞： Discrete(离散检测)：对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞(这是默认值)； Continuous(连续检测)：对动态碰撞体(具有刚体)使用离散碰撞检测，并对静态碰撞体(没有刚体)使用连续碰撞检测；设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。(此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置)，其他刚体将使用离散碰撞检测。 Continuous Speculative(连续推测检测)：对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 刚体 - Unity 手册 (unity3d.com) API: //知识点一 刚体自带添加力的方法 //给刚体加力的目标就是 //让其有一个速度 朝向某一个方向移动 //1.首先应该获取刚体组件 rigidBody = this.GetComponent&lt;Rigidbody&gt;(); //2.添加力 //相对世界坐标 //世界坐标系 Z轴正方向加了一个里 //加力过后 对象是否停止移动 是由阻力决定的 //如果阻力为0 那给了一个力过后 始终 是不会停止运动 rigidBody.AddForce(Vector3.forward * 10); //如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动 rigidBody.AddForce(this.transform.forward * 10); //相对本地坐标 rigidBody.AddRelativeForce(Vector3.forward * 10); //3.添加扭矩力，让其旋转 //相对世界坐标 rigidBody.AddTorque(Vector3.up * 10); //相对本地坐标 rigidBody.AddRelativeTorque(Vector3.up * 10); //4.直接改变速度 //这个速度方向 是相对于 世界坐标系的 //如果要直接通过改变速度 来让其移动 一定要注意这一点 rigidBody.velocity = Vector3.forward * 5; //5.模拟爆炸效果 //模拟爆炸的力 一定是 所有希望产生爆炸效果影响的对象 //都需要得到他们的刚体 来执行这个方法 才能都有效果 rigidBody.AddExplosionForce(100, Vector3.zero, 10); //知识点二 力的几种模式 //第二个参数 力的模式 主要的作用 就是 计算方式不同而已 //由于4中计算方式的不同 最终的移动速度就会不同 rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration); //动量定理 //Ft = mv // v = Ft/m; //F:力 //t：时间 //m:质量 //v:速度 //1.Acceleration //给物体增加一个持续的加速度，忽略其质量 //v = Ft/m //F:(0,0,10) //t:0.02s //m:默认为1 //v = 10*0.02/ 1 = 0.2m/s //每物理帧移动0.2m/s*0.02 = 0.004m //2.Force //给物体添加一个持续的力，与物体的质量有关 //v = Ft/m //F:(0,0,10) //t:0.02s //m:2kg //v = 10*0.02/ 2 = 0.1m/s //每物理帧移动0.1m/s*0.02 = 0.002m //3.Impulse //给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:2kg //v = 10*1/ 2 = 5m/s //每物理帧移动5m/s*0.02 = 0.1m //4.VelocityChange //给物体添加一个瞬时速度，忽略质量，忽略时间 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:默认为1 //v = 10*1/ 1 = 10m/s //每物理帧移动10m/s*0.02 = 0.2m //知识点三 力场脚本(Unity封装好了的组件) ConstantForce组件 //补充 刚体的休眠 //获取刚体是否处于休眠状态 如果是 if (rigidBody.IsSleeping()) { //就唤醒它 rigidBody.WakeUp(); } UnityEngine.Rigidbody - Unity 脚本 API (unity3d.com) 碰撞器碰撞器面板说明： 1.3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 2.共同参数： Is Trigger：是否是触发器，如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略，主要用于进行没有物理效果的碰撞检测； Material：物理材质(工程右键可以创建一个物理材质.material文件)，可以确定碰撞体和其它对象碰撞时的交互(表现)方式。 Center：碰撞体在对象局部空间中的中心点位置 3.常用碰撞器： BoxCollider-盒状碰撞器-Size：碰撞体在X、Y、Z方向上的大小； Sphere Collider-球状碰撞器-Radius：球形碰撞体的半径大小； Capsule Collider-胶囊碰撞器： Radius：胶囊体的半径 Height：胶囊体的高度 Direction：胶囊体在对象局部空间中的轴向 4.异形物体使用多种碰撞器组合：刚体对象的子对象碰撞器信息参与碰撞检测； 5.不常用碰撞器： Mesh Collider-网格碰撞器： Convex：勾选此复选框可启用 Convex。如果启用此属性，该 Mesh Collider 将与其他 Mesh Collider 发生碰撞。Convex Mesh Collider 最多 255 个三角形。 Cooking Options-启用或禁用影响物理引擎对网格处理方式的网格烹制选项： -None：禁用下方列出的所有 Cooking Options -Everything：启用下方列出的所有 Cooking Options。 -Cook for Faster Simulation：使物理引擎烹制网格以加快模拟速度。启用此设置后，这会运行一些额外步骤，以保证生成的网格对于运行时性能是最佳的。这会影响物理查询和接触生成的性能。禁用此设置后，物理引擎会使用更快的烹制速度，并尽可能快速生成结果。因此，烹制的 Mesh Collider 可能不是最佳的。 -Enable Mesh Cleaning：使物理引擎清理网格。启用此设置后，烹制过程会尝试消除网格的退化三角形以及其他几何瑕疵。此过程生成的网格更适合于在碰撞检测中使用，往往可生成更准确的击中点。 -Weld Colocated Vertices：使物理引擎在网格中删除相等的顶点。启用此设置后，物理引擎将合并具有相同位置的顶点。这对于运行时发生的碰撞反馈十分重要。 Mesh：引用需要用于碰撞的网格。 Wheel Collider-环状 碰撞器： Mass：车轮的质量 Radius：车轮的半径 Wheel Damping Rate：这是应用于车轮的阻尼值 Suspension Distance：车轮悬架的最大延伸距离(在局部空间中测量)。悬架始终向下延伸穿过局部 Y 轴。 Force App Point Distance：此参数定义车轮上的受力点。此距离应该是距车轮底部静止位置的距离(沿悬架行程方向)，以米为单位。当 forceAppPointDistance = 0 时，受力点位于静止的车轮底部。较好的车辆会使受力点略低于车辆质心。 Suspension Spring：悬架尝试通过增加弹簧力和阻尼力来到达目标位置 (Target Position) -Spring：弹簧力尝试到达目标位置。值越大，悬架达到目标位置就越快 -Damper：抑制悬架速度。值越大，悬架弹簧移动就越慢 -Target Position：悬架沿悬架距离 (Suspension Distance) 的静止距离。1 对应于完全展开的悬架，0 对应于完全压缩的悬架。默认值为 0.5，与常规汽车的悬架行为匹配。 Forward Friction-车轮向前滚动时轮胎摩擦的特性；Sideways Friction车轮侧向滚动时轮胎摩擦的特性—： -Extremum Slip：曲线的极值点。 -Extremum Value：曲线的极值点。 -Asymptote Slip：曲线的渐近点。 -Asymptote Value：曲线的渐近点。 -Stiffness：Extremum Value 和 Asymptote Value 的乘数(默认值为 1)。改变摩擦力的刚度。将此值设置为零将完全禁用车轮的所有摩擦力。通常在运行时修改刚度以使用脚本来模拟各种地面材质。 注意事项：不必通过转动或滚动 WheelCollider 对象来控制汽车；附加了 WheelCollider 的对象应始终相对于汽车本身固定； Terrain Collider-地形碰撞器 Terrain Data：地形数据 Enable Tree Colliders：选中此属性时，将启用树碰撞体 碰撞体 - Unity 手册 (unity3d.com) 物理材质物理材质参数说明 Dynamic Friction：已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止(除非用很大的力或重力推动对象) Static Friction：当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness：表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine-两个碰撞对象的摩擦力的组合方式： -Average：对两个摩擦值求平均值。 -Minimum：使用两个值中的最小值。 -Maximum：使用两个值中的最大值。 -Multiply：两个摩擦值相乘。 unce Combine：两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同 碰撞检测函数注意：碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用. //知识点一 物理碰撞检测响应函数 //碰撞触发接触时会 自动执行这个函数 private void OnCollisionEnter(Collision collision) { //Collision类型的 参数 包含了 碰到自己的对象的相关信息 //关键参数 //1.碰撞到的对象碰撞器的信息 //collision.collider //2.碰撞对象的依附对象(GameObject) //collision.gameObject //3.碰撞对象的依附对象的位置信息 //collision.transform //4.触碰点数相关 //collision.contactCount //接触点 具体的坐标 //ContactPoint[] pos = collision.contacts; //只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息 print(this.name + \"被\" + collision.gameObject.name + \"撞到了\"); } //碰撞结束分离时 会自动执行的函数 private void OnCollisionExit(Collision collision) { print(this.name + \"被\" + collision.gameObject.name + \"结束碰撞了\"); } //两个物体相互接触摩擦时 会不停的调用该函数 private void OnCollisionStay(Collision collision) { print(this.name + \"一直在和\" + collision.gameObject.name + \"接触\"); } //知识点二 触发器检测响应函数 //触发开始的函数 当第一次接触时 会自动调用 protected virtual void OnTriggerEnter(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"触发了\"); } //触发结束的函数 当水乳相融的状态结束时 会调用一次 private void OnTriggerExit(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"结束水乳相融的状态了\"); } //当两个对象 水乳相融的时候 会不停调用 private void OnTriggerStay(Collider other) { print(this.name + \"和\" + other.gameObject.name + \"正在水乳相融\"); } 音效系统音频文件导入1.导入参数设置 常用格式：wav、mp3、ogg、aiff； 音频文件属性设置 Force To Mono：多声道转单声道； Normalize：强制为单声道时，混合过程中被标准化； Load In Background：在后台加载，不阻塞主线程； Ambisonic：立体混响声 ，非常适合 360 度视频和 XR 应用程序，如果音频文件包含立体混响声编码的音频，请启用此选项； LoadType-加载类型： Decompress On Load：不压缩形式存在内存，加载块，但是内存占用高(适用于小音效文件)； Compress in memory：压缩形式存在内存，加载慢，内存小(仅适用于较大音效文件) Streaming：以流形式存在，使用时解码。内存占用最小，cpu消耗高(性能换内存) Preload Audio Data：预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format-压缩方式： PCM：音频以最高质量存储 Vorbis：相对PCM压缩的更小，根据质量决定 ADPCM：包含噪音，会被多次播放的声音，如碰撞声 Quality：音频质量，确定要应用于压缩剪辑的压缩量。(不适用于 PCM/ADPCM/HEVAG 格式) Sample Rate Setting-PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率： Preserve Sample Rate：此设置可保持采样率不变(默认值)； Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率； Override Sample Rate：此设置允许手动覆盖采样率，因此可有效地将其用于丢弃频率内容； 音频源和音频监听组件组件面板说明： AudioSource-音频源： AudioClip：声音剪辑文件(音频文件) Output：默认将直接输出到场景中的音频监听器，可以更改为输出到混音器(音乐游戏可能会用)； Mute：静音开关； Bypass Effect：开关滤波器效果； Bypass Listener Effects：快速开关所有监听器； Bypass Reverb Zones：快速开关所有混响区 Play On Awake：对象创建时就播放音乐，也就是开关启动游戏就播放； Loop：循环 Priority：优先级(越大越不容易被其他音效覆盖) Volume：音量大小 Pitch：音高 Stereo Pan：2D声音立体声位置。相当于左右声道 Spatial Blend：音频受3D空间的影响程度(设置是2d游戏还是3d音效) Reverb Zone Mix：到混响区的输出信号量 3D Sound Settings-和Spatial Blend参数成正比应用： Doppler Level：多普勒效果等级 Spread：扩散角度设置为3D立体声还是多声道 Volume Rolloff-声音衰减速度： Logarithmic Rolloff：靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff：与音频源的距离越远，听到的声音越小。 Custom Rolloff：音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance：最小距离内，声音保持最大响度；最大距离外，声音开始减弱； AudioListener-音频监听脚本； 音频源 - Unity 手册 (unity3d.com) 音频源代码控制//知识点一 代码控制播放停止 //播放音效 audioSource.Play(); //延迟播放 填写的是秒数 audioSource.PlayDelayed(5); //停止音效 audioSource.Stop(); //暂停 audioSource.Pause(); //停止暂停 和暂停后 Play效果是一样的 都会继续播放现在的音效 audioSource.UnPause(); 知识点二 如何检测音效播放完毕 //如果你希望某一个音效播放完毕后 想要做什么事情 //那就可以在Update生命周期函数中 不停的去检测 它的 该属性 //如果是false就代表播放完毕了 audioSource.isPlaying 知识点三 如何动态控制音效播放 //1.直接在要播放音效的对象上挂载脚本 控制播放 //2.实例化挂载了音效源脚本的对象 //这种方法 其实用的比较少 //Instantiate(obj); //3.用一个AudioSource来控制播放不同的音效 //AudioSource aus = this.gameObject.AddComponent&lt;AudioSource&gt;(); //aus.clip = clip; //aus.Play(); //潜在知识点 //一个GameObject可以挂载多个 音效源脚本AudioSource //使用时要注意 如果要挂载多个 那一定要自己管理他们 控制他们的播放 停止 不然 我们没有办法准确的获取 //谁是谁 UnityEngine.AudioClip - Unity 脚本 API (unity3d.com) 麦克风输入相关知识点一 获取设备麦克风信息 string[] strs = Microphone.devices; 知识点二 开始录制 //参数一：设备名 传空使用默认设备 //参数二：超过录制长度后 是否重头录制 //参数三：录制时长 //参数四：采样率 clip = Microphone.Start(null, false, 10, 44100); 知识点三 结束录制 Microphone.End(null); 知识点四 获取音频数据用于存储或者传输 //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[clip.channels * clip.samples]; clip.GetData(f, 0); print(f.Length); UnityEngine.Microphone - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"C#进阶","slug":"02004-C#进阶","date":"2019-08-02T13:00:00.000Z","updated":"2022-02-18T11:54:57.292Z","comments":true,"path":"posts/1028.html","link":"","permalink":"http://wwy010518.github.io/posts/1028.html","excerpt":"","text":"CLR中简单数据结构类命名空间：System.Collections； ArrayList语法:new ArrayList();建议：本质是一个自动扩容的object数值，存在装箱拆箱，尽量少用；C# 动态数组(ArrayList) |菜鸟教程 (runoob.com) Stack(栈)语法：new Stack();建议：存在装箱拆箱；C# 堆栈(Stack) | 菜鸟教程 (runoob.com) Queue(队列)语法：new Queue();建议：存在装箱拆箱；C# 队列(队列) |菜鸟教程 (runoob.com) Hashtable(哈希表)定义：又叫散列表，是基于键的哈希代码组织起来的键值对，主要用来提高数据查询效率；语法：new Hashtable();迭代器遍历法: IDictionaryEnumerator me=哈希表对象名.GetEnumerator(); while(me.MoveNext()){ } 建议：存在装箱拆箱；C# 哈希表(Hashtable) |菜鸟教程 (runoob.com) CLR中的泛形命名空间：System.Collections.Generic 泛形定义：通过类型参数来实现代码操作多种类型；原理：相当于占位符，定义类或者方法是用替代符代替变量类型，当真正使用时再指定具体类型； 泛形约束关键字：where，可以多个使用;种类：6种如下：1.值类型 where 泛形字母:struct；2.引用类型 where 泛形字母:class；3.存在无参公共构造函数 where 泛形字母:new()；4.某个类本身或者派生类 where 泛形字母:类名；5.每个接口的派生 where 泛形字母:接口名；6.另一个泛形类型或者派生类型 where 泛形字母:另一个泛形字母； List定义：表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。语法：new List&lt;&gt;();List 类 (System.Collections.Generic) | Microsoft Docs Dictionary定义：表示键和值的集合。语法：new Dictionart&lt;键,值&gt;();Dictionary 类 (System.Collections.Generic) | Microsoft Docs LinkedList定义：表示双重链接列表。语法：new LinkedList&lt;&gt;();LinkedList 类 (System.Collections.Generic) | Microsoft Docs 泛形队列定义：表示对象的先进先出泛形集合。语法：new Queue&lt;&gt;();Queue 类 (System.Collections.Generic) | Microsoft Docs 泛形栈定义：表示相同指定类型的实例可变大小的后进先出 (LIFO) 集合。语法：new Stack&lt;&gt;();Stack 类 (System.Collections.Generic) | Microsoft Docs 委托和事件委托定义：C# 中的委托(Delegate)类似于 C 或 C++ 中函数的指针,本质时一个类。委托(Delegate) 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变，专门用来装载函数的容器。语法： //定义 访问修饰符 delegate 返回值类型 委托名&lt;泛形类型&gt;(参数列表) //实例化 委托名 变量名=new 委托名(); //赋值,参数要一致 变量名[+或-]=方法名() //使用 委托变量名(对应参数): 系统自带的委托：Action&lt;泛形类型,……泛形类型&gt;和Func&lt;泛形类型,…..返回值&gt;;(d都支持16个泛形类型) 事件定义:让委托使用更加安全，事件是一种特殊的变量类型语法：访问修饰符 event 委托类型 事件名和委托区别：不能再类外部赋值(可以加减)，不能在类外部调用，只能在类内部封装调用； 匿名函数定义：没有名字的函数，要配合委托和事件使用；缺点：没有名字，无法通过+-移除；语法： Action a=delegate(参数列表){ } Lambad表达式定义：可以理解成是匿名函数的简写； (参数列表)=&gt;{ } 多线程和任务前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存 多线程(Thread)命名空间：using System.Threading语法: //启动线程，将要执行的代码逻辑封装到一个函数语句块中 Thread 线程名=new Thread(委托方法); //启动线程 线程名.start(); //设置为后台线程,当进程结束后台线程结束 线程名.IsBackground=true; //关闭释放一个死循环进程，有俩中方法 //为线程死循环加一个标志变量 //通过线程提供的方法(在.net core版本会无法中止报错),可以加异常捕捉 线程名.Abort(); //线程休眠 线程名.Sleep(时间/ms); C# 多线程 | 菜鸟教程 (runoob.com) 共享数据问题：多线程操作同一内存区域可能出现问题，可以通过加锁的形式避免问题 lock(同一引用类型变量){ } 线程池(ThreadPoll)命名空间：using System.Threading定义:ThreadPoll是线程池(享元设计模式)，其目的是为了减少开启新线程消耗的资源(使用线程池中的空闲线程，不必在开启新线程，以及统一管理线程(线程池中的线程执行完毕后，回归到线程池里，等待新任务).优缺点：ThreadPoll性能优于Thread，但是Thread和ThreadPoll对线程的控制都不是很好，例如线程等待(线程执行一段时间无响应后，直接停止线程，释放资源 等 都没有直接的API来控制 只能通过硬编码来实现，同时ThreadPool使用的是线程池全局队列，全局队列中的线程依旧会存在竞争共享资源的情况，从而影响性能。语法： //快速启动 ThreadPool.QueueUserWorkItem(委托方法); //获取线程池中辅助线程的最大数量(workerThreadsMax)和线程池中异步I/O线程的最大数量(completionPortThreadsMax) ThreadPool.GetMaxThreads(out int workerThreadsMax, out int completionPortThreadsMax); //获取线程池中辅助线程的最小数量(workerThreadsMin)和线程池中异步I/O线程的最小数量(completionPortThreadsMin) ThreadPool.GetMinThreads(out int workerThreadsMin, out int completionPortThreadsMin); //设置最大线程数量 和 设置最小线程数量，在进程内是全局的。在一个地方设置了，后面所有的请求中都是这个数量了 //委托异步调用、Task、Parallel、async/await 都使用的是线程池的线程； new Thread()不受限制，但是会占用线程池的数量。 ThreadPool.SetMaxThreads(12, 12);//不能低于当前电脑的线程数；比如四核八线程，就不能低于8，否则无效 ThreadPool.SetMinThreads(1, 1); //线程等待，需要使用ManualResetEvent来完成 ManualResetEvent mre = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem((obj) =&gt; { DoSomething(\"\"); mre.Set(); } ); mre.WaitOne()； 任务(Task)命名空间：using System.Threading.Tasks特点：Task是基于任务的异步编程模型,Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。建议：使用Task的时候应该尽量结合async和await关键字来使用。避免使用.Result 和 .Wait()来阻塞等待;.Result 和 .Wait()会占用线程资源，直到任务完成；而await的基于异步回调的，不会浪费CPU资源；async和await是语法糖，本质上其实是ContinueWith()。基本语法： //Task使用方式1 Task task1 = new Task(() =&gt; { DoSomething(\"张三\"); }); task1.Start(); //Task使用方式2 var taskFactory = Task.Factory; Task&lt;int&gt; t1 = taskFactory.StartNew&lt;int&gt;(() =&gt; { DoSomething(\"王五\"); return 1; }); Task t2 = taskFactory.StartNew(() =&gt; { DoSomething(\"赵六\"); }); Task t3 = taskFactory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"所有线程都完成了，就会调用这个函数， 不会阻塞主线程\"); }); Task t4 = taskFactory.ContinueWhenAny(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"任意一个线程完成了，就会调用这个函数， 不会阻塞主线程\"); }); //Task使用方式3 Task&lt;int&gt; task = Task.Run&lt;int&gt;(() =&gt; { DoSomething(\"李四\"); return 1; }); int temp = task.Result; //阻塞执行完毕并获取结果，不建议使用这种方式 task.Wait(); //阻塞，直到子线程执行完毕，不建议使用这种方式 await task; //阻塞，直到子线程执行完毕。 但是主线程(调用方)将继续往下执行，await task后面的代码等同于封装在ContinueWith()里面 //Task其它使用方式 //Task.Delay(2000)不阻塞当前线程，一般配合ContinueWith使用，在ContinueWith里面的子线程将等待2秒之后执行 //Thread.Sleep(2000)是阻塞当前线程 Task task3 = Task.Delay(2000).ContinueWith((t) =&gt; { }); //等待所有线程完成 Task.WaitAll(new Task[] { task1, t1 }); //等待任意一个线程完成 Task.WaitAny(new Task[] { task1, t1 }); //线程回调 task1.ContinueWith((o) =&gt; { Console.WriteLine(\"线程回调，task1执行完毕之后执行这里。\"); } //Task取消任务 CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; ManualResetEvent resetEvent = new ManualResetEvent(true); //定义任务 Task task = new Task(async () =&gt; { while (true) { if (token.IsCancellationRequested) { return; } // 初始化为true时执行WaitOne不阻塞 resetEvent.WaitOne(); // Doing something....... // 模拟等待100ms await Task.Delay(100); } }, token); //任务开始 task.Start(); //任务暂停 resetEvent.Reset(); //任务继续 resetEvent.Set(); //取消Task tokenSource.Cancel(); async/await语法使用案例： static void Main(string[] args) { string content = GetContentAsync(Environment.CurrentDirectory + @\"/test.txt\").Result; //调用同步方法 //string content = GetContent(Environment.CurrentDirectory + @\"/test.txt\"); Console.WriteLine(content); Console.ReadKey(); } //异步读取文件内容 async static Task&lt;string&gt; GetContentAsync(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //ReadAync方法异步读取内容，不阻塞线程 Console.WriteLine(\"开始读取文件\"); int len = await fs.ReadAsync(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } //同步读取文件内容 static string GetContent(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //Read方法同步读取内容，阻塞线程 int len = fs.Read(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } 预处理器指令什么是编译器源语言程序：某种程序设计语言写的，像c#、c、c++、java等；目标语言程序：计算机可以识别的二进制数程序；编译器：是一种翻译程序(编译原理 )，将源语言程序翻译成目标语言程序； 什么是预处理器指令定义：指导编译器，在实际编译开始时对信息进行预处理，都是以#开始，不是指令，所以不以；结束； 常见的预处理器指令//写在脚本最前面，配合if指令或特性使用1.#define：定义一个符号，类似一个没有值的变量2.#undef：取消define定义的符号3.#if、#elif、#else、#endif：和if语法规则一样，用于告诉编译器进行编译代码的流程控制；4.#warning、#error：告诉编译器是报警告还是报错； 反射和特性程序集：由编译器编译(.exe或者.dll)，供编译执行的中间产物；元数据：数据的数据； 反射概念：程序正在运行时可以查看其他程序集或者自己的元数据这就叫反射；type定义：类的信息类，是访问元数据的主要方式，反射的技术；语法：获取的type指向的内存都是一样的 //1.通过object.GetType()获取对象的Type Type t1=object.GetType(); //2.通过typeof关键字获取类的Type Type t2=typeof(int); //3.通过类名获取，但是必须有命名空间 Type p3=Type.GetType(\"System.Int32\"); //程序集获取 t1.Assembly; //获取类的所有公共成员 MemberInfo[] infos=t1.GetMembers(); //获取类所有构造函数并调用 ConstructorInfo[] ctors=t1.GetConstructors(); //获取构造函数传入 Type数组 数组中按顺序是参数类型，执行构造函数传入 object数组 表示按顺序传入的参数； //得到无参构造 ConstructorInfo info =t1.GetConstructor(new Type[]); info.Invoke(null) as 类名; //得到有参构造 ConstructorInfo info =t1.GetConstructor(new Type[]{typeof(int)}); info.Invoke(new object[]{2}) as 类名; //得到所有成员变量 FieldInfo[] fieldINfos=t1.GetFields(); //得到指定名称的公共成员变量 FieldInfo infoj=t1.GetField(\"变量名\")； //通过反射获取变量值 infoj.GetValue(类实例); //通过反射设置变量值 infoj.SetValue(类实例,要赋的值)； //获得类的公共成员方法 MethodInfo[] methods=t1.GetMethods(); //获取指定方法 MethodInfo method=t1.GetMethod(\"方法名\"，new Type[]{反射参数类型同上}); method.Invoke(参数)； 特性定义：本质是个类，可以利用特性类为元数据添加额外信息，之后可以用反射获取这些额外信息，类、变量、函数前都可以添加；自定义特性：继承特性基类 Attribute(使用自定义特性时类名后面会省略Attribute这几个字);语法 //1.定义特性 class 特性类名：Attribute{ } //2.特性使用 [特性名(参数列表)] //类、函数、变量上一行 //3.判断是否使用了某个特性 //参数一：特性的类型 参数二：是否搜索继承链(属性和时间忽略) if(类type类型.IsDefind(typeof(特性类型)，false)){} //4.获取Type元数据中的所有特性 t.GetCustomAttributes(ture); //5.为特性类加特性，限制自定义特性 //参数一：AttributeTargets--特性可以用在哪里 //参数二：AllowMultiple--是否允许多个特性在同一个目标上 //参数三：Inherited--特性是否能被派生类和重写成员继承 [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple=true,Inherited=true)] //6.系统自带特性 //6.1过时特性 [Obsolete(\"过时特性，后面是ture直接报错，否则警告\"，false)] //6.2调用者信息特性 用处不大，省略，用工具就可以了 //6.3条件编译特性 //和#define配套使用，必须有该参数名的预指令符号才会执行修饰成员 using System.Runtime.CompilerServices [Conditional(\"Fun\")] //6.4外部Dll包函数特性 //用来标记非.Net的函数，表明在一个外部的DLL中定义，用来调用c或者c++得DLL包写好的方法 using System.Runtime.InteropServices [DllImport(\"程序集全名\")] public static extern int 外部DLL元数据函数名() 其他补充协变逆变协变：out逆变：in作用一：用out修饰的泛形只能作为返回值，用in修饰的泛形只能作为参数作用二：用out和in修饰的泛形委托可以i互相装载(有父子关系的委托) //结合里氏替换原则理解 //协变 父类总是能被子类替代 TestOut&lt;Son&gt; os=()=&gt;{ } TestOut&lt;Father&gt; of=os;//参数必须声明out of();//实际上os装的函数返回的是Son的 //逆变 子类装父类委托 TestIn&lt;Father&gt; of=()=&gt;{ } TestIn&lt;Son&gt; os=of;//参数必须声明in os();//实际上os装的函数返回的是Father的 迭代器(iterator)概念：又称为光标(cursor)，是程序设计的软件设计模式，是可以在遍历访问的接口，设计人员无需关心容器的内存细节，能用foreach遍历的类，都实现了迭代器；关键接口：IEnumerator(迭代器实现),IEnumerable(foreach实现，有方法即可);命名空间：using System.Collections;yield return：是c#提供的语法糖(糖衣语法)，可以将复杂逻辑简单化，增加程序可读性，yield关键字可以理解为暂时返回，保留当前状态； 特殊语法# 隐藏类型var 可以用来表示任何类型的变量，一般用来临时变量，但是不能再更改类型。 # 设置对象初始值 可以直接通过大括号来进行赋值。 # 设置集合初始值 可以直接通过大括号来进行赋值。 # 匿名类型 var变量可声明为自定义的匿名类型，但是只能有变量。语法 var v=new {age=10,name=\"小明}; # 可空类型//1.数值类型使用，声明时再值类型后面加？可以赋值为空 int? lue=null; //又如 int[] os=null; int? x=os?[0]; //2.引用类型使用，相当于一种语法糖，自动判断是否为空,例如判断委托是否为不为空才执行 o?Invoke(); //3.判断值类型是否为空 值变量名.HasValue； //4.安全获取值类型默认值(可以指定默认值) 值变量名.GetValueOrDefault(默认值); # 空和并操作符定义：左边值？？右边值，左边为null返回右边值，否则左边； # 内插字符串 用关键字$，类似于Format拼接字符串。语法 Console.WriteLine($\"你好，{name}”); # 单句逻辑简略写法 逻辑语句只有一句代码的话可以省略{}，而属性只有一句getset可以写成get=&gt;返回值;set=&gt;变量名=要赋的值，方法同理。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#核心","slug":"02003-C#核心","date":"2019-07-15T13:00:00.000Z","updated":"2022-01-25T07:47:52.980Z","comments":true,"path":"posts/1027.html","link":"","permalink":"http://wwy010518.github.io/posts/1027.html","excerpt":"","text":"面向对象基本概念其他编程方式：面向过程编程；三大特征：封装+继承+多态；七大原则：1.单一原则：一个类只处理自己应该处理的。应该各司其职，例如把每个移动技能都尽量写出一个类，方便修改。2.开闭原则：新功能尽量是加处理而不是改代码。继承就是最明显的开闭原则，不要修改模板的内容，例如定义属性要用方法定义， getset，方便修改，修改类时或者改别人的方法，不清楚逻辑的就再写一个类。3.依赖倒置原则：不依赖于具体实现，要依赖抽象(接口)。要依赖于抽象，不要依赖于具体实现，可以先了解需求，再画图，最后变成代码。4.接口隔离原则：一个接口一个行为。接口里的单一原则，需要分的事件要分清楚。5.里氏替换原则：用父类容器装载子类，任何地方子类都能替换父类。不要修改别人的代码，可以继承他的代码去重写(注：多态：父类的指针指向子类，而调用子类的方法)6.合成复用原则：尽量用组合复用的形式。继承关系中，父类要可以解决子类共同的问题，子类时解决特与的问题，能用现有的类，就别再自己创建类。7.迪米特法则：一个类尽量减少对别的类引用。又叫最少知识原则，减少耦合性，类自己能解决的，尽量不要牵扯别的类，比如A类引用B类的方法，但是B类方法参数改了，A类也要改。 面向对象三特征-封装一般类定义： 类和对象class 类名{ 类名 对象名=new 类名; } 类一般成员和封装成员变量：成员变量是声明在类中的变量，可以是任意类型；成员方法(函数)：类的成员函数是一个在类定义中有它的定义或原型的函数;访问修饰符种类：public(接口成员、命名空间、枚举默认)、private(类成员)、protected、internal(类、结构、接口、委托默认)； 构造函数构造函数：类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行，构造函数的名称与类的名称完全相同，它没有任何返回类型默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，以下是它的特殊写法： public 类名(参数1，参数2):this(参数1){ //默认会先调用无参构造(this)或者父类构造函数(换成base) } ##析构函数析构函数：类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行，析构函数的名称是在类的名称前加上一个波浪形(~)作为前缀，它不返回值，也不带任何参数，析构函数用于在结束程序(比如关闭文件、释放内存等)之前释放资源，就是当引用类型的堆被回收时被调用，析构函数不能继承或重载。 垃圾回收机制定义:简称GC，当堆(Heap)中的变量没有被任何对象引用时，就会被自动回收；算法：引用计数、标记清除、标记整理、复制集合；注意事项：GC只负责堆的垃圾回收,而栈(stack)的内存时系统自动管理的，值类型有自己的生命周期，会自动分配和释放；原理：C#会把堆中的内存分为0代内存、1代内存、2代内存(代是分代算法，代系数越大速度越慢，内存越大)，新分配的对象会配置在0代内存，每次分配都可能会进行垃圾回收释放内存(0代内存或者1代内存满时)，垃圾回收机制确认堆中的垃圾，首先会标记对象，发现是否有引用，标记后可达对象，未标记未不可达对象(垃圾)，然后就将对象压缩堆(挂起执行托管代码线程)释放垃圾，搬迁可达对象地址到下一代内存(到第二代内存不会在搬迁)，大对象(83kb以上)总认为是第二代内存。手动触发代码：GC.Collect();一般Loading过场景调用 成员属性语法： 访问修饰符 属性类型 属性名{ 访问修饰符 get{}//自动属性可以省略{} 访问修饰符 set{}//自动属性可以省略{} } 索引器概念:让对象可以像数组一样通过索引访问元素，索引器可以重载；语法： 访问修饰符 返回值 this[参数1、参数2]{ get{} set{} } 静态类和静态成员static静态类：不能被实例化，只能有静态成员；静态变量：当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本；静态函数：这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在；静态构造函数：不能使用访问修饰符，不能有参数，使用静态类或者普通类的成员时会自动且仅调用一次； 拓展方法特点：一定是写在静态类，一定是静态函数，第一个参数为拓展目标，第一个参数用this修饰；语法： 访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数1，参数2){ } 运算符重载概念：使用operator关键字让自定义类和结构体可以使用运算符；特点：一定是公告静态方法，返回值在operator前(条件运算要成对出现，一个符号可以多个重载，不能使用ref和out);语法： public static 返回类型 operator 运算符(参数列表){ } 不可重载的运算符:逻辑与&amp;&amp; 、逻辑非||、索引符[]、强转符号()、点.、三目运算符?:、赋值符号=； 内部类和分部类内部类定义:在一个类中再声明一个类，使用时要外部类点出自己；分部类：用partial把类分成几部分,注意访问修饰符要一样;分部方法:用partial将方法声明和实现分离，强制私有，只能在分部类声明，不能有返回值，不能用out关键字； 面向对象三特征-继承继承基本规则语法： class 类名 ：被继承的类{ } 里氏替换原则概念:任何父类出现的地方，子类都可以替代语法: 父类 变量名=new 子类()； ###is关键字定义:判断一个对象是否为指定类对象，返回bool值语法:对象 is 类名 ###as关键字定义:将一个对象转换为指定类对象，没有返回null语法:对象 as 类名 继承中的构造函数特点:实例化时先执行父类构造函数,再执行子类构造函数； 万物之父和装箱拆箱万物之父关键字:object装箱:例如object存储值类型发生，把值类型从栈中迁移到堆中，变成引用类型；拆箱:例如把object转为值类型发生，把引用类型从堆中迁移到栈中，变成值类型； 密封类概念:使用sealed关键字使类无法再被继承； 面向对象三特征-多态vob关键字：virtual(虚函数)和override(重写); 抽象类和抽象方法关键字：abstract(抽象函数)；特点：抽象类不能被实例化，但是遵守里氏替换原则，抽象方法没有方法体； 接口关键字:interface；特点：不包含成员变量，只有抽象方法、属性、索引器、事件，成员不能被实现，不能是私有成员，类可以继承多个接口，接口也遵守里氏替换原则；作用：不作为实体基类,但是可以作为一个行为基类;命名规则:帕斯卡命名法前面加I; ###显示实现接口作用：当实现俩个接口后，其中有相同方法时；语法：用接口名点出方法名; 密封方法关键字:sealed修饰不能再被重写； 面向对象相关知识点命名空间特点：命名空间可以包裹命名空间;语法： namespace 命名空间名{ } 万物之父中的方法静态方法Equals:判断俩个对象是否相等,值类型比较数值，引用类型比较地址;静态方法RefereceEquals：判断俩个对象引用是否相等，主要用于应用类型，值类型返回始终false;普通方法GetType():获取对象运行时的类型(反射相关);普通方法MemberwiseClone：拷贝对象,引用对象指向相同地址;虚方法Equals:相当于RefereceEquals,但是在种类中ValueType中重写了,可以用来比较值相等；虚方法GetHashCode：获取对象哈希值(对象唯一编码，但是也可能u不同对象哈希码一样)；虚方法ToString：返回对象代表的字符串; string注意事项：string大部分方法需要赋值再使用，因为会实例化一个新的字符串；字符串名[]：字符串索引器;(静态)string.Format()：字符串拼接(替代);字符串名.IndexOf()：正向查找字符位置;字符串名.LastIndexOf()：反向查找字符位置;字符串名.Remove()：移除指定位置的字符;字符串名.Replace()：替换指定字符串;字符串名.ToUpper()：字符串全部大写；字符串名.ToLower()：字符串全部小写;字符串名.Substring()：字符串截取；字符串名.Split()：字符串切割； StringBuilder作用：修改字符串而不创建新的对象字符串.Capacity:获取容量；字符串.Append:增；字符串.AppendFormat():拼接；字符串.Insert():插入；字符串.Remove():删；字符串.Clear():清空；索引-字符串[]:用来查和改；str.Replace():替换； 字符串拼接的方式直接通过+拼接 会有性能问题，字符串少还好，越多GC越严重。 通过StringBuilder拼接字符串 字符串数量越多性能相对直接+拼接方法越高。 通过StringBuffer拼接字符串 区别：线程安全版的StringBuilder，但是性能不如StringBuilder; string.Format原理：其底层本质还是StringBuilder来实现的； $方式拼接字符串原理：是string.Format简化版，C#6.0新增操作；语法： string str = $\"my name is{name}, I'm {age} years old\"; 知识拓展多脚本文件.cs：源码文件.sln：解决方案入口文件.dll：编译文件 UML定义：统一建模语言，是面向对象设计的建模语言；理解：可以通过一些UML可视化软件(visio)就可以生成代码；","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#基础","slug":"02002-C#基础","date":"2019-07-02T13:00:00.000Z","updated":"2022-01-25T04:23:57.493Z","comments":true,"path":"posts/1026.html","link":"","permalink":"http://wwy010518.github.io/posts/1026.html","excerpt":"","text":"将之前的笔记记录在博客上 复杂数据类型特点：数据(变量)集合、自定义； 枚举 枚举是一个被命名的整形常量集合,可以声明再命名空间、类和结构体中。 枚举声明enum 变量名{ 名1,//枚举中默认是0下面累加 名2=4,//可以赋值,下面数值接着从此开始 名3 } 枚举的类型转换1.枚举和int互转后是数值的转换2.枚举转换成string是枚举名3.string转换成枚举,必须有这个字符串名的枚举名,实例如下： Enum.Parse(typeof(声明枚举类型名),\"Other\"); 数组 数组是储存一组相同的数值集合,下标从0开始。 一维数组声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1,2,3,4……(第数组长度-1个) }；获取长度：数组名.length; 二维数组声明：变量类型【,】 二维数组名=new 变量类型【行,列】{ { 1,1,1… },{ 1,1,1…. },{ 1,1,1…. }… };获取长度:数组名.length(维度); 交叉数组 即数组的数组。 结构体public struct 结构体名{ 变量类型 变量名 构造函数(可选) 函数 } 结构体和类相同点：1.两者都拥有成员,包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。2.两者的成员都有其各自的存取范围。例如,可以将某一个成员声明为Public,而将另一个成员声明为Private。3.两者都可以实现接口。4.两者都可以公开一个默认属性,然而前提是这个属性至少要取得一个自变量。5.两者都可以声明和触发事件,而且两者都可以声明委托(Delegate)。6.两者都是container类型,这表示它们可以包含其他数据类型作为成员。 区别：1.结构是实值类型(Value Types),而类则是引用类型(Reference Types)。2.结构使用栈存储(Stack Allocation),而类使用堆存储(Heap Allocation)。3.所有结构成员默认都是Public,而类的变量和常量数则默认位Private,不过其他类成员默认都是Public。4.结构成员不能被声明位Protected,而类成员可以。5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化,但是类变量声明可以。6.结构不能声明默认的构造函数,也就是不拥有参数的非共享构造函数,但是类则无此限制。7.二者都可以拥有共享构造函数,结构的共享构造函数不能带有参数,但是类的共享构造函数则可以带或者不带参数。8.结构不允许声明析构函数(Destructor),类则无此限制。9.结构的实例(Instance)声明,不允许对包含的变量进行初始化设定,类则可以在声明类的实例时,同时进行变量初始化。1.结构是隐式继承自ValueType类,而且不能继承任何其他类型,类则可以继续自ValueType以外的任何类。11.结构是无法被继承的,类则可以。12.结构永远不会终止,因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止,当内存回收进程检测到没有任何作用的类时,它就会调用类的Finalize方法。13.结构不需要构造函数,类则需要构造函数。14.结构只能在一种情况下使用非共享构造函数,那就是非共享构造函数会接受参数。但是类则无此限制,它可以使用带参数或不带参数的非共享构造函数。15.每一个结构都具有无参数的隐含公共构造函数,此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上,由于结构是数值类型的,因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的,而且对象变量可引用不同的类实例,在此方面的区别,会对使用将结构和类造成如下的影响：16.结构变量会隐式的使用结构的无参数构造函数来初始化成员,这就意味语句 Struct S = new Struct()。17.当您将一个结构变量赋值给另一个,或者将结构实例传递到程序变量时,所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个,或者将对象变量传递给程序时,则只是复制指针。18.您可以将Null值赋值给结构变量,但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化,但是您还是可以调用变量的方法并访问其数据成员。相反的,如果您将对象变量设定为Null,您就会中断它与任何类型实例的关联,而且除非您再将另一个实例赋值给它,否则无法通过变量访问任何成员。19.您可以在不同时间将不同的类的实例赋值给同一个对象变量,而且在同一时间可有好几个对象变量引用相同的类实例,如果您对类成员值做了改变,则其他指向相同实例的对象变量也会发生改变。然而,结构成员则会封装在他们自己的实例中,变更结构成员值并不会对其他任何结构变量的成员造成影响,甚至也不会影响相同结构声明的其他实例。20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。 如何选择结构还是类:1.堆栈的空间有限,对于大量的逻辑的对象,创建类要比创建结构好一些2.结构表示如点、矩形和颜色这样的轻量对象,例如,如果声明一个含有 1000 个点对象的数组,则将为引用每个对象分配附加的内存。在此情况下,结构的成本较低。3.在表现抽象和多级别的对象层次时,类是最好的选择。4.大多数情况下该类型只是一些数据时,结构时最佳的选择。 值类型和引用类型值类型 其他类型、结构体；存储位置：栈空间–系统分配,自动回收,小而快特点：在赋值时,把内容拷贝给对方,它变我不变,内存地址不变。 引用类型 string、数组、类存储位置：手动申请和释放,大而慢特点：在赋值时,让俩者指向一个值,它变我也变,指向堆中相同内存地址。 特殊引用类型string string在赋值时也会再分配一个内存空间。 函数 函数可以写在类中和结构体中。 函数基础基本语法：static 返回类型 函数名(参数类型 参数名1….){ 代码逻辑；return 返回值 } ref和out 在函数内部传入,里面变了,外面也变了。声明：函数参数的修饰符；区别：ref传入的参数必须初始化,out传入的变量必须在内部赋值； 变长参数和参数默认值变长参数声明：params 变量类型[] 变量名；参数默认值：可选参数,在方法声明时就进行赋值,可选参数必须写在普通参数后面； 函数重载定义：重载和返回值无关,和参数类型、个数、顺序有关； 递归函数定义：就是让函数自己调用自己,但是需要留出出口,否则就是死循环","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#入门","slug":"02001-C#入门","date":"2019-06-18T13:00:00.000Z","updated":"2022-01-24T15:04:28.242Z","comments":true,"path":"posts/1025.html","link":"","permalink":"http://wwy010518.github.io/posts/1025.html","excerpt":"","text":"将之前的笔记记录在博客上 C#基础知识主流语言的应用领域C: 嵌入式硬件开发C++: 游戏客户端、服务器、软件C#: 游戏客户端、服务器、软件、网站 Java: 安卓、服务器、软件、网站JavaScript: H5游戏、网站、服务器PHP: 网站、服务器Python: 网站、服务器、辅助开发 SQL: 数据库Go: 服务器Objective-C: 苹果(mac、ios)相关Swift: 苹果(mac、ios)相关 开发环境搭建IDE是什么IDE(Integrated Development Environment )集成开发环境它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代码命令，听从你的指令和你进行交流。 常用的IDE(集成开发环境)软件Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;Android Studio: 谷歌推出，主要用于开发安卓应用;Xcode:苹果推出，主要用于开发苹果应用; 第一个应用程序理解写代码这件事通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算机通过这些命令来执行一些行为，从而实现一些特定的需求。比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能够动起来 注释的三种方式1.两杠注释:用于注释一行信息2.星号注释:用于注释多行信息3.三杠注释:用于注释类、命名空间等 快捷注释的方法1.上方工具栏2.快捷键CTRL + K + C 注释CTRL + K + U 取消注释 折叠代码由#region #endregion配对出现 控制台输入打印语句Console.Write():输出 Console.WriteLine:换行输出 Console.ReadKey:检测用户按下 Console.ReadLine:用户输入回车 变量变量类型有符号的整形变量sbyte: -128-127(字节占1);short: -32768-32767(字节占2);int: -21亿-21亿多(字节占4);long: -9百万兆-9百万兆(字节占8); 无符号的整数变量byte:0-255(字节占1);ushort: 0-65535(字节占2);uint: 0-42亿多(字节占4);ulong: 0-18百万兆(字节占8); 浮点型float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;double:(字节占8) 存储15-17位有效数字;decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; 特殊类型bool:非真即假(字节占1);char:存储单个字符(字节占2);string:存储多个字符，没有上限(长度可变); 变量的本质 数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000通过sizeof获取变量占用的内存空间(例如:sizeof(int);;1byte=8bit;1kb=1024byte;1mb=1024kb;1gb=1024mb;1tb=1024gb; 进制转换(整数，左侧第一位表示符号)十进制转二进制:不停除2;二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0); 命名规则1.不能重名;2.不能以数字开头;3.不能是关键字;4.不能有特殊符号(下划线除外); 驼峰命名法(变量)、帕斯卡命名法(函数、类) 常量关键字const，必须初始化，不能被修改。 转义字符 是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行 固定写法常用的转义字符':单引号;\":双引号\\n:换行\\:斜杠 不常用的转义字符\\t:制表符(空一个tab键)\\b:光标退格\\0:空字符\\a:警告音 取消转义字符 在字符串前面加一个@(例如@”\\你好\") 类型转换 不同变量类型之间的相互转换 隐式转换 不同类型之间的自动转换，大范围转小范围 相同大类型之间的转换 特殊类型不存在隐式转换 不同大类型之间的转换无符号和有符号之间 有符号的变量不能隐式转换无符号的; 无符号的变量隐式转换有符号的前提是范围一定是涵盖的; 浮点数和整数之间 浮点数可以转任何类型整数; 整数不能转换浮点型(不能存小数); 特殊类型和其他类型 char类型可以隐式转换成整数和浮点型(ASCII码); bool和string不能和其他类型互相转换; 显示转换 手动转换。 括号强转 小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。 Parse法 把字符串类型转换成对应类型，前提能转换，否则报错。语法:变量类型.Parse(“字符串”) Convert法 更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。语法:Convert.To目标类型(变量或者常量) 其他类型转string作用:拼接打印;语法:变量.ToString(); 异常捕获 避免程序报错造成卡死 try{ }catch{ }finally{ } 运算符算数运算符赋值运算符:=算数运算符:+ - * / %复合运算符:+= -+ *= /= %=自增运算符:a++(先用再加) ++a(先加再用) 运算符的优先级1.乘除大于加减;2.括号优先; 字符串拼接方法一:+号拼接;方法二:string.Format(“{0}”，18);控制台打印拼接:支持类似方法二; 条件运算符 只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。条件运算符:&gt; &lt; == != &gt;= &lt;=; 逻辑运算符逻辑运算符:&amp;&amp; || ! 运算符优先级 ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。 位运算符位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)位或:|(有1则1)异或:^(对位运算，相同为0，不同为1)位取反:~(0变1，1变0，反码补码问题)左右移:&lt;&lt;(左移几位，右边加几个0) &gt;&gt;(右移几位，右边去几个数) 三目运算符语法:空位(bool类型)？空位:空位; 条件分支语句if语句if(){ }else if(){ }else{ } switch语句switch(){ case 变量: break; default: break; } 循环语句while循环while(循环跳出条件){ } do-while循环do{ }while(); for循环for(int i=1;i&lt;条件;i++){ } foreach循环foreach(var i in 集合需要继承自一个接口){ } 知识补充控制台相关1.Console.Readkey().Keycahr-可以保存输入的字符;2.Console.Clear()-清空控制台;3.Console.SetWindowSize(宽，高);4.Console.SetBufferSize(宽，高)-缓冲区大小;5.Console.SetCursorPosition(x，y)-设置光标的位置6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear8.Console.CursorVisiable=false-设置光标显隐9.Environment.Exit(0)-关闭控制台 随机数语法:Random 变量名=new Random();生成非负数:变量名.Next(最小到最大，范围不包括最大);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]}],"categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"},{"name":"Game-Play","slug":"Game-Play","permalink":"http://wwy010518.github.io/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"http://wwy010518.github.io/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"其他","slug":"其他","permalink":"http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"UnityEditor","slug":"游戏引擎/Unity/UnityEditor","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"},{"name":"数据结构和算法","slug":"CS基础/数据结构和算法","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"换装","slug":"换装","permalink":"http://wwy010518.github.io/tags/%E6%8D%A2%E8%A3%85/"},{"name":"Animancer","slug":"Animancer","permalink":"http://wwy010518.github.io/tags/Animancer/"},{"name":"Playable","slug":"Playable","permalink":"http://wwy010518.github.io/tags/Playable/"},{"name":"ET","slug":"ET","permalink":"http://wwy010518.github.io/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Lua","slug":"Lua","permalink":"http://wwy010518.github.io/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://wwy010518.github.io/tags/AssetBundle/"},{"name":"Markdown","slug":"Markdown","permalink":"http://wwy010518.github.io/tags/Markdown/"},{"name":"UnityEditor","slug":"UnityEditor","permalink":"http://wwy010518.github.io/tags/UnityEditor/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"MVC","slug":"MVC","permalink":"http://wwy010518.github.io/tags/MVC/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]}