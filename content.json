{"meta":{"title":"雪夜の自我救赎","subtitle":"雪夜の博客","description":"天再高又怎么样，踮起脚尖就能更接近太阳","author":"雪夜","url":"https://wwy.wwywy.com","root":"/"},"pages":[{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://wwy.wwywy.com/archives/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-01-22T04:07:31.290Z","comments":false,"path":"about/index.html","permalink":"https://wwy.wwywy.com/about/index.html","excerpt":"","text":"憨憨“ 不要惧怕别人的偏见、认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：憨憨的个人空间 QQ：3179342661 座右铭：保持初心，漫步远方"},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://wwy.wwywy.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://wwy.wwywy.com/comments/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://wwy.wwywy.com/link/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2022-07-10T15:21:23.167Z","comments":true,"path":"music/index.html","permalink":"https://wwy.wwywy.com/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://wwy.wwywy.com/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-01-22T03:16:54.165Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"https://wwy.wwywy.com/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://wwy.wwywy.com/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"https://wwy.wwywy.com/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"https://wwy.wwywy.com/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://wwy.wwywy.com/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"Luban工具详解","slug":"04200-Luban工具详解","date":"2022-07-15T06:00:58.185Z","updated":"2022-07-15T15:18:10.112Z","comments":true,"path":"posts/2176.html","link":"","permalink":"https://wwy.wwywy.com/posts/2176.html","excerpt":"","text":"待写","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"工具链","slug":"Game-Play/技术架构/工具链","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E5%B7%A5%E5%85%B7%E9%93%BE/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Json","slug":"Json","permalink":"https://wwy.wwywy.com/tags/Json/"},{"name":"Excel","slug":"Excel","permalink":"https://wwy.wwywy.com/tags/Excel/"},{"name":"Xml","slug":"Xml","permalink":"https://wwy.wwywy.com/tags/Xml/"},{"name":"Luban","slug":"Luban","permalink":"https://wwy.wwywy.com/tags/Luban/"}]},{"title":"ILRuntiome热更新技术","slug":"04151-ILRuntiome热更新技术","date":"2022-07-09T13:00:00.000Z","updated":"2022-07-11T03:11:54.621Z","comments":true,"path":"posts/2153.html","link":"","permalink":"https://wwy.wwywy.com/posts/2153.html","excerpt":"","text":"ILRuntime介绍 ILRuntime项目为基于C#的平台（例如Unity）提供了一个纯C#实现，快速、方便且可靠的IL运行时，使得能够在不支持JIT的硬件环境（如iOS）能够实现代码的热更新。 ILRuntime的优势 同市面上的其他热更方案相比，ILRuntime主要有以下优点： 无缝访问C#工程的现成代码，无需额外抽象脚本API 直接使用VS2015进行开发，ILRuntime的解译引擎支持.Net 4.6编译的DLL 执行效率是L#的10-20倍 选择性的CLR绑定使跨域调用更快速，绑定后跨域调用的性能能达到slua的2倍左右（从脚本调用GameObject之类的接口） 支持跨域继承 完整的泛型支持 拥有Visual Studio的调试插件，可以实现真机源码级调试。支持Visual Studio 2015 Update3 以及Visual Studio 2017和Visual Studio 2019 最新的2.0版引入的寄存器模式将数学运算性能进行了大幅优化 C# vs Lua 目前市面上主流的热更方案，主要分为Lua的实现和用C#的实现，两种实现方式各有各的优缺点； Lua：Lua是一个已经非常成熟的解决方案，但是对于Unity项目而言，也有非常明显的缺点。就是如果使用Lua来进行逻辑开发，就势必要求团队当中的人员需要同时对Lua和C#都特别熟悉，或者将团队中的人员分成C#小组和Lua小组。不管哪一种方案，对于中小型团队都是非常痛苦的一件事情； 用C#来作为热更语言最大的优势就是项目可以用同一个语言来进行开发，对Unity项目而言，这种方式肯定是开发效率最高的，最新2.0版本的ILRuntime，加入了寄存器模式，在10多项测试用例当中的性能，均已超过lua53版xlua； 性能对比注意事项 如果需要测试ILRuntime对比Lua的性能Benchmark，需要确认以下几点，ILRuntime设计上为了在开发时提供更多的调试支持。在Unity Editor中运行会有很多额外的性能开销，因此在Unity Editor中直接测试并不能代表ILRuntime的实际运行性能。 ILRuntime加载的dll文件是Release模式编译的 dll中对外部API的调用都进行了CLR绑定 确保没有勾选Development Build的情况下发布成正式真机运行包，而不是在Editor中直接运行 可以直接使用Demo工程中提供的性能测试进行对比 调试插件 ILRuntime提供了一个支持Visual Studio 2015、Visual Studio 2017和Visual Studio 2019的调试插件，用来源码级调试你的热更脚本，你可以在这里下载到最新的Visual Studio调试插件。 使用方法如下： 安装ILRuntime调试插件，并重新启动VS2015或VS2017、VS2019 确保dll和pdb都加载完毕。 运行Unity工程，并保证执行过appdomain.DebugService.StartDebugService（56000）;来启动调试服务器 用VisualStudio打开热更DLL项目 点击菜单中的Debug-&gt;Attach to ILRuntime按钮。注意，不是“附加Unity调试程序” 在弹出来的窗口中填入被调试的主机的IP地址以及调试服务器的端口 点击Attach按钮后，即可像UnityVS一样下断点调试 ILRuntime环境搭建导入ILRuntime ILRuntime1.6版新增了Package Manager发布，使用Unity2018以上版本可以直接通过Package Manager安装，如果你使用的是Unity，或者无法在PackageManager中找到ILRuntime，则需要按照以下步骤设置项目； 首先需要在项目的Packages/manifest.json中，添加ILRuntime的源信息，在这个文件的dependencies节点前增加以下代码\"scopedRegistries\": [ { \"name\": \"ILRuntime\", \"url\": \"https://registry.npmjs.org\", \"scopes\": [ \"com.ourpalm\" ] } ], 然后通过Unity的菜单，打开Package Manager，将上部标签页选项选择为All Packages，Advanced里勾上Show Preview Packages，等待Unity加载完包信息，应该就能在左侧列表中找到ILRuntime，点击安装即可Window-&gt;Package Manager； 部分Unity版本可以无法直接在列表中刷出ILRuntime，如果左边列表找不着，那就在项目的manifest.json中的dependencies段的开头，增加如下代码手动将ILRuntime添加进项目；\"com.ourpalm.ilruntime\": \"1.6.0\", 示例导入工程后有可能因为没开启unsafe导致编译报错，可以在PlayerSettings中勾选Allow unsafe code解决编译问题； 创建HotFix项目 首先创建一个C#类库工程，接下来，我们将开始配置这个热更工程，以便我们在里面可以编写业务代码； 在Unity项目创建一个DLL文件夹，将UnityEngine和UnityEngine.CoreModule放进去，使用文本编辑器打开HotFix.csproj这个文件，配置如下内容，注意路径可能本人不一致，或者你也可以直接在VS中添加依赖项； &lt;ItemGroup&gt; &lt;Reference Include=\"Assembly-CSharp\"&gt; //Unity项目编译后的程序集，路径如下 &lt;HintPath&gt;..\\..\\..\\..\\Library\\ScriptAssemblies\\Assembly-CSharp.dll&lt;/HintPath&gt; &lt;Private&gt;false&lt;/Private&gt; &lt;/Reference&gt; &lt;Reference Include=\"UnityEngine\"&gt; &lt;HintPath&gt;..\\..\\..\\..\\DLL\\UnityEngine.dll&lt;/HintPath&gt; &lt;Private&gt;false&lt;/Private&gt; &lt;/Reference&gt; &lt;Reference Include=\"UnityEngine.CoreModule\"&gt; &lt;HintPath&gt;..\\..\\..\\..\\DLL\\UnityEngine.CoreModule.dll&lt;/HintPath&gt; &lt;Private&gt;false&lt;/Private&gt; &lt;/Reference&gt; &lt;/ItemGroup&gt; 接下来我们就可以在热更工程编写代码了，我们在HotFix工程中新增一个c#文件，名字叫AppMain.cs 如图所示； using System; using UnityEngine; namespace HotFix { public class AppMain { public static void Start() { Debug.Log(\"AppMain::Start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); } } } 接下来我们要配置一下这个热更工程的dll输入路径，右键项目属性，在生成事件后填入如下内容，解释一下，就是把路径Assets\\GAssets\\CSProject~\\HotFix\\bin\\Debug\\netstandard2.1\\下生成的HotFix.dll和HotFix.pdb拷贝到Assets\\StreamingAssets\\路径下，并且给文件加上.txt后缀名 ； Copy \"$(TargetDir)HotFix.dll\" \"$(TargetDir)..\\..\\..\\..\\..\\..\\StreamingAssets\\HotFix.dll.txt\" Copy \"$(TargetDir)HotFix.pdb\" \"$(TargetDir)..\\..\\..\\..\\..\\..\\StreamingAssets\\HotFix.pdb.txt\" Unity中调用热更部分已经配置好了，接下来，我们要在主工程启动ILRuntime的运行时环境，并且加载热更代码，运行起来，具体步骤如下，新建一个c#文件Startup.cs 里面的内容如下，然后运行即可，就可以看到控制台输出了AppMain::Start&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;； using System.Collections; using System.Collections.Generic; using System.IO; using UnityEngine; using UnityEngine.Networking; public class Startup : MonoBehaviour { private ILRuntime.Runtime.Enviorment.AppDomain appdomain; void Start() { StartCoroutine(LoadILRuntime()); } IEnumerator LoadILRuntime() { appdomain = new ILRuntime.Runtime.Enviorment.AppDomain(); UnityWebRequest webRequest = UnityWebRequest.Get(StreamingAssetsPath(\"HotFix.dll.txt\")); yield return webRequest.SendWebRequest(); if (webRequest.result != UnityWebRequest.Result.Success) { yield break; } byte[] dll = webRequest.downloadHandler.data; webRequest.Dispose(); webRequest = UnityWebRequest.Get(StreamingAssetsPath(\"HotFix.pdb.txt\")); yield return webRequest.SendWebRequest(); if (webRequest.result != UnityWebRequest.Result.Success) { yield break; } byte[] pdb = webRequest.downloadHandler.data; webRequest.Dispose(); appdomain.LoadAssembly(new MemoryStream(dll), new MemoryStream(pdb), new ILRuntime.Mono.Cecil.Pdb.PdbReaderProvider()); OnILRuntimeInitialized(); } void OnILRuntimeInitialized() { appdomain.Invoke(\"HotFix.AppMain\", \"Start\", null, null); } public string StreamingAssetsPath(string fileName) { string path = Application.streamingAssetsPath + \"/\" + fileName; return path; } } 热更代码中编写Mono脚本 我们在常规的unity代码编写流程，是实现一个monobehaviour脚本，挂载在一个GameObject对象上，通过实现Awake，Start，Update，OnDestroy 这样一些函数驱动游戏逻辑的执行，在ILRuntime中，我们在热更工程中编写的代码本质上是脚本，也就是文本字符串，在Unity主工程看来，并没有什么monobehaviour脚本被创建出来，但我们依然希望在热更工程中像常规的Unity项目一样，使用monobehaviour脚本的模式编写代码，那怎么实现呢？ 实现方法步骤： 在主工程中，实现一个真正的monobehaviour脚本命名为MonoProxy，作为代理，以后无论热更工程的任何GameObject想要挂载脚本，都挂载这个固定的MonoProxy类； 热更工程将一个自定义的热更脚本和这个MonoProxy类绑定，这样Unity在运行时通过驱动MonoProxy类，然后这个MonoProxy类将驱动行为转移到这个热更脚本上，从而驱动这个热更脚本的运行； 为了规范热更热更脚本的编写严谨性，在热更工程中，定义一个热更脚本的基类MonoBase，所有需要挂载在GameObject上的热更脚本(当然这个并不是真正的挂载，真正挂载的是代理类MonoProxy)都必须继承这个MonoBase类； 具体代码如下 在主工程中实现的MonoProxy代理类 using ILRuntime.CLR.TypeSystem; using System.Collections; using System.Collections.Generic; using System.Reflection; using UnityEngine; /// &lt;summary&gt; /// 在GameObject上挂载的真正的脚本对象MonoProxy /// 运行时，会把逻辑执行转交给绑定的对应热更脚本对象ScriptObject /// &lt;/summary&gt; public class MonoProxy : MonoBehaviour { /// &lt;summary&gt; /// 当前这个MonoProxy对象映射的热更脚本的类型字符串 /// &lt;/summary&gt; public string ScriptName; /// &lt;summary&gt; /// 映射的热更脚本的类型的对象 /// &lt;/summary&gt; public object ScriptObject; /// &lt;summary&gt; /// 将本MonoProxy对象和一个热更脚本绑定在一起 /// &lt;/summary&gt; /// &lt;param name=\"scriptName\"&gt;&lt;/param&gt; public void Bind(string scriptName) { ScriptName = \"HotFix.\" + scriptName; ScriptObject = Startup.appdomain.Instantiate(ScriptName); IType scriptIType = Startup.appdomain.LoadedTypes[ScriptName]; FieldInfo goField = scriptIType.ReflectionType.GetField(\"gameObject\"); goField.SetValue(ScriptObject, gameObject); //为什么不实现Awke函数，而在这里申明，因为该函数是在AddComponent后就立马调用的，Mono脚本可能在HotFix中添加，而这时参数并未传递进来，会出问题 Startup.appdomain.Invoke(ScriptName, \"Awake\", ScriptObject, null); } void Start() { Startup.appdomain.Invoke(ScriptName, \"Start\", ScriptObject, null); } void Update() { Startup.appdomain.Invoke(ScriptName, \"Update\", ScriptObject, null); } private void OnDestroy() { Startup.appdomain.Invoke(ScriptName, \"OnDestroy\", ScriptObject, null); } } 热更工程中的MonoBase类（即所有需要挂载的热更脚本的基类） using System; using System.Collections.Generic; using System.Text; using UnityEngine; namespace HotFix { public class MonoBase { public GameObject gameObject; public virtual void Awake() { } public virtual void Start() { } public virtual void Update() { } public virtual void OnDestroy() { } } } 创建一个HelloComponent脚本集成自MonoBase进行实验： using System; using System.Collections.Generic; using System.Text; using UnityEngine; namespace HotFix { public class HelloComponent : MonoBase { public override void Awake() { Debug.Log(gameObject.name + \" HelloComponent::Awake\"); } public override void Start() { Debug.Log(gameObject.name + \" HelloComponent::Start\"); } public override void Update() { Debug.Log(gameObject.name + \" HelloComponent::Update \" + Time.deltaTime); } public override void OnDestroy() { Debug.Log(gameObject.name + \" HelloComponent::OnDestroy \"); } } } 演示下使用，在热更工程中创建一个GameObject，命名为Hello，并且挂载一个脚本HelloComponent，编译运行后就能看到效果了： using System; using UnityEngine; namespace HotFix { public class AppMain { public static void Start() { GameObject go = new GameObject(\"HelloGo\"); MonoProxy monoProxy = go.AddComponent&lt;MonoProxy&gt;(); monoProxy.Bind(\"HelloComponent\"); } } } ILRuntime（适配器）//调用协程来举例子 gameObject.GetComponent&lt;MonoProxy&gt;().StartCoroutine(Coroutine()); //定义的协程函数 public System.Collections.IEnumerator Coroutine(){} 对于这行代码，StartCoroutine确实需要一个真正的协程对象，而这里Coroutine()返回的却是一个ILTypeInstance对象，因为在热更代码中，我们这些创建的类型对象大多数在Unity主工程看来都是ILTypeInstance对象，并没有什么真正意义的协程对象被创建出来！！ 所以ILRuntime运行到这行代码时，发现需要的类型（协程对象）和传入的实际类型（ILTypeInstance对象）不一致时，ILRuntime运行时会试图查找是否有相应的CrossBindingAdaptor类型可以把传入的当前类型对象转换成需要的类型对象，如果有，就用当前类型对象作为输入创建一个需要的类型对象，并且调用这个新的类新对象！！ 以上就是ILRuntime所谓的跨域继承，其实并没有什么继承，本来就是两个类型，用户需要自己实现这个转换过程，实现方法就是自定义一个CrossBindingAdaptor的派生类，并且注册到ILRuntime运行时中去，以下实习一个协程适配器的写法； using ILRuntime.CLR.Method; using ILRuntime.Runtime.Enviorment; using ILRuntime.Runtime.Intepreter; using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class CoroutineAdapter : CrossBindingAdaptor { public override Type BaseCLRType { get { return null; } } public override Type[] BaseCLRTypes { get { //跨域继承只能有1个Adapter，因此应该尽量避免一个类同时实现多个外部接口，对于coroutine来说是IEnumerator&lt;object&gt;,IEnumerator和IDisposable， //ILRuntime虽然支持，但是一定要小心这种用法，使用不当很容易造成不可预期的问题 //日常开发如果需要实现多个DLL外部接口，请在Unity这边先做一个基类实现那些个接口，然后继承那个基类 return new Type[] { typeof(IEnumerator&lt;object&gt;), typeof(IEnumerator), typeof(IDisposable) }; } } public override Type AdaptorType { get { return typeof(Adaptor); } } public override object CreateCLRInstance(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance) { return new Adaptor(appdomain, instance); } /// &lt;summary&gt; /// Coroutine生成的类实现了IEnumerator&lt;System.Object&gt;, IEnumerator, IDisposable 所以都要实现 /// 这个可以通过reflector之类的IL反编译软件得知 /// &lt;/summary&gt; internal class Adaptor : IEnumerator&lt;System.Object&gt;, IEnumerator, IDisposable, CrossBindingAdaptorType { ILTypeInstance instance; ILRuntime.Runtime.Enviorment.AppDomain appdomain; public Adaptor() { } public Adaptor(ILRuntime.Runtime.Enviorment.AppDomain appdomain, ILTypeInstance instance) { this.appdomain = appdomain; this.instance = instance; } public ILTypeInstance ILInstance { get { return instance; } } IMethod mCurrentMethod; bool mCurrentMethodGot; public object Current { get { if (!mCurrentMethodGot) { mCurrentMethod = instance.Type.GetMethod(\"get_Current\", 0); if (mCurrentMethod == null) { //这里写System.Collections.IEnumerator.get_Current而不是直接get_Current是因为coroutine生成的类是显式实现这个接口的，通过Reflector等反编译软件可得知 //为了兼容其他只实现了单一Current属性的，所以上面先直接取了get_Current mCurrentMethod = instance.Type.GetMethod(\"System.Collections.IEnumerator.get_Current\", 0); } mCurrentMethodGot = true; } if (mCurrentMethod != null) { object res = appdomain.Invoke(mCurrentMethod, instance, null); return res; } else { return null; } } } IMethod mDisposeMethod; bool mDisposeMethodGot; public void Dispose() { if (!mDisposeMethodGot) { mDisposeMethod = instance.Type.GetMethod(\"Dispose\", 0); if (mDisposeMethod == null) { mDisposeMethod = instance.Type.GetMethod(\"System.IDisposable.Dispose\", 0); } mDisposeMethodGot = true; } if (mDisposeMethod != null) { appdomain.Invoke(mDisposeMethod, instance, null); } } IMethod mMoveNextMethod; bool mMoveNextMethodGot; public bool MoveNext() { if (!mMoveNextMethodGot) { mMoveNextMethod = instance.Type.GetMethod(\"MoveNext\", 0); mMoveNextMethodGot = true; } if (mMoveNextMethod != null) { return (bool)appdomain.Invoke(mMoveNextMethod, instance, null); } else { return false; } } IMethod mResetMethod; bool mResetMethodGot; public void Reset() { if (!mResetMethodGot) { mResetMethod = instance.Type.GetMethod(\"Reset\", 0); mResetMethodGot = true; } if (mResetMethod != null) { appdomain.Invoke(mResetMethod, instance, null); } } public override string ToString() { IMethod m = appdomain.ObjectType.GetMethod(\"ToString\", 0); m = instance.Type.GetVirtualMethod(m); if (m == null || m is ILMethod) { return instance.ToString(); } else return instance.Type.FullName; } } } //同时需要注册适配器","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"热更新","slug":"Game-Play/技术架构/热更新","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"热更新","slug":"热更新","permalink":"https://wwy.wwywy.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"ILRuntimes","slug":"ILRuntimes","permalink":"https://wwy.wwywy.com/tags/ILRuntimes/"}]},{"title":"YooAsset资源加载","slug":"03041-YooAsset资源加载","date":"2022-06-25T13:00:00.000Z","updated":"2022-07-11T08:49:19.555Z","comments":true,"path":"posts/1569.html","link":"","permalink":"https://wwy.wwywy.com/posts/1569.html","excerpt":"","text":"YooAsset介绍 YooAsset是一套用于Unity3D的资源管理系统，用于帮助研发团队快速部署和交付游戏，它可以满足商业化游戏的各类需求，并且经历多款百万DAU游戏产品的验证。 安全高效的分包方案 基于资源标签的分包方案，自动对依赖资源包进行分类，避免人工维护成本。可以非常方便的实现零资源安装包，或者全量资源安装包。 强大灵活的打包系统 可以自定义打包策略，自动分析依赖实现资源零冗余，基于资源对象的资源包依赖管理方案，天然的避免了资源包之间循环依赖的问题。 基于引用计数方案 基于引用计数的管理方案，可以帮助我们实现安全的资源卸载策略，更好的对内存管理，避免资源对象冗余。还有强大的分析器可帮助发现潜在的资源泄漏问题。 多种模式自由切换 编辑器模拟模式，单机运行模式，联机运行模式。在编辑器模拟模式下，可以不构建资源包来模拟真实环境，在不修改任何代码的情况下，可以自由切换到其它模式。 强大安全的加载系统 异步加载 支持协程，Task，委托等多种异步加载方式。 同步加载 支持同步加载和异步加载混合使用。 边玩边下载 在加载资源对象的时候，如果资源对象依赖的资源包在本地不存在，会自动从服务器下载到本地，然后再加载资源对象。 多线程下载 支持断点续传，自动验证下载文件，自动修复损坏文件。 多功能下载器 可以按照资源分类标签创建下载器，也可以按照资源对象创建下载器。可以设置同时下载文件数的限制，设置下载失败重试次数，设置下载超时判定时间。多个下载器同时下载不用担心文件重复下载问题，下载器还提供了下载进度以及下载失败等常用接口。 原生格式文件管理 无缝衔接资源打包系统，可以很方便的实现原生文件的版本管理和下载。 可寻址资源定位 默认支持相对路径的资源定位，也支持可寻址资源定位，不需要繁琐的过程即可高效的配置寻址路径。 灵活多变的版本管理 支持线上版本快速回退，支持区分审核版本，测试版本，线上版本，支持灰度更新及测试。 YooAsset快速安装 通过PackageManager安装 打开管理界面 Edit/Project Settings/Package Manager // 输入以下内容 Name: package.openupm.cn URL: https://package.openupm.cn Scope(s): com.tuyoogame.yooasset 打开管理界面 Edit/Windows/Package Manager安装即可 通过Packages清单安装 直接修改Packages文件夹下的清单文件manifest.json { \"dependencies\": { \"com.tuyoogame.yooasset\": \"0.0.1-preview\", ...... }, \"scopedRegistries\": [ { \"name\": \"package.openupm.cn\", \"url\": \"https://package.openupm.cn\", \"scopes\": [ \"com.tuyoogame.yooasset\" ] } ] } 通过Github下载安装 在发布的Release版本中，选择最新版本下载源代码压缩包。 系统需求 支持版本： Unity2019.4+ 支持平台： Windows、OSX、Android、iOS 开发环境: .NET4.x 目录结构Assets └─ YooAsset ├─ Editor 编辑器源码目录 ├─ Runtime 运行时源码目录 ├─ LICENSE 版权文档 └─ README 说明文档 全局配置 通过右键创建配置文件（Project窗体内右键 -&gt; Create -&gt; YooAsset -&gt; Create Setting） 注意：请将配置文件放在Resources文件夹下 配置说明： Asset Bundle File Variant : AssetBundle资源包后缀名 Raw File Variant : 原生资源包后缀名 Patch Manifest File Name : 补丁清单文件名称 Unity Manifest File Name : Unity构建的清单名称 资源收集左侧为分组列表，右侧为该分组的配置界面。 导出按钮可以将配置数据导出为XML文件，导入按钮可以导入保存的XML文件。 注意：该工具仅支持Unity2019+ 公共设置 Enable Addressable：启用可寻址资源定位系统。 Auto Collect Shaders：自动收集所有依赖的材质球使用的着色器，并将这些着色器打进一个资源包里。 Shader Bundle Name：收集的着色器资源包名称。 资源分组 Active Rule：激活规则，规则可以自定义扩展。下面是内置规则： EnableGroup：启用分组。 DisableGroup：禁用分组。 //自定义扩展范例 public class DisableGroup : IActiveRule { public bool IsActiveGroup() { return false; } } Grouper Name：分组名称 Grouper Desc：分组备注信息 Asset Tags：资源分类标签列表，该分组下收集的资源会全部被打上该标签。（注意：多个标签用分号隔开，例如 level1;level2;level3） 资源搜集器 Collect Path：收集路径，可以指定文件夹或单个资源文件。 Collector Type：收集器类型： MainAssetCollector：收集参与打包的主资源对象，并写入到资源清单的资源列表里（可以通过代码加载）。 StaticAssetCollector：收集参与打包的主资源对象，但不写入到资源清单的资源列表里（无法通过代码加载）。 DependAssetCollector：收集参与打包的依赖资源对象，但不写入到资源清单的资源列表里（无法通过代码加载）。 AddressRule 可寻址规则，规则可以自定义扩展。下面是内置规则： AddressByFileName 以文件名为定位地址。 AddressByGrouperAndFileName 以分组名称+文件名为定位地址。 AddressByCollectorAndFileName 以收集器名+文件名为定位地址。 //自定义扩展范例 public class AddressByFileName : IAddressRule { string IAddressRule.GetAssetAddress(AddressRuleData data) { return Path.GetFileNameWithoutExtension(data.AssetPath); } } PackRule 打包规则，规则可以自定义扩展。下面是内置规则： PackSeparately 以文件路径作为资源包名，每个资源文件单独打包。 PackDirectory 以父类文件夹路径作为资源包名，文件夹下所有文件打进一个资源包。 PackTopDirectory 以收集器路径下顶级文件夹为资源包名，文件夹下所有文件打进一个资源包。 PackCollector 以收集器路径作为资源包名，收集的所有文件打进一个资源包。 PackGrouper 以分组名称作为资源包名，收集的所有文件打进一个资源包。 PackRawFile 目录下的资源文件会被处理为原生资源包。 //自定义扩展范例 public class PackDirectory : IPackRule { string IPackRule.GetBundleName(PackRuleData data) { return Path.GetDirectoryName(data.AssetPath); //\"Assets/Config/test.txt\" --&gt; \"Assets/Config\" } } FilterRule 过滤规则，规则可以自定义扩展。下面是内置规则： CollectAll 收集目录下的所有资源文件 CollectScene 只收集目录下的场景文件 CollectPrefab 只收集目录下的预制体文件 CollectSprite 只收集目录下的精灵类型的文件 //自定义扩展范例 public class CollectScene : IFilterRule { public bool IsCollectAsset(FilterRuleData data) { return Path.GetExtension(data.AssetPath) == \".unity\"; } } AssetTags 资源分类标签列表，该收集器下收集的资源会全部被打上该标签。 资源构建界面介绍 Build Output：构建输出的目录，会根据Unity编辑器当前切换的平台自动划分构建结果。 Build Version：构建版本号，也是资源版本号，版本号必须大于零。 Build Mode：构建模式 (1) 强制构建模式：会删除指定构建平台下的所有构建记录，重新构建所有资源包。 (2) 增量构建模式：以上一次构建结果为基础，对于发生变化的资源进行增量构建。 (3) 演练构建模式：在不生成AssetBundle文件的前提下，进行演练构建并快速生成构建报告和补丁清单。 (4) 模拟构建模式：在编辑器下配合EditorSimulateMode运行模式，来模拟真实运行的环境。 Encryption 加密类列表。 Compression 资源包的压缩方式。 Append Extension 构建的资源包文件名是否包含后缀格式。 Buildin Tags 标记为安装包里的资源标签列表。构建成功后，会将相关标记的资源包拷贝到StreamingAssets文件夹下。 构建 点击构建按钮会开始构建流程，构建流程分为多个节点顺序执行，如果某个节点发生错误，会导致构建失败。错误信息可以在控制台查看。 资源包加密编写继承IEncryptionServices接口的加密类。注意：加密类文件需要放置在Editor文件夹里。 using System; using YooAsset.Editor; public class GameEncryption : IEncryptionServices { /// &lt;summary&gt; /// 检测资源包是否需要加密 /// &lt;/summary&gt; bool IEncryptionServices.Check(string bundleName) { // 对配置表相关的资源包进行加密 return bundleName.Contains(\"assets/config/\"); } /// &lt;summary&gt; /// 对数据进行加密，并返回加密后的数据 /// &lt;/summary&gt; byte[] IEncryptionServices.Encrypt(byte[] fileData) { int offset = 32; var temper = new byte[fileData.Length + offset]; Buffer.BlockCopy(fileData, 0, temper, offset, fileData.Length); return temper; } } 补丁包构建成功后会在输出目录下找到补丁包文件夹，该文件夹名称为本次构建时指定的资源版本号。 补丁包文件夹里包含补丁清单文件，资源包文件，构建报告文件等。 资源包文件都是以文件的哈希值命名。 补丁清单补丁清单是一个Json格式的文本文件，里面包含了所有资源包的信息，例如：名称，大小，CRC等。 Jenkins支持如果需要自动化构建，可以参考如下代码范例： private static void BuildInternal(BuildTarget buildTarget) { Debug.Log($\"开始构建 : {buildTarget}\"); // 命令行参数 int buildVersion = GetBuildVersion(); // 构建参数 string defaultOutputRoot = AssetBundleBuilderHelper.GetDefaultOutputRoot(); AssetBundleBuilder.BuildParameters buildParameters = new AssetBundleBuilder.BuildParameters(); buildParameters.OutputRoot = defaultOutputRoot; buildParameters.BuildTarget = buildTarget; buildParameters.BuildMode = EBuildMode.ForceRebuild; buildParameters.BuildVersion = buildVersion; buildParameters.BuildinTags = \"buildin\"; buildParameters.VerifyBuildingResult = true; buildParameters.EnableAddressable = false; buildParameters.AppendFileExtension = false; buildParameters.CopyBuildinTagFiles = true; buildParameters.EncryptionServices = new GameEncryption(); buildParameters.CompressOption = ECompressOption.LZ4; // 执行构建 AssetBundleBuilder builder = new AssetBundleBuilder(); builder.Run(buildParameters); } // 从构建命令里获取参数 private static int GetBuildVersion() { foreach (string arg in System.Environment.GetCommandLineArgs()) { if (arg.StartsWith(\"buildVersion\")) return int.Parse(arg.Split(\"=\"[0])[1]); } return -1; } 资源部署在资源补丁包构建成功之后，需要将补丁包传输到CDN服务器上。 如果是本地测试，可以在本地创建一个WEB服务器，然后将补丁包拷贝到WEB服务器下。 按照游戏版本目录部署 在业务开发过程中，每个游戏版本实际都会创建一个SVN分支，该分支工程内每次构建的补丁包上传到对应的CDN目录下即可。 CDN └─android ├─v1.0 ├─v1.1 └─v2.0 └─iphone ├─v1.0 ├─v1.1 └─v2.0 构建报告报告工具，可以查看概览信息（Summary），资源对象列表信息（AssetView），资源包列表信息（BundleView）。 注意：该工具仅支持Unity2019+ 概览视图：打包时的参数信息。 资源对象列表视图：可以查看资源对象列表以及每个资源对象所依赖的资源包。 资源包列表视图：可以查看资源包列表以及每个资源包所包含的资源对象。 调试器调试器是在游戏运行时，帮助我们查看资源包加载信息的工具，通过该工具可以发现潜在的资源泄漏。 可以查看资源对象列表信息（AssetView），资源包列表信息（BundleView）。 真机远程调试注意事项在构建安装包的时候，需要勾选上Development Build和Autoconnect Profiler 初始化资源系统的运行模式支持三种：编辑器模拟模式，单机运行模式，联机运行模式。 // 资源系统初始化方法，根据不同的模式，我们传递不同的创建参数类 YooAssets.InitializeAsync(InitializeParameters parameters); 编辑器模拟模式 在编辑器下，不需要构建资源包，来模拟运行游戏。 注意：该模式只在编辑器下起效 private IEnumerator InitializeYooAsset() { var initParameters = new YooAssets.EditorSimulateModeParameters(); initParameters.LocationServices = new DefaultLocationServices(\"Assets/GameRes\"); yield return YooAssets.InitializeAsync(initParameters); } 单机运行模式 对于不需要热更新资源的游戏，可以使用单机运行模式。 注意：该模式需要构建资源包 private IEnumerator InitializeYooAsset() { var initParameters = new YooAssets.OfflinePlayModeParameters(); initParameters.LocationServices = new DefaultLocationServices(\"Assets/GameRes\"); yield return YooAssets.InitializeAsync(initParameters); } 联机运行模式 对于需要热更新资源的游戏，可以使用联机运行模式，该模式下初始化参数会很多。 注意：该模式需要构建资源包 LocationServices : 资源定位的实例类。 (1) 默认的资源定位服务类（DefaultLocationServices） (2) 可寻址的资源定位服务类（AddressLocationServices） (3) 开发者自定义的资源定位服务类，需要提供实现ILocationServices接口的实例类。 DecryptionServices : 如果资源包在构建的时候有加密，需要提供实现IDecryptionServices接口的实例类。 ClearCacheWhenDirty : 安装包在覆盖安装的时候，是否清空沙盒缓存文件夹。 DefaultHostServer : 默认的资源服务器IP地址。 FallbackHostServer : 备用的资源服务器IP地址。 VerifyLevel : 下载文件校验等级 private IEnumerator InitializeYooAsset() { var initParameters = new YooAssets.HostPlayModeParameters(); initParameters.LocationServices = new DefaultLocationServices(\"Assets/GameRes\"); initParameters.DecryptionServices = null; initParameters.ClearCacheWhenDirty = false; initParameters.DefaultHostServer = \"http://127.0.0.1/CDN1/Android\"; initParameters.FallbackHostServer = \"http://127.0.0.1/CDN2/Android\"; initParameters.VerifyLevel = EVerifyLevel.High; yield return YooAssets.InitializeAsync(initParameters); } 资源文件解密 public class BundleDecryption : IDecryptionServices { public ulong GetFileOffset() { return 32; } } 资源更新获取资源版本 对于联机运行模式，在更新补丁清单之前，需要获取一个资源版本号。 该资源版本号，可以通过YooAssets提供的接口来更新，也可以通过HTTP访问游戏服务器来获取。 private IEnumerator UpdateStaticVersion() { UpdateStaticVersionOperation operation = YooAssets.UpdateStaticVersionAsync(); yield return operation; if (operation.Status == EOperationStatus.Succeed) { //更新成功 int resourceVersion = operation.ResourceVersion; Debug.Log($\"Update resource Version : {resourceVersion}\"); } else { //更新失败 Debug.LogError(operation.Error); } } 更新补丁清单 对于联机运行模式，在获取到资源版本号之后，就可以更新资源清单了。 private IEnumerator UpdatePatchManifest() { UpdateManifestOperation operation = YooAssets.UpdateManifestAsync(resourceVersion); yield return operation; if (operation.Status == EOperationStatus.Succeed) { //更新成功 } else { //更新失败 Debug.LogError(operation.Error); } } 补丁包下载 在补丁清单更新完毕后，就可以更新资源文件了。 根据产品需求，可以选择更新全部资源，或者只更新部分资源。 补丁包下载接口： YooAssets.CreatePatchDownloader(int downloadingMaxNumber, int failedTryAgain) 用于下载更新当前资源版本所有的资源包文件。 YooAssets.CreatePatchDownloader(string[] tags, int downloadingMaxNumber, int failedTryAgain) 用于下载更新资源标签指定的资源包文件。 YooAssets.CreateBundleDownloader(string[] locations, int downloadingMaxNumber, int failedTryAgain) 用于下载更新指定的资源列表依赖的资源包文件。 IEnumerator Download() { int downloadingMaxNum = 10; int failedTryAgain = 3; DownloaderOperation downloader = YooAssets.CreatePatchDownloader(downloadingMaxNum, failedTryAgain); //没有需要下载的资源 if (downloader.TotalDownloadCount == 0) { yield break; } //需要下载的文件总数和总大小 int totalDownloadCount = downloader.TotalDownloadCount; long totalDownloadBytes = downloader.TotalDownloadBytes; //注册回调方法 downloader.OnDownloadErrorCallback = OnDownloadErrorFunction; downloader.OnDownloadProgressCallback = OnDownloadProgressUpdateFunction; downloader.OnDownloadOverCallback = OnDownloadOverFunction; downloader.OnStartDownloadFileCallback = OnStartDownloadFileFunction; //开启下载 downloader.BeginDownload(); yield return downloader; //检测下载结果 if (downloader.Status == EOperationStatus.Succeed) { //下载成功 } else { //下载失败 } } 弱联网更新解决方案 对于偏单机但是也有资源热更需求的项目。当玩家本地网络不稳定或无网络的时候，我们又不希望玩家卡在资源更新步骤而不能正常游戏。所以当玩家本地网络有问题的时候，我们可以跳过资源更新的步骤。 private IEnumerator UpdateStaticVersion() { UpdateStaticVersionOperation operation = YooAssets.UpdateStaticVersionAsync(10); yield return operation; if (operation.Status == EOperationStatus.Succeed) { // 如果获取远端资源版本成功，说明当前网络连接并无问题，可以走正常更新流程。 ...... // 注意：在成功下载所有资源之后，我们需要记录当前最新的资源版本号 PlayerPrefs.SetInt(\"STATIC_VERSION\", resourceVersion); } else { // 如果获取远端资源版本失败，我们走弱联网更新模式。 // 注意：如果从来没有保存过版本信息，则需要从内部读取StaticVersion.bytes文件的版本信息。 int staticVersion = PlayerPrefs.GetInt(\"STATIC_VERSION\", -1); if (staticVersion == -1) { staticVersion = LoadStaticVersionFromStreamingAssets(); PlayerPrefs.SetInt(\"STATIC_VERSION\", staticVersion); } // 在弱联网情况下更新补丁清单 UpdateManifestOperation operation2 = YooAssets.WeaklyUpdateManifestAsync(staticVersion); yield return operation2; if (operation2.Status == EOperationStatus.Succeed) { StartGame(); } else { // 指定版本的资源内容本地并不完整，需要提示玩家更新。 ShowMessageBox(\"请检查本地网络，有新的游戏内容需要更新！\"); } } } 资源加载加载方法 YooAssets.LoadAssetSync() 同步加载资源对象 YooAssets.LoadAssetAsync() 异步加载资源对象 YooAssets.LoadSubAssetsSync() 同步加载子资源对象 YooAssets.LoadSubAssetsAsync() 异步加载子资源对象 YooAssets.LoadSceneAsync() 异步加载场景 YooAssets.GetRawFileAsync() 异步获取原生文件 统一约定 Location为资源的定位地址，也是加载资源对象的唯一标识符。 DefaultLocationServices 默认资源定位服务，location代表的是资源对象的相对路径。 // 以工程内的音频文件为例：\"Assets/GameRes/Audio/bgMusic.mp3\" // 设定资源路径的根目录为：\"Assets/GameRes\"，后续加载的资源定位地址填写相对路径：\"Audio/bgMusic\" var createParameters = new YooAssets.EditorSimulateModeParameters(); createParameters.LocationServices = new DefaultLocationServices(\"Assets/GameRes\"); yield return YooAssets.InitializeAsync(createParameters); ...... YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic\"); AddressLocationServices 可寻址资源定位服务，location代表的是资源对象可寻址地址。 // 以工程内的音频文件为例：\"Assets/GameRes/Audio/bgMusic.mp3\" // 需要在资源配置界面启用可寻址功能（Enable Addressable）。 // 配置界面的可寻址规则为AddressByFileName，那么资源定位地址填写文件名称：\"bgMusic\" var createParameters = new YooAssets.EditorSimulateModeParameters(); createParameters.LocationServices = new AddressLocationServices(); yield return YooAssets.InitializeAsync(createParameters); ...... YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"bgMusic\"); 注意：以下范例执行环境是在DefaultLocationServices下。 加载路径的匹配方式 // 不带扩展名的模糊匹配 YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic\"); // 带扩展名的精准匹配 YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic.mp3\"); 异步加载范例 // 委托加载方式 void Start() { AssetOperationHandle handle = YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic.mp3\"); handle.Completed += Handle_Completed; } void Handle_Completed(AssetOperationHandle handle) { AudioClip audioClip = handle.AssetObject as AudioClip; } // 协程加载方式 IEnumerator Start() { AssetOperationHandle handle = YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic.mp3\"); yield return handle; AudioClip audioClip = handle.AssetObject as AudioClip; } // Task加载方式 async void Start() { AssetOperationHandle handle = YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic.mp3\"); await handle.Task; AudioClip audioClip = handle.AssetObject as AudioClip; } 资源卸载范例 IEnumerator Start() { AssetOperationHandle handle = YooAssets.LoadAssetAsync&lt;AudioClip&gt;(\"Audio/bgMusic.mp3\"); yield return handle; ... handle.Release(); } 资源释放范例 可以在切换场景之后调用资源释放方法或者写定时器间隔时间去释放。 注意：只有调用资源释放方法，资源对象才会在内存里被移除。 private void UnloadAssets() { YooAssets.UnloadUnusedAssets(); } 预制体加载范例 IEnumerator Start() { AssetOperationHandle handle = YooAssets.LoadAssetAsync&lt;GameObject&gt;(\"Panel/login.prefab\"); yield return handle; GameObject go = handle.InstantiateSync(); Debug.Log($\"Prefab name is {go.name}\"); } 子对象加载范例 例如：通过TexturePacker创建的图集，如果需要访问图集的精灵对象，可以通过子对象加载接口。 IEnumerator Start() { SubAssetsOperationHandle handle = YooAssets.LoadSubAssetsAsync&lt;Sprite&gt;(location); yield return handle; var sprite = handle.GetSubAssetObject&lt;Sprite&gt;(\"spriteName\"); Debug.Log($\"Sprite name is {sprite.name}\"); } 场景异步加载范例 注意：当加载新的主场景的时候，会自动释放之前加载的主场景以及附加场景。 IEnumerator Start() { var sceneMode = UnityEngine.SceneManagement.LoadSceneMode.Single; bool activateOnLoad = true; SceneOperationHandle handle = YooAssets.LoadSceneAsync(\"Scene/Login\", sceneMode, activateOnLoad); yield return handle; Debug.Log($\"Scene name is {handle.Scene.name}\"); } 原生文件加载范例 例如：wwise的初始化文件 IEnumerator Start() { string location = \"wwise/init.bnk\"; string copyPath = $\"{Application.persistentDataPath}/Audio/init.bnk\"; RawFileOperation operation = YooAssets.GetRawFileAsync(location, copyPath); yield return operation; byte[] fileData = operation.GetFileData(); string fileText = operation.GetFileText(); } 获取资源信息列表 通过资源标签来获取资源信息列表。 private GetAssetInfosByTag(string tag) { AssetInfo[] assetInfos = YooAssets.GetAssetInfos(tag); foreach (var assetInfo in assetInfos) { Debug.Log(assetInfo.AssetPath); } } FairyGUI支持解决方案 注意：在FairyGUI的面板销毁的时候，将资源句柄列表释放，否则会造成资源泄漏。 // 资源句柄列表 private List&lt;AssetOperationHandle&gt; _handles = new List&lt;AssetOperationHandle&gt;(100); // 加载方法 private object LoadFunc(string name, string extension, System.Type type, out DestroyMethod method) { method = DestroyMethod.None; //注意：这里一定要设置为None string location = $\"FairyRes/{name}{extension}\"; var handle = YooAssets.LoadAssetSync(location , type); _handles.Add(handle); return handle.AssetObject; } // 执行FairyGUI的添加包函数 UIPackage.AddPackage(name, LoadFunc); // 释放资源句柄列表 private void ReleaseHandles() { foreach(var handle in _handles) { handle.Release(); } _handles.Clear(); } UniTask支持解决方案 解决方案","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://wwy.wwywy.com/tags/AssetBundle/"},{"name":"热更新","slug":"热更新","permalink":"https://wwy.wwywy.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"YooAsset","slug":"YooAsset","permalink":"https://wwy.wwywy.com/tags/YooAsset/"},{"name":"资源加载","slug":"资源加载","permalink":"https://wwy.wwywy.com/tags/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"}]},{"title":"情商的修炼之道","slug":"00501-情商的修炼之道","date":"2022-05-22T13:00:00.000Z","updated":"2022-07-10T02:59:55.546Z","comments":true,"path":"posts/321.html","link":"","permalink":"https://wwy.wwywy.com/posts/321.html","excerpt":"","text":"（人生往往是经历无数后悔才能实现的自我救赎，而高情商可以让你少走很多弯路） 何为情商情商的本质 情商的本质就是情绪，体现在以下几点； 论点一：情商高的表现之一就是让别人开心，跟你在一起很舒适，有情感上的共鸣； 论点二：同时，高情商在让别人开心的同时，也让自己开心，而那种靠牺牲自己，为难自己去让去别人感到舒适的，这并不是高情商； 结论：总之，真正的高情商是在自己和别人的情绪之间找到一个和谐点，彼此都特别愉快的实现共赢； 情商的层级 情商也是有层次的，请慢慢尝试从这几步去提升自己的情商 认识自己的情绪； 管理自己的情绪； 认知他人的情绪； 影响他人的情绪； 认识自己的情绪接受自己的情绪： 原因：一味的压抑自己的情绪并不是高情商的表现，当你被别人骂了，自己不开心时，却总安慰自己说没事，去学习、工作的时候就是很开心，隐藏自己的笑容却内心苦苦的，那只是憋屈和强忍； 结论：所以，我们得先学会人有这种情绪，才是解决这个情绪的开始，而接受、了解自己的情绪的情绪就得先从下面三点入手； 给情绪上标签 原因：情绪并没有我们眼里的那么简单，也许大部分人仍然认为情绪就是喜悦、愤怒和悲伤，但是这只是表面上直观的情绪；我们实际感受到的情绪，往往是通过别人的”外在表现”或者自己想要表达的”感受”而体现出的情绪，这些情绪其实是有着很明显的特征的，是有标签的； 例如：生活中就有一些这样的情绪在悄无声息的影响着我们的行为和判断力，你肯定遇到过这样的场景，”啊！！！我不明白我为什么当时会那样子，我好后悔，我明明不是这样想的，但我却说出那样的话”，这种情况就是你不理解的情绪悄无声息的影响了你的判断能力，让你的大脑过热； 结论：所以，认识自己情绪的第一步，就是给情绪贴上标签，要明确情绪之间的界限感，对情绪进行区分，而不是永远都只是感觉很糟糕，我们要能感知更多的情绪； 情绪分级 结论：除了要对情绪进行分类，了解自己处于哪一种情绪外，还要对情绪进行分级； 例如：比如把愤怒分为1~5级，明白自己当前情绪是哪一种程度级别； 自我反省 例如：每天晚上躺在床上反思自己的所作所为，为什么要那样做，是因为生气了吗，没有生气那么为什么要这么做，生气了那么生气程度是否太过火了， 结论：不断的反思自己，这样才会更加”熟悉”自己的情绪，特别注意的是，这是一个长远的、需要坚持的过程； 管理自己的情绪慢/静下来 原因：人本来就是动物，天生的生理习惯就是有情绪就立刻表达出来，但是这种表达方式往往都是野蛮和不理智的，遇到不如意的事情就会动手打人、辱骂，这些都是马上表达的结果； 结论：有激烈情绪时，慢下来或者干脆什么都不做，给大脑一个处理时间； 与自己对话 结论：情绪激烈时注意提醒自己，我现在的情绪如何，我正在做什么，我现在的情绪如何，养成习惯，你就会慢慢的越来越理智； 学习更好的情绪 例如：看书、刷剧、与人交流； 结论：学习更好的情绪表达方式，做生活的观察者、学习者； 认知他人的情绪理解对方的表达 前提：能听得懂别人说的什么话、表达的什么意思，对语文水平还是有一定要求的； 例如：你去邀约别人，而别人说我比较忙，过几天去，但是你过了几天竟然还去邀约别人，其实这只是一种委婉的拒绝方式； 结论：能了解别人表达的情绪； 提升共情能力 反例：你的朋友考试得了大鸭蛋，他难受极了，找你来倾诉，但是你却哈哈哈乐了； 正例：多去和亲近的人分享自己的生活和感受，慢慢的就在数据交换之中逐渐熟悉非我的思维模式，也就是说多去了解别人是咋想的，多进行换位思考，慢慢的就会让别人喜欢上你； 结论：核心是换位思考，能体会到别人的感受，有情感上的共鸣； 学会观察语言外的语言 结论：刻意或者不经意表露出来的行为或动作，比如身体语言； 例如： 俩手交叉：他可能对这事情并不是很关心； 眼神飘忽不定不集中：可能心里装着别的事情； 交谈后匆匆离开：说明这次交流对他并不是很重要； 下意识撅嘴：表示对你所说并不满意； 影响别人的情绪（不要做一些伤天害理的事情^_^） 让自己能接近别人 例如：你身边那些人缘好活跃的人，往往之后会给你深刻的印象，它们就会影响到你的情绪，可能很多话你现在还历历在目，而内心封闭的人往往不能影响别人的情绪，他们很大的原因就是缺乏鼓励，缺乏正反馈，时间长了就不敢主动和陌生人对话，所以要做一个擅长社交的人，容易被别人接纳的人； 结论：接近别人，做个积极交际的人，不要自我封闭； 更加完美的表达自己的想法 例如：内容复杂时先说结论、在一个观点后分条理陈列理由、把最重要的情况说在前面、描述抽象事物时恰当的运用比喻； 方法：经常写作，记录想法，不断完善、修改； 结论：把自己的想法完美的表达出来； 操控别人情绪（请用于正道） 前提：做到前面内容，并熟练运用； 结论：抓住别人的心理诉求，然后……；","categories":[{"name":"其他","slug":"其他","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"为人处世","slug":"其他/为人处世","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/%E4%B8%BA%E4%BA%BA%E5%A4%84%E4%B8%96/"}],"tags":[{"name":"情商","slug":"情商","permalink":"https://wwy.wwywy.com/tags/%E6%83%85%E5%95%86/"}]},{"title":"编译原理","slug":"01010-编译原理","date":"2022-03-03T13:00:00.000Z","updated":"2022-07-10T02:53:54.572Z","comments":true,"path":"posts/520.html","link":"","permalink":"https://wwy.wwywy.com/posts/520.html","excerpt":"","text":"引论什么是编译原理1.计算机编译语言的层次： 机器语言：可以直接被计算机直接理解； 汇编语言：引入助记符，但是还是难以被直接理解，由汇编语言到机器语言是通过汇编的形式； 高级语言：能直接理解的，由高级语言到汇编语言或者机器语言是通过编译的形式； 编译程序补充说明1.编译程序的功能：是把高级语言翻译成等价的目标程序，编译程序把”源语言”翻译成二进制文件的”目标语言”的过程，目标程序可以独立源程序运行（注意编译和运行是分俩个阶段的）； 2.编译器的系统位置以及语言处理流程：源程序=&gt;经过预处理源程序=&gt;汇编语言程序=&gt;可重定位机器码=&gt;目标机器代码； 预处理器：把存储在不同文件中的源程序聚合在一起，把被成为宏的缩写语句转换为原始语句； 编译器：如上； 汇编器：进行可重定位，可重定位指的是在内存中存放的起始位置L不是固定的，而起始位置+相对地址=绝对地址； 链接器/加载器：其中加载器修改可重定位地址，将修改后的指令和数据放到内存中适当位置，而链接器将多个可重定位的机器代码文件连接到一起以及解决外部内存地址问题； 编译系统的结构1.编译过程的划分：分俩批次 第一批次：分析/前端部分，与源语言相关； 词法分析：分析各个短语的词性； 语法分析：划分句子，也就是句子的中的短语； 语义分析：就是分析源语言的语义，分析各个短语在句子中占什么成分，语义分析的结果一般直接用中间代码表示，所以这俩个可以一起实现，同时语法分析时分许句子时同时结合语义分析，所以该三个阶段可以一起实现，这个技术被称为语法制导翻译； 第二批次：综合/后端部分，与目标语言相关，中间代码生成其实也属于前端部分； 中间代码生成； 代码优化：代码优化一般中间代码和目标机器代码都需要优化； 目标代码生成； 解释程序1.解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析上基本同编译过程一致，但是运行用户程序时，它是直接执行源程序或者说源程序的内部形式（中间代码），解释程序不会生成目标代码； 编译程序和解释程序的区别1.区别： 相同点： 都有相同的词法、语法、语义分析过程； 不同点： 编译程序运行速度会更快，编译程序是生成目标代码后再运行的，而解释程序是一边翻译一边执行； 编译程序安全性更高，因为编译程序生成的目标代码是二进制形式的； 编译程序不参与用户程序运行控制，而解释程序参与； 解释程序不需要同机器码打交道，实现起来比较简单，且便于在不同平台上移植； 前端部分简单介绍1.词法分析主要任务：从左到由逐行扫描程序的字符，识别出各个单词，确定单词的类型，将识别出的单词转换成统一的机内表示——语法单元(token)形式，token&lt;种别码，属性值&gt;，第一分量表示种别码，第二个表示值； 单词类型 种别 种别码 关键字/保留字 if,else,then 一词一码 标识符 变量名、数组名、记录名 多词一码 常量 整形、浮点型、字符型、布尔型 一型一码 运算符 算数、关系、逻辑· 一词移码或者一型一码 界限符 ; () = {} … 一词一码 2.语法分析简单介绍：语法分析器从词法分析器输出的token序列种识别出各类短语，并构造语法分析树； 3.语义分析的主要任务： 第一个任务：收集标识符的如下主要属性信息，存储在符号表中： 种属（Kind） 类型（Type） 存储位置和长度 值和作用域 参数和返回值信息 第二个任务：语义检查； 变量或者过程未经申明就使用； 变量或者过程名重复声明； 运算分量类型不匹配； 操作符和操作数之间的类型不匹配； 中间代码生成及编译器后端文法和语言文法的概述1.文法的定义：文法是语言的抽象规则（例如我们的语言都是遵守主谓宾这个文法）； 2.文法的描述： 语法规则构成说明：通过建立一组规则，来描述句子的语法结构，例如： &lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt; &lt;谓语&gt;::=&lt;动词&gt;&lt;直接宾语&gt;…….. 规则推导：有了一组规则，可以按照一定的方式来推导产生句子（方法从一个要识别的符号开始推导，即用相应规则的右部去替代规则的左部） &lt;句子&gt; =&gt; &lt;主语&gt;&lt;谓语&gt; &lt;主语&gt;&lt;谓语&gt; =&gt; &lt;代词&gt;&lt;谓语&gt; 符号和符号串1.字母表：字母表是元素的非空有穷集合，字母表中的元素被称为符号，字母表的运算有乘积、n次幂、正闭包、克林闭包； 2.符号串：由字母表中符号组成的任意又穷序列称为符号串（例如011101是字母表{0,1}上的字符串）； 空串：是长度为0的串，用ε表示； 连接运算：将俩个串进行相连； 幂运算：串的0次幂等于ε，否则S^n = S^n-1*S； 文法的定义1.文法G=（Vn,Vt,P,Z） Vn：非终结符，是用来表示句子成分的符号，有时也称为“语法变量”； Vt：终结符，是文法所定义的语言的基本符号，有时也称为token； P：产生式或规则的集合，描述了将终结符和非终结符组成串的方法，产生式的一般形式：α→β，α称为产生出式的头或者左部，β称为产生式的体或者右部； Z：开始符合 （Z∈Vn），表示文法中的最大语法成分； 例如：文法G=（Vn,Vt,P,S）,Vn={S}，Vt={0,1}，P={S=&gt;0S1,S=&gt;01}，S为开始符号； 2.符号约定： 终结符：a、b、c； 非终结符：A、B、C； 文法符号：X、Y、Z； 终结符号串：u、v……z； 文法符号串：α、β； 语言的定义1.推导：用产生式的右部替换产生式的左部，是一个自顶向下的过程； 2.规约：用产生式的左部替换产生式的右部，是一个自底向上的过程，规约是推导的逆过程； 3.句子和句型：句子是推导出后只包含终结符得就是句子，否则是句型； 文法的分类1..最左推导和最右推导：没搞懂； 3.文法的等价：若L(G1)=L(G2)，则称文法G1和G2是等价的，既然说文法是等价的，所以文法可以是多重的，不同的文法实现同样的功能； 1.文法的类型：低级文法包含高级文法，高级文法一定是低级文法 0型文法（短语文法）：对于产生式α→β的结构中，α至少含有一个非终结符； 1型文法（上下文有关）：对于产生式式α→β，都有|β|&gt;=|α|，仅仅S→ε除外； 2型文法（上下文无关）：对于产生式α→β，α只能是非终结符，产生式型的形式可变形为A→β； 3型文法（正规文法）： 左线性文法：A→wβ | A→w 右线性文法： A→βw | A→w CFG的分析树1.二义性文法： 定义：如果一个文法可以为某个句子生成多颗分析树，则称这个文法时二义性的； 判定：大多数时候我们都希望文法不是歧义性的，可以给出一组充分条件，满足这组充分条件的文法是无二义性的； 正则表达式1.运算类型： *：克林闭包； 连接； |：或运算； 递归文法例如（定义变量）：变量名 x,y,z;,可以推理得：S=&gt;aAb，而A=&gt;B|BcA; 例如（加减乘除）：E=&gt;E+T|T;T=&gt;T*F|F;F=&gt;(E)|a； 词法分析有穷自动机的分类（FA）1.有穷自动机（FA）：是一个五元组 M： 有穷状态集； 输入字母表； 转换函数； 开始状态； 接受状态|终止状态； 2.区别：不确定的有穷自动机（NFA）和确定的有穷自动机（DFA）区别在于转换函数可以有多个能到达的状态集合； 从正则表达式到有穷自动机[![正则表达式到又穷自动机](https://s1.ax1x.com/2022/06/09/XyQ3Of.md.png)](https://imgtu.com/i/XyQ3Of) 由NFA到DFA的转换1.将NFA的状态组成一个新的状态，如以下r=aa*bb*cc的表示[![由NFA到DFA](https://s1.ax1x.com/2022/06/09/XyQsmT.md.png)](https://imgtu.com/i/XyQsmT) 2.子集构造法实例：[![带有ε的NFA到DFA](https://s1.ax1x.com/2022/06/09/XyQbAe.md.png)](https://imgtu.com/i/XyQbAe) 自顶向下语法分析方法（重点）自顶向下分析概述1. 自顶向上优先分析LR分析语法制导的语义计算静态语义分析和中间代码生成运行时存储组织代码优化和目标代码生成1.代码优化： 常数合并：编译时将常数运算进行合并； 常数传播： 代数化简：消掉没有必要的代数，例如x+0 = x； 削弱运算强度：将高复杂度度运算替换为低复杂度运算； 补录tracert -d 查看网络路节点 1.编译器的定义2.考PL/0语言3.考LL(1)4.几天的课：运行时存储器组织、优化和目标代码生成，拍照的东西5.上次课：抽象语法树和利波兰式6.今天的课：运行时存储器组织、优化和目标代码生成，拍照的东西7.分析设计题，老师最后讲 复习文法和语言1.文法： 文法是语言的形式化的描述工具； 文法是一个四元组； 文法是等价的，可以进行改造，文法分类成0、1、2、3型文法； 推导完成的叫句子，中间的过程叫句型，逆推导的过程叫归约； 同一个文法在推导过程中语法树是否具有二义性，是否进行改造； 2. A卷考试重点 写无聊语言的杀，啥也不写的杀，下个学期的补考也杀，带*号的题目不全； 选择题-（40）1.期中考试题（GCC）2.以及目标代码生成、代码优化 解答题（30）1.何为编译器，编译器的组成部分，编译器的各组成部分作用； a、编译器是将高级语言翻译成等价的目标语言的程序； b、编译器由词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成组成： c、如下： 词法分析：主要将字符从左至右读入源程序，对构成源程序的字符进行扫描和分解； 语法分析：在词法分析的基础上将单词序列分解为各类语法短语，这中语法短语也称为语法单位，可表示为语法树； 语义分析：审查源程序有无语义错误，为代码生成阶段收集类型信息； 中间代码生成：在进行语法分析和语义分析后，有的编译程序变成一种内部表现形式，这种表现形似就是中间代码； 代码优化：对中间代码进行变化或者改造，目的是使生成的目标代码更高效； 目标代码生成：将中间代码变换为特定机器上的绝对指令或者重定位的指令代码或者某种汇编指令代码； 2.何为PL/0语言，试用PL/0语言描述xx算法； a、如下： PL/0语言是Pascal的一个子集； PL/0语言编译系统由PL/0编译程序和P-code解释程序组成； 3.如何判断一个文法是LL(1)的，若有文法xx，试将其改造成LL(1)文法； a、如下： 文法不含左递归； 产生式的候选首符集俩俩不相交； 4.请结合C语言说明函数参数传递的方式和不同； a、如下： 按值传递：将实参的值拷贝给形参、有内存分配和释放、不改变外部的值； 地址传递：将形参是指针变量，指针的值拷贝形参指针的值，有内存分配和释放、改变外部值； 引用传递：形参是实参的引用，无内存分配，改变外部值； 5.给出表达式的抽象语法树和利波兰式； 6.请简述代码生成时的指令调度；代码生成，寄存器 分析设计题（30）给出文法：S→A，A→BA，A→c，B→aB，B→b1.构造活前缀DFA2.构造LR(0)分析表，Action表和Goto表；3.给出输入串，写出分析过程（状态栈） 例题： B卷考试重点解答题（70）1.何为编译器，解释编译器的组成，解释各个编译器的作用；2.linux系统在C语言的编译过程；3.何为FA、NFA、DFA，以及将DFA转换成DFA；4.何为文法，举例说明文法的分类；5.LR(0)的分析表6.请把利波兰式复原成为算数表达式，并且将抽象语法树画出来；7.请生成下列语句的目标代码(x=x+1)； 分析设计题（30）1.请参考c语言的变量定义语句，根据要求写出文法2.计算非终结符3.根据文法写出语法分析程序","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"编译原理","slug":"大学知识/CS基础/编译原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"Unity相关-.Net说明以及mono跨平台原理","slug":"03101-Unity相关-跨平台原理","date":"2022-02-18T13:00:00.000Z","updated":"2022-07-11T03:17:07.426Z","comments":true,"path":"posts/1601.html","link":"","permalink":"https://wwy.wwywy.com/posts/1601.html","excerpt":"","text":"了解.Net相关知识微软.Net概述1.微软.Net说明：微软的.Net即不是编程语言也不是框架，是类似于互联网时代、次世代、21世纪的宣传口号，是一整套技术体系的统称，或者说是微软提供的技术水平的代号，本质上是微软为自己一系列取的一个代号，以下是包含内容； 框架体系：.Net Framework、.Net Core、Mono等等； 开发语言：C#、VB、F#等等（C#是.Net平台主推的开发语言）； 开发工具：Visual Studio、Visual Studio Code 等等； 2.微软实现.Net平台的目的： 跨语言：只要是面向.NET平台的编程语言(C#、VB、C++、F#等等)，用其中一种语言编写的内容可以无缝地用在另一种语言编写的应用程序中； 跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的操作系统上，即代码不依赖于操作系统，也不依赖硬件环境； .Net跨语言1.跨语言公共语言规范：微软为了实现跨平台，制定了一些规范，只要一门语言支持这个规则，就能在.Net平台下开发应用程序，以下是规则说明； CLS（公共语言规范）：.Net专门参考每种语言找出语言间的共性，是一组语言互操作的标准规范； CTS（公共类型系统）：当你设计面向.Net语言时需要遵守的一个体系，而刚才提到的CLS公共语言规范就是是CTS公共类型系统的子级，一个编程语言，如果它能够支持CTS，那么我们就称它为面向.NET平台的语言； CLI（公共语言基础结构）：是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准； .Net虚拟机(CLR)1.CLR（公共语言运行时）说明：让应用程序在操作系统上运行，公共语言运行时，它是.Net Framework的基础，所有的.Net技术都是建立在此之上的，它是一个在执行时管理代码的代码，提供内存管理，线程管理等等核心服务，就好像一个小型的操作系统一样，所以形象的把它称为“.Net虚拟机”，Java的虚拟机也是类似这样的东西，如果想要应用程序在目标操作系统上能够运行，就必须依靠.Net提供的CLR环境来支持，它会把程序集中的IL（中间代码）翻译成机器码最终在操作系统上运行； 2.CLR做的事情： .Net跨平台.Net Framework .Net Framework：.Net Framework 在2002年推出1.0版本，.NET Framework 是一个可以快速开发、部署网站服务及应用程序的开发框架，是 Windows 中的一个组件，部分开源，主要用于开发Windows下应用程序，包括公共语言运行时（Common Language Runtime, CLR），虚拟执行系统，.NET Framework 类库等，下面时详细说明； 只要支持CLS公共语言规范的语言都可以用于开发Windows下的各种应用程序和网站程序； BCL（基础类库）和FCL（框架类库）：是这个框架体系中为我们实现好的各种API； 程序集：程序集的表现就是后缀为.dll或者.exe格式的文件，其中包含的最关键信息， PE头、CLR头（就是一些程序的格式信息，比如入口方法，版本号等等） CIL代码（通用中间代码）：是介于源代码和机器码之间的代码之后会通过CLR产生机器码，CIL代码你可以理解为由于可能使用不同的代码进行开发，所以会将这些代码翻译为统一规范的中间代码； .Net Core .Net Core：.Net Core 是2016年推出的.Net Framework的新一代版本，是.Net Framework的翻版实现，它是一个开源项目，它是基于.Net Framework来进行设计的主要目的就是跨平台，是.Net技术框架组成在Windows、MacOS、类Linux系统下的具体实现，它的原理就是为不同的操作系统实现对应的CLR公共语言运行时（.Net虚拟机），这样就可以在不同的平台上，将IL（中间代码）翻译成机器码最终在操作系统上运行了； Mono1.Mono：2004年由Xamarin公司（已被微软收购）所赞助的开源项目，它基于.Net的CLI（Common Language Infrastructure）公共语言基础结构，它相对.Net FrameWork最大的区别就是具备跨平台的能力，它不仅可以运行在Windows、MacOS、Linux等操作系统，甚至还可以运行在PS3、XBOX、Wii等主机平台上，也就是说在.Net Core出现之前，Mono是.Net平台实现跨平台的不二之选； Unity跨平台原理(Mono)1.Unity的组成：Unity的底层是通过C/C++来完成上层逻辑的，Unity主要包括两个部分： Unity Engine（引擎）：提供UnityEngine.dll动态库，各平台不同，C/C++编写，包含平台相关代码、图形API、物理引擎、灯光等等所有游戏引擎底层内容； Unity Editor（编辑器）：提供UnityEditor.dll动态库，大部分由C#编写，用户脚本最初可以使用C#、JavaScript、Boo语言编写，项目代码最后由Mono编译； 2.Mono组成： C#编译器（mcs）； Mono Runtime 类似CLR公共语言运行时（虚拟机），包括JIT（Just in time）即时编译器、AOT（Ahead of time）提前编译器、GC、类库加载器 等； BCL基础类库； Mono类库：提供很多超出.Net的一些额外功能，主要用于构建各种操作系统上的应用； 3.Unity跨平台的基本原理（Mono）：在Unity下使用各种语言进行逻辑实现，这些语言在发布时会被编译成，IL中间代码，最终这些中间代码在对应操作系统上，通过Mono VM（虚拟机），真正翻译成机器码运行起来； 4.Mono的特点： 构建（最终打包时）速度快 Mono编译机制是JIT即时编译，所以支持更多类库 必须将代码发布为托管程序集（.dll文件） Mono VM虚拟机平台维护麻烦，且部分平台不支持（WebGL） 由于Mono版本授权原因，C#很多新特性无法使用 IOS支持Mono，但不在允许32位的Mono应用提交到应用商店 5.基于Mono跨平台的优缺点： 优点：只要在不同操作系统上实现Mono VM（虚拟机），那我们能够支持的平台就会“无限”多； 缺点：维护工作耗时耗力，当Unity版本更新时，Mono VM也需要维护和更新，那多对于N多个平台来说，工作量是非常大的。（Unity的工作量），低版本Mono无法支持新版本C#的强大新特性； Unity跨平台原理(IL2CPP)1.IL2CPP说明：L2CPP是在Unity4.6.1 p5之后的版本中，加入的脚本后处理方式，是继Mono之后的一种跨平台解决方案，顾名思义就是把，IL中间代码转译为CPP代码（C++），再利用各平台优化过的编译器编译为对应平台的目标代码，需要注意的是虽然中间代码变为了C++，但是内存管理还是遵循C#中GC的方式，这也是为什么有一个IL2CPP VM（虚拟机）存在的原因，它主要是用来完成GC管理，线程创建等服务工作的； 2.IL2CPP特点： 相对Mono构建（最终打包时）速度慢； 只支持AOT提前编译； 可以启用引擎代码剥离来减少代码的大小； 程序的运行效率比Mono高，运行速度快； 多平台移植更加方便； 3.Mono和IL2CPP的区别： IL2CPP效率高于Mono，跨平台也更好维护，不使用热更新后者大量反射的化推荐使用IL2CPP； Mono是JIT（半解释半编译程序或者说纯解释程序）即时编译，IL2CPP是AOT（预编译程序）提前编译，导致IL2CPP不能在运行时动态生成代码和类型，所以必须在编译时就完全确定需要用到的类型，举例：List和List中A和B是我们自定义的类，我能必须在代码中显示的调用过，IL2CPP才能保留List和List两个类型。如果在热更新时我们调用List，但是它之前并没有在代码中显示调用过，那么这时就会出现报错等问题。主要就是因为JIT和AOT两个编译模式的不同造成的； IL2CPP模式存在的问题1.安装Unity IL2CPP打包工具：在Unityhub中下载 IL2CPP打包相关工具； IL2CPP打包泛型问题1.问题说明：IL2CPP和Mono最大的区别是，不能在运行时动态生成代码和类型，就是说 泛型相关的内容，如果你在打包生成前没有把之后想要使用的泛型类型显示使用一次，那么之后如果使用没有被编译的类型，就会出现找不到类型的报错； 2.解决方案：其实就是在预言编译之前让IL2CPP知道我们需要使用这个内容，详细如下 泛型类：声明一个类，然后在这个类中声明一些public的泛型类变量； 泛型方法：随便写一个静态方法，在将这个泛型方法在其中调用一下。这个静态方法无需被调用； IL2CPP打包类型裁剪问题1.问题说明：IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后包的尺寸的目的，然而在实际使用过程中，很多类型有可能会被意外剪裁掉，造成运行时抛出找不到某个类型的异常，特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题； 2.解决方案： (1).IL2CPP处理模式时，将PlayerSetting-&gt;Other Setting-&gt;Managed Stripping Level(代码剥离)设置为Low； Disable:Mono模式下才能设置为不删除任何代码 ； Low:默认低级别，保守的删除代码，删除大多数无法访问的代码，同时也最大程度减少剥离实际使用的代码的可能性； Medium:中等级别，不如低级别剥离谨慎，也不会达到高级别的极端； Hight:高级别，尽可能多的删除无法访问的代码，有限优化尺寸减小。如果选择该模式一般需要配合link.xml使用； (2).通过Unity提供的link.xml方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的,在Unity工程的Assets目录中（或其任何子目录中）建立一个叫link.xml的XML文件； 3.link.xml声明格式举例说明：推荐看官网 &lt;!--程序集中保留类型和成员--&gt; &lt;assembly fullname=\"Assembly-CSharp\"&gt; &lt;!--保留命名空间中类以及参数preserve说明：all全部、fields字段、methods方法、nothing只保留类型--&gt; &lt;type fullname=\"MyNameSpace.MyClass\" preserve=\"all\"/&gt; &lt;/assembly&gt;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"mono","slug":"mono","permalink":"https://wwy.wwywy.com/tags/mono/"},{"name":".Net","slug":"Net","permalink":"https://wwy.wwywy.com/tags/Net/"}]},{"title":"Unity插件-Animancer","slug":"03051-Unity插件-Animancer","date":"2022-01-29T13:00:00.000Z","updated":"2022-07-11T03:13:42.625Z","comments":true,"path":"posts/1577.html","link":"","permalink":"https://wwy.wwywy.com/posts/1577.html","excerpt":"","text":"Animancer介绍Animancer初步使用使用方法：添加Animator组件和AnimancerComponent相关组件，再编写脚本控制动画； 脚本案例： public sealed class PlayAnimation : MonoBehaviour { [SerializeField] private AnimancerComponent _Animancer; [SerializeField] private AnimationClip _Clip; private void OnEnable() { _Animancer.Play(_Clip); var state = _Animancer.Play(_Clip); state.Speed = ... state.Time = ... state.NormalizedTime = ... state.Events.OnEnd = ... _Animancer.Play(_Clip).Time = 0; } } Animancer核心组件AnimancerComponent说明：普通的动画师组件 AnimancerComponent类中的API： 成员变量： //1.获取Animator Controller组件 animancer.Animator //2.获取Playable animancer.Playable //3.获取该组件上的动画状态字典 animancer.States //4.获取该组件上的动画层级 animancer.Layers 成员方法： //1.播放动画 animancer.Play(AnimationClip, float, FadeMode) //2.使用键值播放动画。如果该键没有注册，返回null animancer.TryPlay(Object, float, FadeMode) //3.停止当前动画或者目标动画 animancer.Stop(参数) //4.判断是否播放当前动画或者目标动画 animancer.IsPlaying() NamedAnimancerComponent说明：继承自AnimancerComponent并添加一个数组，并按名称注册动画，可以使用名字播放动画，这与 Unity 的旧版组件非常相似； AnimancerComponent类中的API： 增加的成员变量： //1.获取动画源列表 animancer.Animations //1.获取默认动画源 animancer.DefaultAnimation HybridAnimancerComponent说明：继承自NamedAnimancerComponent，并且添加了控制器，可以融合Animator Controller组件和Animancer； Animancer动画状态动画状态说明：播放动画时，Animancer会创建一个状态来管理它并跟踪它的进度，如果以后再次播放相同的动画，它将重用相同的状态； AnimancerState类API 成员变量： //1.获取动画源文件 state.Clip //2.动画事件集合 state.Events //3.动画的长度 state.Length //4.动画的速度 state.Speed //5.状态的开始时间，该变量改变，动画事件也会变 state.NormalizedTime //6.状态的结束时间，该变量改变，动画事件也会变 state.NormalizedEndTime //7.状态的事件集合 state.Events 成员方法： //1.销毁动画 state.Destroy() 主要访问和创建状态的方法： //1.此属性存储该方法最近返回的状态 var state = animancer.States.Current; //2.此属性存储最近由 Layer 的方法返回的状态 var state = animancer.Layers[x].CurrentState; //3.索引器获取 var state = animancer.States[clip]; //4.方法获取 animancer.States.TryGet(clip, out var state); //5.如果已存在的状态，则此方法将返回该状态。否则它将创建并返回一个新的 var state = animancer.States.GetOrCreate(clip); //6.创建新状态，即使该动画已存在一个状态。请注意，每个状态必须具有不同的密钥，否则将引发，注意key时object类型，所以会有装拆箱问题 var state = animancer.States.Create(key, clip); //7.创建新状态，而不为其提供键。 var state = new ClipState(clip); //8.如果存在的状态，则此方法将销毁该状态并返回，否则，它将返回false animancer.States.Destroy(clip); Animancer动画过渡过渡说明：Animancer中除了使用Clip动画源文件来进行使用，也可以使用ClipTransition播放动画，并且这样效果更好； 过渡类类型： //基本过渡： 1.ClipTransition：实现ITransition接口，最基本的过渡类型，FadeDuration可以控制动画淡入淡出过渡的时长，Speed控制速度，StartTime和EndTime控制起始时间，同时动画支持添加帧事件； 2.ClipTransitionSequence：继承自ClipTransition并简单地添加一个数组，这些数组将在第一个之后按顺序播放（使用他们的每个结束事件来播放下一个）； 3.PlayableAssetTransition //混合过渡： 1.ManualMixerTransition：简单的混合动画； 2.LinearMixerTransition：1D混合动画，用一个参数控制，参数信息和Animator里的混合一致； 3.MixerTransition2D：2D混合模式，用俩个参数控制，参数信息和Animator里的混合一致； //控制器过渡： 1.ControllerTransition：使用控制器文件； //过渡资源 1.过渡类+Asset：过渡资源在资源面板下可以创建该过渡资源文件，和上面不同的时，过渡文件整个项目全局共享，而不是每个对象都有自己单独的过渡。它们都遵循相同的命名约定； 2.过渡类+Asset.UnShared:不共享分过渡资源，一般用不着； Animancer混合动画淡入淡出淡入淡出说明：淡入淡出通常不用于动画，因为它们不能混合，但是对于骨架动画非常有用，因为它允许角色模型从一个动画的结束姿势平滑地过渡到另一个动画的起始姿势，而不需要两个姿势完全相同。这也意味着，如果动画在任何时候被中断，过渡仍然可以是平滑的； 常用淡入淡出类型： //1.参数值按百分比计算 下标0:FadeMode.FixedSpeed //2.参数根据事件计算 下标1:FadeMode.FixedDuration //3.好像是不会创建的新的状态 下标2:FadeMode.FromStart 动画的层层说明：基本和Animator使用方法一致； AnimancerLayer类API说明 重要成员变量： //1.层级下标 layer.Index //2.层级叠加模式还是覆盖模式 layer.IsAdditive //3.层权重 layer.Weight 重要成员方法： //1.设置骨骼蒙版 layer.SetMask(AvatarMask) //2.设置层权重 layer.SetWeight(float) 动画混合树混合树说明：基本和Animator使用方法一致； 混合树使用： //混合类类型说明 1.ManualMixerState：没有参数 2.LinearMixerState：float参数，线性插值算法 3.CartesianMixerState：Vector参数，梯度波段O(n2)插值算法 4.DirectionalMixerState：Vector参数，极地梯度波段O(n2)插值算法 //案例 public sealed class LinearMixerExample : MonoBehaviour { private AnimancerComponent _Animancer; private AnimationClip _back; private AnimationClip _forward; private AnimationClip _left; private AnimationClip _right; private float _MovementSpeed; public CartesianMixerState mixState; private void Awake() { mixState = new CartesianMixerState(); //初始化混合动画 mixState.Initialize(_back, _forward，_left，_right); //设置动画参数 mixState.SetThreshold(0, new Vector2(0, 0)); mixState.SetThreshold(1,new Vector2(0,-1)); mixState.SetThreshold(2, new Vector2(0, 1)); mixState.SetThreshold(3, new Vector2(-1, 0)); mixState.SetThreshold(4, new Vector2(1, 0)); //设置混合动画的同步，同步适用于移动，但对于空闲动画，通常应禁用同步 MixerState.AutoSynchronizeChildren = false; mixer.DontSynchronizeChildren(); mixer.DontSynchronize(mixer.GetChild(0)); mixer.Synchronize(mixer.GetChild(1)); //播放 _Animancer.Play(mixState); } private void Update() { var input = new Vector2( Input.GetAxisRaw(\"Horizontal\"), Input.GetAxisRaw(\"Vertical\")); mixState.Parameter = Vector2.MoveTowards( mixState.Parameter, input, _MovementSpeed * Time.deltaTime); } } Animancer事件事件说明：基本和Animator使用方法一致，但是性能更好，且使用Clip文件使用时，每次都会创建垃圾，除非您缓存事件回调，而ClipTransition访问它将直接引用ClipTransition拥有的，因此当您再次播放时，您所做的任何修改都将保留。这意味着修改通常只应在启动时执行一次，而不是每次播放时都重复进行； 用法说明： //1.添加事件 state.Events.Add(0.4f, 事件); //2.结束事件，结束一定会调用 state.Events.OnEnd = 事件; Animancer搭配推荐","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Animancer","slug":"Animancer","permalink":"https://wwy.wwywy.com/tags/Animancer/"},{"name":"Playable","slug":"Playable","permalink":"https://wwy.wwywy.com/tags/Playable/"}]},{"title":"ET6.0框架笔记","slug":"04100-ET6.0框架笔记","date":"2022-01-24T13:00:00.000Z","updated":"2022-07-09T16:21:10.973Z","comments":true,"path":"posts/2112.html","link":"","permalink":"https://wwy.wwywy.com/posts/2112.html","excerpt":"","text":"ET6.0框架介绍项目的初步运行1.运行Unity客户端项目，并且打开编程软件进行初步编译；2.打开服务端项目，第一次打开编译Client下的Mono文件夹；3.重新编译整个解决方案；4.客户端F5生成代码； ET前后端通讯机制登录实例：1.通过NetKcpComponent组件创建Session会话连接；2.Session（由ET框架管理）会话的Id和TChannel进行绑定；3.而TChannel实际创建Socket连接，所以有了SessionId就有了Socket；4.Session向Socket写入客户端登录数据，传输到网关负载均衡服务器； ET的多线程和分布式第一代服务器架构：使用单台物理机，单个服务器进程，单线程无阻塞Socket服务器所有玩家（无数据库软件）；第二代服务器架构：采用分区分服模式，引用数据库软件存储数据，多个服务器进程同时运行，每个服务器单独一个游戏世界，互不牵扯，可以使用多台计算机部署架构，但是游戏服务器进程直接和玩家连接，同时也要和数据库连接；第三代服务器架构：发展除让玩家统一连接的网关服务器，游戏服务器进程只和网关服务器进行通讯，而数据库的任务则交给数据库代理服务器进程进行处理（读取），读取的数据会放在缓存中，提升性能；第三代服务器架构（无缝地图-魔兽世界）：MMORPG游戏的标准配置，引用Login服务器、游戏服务器分化的概念；ET框架服务器架构-Ecs组件式架构：一个游戏可以由多台机器一起运行，一台机器可以运行多个服务器进程Process，一个进程下可以有多个Scene（Realm、Gate、Map游戏服务器、Location定位服务器），可以通过需求变成一二三甚至更加复杂的的服务器架构 登录实例（接上）：1.网关负载均衡服务器随机分配网关配置；2.通过配置向这个随机分配网关服务器请求一个Key,返回给客户端，客户端通过这个连接网关；3.await等待服务端消息返回，该返回消息获取到的只是网关IP地址，断开旧连接；4.游戏客户端和游戏网关建立正式连接；5.登录进Map服务器注意：C就是客户端，R是网关负载均衡服务器，G是网关； ET的ECS组件编程ECS:Entity实体——Component组件——System系统（在ET6.0中实体基本即组件）； 遵守的编程原则：1.实体即组件、组件即实体；2.编写一个实体或者组件，绝不继承除Entity外的任何父类；3.不使用任何虚函数，使用逻辑分发替代；4.Model和ModelView只存放实体和组件的数据字段声明，绝不存放任何逻辑函数；5.Hotfix和HotfixView值保留纯逻辑函数，也就是静态类和扩展方法编写的System,不能存在任何数据字段；6.Model和Hotfix中不能出现跟Unity引擎相关的对象类和调用相关API函数；7.实体组件中声明数据字段必须编写生命周期函数，防止实体对象池回收再利用的逻辑错误； 其他原则：1.系统命名必须是实体名+System；2.系统必须是静态类；3.AddChild和AddComponent的实体需要添加IAwake接口，而且如果实现了生命周期函数，实体或组件也需要继承相应的接口；4.显示层可以调用逻辑层，逻辑层不能直接调用显示层，只能用事件； //1.实体或者组件 public class Computer: Entity,IAwake,IUpdate,IDestroy public class MouseComponent : Entity, IAwake //2.系统 public static class ComputerSystem { //需要使用拓展方法 public static void Start(this Computer self) { Log.Debug(\"计算机启动\"); //这里可以调用身上的组件 self.GetComponent&lt;PCCaseComponent&gt;().StartPower(); self.GetComponent&lt;MonitorsComponent&gt;().DisPlay(); } } //3.实体实例化和组件添加，这里的实体实例化其实也只是添加到ZoneSence身上 Computer computer = args.ZoneScene.AddChild&lt;Computer&gt;(); computer.AddComponent&lt;PCCaseComponent&gt;(); computer.AddComponent&lt;MonitorsComponent&gt;(); computer.AddComponent&lt;KeyBoardComponent&gt;(); computer.AddComponent&lt;MouseComponent&gt;(); computer.Start(); ET中ECS编程的生命周期 ET的生命周期和Unity中的类似，在系统中创建对应的类，然后继承自对应的生命周期系统，实现对应的方法就ok了,这里注意的是实现什么生命周期函数，实体或组件也需要继承对应的接口，而且经过测试，貌似Awake在AddChild之前调用。 //1.生命周期函数类 public class ComputerAwakeSystem : AwakeSystem&lt;Computer&gt; public class ComputerUpdateSystem : UpdateSystem&lt;Computer&gt; public class ComputerDestroySystem : DestroySystem&lt;Computer&gt; ET的逻辑分发OOP面向对象的缺点：继承层次过深时，牵一发而动全身； ET的逻辑分发：ET实现实体多样性只需要用一个枚举去区分就可以了，其中实体组成多样性就是组件的不同，不再需要多重的层次继承； ET的Scene层级树Scene的概念：Scence相对于树的根节点，它本质也是一个实体，实体可以挂载在下面，其他实体也可以挂载在其他实体下，进行对层次的嵌套挂载；但是不管嵌套多少层的实体，它的Domain字段指代的就是实体的根节点Scene；而Zone字段代表的是Scene的逻辑索引Id，在服务器一般当作区服的索引Id； 客户端Scene的层级关系（客户端可以通过ZoneScene字段获取固定Sence根节点）: 服务端Scene的层级关系: 服务端机器人Scene的层级关系 ET的Excel配置工具Excel配置工具注意事项：1.配置文件从第三行第三列开始写，跟VBA宏有关；2.第一个类型字段名必须是Id；3.第一行是给策划看的，第二行是字段的字段名，第三行是字段类型；4.加#是注释，仅给策划使用，不会添加到游戏数据中；5.配置数据经过了Probuf序列化，服务端导出后配置文件在Config文件夹下，客户端在Unity\\Assets\\Bundles\\Config下；可以查看文本形式在Bin\\Json目录下，c是客户端，s是服务端；生成的数据类在Model下的Generate文件夹下；6.如果客户端专用字段在行或者列加c，而服务端加s即可，如果是整个配置文件都分端考虑，则在第一行第一列添加c或s标识；7.行是可以空行的，可以用来分类注释，目测加#；8.一个配置文件下可以有多个配置表，最后进行合并导出，如果有一个表你不想合并出在表名前加#；9.配置工具支持的导表类型可以在Tools\\Apps\\EXcelExporter文件下的Convert静态类中定义或查看；10.数组类型默认在配置文件中加英文,配置; //1.真正获取时用到的是表名+Category这个分部类的单例实例，一般和配置类一起自动生成，是分部类可以例如写一些获取配置信息的方法，配置类也是分部类，可以扩展一些复杂类型 //获取单个 UnitConfig config = UnitConfigCategory.Instance.Get(1001) //获取所有 var configs = UnitConfigCategory.Instance.GetAll() ET中的事件系统1.事件的事件定义是一个结构体，参数传递在其中声明，在EventType命名空间下进行定义，写在Model层下；2.事件逻辑类需要实现AEvent这个类，基类放行填的就是上面的结构体；3.如果视图层也要使用事件在Modelview下定义即可，但是订阅类因为继承了AEvent类，客户端部分就不能使用Monobehavior类型接入这样的订阅方式了，需要特别注意； //1.定义事件，添加事件,必须EventType命名空间下进行定义 public struct InstallComputer { //定义参数 public Computer computer; } //2.调用事件，触发事件 //同步Publish Game.EventSystem.Publish(new EventType.InstallComputer() { computer = computer }); //同步PublishAnycs await Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }); //异步PublishAnycs Game.EventSystem.PublishAnycs(new EventType.InstallComputer() { computer = computer }).Coroutine(); //3.编写事件触发逻辑 public class InstallComputer_AddComponent : AEvent&lt;InstallComputer&gt; { //必须添加async protected async override ETTask Run(InstallComputer arg) { Computer computer = arg.computer; computer.AddComponent&lt;PCCaseComponent&gt;(); computer.AddComponent&lt;MonitorsComponent&gt;(); computer.AddComponent&lt;KeyBoardComponent&gt;(); computer.AddComponent&lt;MouseComponent&gt;(); await ETTask.CompletedTask; } } ET中的ETTask异步编程同步操作：先完成其全部工作在返回调用者；异步操作：先返回给调用者再完成全部工作，异步编程一般是以异步操作编写出运行时间可能持续很长一段时间的函数，常用于IO密集型和计算密集型逻辑；ETTask：ETTask是C#种的Task的精简版，只支持单线程的功能，基本可以做到无GC，在ET中编写异步函数，必须返回ETTask类型，如果有返回值则是ETTask的泛形中的放行，可以在ThirdParty拜读ETTask的源码; 1.ETTask函数编写 //无返回值,参数类型用来控制取消异步函数 public async ETTask TestAsync(ETCancellationToken cancellationToken) { //表明该函数可能是同步函数 await ETTask.CompletedTask; //第二参数同上 bool rt = await TimerComponent.Instance.WaitAsync(1000, cancellationToken); //根据返回值控制 if (rt) Log.Debug(\"函数取消了\"); else Log.Debug(\"继续执行下面逻辑\"); } //有返回值 public async ETTask&lt;int&gt; TestResultAsync() { await TimerComponent.Instance.WaitAsync(1000); return 10; } 2.ETTask函数的调用 //定义取消异步函数实例 ETCancellationToken cancellationToken=new ETCancellationToken(); //等待无返回值函数调用完成 await TestAsync(cancellationToken); //不等待无返回值函数完成，执行下面逻辑 TestAsync(cancellationToken).Coroutine(); //等待函数返回值，一般有返回值的逻辑上必须等待，否则代码可能有问题 int value = await TestResultAsync(); //取消函数 cancellationToken.Cancel(); ET中的Protobuf通讯消息Protobuf：Protobuf就是一个用于生成通讯消息类的代码生成器，是Google公司提出的一种开源的轻便高效的结构化数据存储格式，常用于结构化数据的序列化，具有语言无关、平台无关、可扩展性特性，常用于通讯协议、服务端数据交换等应用场景；Protobuf 拥有类型安全，易用性好，自动化程度高，兼容性强等优势。相对于其他常见的列入XML、JSON，描述同样的数据信息，ProtoBuf序列化后数据量更小、序列化和反序列化速度更快、操作更为简单。Proto数据结构描叙文件——Protobuf Compiler——各种编程语言的消息定义文件；Protobuf的Github开源地址 :GitHub - protocolbuffers/protobuf： Protocol Buffers - Google 的数据交换格式 ET中的Protobuf：版本是proto3，且不是谷歌C++版本，采用是C#版的protobuf-net，代码生成程序在Tools\\Apps\\Proto2CS下的Proto2CS类，是ET框架提供的，不是谷歌原版; .proto描叙文件编写的的注意事项：1.Proto数据结构描叙文件存放在Proto文件夹下；2.OuterMessage是定义客户端和服务端通信的消息；3.InnerMessage是服务端内部通信的消息；4.MongoMessage也是是服务端内部通信的消息，但是内部可以定义实体类型；5.C就是客户端，R是网关负载均衡服务器，G是网关，M是Map服务器；6.消息定义体中的Id不能重复；7.生成的转换类型列表可以在Tools\\Apps\\Proto2CS的Proto2CS类中查看，消息体生成一般在Model\\Generate\\Message下；8.加上repeated转换后是List类型，不支持字典，可以用俩个列表表示键值对；9.字符之间必须要留空格；10.proto文件中的注释意义重大； 网络Handler消息编写注意事项1.类名定义务必以消息类名+Handler作为声明2.ActorLoaction消息使用ActorMessageHandler标签，Actor和普通消息使用MessageHandler标签，新版本可以不用了；3.普通消息一般用于客户端和服务端网关或者网关负载进行通信使用4.Actor和ActorLoaction消息一般用于Unit之间的通信，如服务端内部的Unit通信和客户端和Map服务器进程通信，不同的是ActorLoaction消息需要Location定位的参与； ET普通网络消息编写普通消息.proto文件编写： // ResponseType R2C_LoginTest（普通请求消息一定要注释返回类） message C2R_LoginTest // IRequest（普通请求消息必须注释） { int32 RpcId = 90;（普通请求消息必须声明该字段） string Account = 1; string Password = 2; } message R2C_LoginTest // IResponse（普通响应消息必须注释） { int32 RpcId = 90;（普通响应消息必须声明该字段） int32 Error = 91; string Message = 92; string GateAddress = 1; string Key = 2; } message C2R_SayHello // IMessage（一般消息必须注释） { string Hello = 1; } 普通消息C#代码： //1.客户端编写登录逻辑 public static async ETTask LoginTest(Scene zoneScene, string address) { try { Session session = null; R2C_LoginTest r2C_LoginTest = null; try { session = zoneScene.GetComponent&lt;NetKcpComponent&gt;().Create(NetworkHelper.ToIPEndPoint(address)); { r2C_LoginTest =(R2C_LoginTest)await session.Call(new C2R_LoginTest() { Account = \"123\", Password = \"456\" }); Log.Debug(r2C_LoginTest.Key); session.Send(new C2R_SayHello() { Hello = \"你好\" }); } } finally { session?.Dispose(); } } catch(Exception e) { Log.Error(e.ToString()); } } //2.普通请求消息逻辑 [MessageHandler] public class C2R_LoginTestHandler : AMRpcHandler&lt;C2R_LoginTest, R2C_LoginTest&gt; { protected override async ETTask Run(Session session, C2R_LoginTest request, R2C_LoginTest response, Action reply) { response.Key = \"110\"; reply(); await ETTask.CompletedTask; } } //3.一般消息（不用响应） [MessageHandler] public class C2R_SayHelloHandler : AMHandler&lt;C2R_SayHello&gt; { protected override async ETTask Run(Session session, C2R_SayHello message) { Log.Debug(message.Hello); await ETTask.CompletedTask; } } ET中的Actor通信模型Actor模型： Actor消息：Actor模型中一个很重要的概念就是 Actor地址，因为当一个Actor需要与另外Actor进行通信，必须通过这个地址。ET框架考虑到分布式的网络环境，通过Entity的InstanceId 对Actor地址进行了抽象，屏蔽了不同进程之间的差异。 ActorLocation消息：虽然在Actor模型中只需要知道对方的InstanceId就能发送消息，但是Actor可能在不同的进程之间进行转移，所以一个Actor的Actor地址(InstanceId)会发生动态变化。为此ET框架提供了一种ActorLocation机制，这个机制通过增加Location定位服务器进程， Entity通过注册自身的ID和InstanceId， 使得通信消息被发送到目标Entity所在的实际进程处进行消息的处理； ActorLocation消息Proto文件编写: //ResponseType M2C_TestActorLocationResponse message C2M_TestActorLocationReqeust // IActorLocationRequest { int32 RpcId = 90; string Content = 1; } message M2C_TestActorLocationResponse // IActorLocationResponse { int32 RpcId = 90; int32 Error = 91; string Message = 92; string Content = 1; } message C2M_TestActorLocationMessage // IActorLocationMessage { int32 RpcId = 90; string Content = 1; } ActorLocation消息C#代码编写: 1.客户端场景切换逻辑 try { Session session = zoneScene.GetComponent&lt;Session&gt;(); var message = (M2C_TestActorLocationResponse)await session.Call(new C2M_TestActorLocationReqeust() { Content = \"111\" }); Log.Debug(message.Content); session.Send(new C2M_TestActorLocationMessage() { Content = \"22222\" }); } catch (Exception e) { Log.Error(e); } 2.ActorLocation请求消息逻辑 [ActorMessageHandler] public class C2M_TestActorLocationReqeustHandler : AMActorLocationRpcHandler&lt;Unit, C2M_TestActorLocationReqeust, M2C_TestActorLocationResponse&gt; { protected override async ETTask Run(Unit unit, C2M_TestActorLocationReqeust request, M2C_TestActorLocationResponse response, Action reply) { Log.Debug(request.Content); response.Content = \"333333\"; reply(); await ETTask.CompletedTask; } } 3.ActorLocation一般消息逻辑 [ActorMessageHandler] public class C2M_TestActorLocationMessageHandler : AMActorLocationHandler&lt;Unit, C2M_TestActorLocationMessage&gt; { protected override async ETTask Run(Unit entity, C2M_TestActorLocationMessage message) { Log.Debug(message.Content); //MessageHelper.SendToClient(entity, 发送给客户端的消息); await ETTask.CompletedTask; } } ET教程登录实例实例步骤：1.编写账号登录请求和响应俩条协议Proto；2.服务端创建账户实体以及对应的账户枚举类型,同时SceneType枚举添加登录服务器和ErrorType枚举添加对应错误码，并且在场景工厂类添加登录服务器枚举的组件添加逻辑；3.客户端在视图层对应的逻辑层接口重新编写登录请求的逻辑，并且编写账号信息组件和账号系统以及其生命周期，并且在场景工厂zoneScene添加该组件（创建Session——发送请求——根据返回错误码进行判断——成功则添加Session组件并且添加心跳组件——获取账户信息组件并赋值——返回错误码给视图层做处理）;4.服务端编写登录请求处理逻辑，同时编写Token组件和对应的Token系统，在场景工厂的登录服务器组件添加该组件（判断Scene是否为登录Type——移除Session监听组件——判断账户密码为空——正则判断账户密码长度——数据库读取账户集合——没有账号则添加新账号并且保存——有则判断是否黑名单、密码是否正确——顶号操作并且发送消息——添加会话定时断开组件——根据服务器时间和随机数创建Token令牌——根据session的根节点获取Token组件，并且添加该令牌到Token字典中——令牌和账户Id添加回复内容并回复）; 事后心得：1.数据库组件是单例，数据库组件挂载在账号服务器上就ok了，如果，游戏服务端是分布式的，多进程，可以尝试挂载在Map服务器上，或者直接挂载在GameSence上，全局都可以访问；2.出现问题回复消息后不能马上断开Session，不然一般消息没发出去连接就断开了，可以为Session扩展一个断开连接的方法，在一秒后再断开连接，同时要记得记录一下Session的Id，如果一秒后Id变化，则说明该秒内的逻辑已经重新申请了Session，则不需要再断开了；3.游戏中玩家可能会出现点击过快而导致发送多条数据的情况，除了客户端作一些处理外（参考下面代码案例一），服务端也需要作一些处理，遵循Ecs的编程方式，可以为Session添加一个SessionLock的无逻辑组件，当session有这个组件的时候直接返回，之后使用using包裹住异步处理逻辑和关键逻辑，逻辑处理完释放该组件；4.游戏中很低的概率会出现俩位玩家请求同样的账户密码创建不同的Sessin进行处理，且该账户都是新账号，都进行到了账户创建的逻辑处理，这时候数据库就可能会有俩个一模一样的账号，打破的账号唯一性，所以这里要使用协程锁锁住异步逻辑，也是使用using关键字，同时使用ET自带的CoroutineLockComponent组件，添加一个协程锁类型，锁住账户的哈希码（using (await CoroutineLockComponent.Instance.Wait(CoroutineLockType.Account,request.AccountName.Trim().GetHashCode()))）；5.游戏中可能会有玩家已经上线的情况，这个时候就需要顶号操作，可以定义一个账号Id和会话Id映射字典的组件，挂载在账号服务器上，相应的逻辑处理完后，对玩家其他会话上线进行判断，这里只存取了sessionId，可以通过Game.EventSystem.Get(sessionId) as Session获取Session，进行判断；6.玩家手机没电或者直接杀进程可能session会话不会正常断开连接，这里则需要添加一个账号在线时间检测组件去检测，组件中应该设有一个定时器Id，并且要新定义一个定时器常量类型，并且为该常量类型写逻辑函数（定时器逻辑类标签[Timer(TimerType.AccountCheckOutTimer)]），TimerComponent.Instance.NewOnceTimer(TimeHelper.ServerNow() + 600000, TimerType.AccountCheckOutTimer, self)；","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"ET","slug":"ET","permalink":"https://wwy.wwywy.com/tags/ET/"}]},{"title":"Unity进阶-FairyGUI","slug":"03006-Unity进阶-FairyGUI ","date":"2021-12-12T13:00:00.000Z","updated":"2022-07-15T15:18:14.762Z","comments":true,"path":"posts/1542.html","link":"","permalink":"https://wwy.wwywy.com/posts/1542.html","excerpt":"","text":"FairyGUI概叙FairyGUI介绍 FairyGUI是跨引擎的开源UI解决方案，它包含一个UI编辑器 以及 多个流行游戏引擎的运行库(SDK)，支持包括Unity,Unreal,Cocos2dx,Egret,Laya,Flash等等游戏引擎。 FairyGUI的工作流程1.在FairyGUI编辑器中编辑UI；2.将编辑好的UI导出对应资源（图集和配置文件）；3.将资源导入对应引擎后，结合FairyGUI提供的运行库（SDK） 进行UI功能的制作； FairyGUI的优缺点优点： 可以让美术同学使用编辑器进行UI面板的拼凑，降低美术同学的学习成本，美术不用学习如何使用游戏引擎； 方便项目UI部分的移植； FairyGUI提供了比UGUI、NGUI更多的功能，方便我们的使用； 缺点： 由于它是跨引擎的工具，对部分引擎支持不到位，使用时会遇到一些bug，但Untiy作为主流引擎，相对来说问题较少； FairyGUI基础编辑器基础使用1.项目文件夹结构： assets：包内容放置目录 ，例如package1：每个包一个目录。目录名就是包名； assets_xx：分支内容放置目录，xx就是分支名称，多个分支存在多个类似名称的目录； settings:配置文件放置目录； .objs：内部数据目录。不需要进行版本管理，这里的内容不需要共享； .fairy：项目标识文件。文件名就是项目名，可以随便修改； 2.主界面说明： 菜单栏； 主工具栏：常用功能按钮； 工具栏和舞台区域； 状态栏，显示控制台输出的最后一条信息，点击可打开控制台； 其它功能视图：可以随意拖动位置，也可以关闭，在主菜单-&gt;视图中可以打开关闭后的窗口； 3.支持的格式：可以将资源直接拖入资源库中 图片（PNG、JPG、TGA、SVG等） 声音（MP3、wav等） 动画（spine、龙骨、gif、Flash等） 文字（TTF、位图文字） 包1.包的定义：包是FairyGUI中用于组织资源的，它在文件系统中体现为一个目录，assets文件夹下的每个子目录都表示一个包，最终我们打包时也是以包为单位进行打包的，每个包中都有一个package.xml文件，它是用于记录这个包中的资源对应信息的，是非常重要的文件，包发布后可以得到一个描述文件和一张或多张纹理集（图集），我们在引擎中使用时，就是根据这个描述文件使用纹理中的图片来创建UI的，菜单栏——&gt;资源——&gt;新建包（或者点击快捷按钮）； 2.包的依赖： 说明：FairyGUI不处理包之间的依赖，假设有两个包A和B，A用到了包B中的元件，那么在使用A中内容时需要先手动加载包B相关内容； 建议： 不要建立交叉引用； 公共资源放在公共包中； 避免A用B，B用C这种复杂的关系； 3.资源URL地址：在FairyGUI中每个资源都对应了一个资源URL地址，选中一个资源，右键，会出现复制URL，就可以得到它的资源地址，无论在编辑器还是代码中 我们都可以通过资源地址来得到资源，也可以通过ui://包名//资源名（注意：该格式地址是不包含文件夹的，只需要用包名和资源名）； 组件1.组件的定义： 说明：组件，也可以理解为组合控件，所有的UI相关内容都在其中编辑显示，是我们的最基础容器，它可以包含一个或多个基础显示对象，也可以包含组件，我们之后编辑的所有UI内容都是以组件为容器，比如面板，按钮，输入框等等UI内容都是基于组件制作的，在FairyGUI的舞台编辑区域，编辑的就是组件和组件容器中的各种元件位置属性等等，最终我们发布UI文件后，在Unity中也是以组件为最小单位进行内容加载； 创建方式：菜单栏——&gt;资源——&gt;新建组件（或者点击快捷按钮） 意义：所有面板，复合控件都是以组件为容器进行制作的，之后在Unity加载编辑好的界面时也是以组件为最小单位进行加载的； 2.组件窗口检查器参数说明： 1.组件栏： 最小\\大尺寸：设置组件的尺寸限制，0表示不限制（注意：修改尺寸限制不会修改当前的宽高，即使宽高超出限制），点击轴心右侧三角形可以快速设置轴心的位置； 初始名字：当组件在编辑器内被创建时，自动设置组件的名称为这里设置的，主要作用是，FairyGUI中要求窗口框架组件命名为frame，那么当我们创建一个窗口组件时，就可以在这里把初始名字设置为frame，以后每次使用更加方便； 溢出处理：当组件中内容超出矩形区域时的处理方式（溢出处理不支持代码中动态修改，一开始就要设置好） 可见：超出范围仍然可见； 隐藏：超出范围内容部可见，相当于是一个矩形遮罩； 垂直、水平、自由滚动：只要设置他们就可以做出类似滚动容器的效果，只不过没有滚动条； 边缘：在溢出处理设置为隐藏或者滚动时，可以通过这个参数设置和边缘的留空 和 边缘虚化处理； 自定义遮罩：设置组件内容的一个图片或者图形作为遮罩。遮罩只有预览模式才能看到效果（注意：定义了遮罩的组件，内部的元件永远无法和外部的元件合并DC）； 反向遮罩（挖洞）：不勾选时，就是有像素的地方显示，没有的地方不显示。勾选后，相反； 点击测试：在一些特殊需求中，需要用到不规则区域的点击测试； 图形检测：组件中拖入一个图形，设置为多边形，然后把这个图形设置到点击测试中； 像素检测：如果不规则图形带孔，图形无法画出来，这时就可以使用一种有透明通道的图片然后将图片拖入舞台，再拖入到点击测试中。透明的地方表示点击穿透的区域（像素检测的图片只能放置在和组件的同一包中，也不能用装载器，只能是图片）； 点击穿透：默认情况下，组件的矩形区域将拦截点击，勾选后，点击事件可以穿透组件中没有内容的区域 拓展：就是你要把该组件设置为哪种组合控件，修改后，都会有对应的属性产生，之后会对每个控件的属性详细讲解，我们可以通过扩展快速的做一些通用内容； 背景颜色：辅助设计用，实际组件背景都是透明的，不会有颜色 2.其它栏（自定义区）：主要在编辑器中使用，运行后我们都通过代码获取任何对象，当组件被拖入到到其他组件后，能通过检查器设置的属性一般是固定的，例如一个按钮，我们可以改变它的标题、图标、是否选中等，这些都是编辑器提供的固定属性。但如果我在按钮中放置了额外的文本或者装载器，而且需要设定他们在实例化后的属性时，就需要用自定义属性，将组件的子元件甚至更深层次的元件的属性暴露出来。 元件名称：元件的名称，可以用\".\"引用更深层次的元件，例如n0.n1.n2,表示组件n0的孩子n1的孩子n2。 属性类型：目前支持两种属性，文本和图标； 备注：可选填，如果填写了，则在检查器内使用这里的内容作为标题； 3.设计图栏：可以设定一个组件的设计图，设计图将显示在舞台上，可以设置显示在组件内容的底层或者上层，（使用设计图可以使拼接UI更加快速和精准，设计图不会发布到最终的资源中）； FairyGUI基本元件FairyGUI控件普通文本字体处理富文本输入文本组控制器关联系统标签按钮单选和多选框进度条滑动条滚动条滚动容器列表下拉框Unity中的使用必备组件拓展类分辨率自适应坐标系统输入处理事件机制拖拽相关插入其他对象DrawCall优化FairyGUI进阶分支多国语言树窗口弹出功能曲面UI动效其他功能","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"FairyGUI","slug":"FairyGUI","permalink":"https://wwy.wwywy.com/tags/FairyGUI/"}]},{"title":"Unity进阶-Editor","slug":"03030-Unity进阶-Editor","date":"2021-12-09T13:00:00.000Z","updated":"2022-07-10T03:05:15.571Z","comments":true,"path":"posts/1560.html","link":"","permalink":"https://wwy.wwywy.com/posts/1560.html","excerpt":"","text":"Editor文件夹1.Editor介绍：以下介绍 Editor文件夹可以放在项目的任何文件夹下，可以有多个； 放在其中的内容，项目打包时不会被打包到项目中； 一般编辑器相关代码都可以放在该文件夹中； 要想访问Editor的代码，必须也放在该文件夹下； 添加菜单栏1.编辑器菜单栏添加新的选项入口 //可以通过Unity提供我们的MenuItem特性在菜单栏添加选项按钮 //特性名：MenuItem //命名空间：UnityEditor //规则一：一定是静态方法 //规则二：我们这个菜单栏按钮 必须有至少一个斜杠 不然会报错 它不支持只有一个菜单栏入口 //规则三：这个特性可以用在任意的类当中 [MenuItem(\"GameTool/Test\")] private static void Test() 2.刷新Project窗口内容 //类名：AssetDatabase //命名空间：UnityEditor //方法：Refresh Directory.CreateDirectory(Application.dataPath + \"/测试文件夹\"); AssetDatabase.Refresh(); 3.Editor文件夹","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"UnityEditor","slug":"游戏引擎/Unity/UnityEditor","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"UnityEditor","slug":"UnityEditor","permalink":"https://wwy.wwywy.com/tags/UnityEditor/"}]},{"title":"Unity进阶-InputSystem","slug":"03013-Unity进阶-InputSystem","date":"2021-11-13T13:00:00.000Z","updated":"2022-07-09T16:17:09.191Z","comments":true,"path":"posts/1547.html","link":"","permalink":"https://wwy.wwywy.com/posts/1547.html","excerpt":"","text":"InputSystem概述1.InputSystem说明：Unity提供的新的用于检测玩家设备输入的系统，InputSystem让我们可以专注于功能逻辑开发，不用操心输入检测相关代码； 2.InputSystem导入说明：packageManager中导入Input System 3.InputSystem选择说明：导入InputSystem包后，老的输入系统会被禁用掉，可以在File——&gt;Build Setting——&gt;Player Setting——&gt;Other——&gt;Active Input Handling中可以同时启用也可以只启用其中之一,每次启用后会重启Unity； InputSystem知识点代码检测输入1.代码直接监听的说明：这种观察者模式的监听方式和InputManager是基本类似的，但是这也就是InputManager的弊端，所以直接得代码检测方式对于InputSystem一般是简单做法或者是有特殊需求才使用的，新输入系统的设计初衷就是想提升开发者的开发效率，不提倡写代码来处理输入逻辑，之后我们学了配置文件相关知识后，都是通过配置文件来设置监听（监视窃听）的输入事件类型，我们只需要把工作重心放在输入触发后的逻辑处理； 键盘输入监听（Keyboard）1.获取当前键盘设别 //新输入系统 提供了对应的输入设备类 帮助我们对某一种设备输入进行检测 //需要引用命名空间UnityEngine.InputSystem; Keyboard keyBoard = Keyboard.current; 2.单个按键监听 //首先要得到某一个按键 通过键盘类对象 点出 各种按键 来获取 //按下 keyBoard.按键.wasPressedThisFrame //抬起 keyBoard.按键.wasReleasedThisFrame //长按 keyBoard.按键.isPressed //可以处理 任意键 按下 抬起 长按 相关的逻辑 Keyboard.current.anyKey.监听类型（同上） 3.通过时间监听按键按下 //通过给keyboard对象中的 文本输入事件 添加委托函数 //便可以获得每次输入的内容 keyBoard.onTextInput += (c) =&gt; { print(\"通过lambda表达式\" + c); }; keyBoard.onTextInput += TextInput; 鼠标输入监听（Mouse）1.获取当前鼠标设备（需要引用命名空间） Mouse mouse = Mouse.current; 2.鼠标各键位 按下 抬起 长按 //鼠标左键 mouse.leftButton.监听类型（同上） //鼠标右键 mouse.rightButton.监听类型（同上） //鼠标中键 mouse.middleButton.监听类型（同上） //鼠标 向前向后键 mouse.forwardButton.监听类型（同上） mouse.backButton.监听类型（同上） 3.鼠标位置相关 //获取当前鼠标位置（屏幕坐标） mouse.position.ReadValue(); //得到鼠标两帧之间的一个偏移向量（其实就是获取鼠标滑动方向） mouse.delta.ReadValue(); //鼠标中间 滚轮的方向向量 mouse.scroll.ReadValue(); 触屏输入监听（Touchscreen）1.获取当前触屏设备 Touchscreen ts = Touchscreen.current; //由于触屏相关都是在移动平台或提供触屏的设备上使用 //所以在使用时最好做一次判空 2.得到触屏手指信息 //得到触屏手指数量 ts.touches.Count //获取指定单个索引手指 TouchControl tc = ts.touches[0]; //按下 抬起 长按 tc.press.监听类型（同上） //点击手势 tc.tap.isPressed //连续点击次数 tc.tapCount; 3.手指位置等相关信息 //位置 print(tc.position.ReadValue()); //第一次接触时位置 print(tc.startPosition.ReadValue()); //接触区域大小 tc.radius.ReadValue(); //偏移位置 tc.delta.ReadValue(); //得到当前手指的 状态（阶段） UnityEngine.InputSystem.TouchPhase tp = tc.phase.ReadValue(); switch (tp) { //无 case UnityEngine.InputSystem.TouchPhase.None: break; //开始接触 case UnityEngine.InputSystem.TouchPhase.Began: break; //移动 case UnityEngine.InputSystem.TouchPhase.Moved: break; //结束 case UnityEngine.InputSystem.TouchPhase.Ended: break; //取消 case UnityEngine.InputSystem.TouchPhase.Canceled: break; //静止 case UnityEngine.InputSystem.TouchPhase.Stationary: break; default: break; } 手柄输入监听（Gamepad）1.获取当前手柄 Gamepad gamePad = Gamepad.current; 2.手柄摇杆 //摇杆方向 //左摇杆 gamePad.leftStick.ReadValue() //右摇杆 gamePad.rightStick.ReadValue() //左遥感按键监听 gamePad.leftStickButton.监听类型（同上） //右摇杆按键监听 gamePad.rightStickButton.监听类型（同上） 3.手柄方向键 //对应手柄上4个方向键 上下左右 gamePad.dpad.left.监听类型（同上） gamePad.dpad.right.监听类型（同上） gamePad.dpad.up.监听类型（同上） gamePad.dpad.down.监听类型（同上） 4.手柄右侧按键 //通用 //Y、△ //gamePad.buttonNorth //A、X //gamePad.buttonSouth //X、□ //gamePad.buttonWest //B、○ //gamePad.buttonEast //wasPressedThisFrame //wasReleasedThisFrame //isPressed //手柄右侧按钮 x ○ △ □ A B Y //○ //gamePad.circleButton //△ //gamePad.triangleButton //□ //gamePad.squareButton //X //gamePad.crossButton //x //gamePad.xButton //a //gamePad.aButton //b //gamePad.bButton //Y //gamePad.yButton 5.手柄中央按键 //中央键 //gamePad.startButton //gamePad.selectButton //wasPressedThisFrame //wasReleasedThisFrame //isPressed 6.手柄肩部按键 //左上右上 肩部键位 //左右前方肩部键 //gamePad.leftShoulder //gamePad.rightShoulder //左右后方触发键 //gamePad.leftTrigger //gamePad.rightTrigger //wasPressedThisFrame //wasReleasedThisFrame //isPressed 其他输入监听1.其他类型说明： //其它 //Joystick—摇杆 //Pen—电子笔 //Sensor（传感器） //https://docs.unity3d.com/Packages/com.unity.inputsystem@1.2/manual/Sensors.html#accelerometer //Gyroscope—陀螺仪 //GravitySensor—重力传感器 //加速传感器 //光照传感器 //等等 InputAction类1.InputAction说明：顾名思义，InputAction是InputSystem帮助我们封装的输入动作类，它的主要作用，是不需要我们通过写代码的形式来处理输入，而是直接在Inspector窗口编辑想要处理的输入类型，当输入触发时，我们只需要把精力花在输入触发后的逻辑处理上；我们在想要用于处理输入动作的类中，申明对应的InputAction类型的成员变量（注意：需要引用命名空间UnityEngine.InputSystem）； InputAction使用API1.启动输入检测 move.Enable(); 2.操作监听相关 //开始操作 move.started += TestFun; //真正触发 move.performed += (context) =&gt;{}； //结束操作 move.canceled += (context) =&gt;{}； 3.关键参数CallbackContext //当前状态 //没有启用 Disabled //等待 Waiting //开始 Started //触发 Performed //结束 Canceled context.phase //动作行为信息 context.action.name; //控件信息 context.control.name; //获取值 context.ReadValue&lt;要获取的类型&gt;; //持续时间 context.duration; //开始时间 context.startTime; InputAction齿轮面板参数1.Actions：输入动作设置，设置检测哪些输入 Action Type：动作类型 Value-值类型，主要用于状态连续更改的输入，例如鼠标的移动，手柄的遥感。如果有多个设备绑定这个Action，只会发送其中一个设备（最受控制的）的输入： Button：按钮类型，用于每次按下时触发的Action; Pass Through：直通类型，和Value一样，区别在于如果有多个设备绑定这个Action，会发送所有设备的输入; Control Type-控制类型，在这里选择对应的类型，之后在选择对应设备按键相关属性时，会根据你选择内容的不同，筛选对应内容，这上面显示的内容就是各设备属性的返回值类型，当你选择他们后，非选择的类型将不会在之后的按键设置中出现，很多内容我们基本用不到，相当于是在这里筛选输入设备： Any：任何指 Analog：模拟值，浮点数 Axis：一维轴浮点数，例如：摇杆输入返回值 Bone：骨骼 Digital：数字 Double：浮点 Dpad：4向按钮，例如：摇杆上的D-pad Eyes：VR相关数值 Integer：整数 Quaternion：四元数 Stick：摇杆相关 Touch：触屏相关 Vector2：2维向量 Vector3：3维向量 2.Interactions-相互作用设置，用于特殊输入，比如长按、多次点击等等，当满足条件时才会触发这个行为（设置长按时间、点击次数等等，3个事，开始started，触发performed，结束canceled）： Hold：适用于需要输入设备保持一段时间的操作。当按钮按下会触发started，若在松开按钮前，按住时间大于等于Hold Time则会触发performed（时间一到就触发），否则触发canceled； Tap：和Hold相反，需要在一段时间内按下松开来触发。当按钮按下会触发started，若在Max Tap Duriation时间内（小于）松开按钮，触发performed，否则触发canceled； SlowTap：类似Hold，但是它在按住时间大于等于Max Tap Duriation的时候，并不会立刻触发performed，而是会在松开的时候才触发performed； MultiTap：用作于多次点击，例如双击或者三连击。Tap Count为点击次数，Max Tap Spacing为每次点击之间的间隔（默认值为 2 * Max Tap Duration）。Max Tap Duration为每次点击的持续时间，即按下和松开按钮的这段时间。当每次点击时间小于Max Tap Duration，且点击间隔时间小于Max Tap Spacing，点击Tap Count次，触发performed。 Press可以实现类似按钮的操作 Press Only：按下的时候触发started和performed。不触发canceled Release Only：按下的时候触发started，松开的时候触发performed Press And Release：按下的时候触发started和performed，松开的时候会再次触发started和performed。不触发canceled； Press Point：在Input System中，每个按钮都有对应的浮点值，例如普通的按钮，将会在0（未按下）和1（按下）之间。因此我们可以利用这个值（Press Point）来进行区分，当大于等于这个值则认为按钮按下了。 3.Processors-值处理加工设置，对得到的值进行处理加工： Clamp：将输入值钳制到[min..max]范围。 Invert：反转控件中的值（即，将值乘以-1）。 Invert Vector 2：反转控件中的值（即，将值乘以-1）。如果invertX为真，则反转矢量的x轴；如果invertY为真，则反转矢量的y轴。 Invert Vector 3：反转控件中的值（即，将值乘以-1）。如果反转x为真，则反转矢量的x轴；如果反转y为真，则反转y轴；如果反转z为真，则反转z轴。 Normalize：如果最小值&gt;=零，则将[min..max]范围内的输入值规格化为无符号规格化形式[0..1]，如果最小值&lt;零，则将输入值规格化为有符号规格化形式[-1..1]。 Normalize Vector 2：将输入向量规格化为单位长度（1）。 Normalize Vector 3：将输入向量规格化为单位长度（1） Scale：将所有输入值乘以系数。 Scale Vector 2：将所有输入值沿x轴乘以x，沿y轴乘以y。 Scale Vector 3：将所有输入值沿x轴乘以x，沿y轴乘以y，沿z轴乘以z。 Axis Deadzone：axis死区处理器缩放控件的值，使绝对值小于最小值的任何值为0，绝对值大于最大值的任何值为1或-1。许多控件没有精确的静止点（也就是说，当控件位于中心时，它们并不总是精确报告0）。在死区处理器上使用最小值可避免此类控件的无意输入。此外，当轴一直移动时，某些控件不一致地报告其最大值。在死区处理器上使用最大值可确保在这种情况下始终获得最大值。 Stick Deadzone：摇杆死区处理器缩放Vector2控件（如摇杆）的值，以便任何幅值小于最小值的输入向量都将得到（0,0），而任何幅值大于最大值的输入向量都将规格化为长度1。许多控件没有精确的静止点（也就是说，当控件位于中心时，它们并不总是精确地报告0,0）。在死区处理器上使用最小值可避免此类控件的无意输入。此外，当轴一直移动时，某些控件不一致地报告其最大值。在死区处理器上使用最大值可确保在这种情况下始终获得最大值。 InputAction添加面板参数1.Add Binding:添加新的输入绑定（单按键输入）； 2.Add Positive\\Negative Binding Or Add 1D Axis Composite(2019版本)：添加1D轴组合（类似Input中的水平竖直热键，返回-1~1之间的一个值） Negative：负面按键，例如 0~-1 Positive：正向按键，例如 0~1 Composite Type：复合类型 MinValue：最小值 MaxValue：最大值 Which Side Wins：哪一方获胜（当同时按下时如何处理） Neither：双方没有优先权，返回MinValue和MaxValue的中间值 Positive：正面优先，返回maxValue Negative：负面优先，返回minValue 3.Add Up\\Down\\Left\\Right Composite Or Add 2D Vector Composite（2019版本）:添加2D向量组合（类似将Input中的水平竖直热键组合在一起，得到的Vector中的x，y分别表示两个轴） Up:上 ( 0 , 1 ) Down：下 ( 0 , -1 ) Left：左 ( -1 , 0 ) Right：右 ( 1 , 0 ) Composite Type：复合类型 Mode：处理模式 Analog：模拟值，浮点值 Digital Normalized：单位化向量 Digital：未单位化的向量 4.Add Up\\Down\\Left\\Right\\Forward\\Backward Composite-添加3D向量组合：和2D类似； 5.Add Button With One Modifier Composite:添加带有一个复合修改器的按钮（可以理解为双组合键， 比如Ctrl+C、Ctrl+V） Modifier：复合输入内容 Button：触发输入内容(举例：复制按键Ctrl+C,Ctrl为Modifier,C为Button) 6.Add Button With Two Modifier Composite-添加带有两个复合修改器的按钮（可以理解为三组合键，比如Ctrl+K+U）: Modifier：复合输入内容 Button：触发输入内容(举例：复制按键Ctrl+K+U,Ctrl为Modifier1,K为Modifier2,U为Button) 7.输入类型说明： Path：从哪个控件接受输入 Usages：常用用法 GamePad：游戏手柄 Joystick：操纵杆 Keyboard：键盘 Mouse：鼠标 Pen：笔 Pointer：指针 Sensor：传感器 TouchScreen：触屏 Tracked Device：履带装置 XR Controller：XR 控制器 XR HMD：XR 头戴显示器 Other：其它 InputSystemPackage设置1.UpdateMode：更新模式 Process Events In Dynamic Update：在动态更新中处理事件 Process Events In Fixed Update：在固定更新中处理事件 Process Events Manually：手动处理事件 2.Background Behavior：后台行为 Reset And Disable Non Background Devices：重置和禁用非后台设备 Reset And Disable All Devices：重置和禁用所有设备 Ignore Focus：忽略焦点 3.Filter Noise on .current：过滤当前设备的噪音 4.Compensate Orientation：定向补偿 5.Default Deadzone Min：默认死区最小值 6.Default Deadzone Max：默认死区最大值 7.Default Button Press Point：默认按钮按下点 8.Button Release Threshold：按钮释放阈值 9.Default Tap TIme：默认点击时间 10.Default Slow Tap Time：默认慢速点击时间 11.Default Hold Time：默认保持时间 12.Tap Radius：点击半径 13.MultTap Delay TIme：多次点击延迟时间 14.Supported Devices：支持的设备，如果希望输入系统支持其可以识别的所有输入设备，请将支持的设备保留为空；但是，如果您只对某一组设备感兴趣，那么在此处添加它们将缩小编辑器中显示的范围，并避免从与项目无关的设备获取输入；在此处添加设备时，任何未被分类为受支持的设备都将显示在输入调试器的“不受支持的设备”下； 15.Motion Usage：动作使用 16.Description：描述 17.Play Mode Input Behavior：播放模式输入行为 Pointers And Keyboards Respect Game View Focus：指针和键盘遵守游戏视图焦点 All Devices Respect Game View Focus：所有设备都遵守游戏视图焦点 All Device Input Always Goes To Game View：所有设备输入始终进入游戏视图 InputActions输入动作配置文件1.输入配置文件说明：输入系统中提供了一种输入配置文件，你可以理解它是InputAction的集合，可以在一个文件中编辑多个InputAction的信息，里面记录了想要处理的行为和动作（也就是InputAction的相关信息），我们可以在其中自己定义 InputAction（比如：开火、移动、旋转等），然后为这个InputAction关联对应的输入动作，之后将该配置文件和PlayerInput进行关联，PlayerInput会自动帮助我们解析该文件，当触发这些InputAction输入动作时会以分发事件的形式通知我们执行行为； 2.创建输入配置文件：在Project窗口右键Create创建InputActions配置文件； 输入配置文件1.（左边）ActionMaps:行动地图窗口,可以理解为配置文件中的行为分组配置,可以配置多套操作规范; 2.（中间）Actions 输入动作窗口,我们在这里可以创建各种InputAciton; 3.（右边）Properties 输入操作绑定的输入属性 4.(上方)工具栏-提供保存、搜索等功能按键: Add Control:设置控制方案: Gamepad：手柄 Joystick：摇杆 KeyboardMouse：键盘鼠标 Touch：触屏 XR：VR/AR等 All Devices：设备选择,当切换了控制方案后,该控制方案可能是由多个设备配合控制,可以在这里进一步筛选对应设备 Save Asset:保存配置按钮; Auto-Save：自动保存配置; 搜索栏：可以搜索对应动作行为; 输入配置文件生成C#代码1.根据配置文件生成C#代码：选择InputActions文件后，在Inspector窗口设置生成路径，类名，命名空间，应用后生成代码； 2.使用生成后的输入代码 1.创建生成的代码对象 input = new 类名(); 2.激活输入 input.Enable(); 3.事件监听 input.Input名.按钮名.performed += (context) =&gt;{}； PlayerInput1.PlayerInput说明：PlayerInput是InputSystem提供的，专门用于接受玩家输入来处理自定义逻辑的组件，选择任意对象（一般为一个玩家对象）为其添加PlayerInput组件即可，工作原理如下： 配置输入文件（InputActions文件）； 通过PlayerInput关联配置文件，它会自动解析该配置文件； 关联对应的响应函数，处理对应逻辑； PlayerInput组件面板说明：1.Actions-行为,一套输入动作和玩家相关联，帮助我们监听一些按键的输入: Default Control Scheme：默认启用哪一个控制方案 Default Actions Map：默认启用哪一个行为映射方案 2.Camera：关联摄像机，当分屏设置时才需修改此选项 3.Behavior：如何通知游戏对象上执行对应逻辑 SendMessage：将逻辑脚本挂载在和PlayerInput同一对象上，会通过SendMessage通知执行对应函数 BroadcastMessage：，将逻辑脚本挂载在其自身或子对象上。会通过BroadcastMessage通知执行对应函数 Invoke UnityEvent Actions：通过拖拽脚本关联函数指明想要执行的函数逻辑 Invoke CSharp Events：通过Csharp事件监听处理对应逻辑，通过获取PlayerInput进行事件监听 PlayerInputBehavior详细说明1.Send Messages //在自定义脚本中 //申明名为 \"On+行为名\" 的函数 //没有参数 或者 参数类型为InputValue //将该自定义脚本挂载到PlayerInput依附的对象上 //当触发对应输入时 会自动调用函数 //并且还有默认的3个和设备相关的函数可以调用 //设备注册(当控制器从设备丢失中恢复并再次运行时会触发)：OnDeviceRegained(PlayerInput input) //设备丢失（玩家失去了分配给它的设备之一，例如，当无线设备耗尽电池时）：OnDeviceLost(PlayerInput input) //控制器切换：OnControlsChanged(PlayerInput input) 2.Broadcast Messages //基本和SendMessage规则一致 //唯一的区别是，自定义脚本不仅可以挂载在PlayerInput依附的对象上 //还可以挂载在其子对象下 3.Invoke Unity Events //该模式可以让我们在Inspector窗口上通过拖拽的形式关联响应函数 //但是注意：响应函数的参数类型 需要改为 InputAction.CallbackContext 4.Invoke C Sharp Events //1.获取PlayerInput组件 PlayerInput input = this.GetComponent&lt;PlayerInput&gt;(); //手动获取需要的值，比如在Update中获取值 input.currentActionMap[\"Move\"].ReadValue&lt;Vector2&gt;() //2.获取对应事件进行委托函数添加 input.onDeviceLost += OnDeviceLost; input.onDeviceRegained += OnDeviceRegained; input.onControlsChanged += OnControlsChanged; input.onActionTriggered += OnActionTrigger; //3.当触发输入时会自动触发事件调用对应函数 //用Switch来集中处理 public void OnActionTrigger(InputAction.CallbackContext context) { switch (context.action.name) { case \"Fire\": //输入阶段的判断 触发阶段 才去做逻辑 if(context.phase == InputActionPhase.Performed) print(\"开火\"); break; case \"Look\": print(\"看向\"); print(context.ReadValue&lt;Vector2&gt;()); break; case \"Move\": print(\"移动\"); print(context.ReadValue&lt;Vector2&gt;()); break; } } PlayerInputManager1.PlayerInputManager 组件主要是用于管理本地多人输入的输入管理器，它主要管理玩家加入和离开； PlayerInputManager组件面板说明Notification Behavior-当玩家进入时PlayerInputManager如何通知关联的对象，它的工作方式和PlayerInput相同： Join Behavior：玩家加入的机制 Join Players When Button Is Pressed：当有新设备加入按下任意键，或者没有任何玩家时按下任意键； Join Players When Join Action Is Triggered：当有新设备加入按下指定按键触发玩家加入； Join Players Manually：不要自动加入玩家，需要自己手动加入玩家； Player Prefab：挂载PlayerInput组件的游戏对象 Joining Enabled By Default：启用后，新加玩家按照JoinBehavior的规则加入 Limit Number Of Players：启用后，可以限制加入游戏的玩家数量 Max Player Count：允许参加游戏的最大玩家数 Enable Split_Screen：如果启用，会自动为每个对象分配可用屏幕区域的一部分，用于多人分屏游戏 Maintain Aspect Ratio：假值使游戏能够生成屏幕区域，其纵横比与细分屏幕时的屏幕分辨率不同 Set Fixed Number：如果该值大于零，则PlayerInputManager始终将屏幕分割为固定数量的矩形，而不考虑实际的玩家数量。 Screen Rectangle：可用于分配播放器拆分屏幕的规范化屏幕矩形 UGUI配合使用1.InputSystem对UI的支持：新输入系统InputSystem不支持IMGUI（GUI）注意：编辑器代码不受影响，新输入系统支持UGUI，但是需要使用新输入系统输入模块（Input System UI Input Module），如果当前激活的是InputSystem，那么OnGUI中的输入判断相关内容不会被触发，你必须要选择Both或者只激活老输入系统InputManager才能让OnGUI中内容有用； 2.更多支持说明 UI 支持|输入系统|1.2.0 (unity3d.com) Input System UI Input Module组件参数说明1.Move Repeat Delay：生成初始IMoveHandler之间的初始延迟（秒）。OnMove导航事件，并在移动操作保持激活状态时生成重复的导航事件： 2.Move Repeat Rate：移动动作保持激活时，生成重复导航事件之间的间隔（秒）。请注意，这是由帧速率限制的；每帧不会有多个移动重复事件，因此，如果帧速率低于重复率，则有效重复率将低于此设置。 3.XR Tracking Origin：XR设备相关 Deselect On Background CLick：默认情况下，当指针被点击并且没有击中任何游戏对象时，当前选择被清除。然而，这可能会妨碍键盘和游戏板导航，因为它们需要关闭当前选定的对象。要防止自动取消选择，请将此属性设置为false。 4.Pointer Behavior-如何处理将输入送入UI的多个指针： Single Mouse Or Pen BUt Multi Touch And Track：对于未分类为触摸或跟踪输入的所有输入，其行为类似于单个统一指针，对于跟踪和触摸输入，其行为类似于所有指针；例如，如果在鼠标和笔上接收到并发输入，则将两者的输入馈送到同一UI指针实例中；其中一个的位置输入将覆盖另一个的位置。请注意，当从触摸或跟踪设备接收到输入时，鼠标和笔的单个统一指针将被删除，包括在鼠标/笔光标当前悬停在对象上时发送的IPointerExit事件。 Single Unified Pointer：所有指针输入都是统一的，因此只有一个指针。这包括触摸和跟踪输入。例如，这意味着，无论有多少设备将输入输入输入点，只有帧中最后一个这样的输入才会生效并成为当前UI指针的位置。 All Pointers As Is：UI输入模块不会统一任何指针输入。任何设备，包括提供输入指针类型动作的触摸和跟踪设备，都将是其自己的指针（或触摸输入的多个指针）；注意：这可能意味着UI中将有任意数量的指针，并且可能同时指向多个对象。 5.Actions Asset：包含控制UI的所有操作的输入操作资产。您可以使用以下属性选择资产中的哪些操作对应于哪些UI输入；默认情况下，这将引用名为DefaultInputActions的内置资产，该资产包含用于驱动UI的常见默认操作。如果要设置自己的操作，请创建自定义输入操作资源并在此处分配。在Inspector中将新资源引用指定给此字段时，编辑器会尝试根据常用命名约定自动将操作映射到UI输入。 6.Point：提供2D屏幕位置的动作。用作指向UI元素的光标，以实现鼠标样式的UI交互；设置为传递操作类型和向量2值类型。 7.Left Click：映射到用于与UI交互的主光标按钮的操作；设置为传递操作类型和按钮值类型。 8.Middle Click：映射到用于与UI交互的中间光标按钮的操作；设置为传递操作类型和按钮值类型。 9.Right Click：映射到用于与UI交互的辅助光标按钮的操作；设置为传递操作类型和按钮值类型。 10.Scroll Wheel：提供手势输入以允许在UI中滚动的操作；设置为传递操作类型和向量2值类型。 11.Move：一种操作，提供用于选择当前活动用户界面的二维矢量。这允许游戏板或箭头键样式的UI导航；设置为传递操作类型和向量2值类型 12.Submit：与当前选择的UI接触或“单击”的操作；设置为按钮动作类型。 13.Cancel：退出与当前选定UI的任何交互的操作；设置为按钮动作类型。 14.Tracked Position：提供一个或多个空间跟踪设备（如XR hand控制器）的3D位置的动作。结合跟踪设备方向，这允许通过指向空间中的UI可选择项进行XR样式的UI交互；设置为传递操作类型和向量3值类型。 15.Tracked Orientation：传递表示一个或多个空间跟踪设备（如XR hand控制器）旋转的四元数的操作。结合跟踪设备位置，这允许通过指向空间中的UI可选择项进行XR样式的UI交互；设置为传递操作类型和四元数值类型。 Multiplayer Event System多人组件说明1.使用条件说明：如果同一设备上的多人游戏，每个人想要使用自己的一套独立UI，需要将EventSystem中的EventSystem组件替换为Multiplayer Event System组件； 2.Multiplayer Event System组件说明：与EventSystem组件不同，可以在场景中同时激活多个MultiplayerEventSystem，这样，您可以有多个玩家，每个玩家都有自己的InputSystemUIInputModule和MultiplayerEventSystem组件，每个玩家都可以有自己的一组操作来驱动自己的UI实例，如果您正在使用PlayerInput组件，还可以设置PlayerInput以自动配置玩家的InputSystemUIInputModule以使用玩家的操作；MultilayerEventSystem组件的属性与事件系统中的属性相同，此外，MultiplayerEventSystem组件还添加了一个playerRoot属性，您可以将其设置为一个游戏对象，该游戏对象包含此事件系统应在其层次结构中处理的所有UI可选择项； Tracked Device Raycaster组件配对VR中Canvas组件1.使用条件说明：如果想在VR项目中使用新输入系统配合UGUI使用，需要在Canvas对象上添加Tracked Device Raycaster组件； On-Screen组件（绝对重点）1.使用说明：On-Screen组件可以模拟UI和用户操作的交互，如On-Screen Button用来按钮交互，On-Screen Stick用来摇杆交互 InputDebug1.InputDebug说明：InputDebug顾名思义是输入调试器的意思，我们可以通过输入调试窗口检测输入相关信息，当我们的输入不按预期工作时，可以通过它来排查问题； 2.打开InputDebug窗口 1.Window(窗口)-&gt;Analysis(分析)-&gt;Input Debugger(输入调试器) 2.PlayerInput组件-&gt;Open Input Debugger InputDebug窗口信息说明1.Add Devices Not Listed in Supported Devices：添加未在支持的设备中列出的设备； 2.Enable Event Diagnostics：启用事件诊断； 3.Simulate TOuch Input From Mouse or pen：模拟鼠标或笔的触摸输入； 4.Remote Devices：远程设备； 5.Devices：系统中当前所有输入设备列表； 6.Unsupported：不支持、无法识别的设备列表； 7.Layouts：设备布局列表，所有已注册的设备控制列表； 8.Abstract Devices：抽象设备； 9.Specific Devices：特定设备； 10.Settings：设置相关，默认的一些特殊输入设置； 11.Metrics：指标相关，输入系统资源使用情况的统计信息； 知识补充InputSystem专门任意键方案（改键）1.方案说明：InputSystem.onAnyButtonPress.CallOnce((control) =&gt;（）； 如果用Call 按键盘会报错 但是也能正常执行； 用CallOnce 只会执行一次 但是不会报错； Json手动加载输入配置文件string json = Resources.Load&lt;TextAsset&gt;(\"PlayerInputTest\").text; InputActionAsset asset = InputActionAsset.FromJson(json); input.actions = asset; input.onActionTriggered += (context) =&gt; { if(context.phase == InputActionPhase.Performed) { switch (context.action.name) { case \"Move\": print(\"移动\"); break; case \"Look\": print(\"看向\"); break; case \"Fire\": print(\"开火\"); break; } } }; 改键","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"InputSystem","slug":"InputSystem","permalink":"https://wwy.wwywy.com/tags/InputSystem/"}]},{"title":"Lua热更新技术","slug":"04150-Lua热更新技术","date":"2021-10-28T13:00:00.000Z","updated":"2022-07-11T03:12:00.841Z","comments":true,"path":"posts/2152.html","link":"","permalink":"https://wwy.wwywy.com/posts/2152.html","excerpt":"","text":"热更新介绍1.热更新说明：游戏或者软件无需重新下载客户端进行安装，而是在应用程序启动情况下，在内部进行的资源或者代码更新，能迅速修复Bug、提升玩家留存率； 2.热更新分类：以下俩种 资源的热更新：Unity内置的有AssetBundle来进行资源热更； 逻辑的热更新：也就是对代码的热更新，一般使用xlua、tolua；","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"热更新","slug":"Game-Play/技术架构/热更新","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://wwy.wwywy.com/tags/Lua/"},{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"xLua","slug":"xLua","permalink":"https://wwy.wwywy.com/tags/xLua/"},{"name":"toLua","slug":"toLua","permalink":"https://wwy.wwywy.com/tags/toLua/"},{"name":"热更新","slug":"热更新","permalink":"https://wwy.wwywy.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Markdown语法格式（.md后缀-使用typora）","slug":"00001-Markdown语法格式","date":"2021-09-28T13:00:00.000Z","updated":"2022-07-09T16:11:56.033Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://wwy.wwywy.com/posts/1.html","excerpt":"","text":"Markdown基本语法格式标题：#标题1 （大） ##标题2 ###标题3 ####标题4 （小） 以此类推 最高标题6 代码块：​```代码块名称(可以输入各种语言java、c++、html等) 加粗：//加粗 **加粗** //代码高亮显示 ==高亮== //删除线 ~~删除线~~ //斜体 *斜体内容* 引用：//引用语法 &gt;作者：泽 &gt;&gt;作者：泽 &gt;&gt;&gt;作者：泽 分割线：//分割线 --- *** 图片插入：//在线图片与本地图片 ![照片名子]（/image/me.png） 超链接：//超链接语法 [超链接名字]（https://gihub.com/yerenping） 列表：//无需列表 - 目录1 -后加空格 - 目录2 - 目录3 //有序列表 1+. +名称 表格：右键》插入》表格 用代码过于复杂不推荐使用 用 Markdown 写数学公式Markdown 是很优秀的标记语言，目前很多平台都带 $\\TeX$ 公式引擎（XTeX, Mathjax 等）的 Markdown 编辑器。文章介绍使用 Typora 客户端做公式笔记，主要为多行公式的 $\\TeX$ 语法和公式识别两个问题。 Markdown 的用法本文不再赘述了，直接讲一下公式的问题： 行内公式和简单单行公式行内公式： 系统状态方程 $\\dot{x}=Ax$ 的解为 $x=e^Ax(0)$ 渲染效果： 系统状态方程 $\\dot{x}=Ax$ 的解为 $x=e^Ax(0)$ 简单行间公式： 系统状态方程 $\\dot{x}=Ax$ 的解为 $$ x=e^Ax(0) $$ 渲染效果： 系统状态方程 $\\dot{x}=Ax$ 的解为$$x=e^Ax(0)$$Remark： 在 Typora 中，公式功能需要自行开启 在 Typora 中，默认是无编号，需要自行开启 多行公式简单多行公式用法：用两个$$ 嵌套，或者使用 \\begin{equation}\\end{equation} 示例： $$ f_1(x)\\\\ % 使用 \\\\ 换行 f_2(x)\\label{Multi1} % 设置 label 是为了方便引用 $$ $$ \\begin{equation} f_1(x)\\\\ f_2(x)\\notag % \\notag 取消编号 \\end{equation} $$ 渲染效果$$f_1(x)\\f_2(x)\\label{Multi1}$$ $$\\begin{equation}f_1(x)\\f_2(x)\\notag\\end{equation}$$ Remark: 设置 label 可以很方便的引用公式，使用 \\eqref{} 引用 \\notag 可以取消编号，相应的，\\tag{} 可以设置任意的标注内容 array 环境array 环境用于简单的多行公式，比式 $\\eqref{Multi1}$ 多了一个对对齐选项 用法：\\begin{array}{l}\\end{array}，l 为对齐方式。left, right, center 示例： $$ \\begin{equation} \\dot{\\boldsymbol{x}}=f(\\boldsymbol{x}) =\\left\\{ \\begin{array}{ll} % 对齐选项有l/c/r(对应左中右)，需要几列就写几个 f_{1}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{1} \\\\ f_{2}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{2} % &amp; 分列，\\\\ 分行 \\end{array}\\right. \\end{equation} $$ 渲染效果：$$\\begin{equation}\\dot{\\boldsymbol{x}}=f(\\boldsymbol{x})=\\left{ \\begin{array}{ll} f_{1}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{1} \\ f_{2}(\\boldsymbol{x}) &amp; \\boldsymbol{x} \\in S_{2} \\end{array}\\right.\\end{equation}$$Remark: \\left\\{ 和 \\right. 用于自适应括号大小，只需要单边括号时，另一侧括号用 . 代替 大括号在 $\\LaTeX$ 中用作参数括号，需要加转义字符 \\ 使用 array 环境中需要几列就设置几列的对齐方式，使用 &amp; 分列，\\\\ 分行 \\boldsymbol{} 用于粗体数学符号 array 也用于矩阵输入，但矩阵现多使用 matrix 环境 aligned 环境aligned 环境用于需要设置对齐点的多行公式 用法：\\begin{aligned}\\end{ailgned} 示例： $$ \\begin{equation} \\begin{aligned} &amp;\\dot{\\boldsymbol{x}}=A \\boldsymbol{x}+B \\boldsymbol{u}, \\quad \\boldsymbol{x}(0)=\\boldsymbol{x}_{0}\\\\ % 使用 &amp; 设置对齐点，使用 \\\\ 分行 &amp;y=C x+D u \\end{aligned} \\end{equation} $$ 渲染效果：$$\\begin{equation}\\begin{aligned}&amp;\\dot{\\boldsymbol{x}}=A \\boldsymbol{x}+B \\boldsymbol{u}, \\quad \\boldsymbol{x}(0)=\\boldsymbol{x}_{0}\\&amp;y=C x+D u\\end{aligned}\\end{equation}$$Remark: aligned 需要 amsmath 宏包支持，现在大部分的引擎都会带有该宏包 \\quad 用于生成空白间距，类似的命令有：\\qquad \\, \\: \\; （正间距）\\! （负间距） 嵌套的 equation 环境是为了生成编号 在 $\\LaTeX$ 中aligned 是无法单独使用的，必须嵌套在 equation 环境中，在很多其他基于 $TeX$ 的引擎中，都默认省去了 equation 环境，任何行间公式都是当做 equaiton 环境处理，所以会出现 aligned 能够单独使用的情况，但是在需要编号的时候，aligned 是无法自动生成编号的，这是可以嵌套一个 equation 环境来生成编号 简单宏定义宏定义能够实现自定义算符、简化过于冗长的命令 自定义命令用法：\\newcommand\\定义命令[参数个数]{内容}（内容中用 #1, #2, #3 … 来设置形参） 自定义算符用法：\\DeclareMathOperator{\\定义命令}{算符} 示例： $$ \\newcommand{\\bx}{\\boldsymbol{x}} \\notag \\DeclareMathOperator{\\sign}{sign} $$ 渲染效果：$\\sign{x},\\bx$ (\\sign{x},\\bx) Remark: 声明需在文章最开头设置 在 Typora 中，如果公式渲染异常，可以再编辑中找到刷新公式 公式识别问题[Mathpix][] 提供 $\\LaTeX$ 公式识别，准确度很高，每月 50 次免费，推荐注册可以获得 50-200 次额外次数，API 可以获得没有 1000 次，日常使用是足够了。 参考文档文章简单介绍了几个多行公式的实现，这里再贴出几个文档，以飨读者： MathJax参考文档：http://docs.mathjax.org/en/latest/ LaTeX参考文档：http://www.ctan.org/pkg/lshort-zh-cn","categories":[{"name":"其他","slug":"其他","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://wwy.wwywy.com/tags/Markdown/"}]},{"title":"游戏程序基础框架实例","slug":"04010-游戏程序基础框架实例","date":"2021-09-20T13:00:00.000Z","updated":"2022-07-10T03:08:29.126Z","comments":true,"path":"posts/2056.html","link":"","permalink":"https://wwy.wwywy.com/posts/2056.html","excerpt":"","text":"单例管理者基类不继承自Mono1.利用单例模式和泛形去实现模块管理者基类； public class SingletonBase&lt;T&gt; where T:new() { private static T instance; public static T GetInstance() { if (instance == null) instance = new T(); return instance; } } 继承自Mono1.直接实例化通过生成游戏对象并且附加脚本；2.Awake实例化的话要保证单例的唯一性； public class SingletonMono&lt;T&gt; : MonoBehaviour where T : MonoBehaviour { private static T instance; public static T GetInstance() { if (instance == null) { GameObject go = new GameObject { name = typeof(T).Name, }; instance = go.AddComponent&lt;T&gt;(); DontDestroyOnLoad(go); } return instance; } protected virtual void Awake() { if (instance == null) { instance = this as T; DontDestroyOnLoad(gameObject); } } } 事件管理者1.观察者模式，利用了泛形和委托（事件）2.这里的事件字典只能对付小游戏，大型游戏仍是不够 public interface IEventInfo { } public class EventInfo : IEventInfo { public event UnityAction actions; public EventInfo(UnityAction action) { actions += action; } public void EventTrigger() { actions?.Invoke(); } } public class EventInfo&lt;T&gt; : IEventInfo { public event UnityAction&lt;T&gt; actions; public EventInfo(UnityAction&lt;T&gt; action) { actions += action; } public void EventTrigger(T Info) { actions?.Invoke(Info); } } public class EventMgr : SingletonBase&lt;EventMgr&gt; { //暂时只定义一个字典进行储存，小游戏够用了 private Dictionary&lt;string, IEventInfo&gt; eventDic = new Dictionary&lt;string, IEventInfo&gt;(); public void AddListenter(string name,UnityAction action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions += action; else eventDic.Add(name,new EventInfo(action)); } public void AddListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions += action; else eventDic.Add(name, new EventInfo&lt;T&gt;(action)); } public void RemoveListenter(string name, UnityAction action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).actions -= action; } public void RemoveListenter&lt;T&gt;(string name, UnityAction&lt;T&gt; action) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).actions -= action; } public void EventTrigger(string name) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo).EventTrigger(); } public void EventTrigger&lt;T&gt;(string name,T info) { if (eventDic.TryGetValue(name, out IEventInfo eventInfo)) (eventInfo as EventInfo&lt;T&gt;).EventTrigger(info); } public void Clear() { eventDic.Clear(); } } Mono根节点1.可以创建一个全局唯一的Mono节点使用2.实现游戏入口继承自该节点即可，但是实现Awake单例 public class MonoRoot : SingletonMono&lt;MonoRoot&gt; { private event UnityAction updateActions; protected override void Awake() { base.Awake(); } protected virtual void Update() { updateActions?.Invoke(); } public void AddUpdateListenter(UnityAction updateAction) { updateActions += updateAction; } public void RemoveUpdateListenter(UnityAction updateAction) { updateActions -= updateAction; } } 资源加载管理者1.资源加载有同步加载和异步加载，异步加载用协程实现2.资源加载管理者包括场景切换，以及配置文件加载 public class ResMgr : SingletonBase&lt;ResMgr&gt; { #region 资源加载 private Dictionary&lt;string,Object&gt; ObjCacheDic=new Dictionary&lt;string, Object&gt;(); public T LoadObj&lt;T&gt;(string path , bool isIns=true , bool isCache= true ) where T : Object { T obj; if (ObjCacheDic.TryGetValue(path, out Object cacheObj)) obj = cacheObj as T; else { obj = Resources.Load&lt;T&gt;(path); if (isCache) ObjCacheDic.Add(path, obj); }; if (obj is GameObject &amp;&amp; isIns) return GameObject.Instantiate(obj); else return obj; } public void LoadObjAsyn&lt;T&gt;(string path,UnityAction&lt;T&gt; callback, bool isIns = true, bool isCache = true) where T : Object { if (ObjCacheDic.TryGetValue(path, out Object obj)) { if (obj is GameObject &amp;&amp; isIns) callback(GameObject.Instantiate(obj) as T); else callback(obj as T); } else MonoRoot.GetInstance().StartCoroutine(ReallyLoadObjAsyn(path, callback, isIns, isCache)); } public IEnumerator ReallyLoadObjAsyn&lt;T&gt;(string path, UnityAction&lt;T&gt; callback, bool isIns, bool isCache) where T : Object { ResourceRequest r = Resources.LoadAsync&lt;T&gt;(path); yield return r; if(isCache) ObjCacheDic.Add(path, r.asset); if (r.asset is GameObject &amp;&amp; isIns) callback(GameObject.Instantiate(r.asset) as T); else callback(r.asset as T); } #endregion #region 场景切换 public void LoadScene(string name, UnityAction fun) { //场景同步加载 SceneManager.LoadScene(name); //加载完成过后 才会去执行fun fun(); } public void LoadSceneAsyn(string name, UnityAction fun) { MonoRoot.GetInstance().StartCoroutine(ReallyLoadSceneAsyn(name, fun)); } public IEnumerator ReallyLoadSceneAsyn(string name, UnityAction fun) { AsyncOperation op = SceneManager.LoadSceneAsync(name); while (!op.isDone) { //这里可以去做一些事情，例如更新进度条 //EventMgr.GetInstance().EventTrigger(\"更新进度条\", op.progress); yield return op.progress; } //加载完成过后 才会去执行fun fun(); } #endregion } 缓存池管理者1.用一个类类型去包装缓存队列，这个类里面应该封装了获取和设置缓存对象的方法2.缓存池目前只支持预制物的缓存 public class PoolMgr :SingletonBase&lt;PoolMgr&gt; { private Dictionary&lt;string, PoolData&gt; poolDic=new Dictionary&lt;string, PoolData&gt;(); private GameObject poolRoot; public void GetObj(string name, UnityAction&lt;GameObject&gt; callBack) { if(poolDic.TryGetValue(name, out PoolData poolData) &amp;&amp; poolData.Count &gt; 0) { callBack(poolData.GetObj()); } else { //创建资源应使用资源路径 ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(name, (go) =&gt;{ go.name = name; callBack(go); }); } } public void PushObj(string name,GameObject obj) { if(poolRoot=null)poolRoot=new GameObject(\"PoolRoot\"); if(poolDic.TryGetValue(name,out PoolData poolData)) poolData.PushObj(obj); else poolDic.Add(name, new PoolData(obj,poolRoot)); } public void Clear() { poolDic.Clear(); poolRoot = null; } } public class PoolData { private GameObject parentRoot; private Queue&lt;GameObject&gt; objQue; public PoolData(GameObject obj,GameObject poolObj) { parentRoot = new GameObject($\"{obj.name}Root\"); parentRoot.transform.parent = poolObj.transform; objQue = new Queue&lt;GameObject&gt;(); } public int Count { get { return objQue.Count; } } public void PushObj(GameObject obj) { //存起来 objQue.Enqueue(obj); //失活 让其隐藏 obj.SetActive(false); //设置父对象 obj.transform.parent = parentRoot.transform; } public GameObject GetObj() { //取出第一个 GameObject obj = objQue.Dequeue(); //激活 让其显示 obj.SetActive(true); //断开了父子关系 obj.transform.parent = null; return obj; } } 输入管理者1.输入管理者耦合事件监听和Mono根节点 public class InputMgr : SingletonBase&lt;InputMgr&gt; { private bool isStart = false; public InputMgr() { MonoMgr.GetInstance().AddUpdateListener(UpdateIpt); } public void StartOrEndCheck(bool isOpen) { isStart = isOpen; } private void CheckKeyCode(KeyCode key) { //事件中心模块 分发按下抬起事件 if (Input.GetKeyDown(key)) EventCenter.GetInstance().EventTrigger(\"某键按下\", key); //事件中心模块 分发按下抬起事件 if (Input.GetKeyUp(key)) EventCenter.GetInstance().EventTrigger(\"某键抬起\", key); } private void UpdateIpt() { //没有开启输入检测 就不去检测 直接return if (!isStart) return; CheckKeyCode(KeyCode.W); CheckKeyCode(KeyCode.S); CheckKeyCode(KeyCode.A); CheckKeyCode(KeyCode.D); } } 音效管理者1.一般音效资源应该做缓存池处理 public class MusicMgr : MonoBehaviour { private bool isMute = false; //背景音乐源 private AudioSource bkSource; //背景音乐大小 private float bkValue = 1; //一般音乐列表 private List&lt;AudioSource&gt; sourceLst = new List&lt;AudioSource&gt;(); //背景音乐大小 private float soundValue = 1; //音乐源节点 private GameObject musicRoot; public MusicMgr() { MonoMgr.GetInstance().AddUpdateListener(UpdateMsc); } //音乐播放完就回收 private void UpdateMsc() { for (int i = sourceLst.Count - 1; i &gt;= 0; --i) { if (!sourceLst[i].isPlaying) { GameObject.Destroy(sourceLst[i]); sourceLst.RemoveAt(i); } } } public void PlayBkMusic(string name) { if(!musicRoot) musicRoot=new GameObject(\"MusicRoot\"); if (bkSource) bkSource = musicRoot.AddComponent&lt;AudioSource&gt;(); //异步加载背景音乐 加载完成后 播放 ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;(\"Music/BK/\" + name, (clip) =&gt; { bkSource.clip = clip; bkSource.loop = true; bkSource.volume = bkValue; bkSource.Play(); }); } public void PauseBKMusic() { bkSource?.Pause(); } public void StopBKMusic() { bkSource?.Stop(); } public void ChangeBKValue(float v) { bkValue = v; if (bkSource == null) bkSource.volume = bkValue; } public void PlaySound(string name, bool isLoop=false, GameObject parent=null, UnityAction&lt;AudioSource&gt; callBack = null) { if (!musicRoot) musicRoot = new GameObject(\"MusicRoot\"); //当音效资源异步加载结束后 再添加一个音效 ResMgr.GetInstance().LoadObjAsyn&lt;AudioClip&gt;(\"Music/Sound/\" + name, (clip) =&gt; { AudioSource source; if (parent) source=parent.AddComponent&lt;AudioSource&gt;(); else source = musicRoot.AddComponent&lt;AudioSource&gt;(); source.clip = clip; source.loop = isLoop; source.volume = soundValue; source.Play(); sourceLst.Add(source); if (callBack != null) callBack(source); }); } public void ChangeSoundValue(float value) { soundValue = value; for (int i = 0; i &lt; sourceLst.Count; ++i) sourceLst[i].volume = value; } public void StopSound(AudioSource source) { if (sourceLst.Contains(source)) { sourceLst.Remove(source); source.Stop(); GameObject.Destroy(source); } } } UI管理者和UI面板基类面板基类public class BasePanel : MonoBehaviour { //通过里式转换原则 来存储所有的控件 private Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt; controlDic = new Dictionary&lt;string, List&lt;UIBehaviour&gt;&gt;(); protected virtual void Awake() { FindChildrenControl&lt;Button&gt;(); FindChildrenControl&lt;Image&gt;(); FindChildrenControl&lt;Text&gt;(); FindChildrenControl&lt;Toggle&gt;(); FindChildrenControl&lt;Slider&gt;(); FindChildrenControl&lt;ScrollRect&gt;(); FindChildrenControl&lt;InputField&gt;(); } public virtual void ShowMe() { } public virtual void HideMe() { } protected virtual void OnClick(string btnName) { } protected virtual void OnValueChanged(string toggleName, bool value) { } protected T GetControl&lt;T&gt;(string controlName) where T : UIBehaviour { if (controlDic.ContainsKey(controlName)) { for (int i = 0; i &lt; controlDic[controlName].Count; ++i) { if (controlDic[controlName][i] is T) return controlDic[controlName][i] as T; } } return null; } private void FindChildrenControl&lt;T&gt;() where T : UIBehaviour { T[] controls = this.GetComponentsInChildren&lt;T&gt;(); for (int i = 0; i &lt; controls.Length; ++i) { string objName = controls[i].gameObject.name; if (controlDic.ContainsKey(objName)) controlDic[objName].Add(controls[i]); else controlDic.Add(objName, new List&lt;UIBehaviour&gt;() { controls[i] }); //如果是按钮控件 if (controls[i] is Button) { (controls[i] as Button).onClick.AddListener(() =&gt; { OnClick(objName); }); } //如果是单选框或者多选框 else if (controls[i] is Toggle) { (controls[i] as Toggle).onValueChanged.AddListener((value) =&gt; { OnValueChanged(objName, value); }); } } } } UI管理者public class UIMgr : SingletonBase&lt;UIMgr&gt; { public Dictionary&lt;string, BasePanel&gt; panelDic = new Dictionary&lt;string, BasePanel&gt;(); private Transform bot; private Transform mid; private Transform top; private Transform system; //记录我们UI的Canvas父对象 方便以后外部可能会使用它 public RectTransform canvas; public UIMgr() { //创建Canvas 让其过场景的时候 不被移除 GameObject obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;(\"UI/Canvas\"); canvas = obj.transform as RectTransform; GameObject.DontDestroyOnLoad(obj); //找到各层 bot = canvas.Find(\"Bot\"); mid = canvas.Find(\"Mid\"); top = canvas.Find(\"Top\"); system = canvas.Find(\"System\"); //创建EventSystem 让其过场景的时候 不被移除 obj = ResMgr.GetInstance().LoadObj&lt;GameObject&gt;(\"UI/EventSystem\"); GameObject.DontDestroyOnLoad(obj); } /// &lt;summary&gt; /// 通过层级枚举 得到对应层级的父对象 /// &lt;/summary&gt; /// &lt;param name=\"layer\"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Transform GetLayerFather(EUIayer layer) { switch (layer) { case EUIayer.Bot: return this.bot; case EUIayer.Mid: return this.mid; case EUIayer.Top: return this.top; case EUIayer.System: return this.system; } return null; } /// &lt;summary&gt; /// 显示面板 /// &lt;/summary&gt; /// &lt;typeparam name=\"T\"&gt;面板脚本类型&lt;/typeparam&gt; /// &lt;param name=\"panelName\"&gt;面板名&lt;/param&gt; /// &lt;param name=\"layer\"&gt;显示在哪一层&lt;/param&gt; /// &lt;param name=\"callBack\"&gt;当面板预设体创建成功后 你想做的事&lt;/param&gt; public void ShowPanel&lt;T&gt;(string panelName, EUIayer layer = EUIayer.Mid, UnityAction&lt;T&gt; callBack = null) where T : BasePanel { if (panelDic.ContainsKey(panelName)) { panelDic[panelName].ShowMe(); // 处理面板创建完成后的逻辑 if (callBack != null) callBack(panelDic[panelName] as T); //避免面板重复加载 如果存在该面板 即直接显示 调用回调函数后 直接return 不再处理后面的异步加载逻辑 return; } ResMgr.GetInstance().LoadObjAsyn&lt;GameObject&gt;(\"UI/\" + panelName, (obj) =&gt; { //把他作为 Canvas的子对象 //并且 要设置它的相对位置 //找到父对象 你到底显示在哪一层 Transform father = bot; switch (layer) { case EUIayer.Mid: father = mid; break; case EUIayer.Top: father = top; break; case EUIayer.System: father = system; break; } //设置父对象 设置相对位置和大小 obj.transform.SetParent(father); obj.transform.localPosition = Vector3.zero; obj.transform.localScale = Vector3.one; (obj.transform as RectTransform).offsetMax = Vector2.zero; (obj.transform as RectTransform).offsetMin = Vector2.zero; //得到预设体身上的面板脚本 T panel = obj.GetComponent&lt;T&gt;(); // 处理面板创建完成后的逻辑 if (callBack != null) callBack(panel); panel.ShowMe(); //把面板存起来 panelDic.Add(panelName, panel); }); } /// &lt;summary&gt; /// 隐藏面板 /// &lt;/summary&gt; /// &lt;param name=\"panelName\"&gt;&lt;/param&gt; public void HidePanel(string panelName) { if (panelDic.ContainsKey(panelName)) { panelDic[panelName].HideMe(); GameObject.Destroy(panelDic[panelName].gameObject); panelDic.Remove(panelName); } } /// &lt;summary&gt; /// 得到某一个已经显示的面板 方便外部使用 /// &lt;/summary&gt; public T GetPanel&lt;T&gt;(string name) where T : BasePanel { if (panelDic.ContainsKey(name)) return panelDic[name] as T; return null; } /// &lt;summary&gt; /// 给控件添加自定义事件监听 /// &lt;/summary&gt; /// &lt;param name=\"control\"&gt;控件对象&lt;/param&gt; /// &lt;param name=\"type\"&gt;事件类型&lt;/param&gt; /// &lt;param name=\"callBack\"&gt;事件的响应函数&lt;/param&gt; public static void AddCustomEventListener(UIBehaviour control, EventTriggerType type, UnityAction&lt;BaseEventData&gt; callBack) { EventTrigger trigger = control.GetComponent&lt;EventTrigger&gt;(); if (trigger == null) trigger = control.gameObject.AddComponent&lt;EventTrigger&gt;(); EventTrigger.Entry entry = new EventTrigger.Entry(); entry.eventID = type; entry.callback.AddListener(callBack); trigger.triggers.Add(entry); } } /// &lt;summary&gt; /// UI层级 /// &lt;/summary&gt; public enum EUIayer { Bot, Mid, Top, System, }","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"Unity进阶-Addressables","slug":"03015-Unity进阶-Addressables","date":"2021-08-21T13:00:00.000Z","updated":"2022-07-09T16:17:35.718Z","comments":true,"path":"posts/1549.html","link":"","permalink":"https://wwy.wwywy.com/posts/1549.html","excerpt":"","text":"Addressables概述1.Addressables说明：Addressables是基于AssetBundle架构做的高阶流程，目的是实现资源自动化管理，Addressables翻译过来是可寻址的意思，它是可寻址资源管理系统，是Unity从2018.2版本开始，建议用于替代AssetBundle的高阶资源管理系统，在之后的Unity的新版本中，AssetBundle将渐渐被淘汰； 2.Addressables的优点： 自动化管理AB包打包、发布、加载； 可以更方便的进行本地、远程资源的加载； 系统会自动处理资源关联性； 内存管理更方便； 迭代更方便； 3.Addressables使用方法： 导入包：在Package Manager中导入该包； 创建配置文件：在Window找到Addressables中的Groups点击创建配置文件，或者直接在Inspector窗口勾选Addressable就会自动创建； 资源加载基础寻址资源设置1.让资源变为可寻址资源: //方法一：选中资源，勾选Inspector窗口中的Addressable //方法二：选中资源，拖入Addressables Groups窗口中 //注意： //1.C#代码无法作为可寻址资源 //2.Resources文件夹下资源如果变为寻址资源，会移入Resources_moved文件夹中 // 原因：Resources文件夹下资源会最终打包出去，如果变为可寻址资源意味着想通过Addressables进行管理 // 那么它就没有必要通过Resources方式去加载和打包，所以会自动迁移，避免重复打包，浪费空间 //3.右键选择资源时菜单内容 //Move Addressables to Group：将该资源放入到现有的另一个组中 //Move Addressables to New Gourp：使用与当前组相同设置创建一个新租，并将该资源放入该新组中 //Rmove Addressables：移除资源，该资源会变为不可寻址资源 //Simplify Addressable Names：简化可寻址资源名，会删除名称中的路径和拓展，简化缩短名称 //Copy Address to Clipboard：将地址复制到剪贴板 //Change Address：改名 //Create New Group：创建新租 2.资源组窗口讲解: (1).资源信息（关键） //1.GroupName\\Addressable Name：分组名\\可寻址名（可重名，描述资源） //2.Path：路径（不可重复，资源定位） //3.Labels：标签（可重复、可用于区分资源种类，例如青铜装备、黄金装备） (2).创建分组相关 //Create——&gt;Group //Packed Assets:打包资源分组 //Blank(no schema):空白（无架构） //区别：Packed Assets默认自带默认打包加载相关设置信息，Blank没有相关信息需要自己关联 //组对于我们来说意义重大，之后在资源打包时，一个组可以作为一个或多个AB包 //关于组设置相关信息，之后详细讲解 (3).选中某一组后右键 //Remove Group(s):移除组，组中所有资源恢复为不可寻址资源 //Simplify Addressable Names:简化可寻址名称，会删除名称中的路径和拓展，简化缩短名称 //Set as Default:设置为默认组，当直接勾选资源中的Addressable时，会自动加入该组 //Inspect Group Setting:快速选中关联的组相关配置文件 //Rename:重命名 //Create New Group:创建新组 (4).配置概述相关 //Manage Profiles：管理配置文件 //可以配置打包目标、本地远程的打包加载路径等等信息（之后再详细讲解） (5).Tools工具相关 //Inspect System Settings：检查系统设置 //Check for content Update Restrictions:检查内容更新限制 //Window：打开Addressables相关窗口 //Groups View：分组视图相关 // Show Sprite and Subobject Addressable：显示可寻址对象的精灵和子对象，一般想要看到图集资源内内容时可以勾选该选项 // Group Hierarchy with Dashes：带破折号的组层次结构 (6).Play Mode Script播放模式脚本（编辑模式下如何运行） //确定在编辑器播放模式下运行游戏时，可寻址系统如何访问可寻址资源 //Use Asset Database（fastest）： //使用资源数据库（最快的），一般在开发阶段使用，使用此选项时，您不必打包可寻址内容，它会直接使用文件夹中的资源 //在实际开发时，可以不使用这种模式，这种模式没有测试的意义 //Simulate Groups（advanced）： //模拟组（后期），一般在测试阶段使用，分析布局和依赖项的内容，而不创建AB包 //通过ResourceManager从资产数据库加载资产，就像通过AB包加载一样 //通过引入时间延迟，模拟远程资产绑定的下载速度和本地绑定的文件加载速度 //在开发阶段可以使用这个模式来进行资源加载 //Use Existing Build（requires built groups）： //正儿八经的从AB包加载资源 //使用现有AB包（需要构建AB包），一般在最终发布测试阶段使用 //从早期内容版本创建的AB包加载资产 //在使用此选项之前，必须使用生成脚本（如默认生成脚本）打包资源 //远程内容必须托管在用于生成内容的配置文件的RemoteLoadPath上 (7).Build（构建打包相关） //New Build：构建AB包资源（相当于打包资源分组） //Update a Previour Build：更新以前的版本 //Clean Build：清空之前的构建资源 3.资源名注意事项: //1.资源路径一定不允许相同（后缀不同，名字相同可以） //2.资源名我们可以随意修改 //3.之后在加载资源时我们可以使用名字和标签作为双标识加载指定资源 //4.我们可以按规则将资源进行分组,比如：角色、装备、怪物、UI等等 指定资源加载（不常用）1.Addressables中的资源标识类 //AssetReference 通用资源标识类 可以用来加载任意类型资源 //AssetReferenceAtlasedSprite 图集资源标识类 //AssetReferenceGameObject 游戏对象资源标识类 //AssetReferenceSprite 精灵图片资源标识类 //AssetReferenceTexture 贴图资源标识类 //AssetReferenceTexture2D //AssetReferenceTexture3D //AssetReferenceT&lt;&gt; 指定类型标识类 //通过不同类型标识类对象的申明 我们可以在Inspector窗口中筛选关联的资源对象 2.加载资源 //注意：所有Addressables加载相关都使用异步加载 //需要引用命名空间：using UnityEngine.ResourceManagement.AsyncOperations; //AsyncOperationHandle&lt;GameObject&gt; handle = assetReference.LoadAssetAsync&lt;GameObject&gt;(); //加载成功后使用 //1.通过事件函数传入的参数判断加载是否成功 并且创建 //2.通过资源标识类对象判断 并且创建 //一步到位，通过异步加载返回值 对完成进行事件监听 assetReference.LoadAssetAsync&lt;GameObject&gt;().Completed += (handle) =&gt; { //使用传入的参数（建议） //判断是否加载成功 if (handle.Status == AsyncOperationStatus.Succeeded) { GameObject cube = Instantiate(handle.Result); //一定资源加载过后 使用完后 再去释放 assetReference.ReleaseAsset(); } //使用标识类创建,现在不推荐 //if(assetReference.IsDone)Instantiate(assetReference.Asset); }; 3.加载场景 sceneReference.LoadSceneAsync().Completed += (handle) =&gt; { //初始化场景的一些信息，和资源加载相同 print(\"场景加载结束\"); }; 4.释放资源 //释放资源相关API //ReleaseAsset //写在外部是不合理的，一般写在加载字资源后 //assetReference.ReleaseAsset(); //1.释放资源方法后,资源标识类中的资源会置空，但是AsyncOperationHandle类中的对象不为空 //2.释放资源不会影响场景中被实例化出来的对象，但是会影响使用的资源，例如贴图等，和AssetBundle是一样的； 5.直接实例化对象 //只适用于 想要实例化的 对象 才会直接使用该方法 一般都是GameObject预设体 gameobjcetReference.InstantiateAsync(); 6.自定义标识类 //自定义类 继承AssetReferenceT&lt;Material&gt;类 即可自定义一个指定类型的标识类 //该功能主要用于Unity2020.1之前，因为之前的版本不能直接使用AssetReferenceT泛型字段 Label标签1.Label标签的作用：可以在寻址资源设置中，为相同作用的资源（模型、贴图、材质、UI等），我们可以让他们的资源名相同，通过标签Label区分他们来加载使用； 2.Label标签特性约束：通过特性[AssetReferenceUILabelRestriction()]来约束资源，里面可以填多个标签名； 动态加载资源1.通过资源名或标签名动态加载单个资源 //命名空间： //UnityEngine.AddressableAssets 和 UnityEngine.ResourceManagement.AsyncOperations //参数名可以是资源名也可以是标签名 Addressables.LoadAssetAsync&lt;GameObject&gt;(\"Red\").Completed += (handle) =&gt; { //判断加载成功 if (handle.Status == AsyncOperationStatus.Succeeded) Instantiate(handle.Result); //一定要是 加载完成后 使用完毕后 再去释放 //需要指定要释放哪一个返回值,不管任何资源 只要释放后 都会影响之前在使用该资源的对象 Addressables.Release(handle); }; //注意： //1.如果存在同名或同标签的同类型资源，我们无法确定加载的哪一个，它会自动加载找到的第一个满足条件的对象 //2.如果存在同名或同标签的不同类型资源，我们可以根据泛型类型来决定加载哪一个 2.根据资源名或标签名加载多个对象 //加载资源 //参数一：资源名或标签名 //参数二：加载结束后的回调函数 //参数三：如果为true表示当资源加载失败时，会自动将已加载的资源和依赖都释放掉；如果为false，需要自己手动来管理释放 AsyncOperationHandle&lt;IList&lt;Object&gt;&gt; handle = Addressables.LoadAssetsAsync&lt;Object&gt;(\"Red\", (obj) =&gt; { //释放资源 Addressables.Release(obj); }); 3.根据多种信息加载对象 //参数一：想要加载资源的条件列表（资源名、Lable名） //参数二：每个加载资源结束后会调用的函数，会把加载到的资源传入该函数中 //参数三：可寻址的合并模式，用于合并请求结果的选项。 //如果键（Cube，Red）映射到结果（[1,2,3]，[1,3,4]），数字代表不同的资源 //None：不发生合并，将使用第一组结果 结果为[1,2,3] //UseFirst：应用第一组结果 结果为[1,2,3] //Union：合并所有结果 结果为[1,2,3,4] //Intersection：使用相交结果 结果为[1,3] //参数四：如果为true表示当资源加载失败时，会自动将已加载的资源和依赖都释放掉 // 如果为false，需要自己手动来管理释放 List&lt;string&gt; strs = new List&lt;string&gt;() { \"Cube\", \"HD\" }; Addressables.LoadAssetsAsync&lt;Object&gt;(strs, (obj) =&gt; { print(obj.name); }, Addressables.MergeMode.Intersection); 4.动态加载场景 //参数一：场景名 //参数二：加载模式 （叠加还是单独,叠加就是两个场景一起显示,单独就是只保留新加载的场景，正常情况为单独） //参数三：场景加载是否激活，如果为false，加载完成后不会直接切换，需要自己使用返回值中的ActivateAsync方法 //参数四：场景加载的异步操作优先级 Addressables.LoadSceneAsync(\"SampleScene\", UnityEngine.SceneManagement.LoadSceneMode.Single, false).Completed += (obj)=&gt; { //比如说 手动激活场景 obj.Result.ActivateAsync().completed += (a) =&gt; { //然后再去创建场景上的对象 //然后再去隐藏 加载界面 //注意：场景资源也是可以释放的，并不会影响当前已经加载出来的场景，因为场景的本质只是配置文件 Addressables.Release(obj); }; }; 窗口相关Profile概述配置窗口1.Profiles窗口打开方式 //方法一：Window &gt; Asset Management &gt; Addressables &gt; Profiles //方法二：在AddressableAssetSettings中打开 //方法三：在Addressables Groups窗口中打开 2.Profiles窗口参数相关 (1).右侧 BuildTarget：构建目标，可以在这里设置是哪个平台，默认是你激活哪个平台就是哪个平台 LocalBuildPath：本地构建路径，默认在项目的Library库文件夹中 LocalLoadPath：本地加载路径，在哪里加载本地已有的资源 RemoteBuildPath：远程构建路径 RemoteLoadPath：远程加载路径，在哪里下载远程内容和目录 (2).左侧 Profile：概述文件 Variable：变量（所有概述文件通用） Build Load Path Variables：构建加载路径变量（所有概述文件通用） (3).注意： 1.一般情况下，不要去修改本地构建和加载路径默认值 2.当我们针对不同平台远程分发内容时，通过多个配置文件最方便。如果你想要最终的发布包包含所有内容，那么一个默认配置就够了 3.Profiles变量语法 //所有的变量类型都是string字符串类型 //你可以在其中填写一些固定的路径或值来决定路径 //还可以使用两个语法指示符让原本的静态属性变成动态属性 //[]:方括号，可以使用它包裹变量，在打包构建时会计算方括号包围的内容 //比如 //使用自己的变量[BuildTarget] //使用别的脚本中变量[UnityEditor.EditorUserBuildSettings.activeBuildTarget] //在打包构建时，会使用方括号内变量对应的字符串拼接到目录中 //{}:大括号，可以使用它包裹变量，在运行时会计算大括号包围的内容 //比如 //使用别的脚本中变量{UnityEngine.AddressableAssets.Addressables.RuntimePath} //注意：方括号和大括号中使用的变量一定是静态变量或者属性。名称、类型、命名空间必须匹配 //比如在运行时 UnityEditor编辑器命名空间下的内容是不能使用的 Addressables Hosting可寻址托管窗口1.Addressables Hosting可寻址托管窗口的作用 //一般资源服务器需要将其搭建为http服务器 //这样才能进行资源的上传和下载 //而Unity为了简化本地测试的这一过程 //提供了快捷搭建http服务器的工具 // Addressables Hosting 窗口 //通过它我们可以将我们的本机模拟为一台远端服务器来进行远端发布加载测试 //可以帮助我们快速的进行远程打包下载的相关测试 //简单理解就是把本机作为一台资源服务器 2.打开可寻址托管窗口 //方法一：Window &gt; Asset Management &gt; Addressables &gt; Hosting //方法二：Addressables Groups窗口中 &gt; Tools &gt; Window &gt; Hosting Services 3.可寻址托管窗口参数 (1).左边区域： Local Hosting：本地托管，通过本机模拟加载相关内容 Custom Service：自定义服务 (2).右边区域: Service Name：服务器名称 Service Type（ID）：服务器类型 Port：端口号（一般不自己设置，避免和其它应用产生冲突） Upload Speed（kb/s）：上载速度 Enable：是否启用，启用后会自动分配端口号 Hosting Service Variables-托管服务变量(IP地址、端口号等，我们可以使用这些变量名来编辑Addressables Profiles中的发布和加载相关路径，如http://[PrivateIpAddress]:[HostingServicePort]/[BuildTarget])： Variable Name：变量名 Value：值 4.注意事项 //Addressable Hosting窗口创建的本地服务器有时候会失效 //可以在资料区下载第三方工具 让本机变为一个http服务器 模拟远端加载 事件查看窗口1.事件查看查看说明 //使用可寻址事件查看窗口可以监视可寻址资源的资源内存管理 //该窗口 //1.显示应用程序何时加载和卸载资源 //2.显示所有可寻址系统操作的引用计数 //3.显示应用程序帧率和分配的内存总量近似图 //我们可以通过它来检查可寻址资源对性能的影响 //并检查没有释放的资源 2.打开事件查看窗口 //注意：使用事件查看窗口的前提要打开AddressablesAssetSettings配置文件中的事件发送开关 //1.Window &gt; Asset Management &gt; Addressables &gt; Event Viewer //2.Addressabeles Groups &gt; Window &gt; Event Viewer 3.事件查看窗口参数 (1).左上角： Clear Event：清楚所有记录的帧，会清空窗口中所有内容； Unhide All Hidden Events：显示你隐藏的所有事件内容（当我们右键一个内容隐藏后才会显示该选项）； (2).右上角： Frame：显示当前所在帧数； 左按钮和右按钮：在记录的帧中前后切换查看信息； Current:选中当前帧； (3).中央部分： FPS:应用的帧率； MonoHeap：正在使用的托管堆内存量； Event Counts：事件计数，某一帧中发生的可寻址事件的数量； Instantiation Counts:实例化计数，某一帧中Addressables.InstantiateAsync的调用数量； 线性图标：显示统计的什么时候加载释放资源的信息； Event 相关：显示当前帧中发生的可寻址操作的事件； 分析窗口Analyze tool | Addressables | 1.18.19 (unity.cn) 1.分析窗口说明： //分析窗口是一种收集项目可寻址布局信息的工具 //它是一种信息工具，可以让我们对可寻址文件布局做出更明智的决定 2.打开分析窗口： //1.Window &gt; Asset Management &gt; Addressables &gt; Analyze //2.Addressabeles Groups &gt; Window &gt; Analyze 3.分析窗口参数说明： (1).上方三个按钮: Analyze Selected Rules：分析选定的规则; Clear Selected Rules：清除选定规则; Fix Selected Rules：修复选定规则; (2).下方的内容Analyze Rules（分析规则） a.Fixable Rules-可修复的规则（提供了分析和修复两种功能的规则出现在这里）： Check Duplicate Bundle Dependencies:检查重复的AB包依赖项，比如资源a和b，都使用了材质c，a和b是可寻址资源，c不是可寻址资源，a，b分别在两个AB包中，那么这时两个AB包中都会有资源c，这时就可以通过该规则排查出该问题，那么这时我们可以选择自己重新处理后打包，也可以选择修复功能，建议使用自己处理问题，因为某些特殊情况它也会认为有问题，比如，一个FBX中有多个网格信息a，b，这时我们分别把网格a放入包A，网格b放入包B，它也会认为A和B有重复资源，但其实他们并没有重复； b.Unfixable Rules-不可修复的规则（对于只有分析功能，没有修复功能的规则在这里出现）: Check Resources to Addressable Duplicate Dependencies:检查可寻址重复依赖项的资源,同时出现在可寻址资源和应用程序构建的资源中,比如一个资源A，它是可寻址资源,但是它同时在Resources、StreamingAssets等特殊文件夹中，最终会被打包出去; Check Scene to Addressable Duplicate Dependencies:检查场景到可寻址重复依赖项,同时出现在可寻址资源和某一个场景中,比如一个资源A，它是可寻址资源但是它有直接出现在某一个场景中,这时你需要自己根据需求进行处理; Bundle Layout Preview:AB包布局预览 构建布局报告1.构建布局报告说明： //构建布局报告提供了有关可寻址资源的构建打包的详细信息和统计信息 //包括 //1.AB包的描述 //2.每个资源和AB包的大小 //3.解析作为依赖项隐式包含在AB包中的不可寻址资源 //4.AB包的依赖关系 //我们可以通过查看报告文件获取这些信息 2.如何查看构建布局报告： //1.启用调试构建布局功能 //Edit &gt; Preferences &gt; Addressables //启用Debug Build Layout //2.只要我们构建打包可寻址资源后 //就可以在Library/com.unity.addressables/文件夹中找到buildlayout.txt文件 3.构建布局报告的内容： //内容中主要包含： //1.摘要信息(包括AB包数量、大小等等) //2.每组相关信息（哪些资源，几个包，包大小等等） //3.依赖相关信息 配置相关1.配置文件分类：我们在导入Addressables包之后创建的那些就是配置文件，AddressableAssetsData文件夹下的内容都是本质为ScriptableObject的数据配置文件，他们会影响我们的打包方式等等相关内容； AssetGroups(资源组)：当我们创建一个组就会多一些相关数据配置文件 AssetGroupTemplates：资源组模板，主要是对资源组的一些默认设置，可以自己创建模板在Project窗口右键或者点击+号，Create(创建)——&gt;Addressables(可寻址)——&gt;Group Templates(组模板)——&gt;Blank Group Template(空白组模板)； Packed Assets：默认的打包资源数据配置模板； DataBuilders：数据生成器，这些内容决定了在不同模式下，资源打包和使用的方式； BuildScriptFastMode：构建脚本快速模式 ； BuildScriptPackedMode：构建脚本打包模式； BuildScriptPackedPlayMode：构建脚本打包播放模式； BuildScriptVirtualMode：构建脚本虚拟模式； AddressableAssetSettings：可寻址资源设置，该配置文件可以设置一些可寻址资源的一些公共设置； DefaultObject：默认对象； AddressableAssetSetting配置（可寻址资源设置）1.Profile-概述配置: Profile In Use：可以在这选择使用的是哪一套配置文件 Manage Profiles：点击它会打开管理配置文件窗口 2.Diagnostics-诊断: Send Profiler Events：启用分析器事件，启用它后我们可以在Event Viewer窗口查看Addressable相关信息 Log Runtime Exceptions：记录运行时加载相关的异常 3.Catalog-目录相关设置，将资源的地址映射到其物理位置: Player Version Override：重写用于制定远程目录名称的时间戳,如果不设置默认使用时间戳作为远程目录命名; Compress Local Catalog：在压缩的AssetBundle文件中生成目录。可以压缩大小，但是会增加生成和加载的时间 Optimize Catalog Size：通过为内部ID创建查找表来减小目录的大小。会增加加载目录所需的时间 4.Content Update-内容更新: Disable Catalog Update on Startup：当可寻址系统在运行时初始化时，禁用自动检查更新的远程目录。您可以手动检查更新的目录。 Content State Build Path：在何处生成由默认生成脚本生成的内容状态文件。 Build Remote Catalog-构建远程目录(勾选后会出现新选项): Build &amp; Load Paths：在何处生成和加载远程目录。从列表中选择一个配置文件路径，如果要分别设置生成路径和加载路径，请选择&lt;custom&gt;,仅在启用生成远程目录时可见; Build Path：远程构建路径，在何处构建远程目录。通常，应该使用RemoteBuildPath配置文件变量,仅当将生成和加载路径设置为&lt;custom&gt;时显示; Load Path：远程加载路径，用于访问远程目录的URL。通常，应该使用RemoteLoadPath配置文件变量,仅当将生成和加载路径设置为&lt;custom&gt;时显示; Path Preview：路径预览 5.(不重要)Custom Certificeate handle：用于自定义证书处理的类。该列表包含项目中扩展UnityEngine的所有类。网络。证书管理员。 Max Concurrent Web Requests：系统对超过此限制的任何请求进行队列处理 Catalog Download Timeout：等待目录文件下载的时间为多少秒。 6.Build-生成构建相关设置： Ignore Invalid/Unsupported Files in Build：忽略生成中无效不受支持的文件，如果启用，Addressable生成脚本将排除无效或不受支持的文件，而不是中止生成； Unique Bundle IDs：唯一约束ID，是否为每个构建中的包生成一个唯一的名称； Contiguous Bundles：连续捆绑，生成更高效的捆绑包布局。如果您有Addressables 1.12.1或更早版本生成的捆绑包，请禁用此选项以最小化捆绑包更改； Non-Recursive Dependency Calculation：非递归依赖计算，不使用递归计算依赖项； Shader Bundle Naming Prefix：着色器包命名前缀； MonoScript Bundle Naming Prefix：Mono脚本包命名前缀； Strip Unity Version From AssetBundles：从AssetBUndles中剥离Unity版本，决定是否从包头中删除版本信息； Disable Visible Sub Asset Representations：禁用可见子资源，如果您不直接使用子对象(Sprite、子网格等)，则启用此选项可以提高构建时间； 7.Build and Play Mode Scripts-构建和编辑器模式脚本，在编辑器中进入播放模式时，选择Addressable系统如何加载资产，这些脚本处理默认的构建进程，并提供不同的方式在编辑模式下访问数据，我们可以在AddressableAssetData/DataBuilders文件夹中找到这些脚本，如果要为他们自定义脚本，那么对应的脚本需要时BuildScriptBase的子类，并且继承IDataBuilder： Use Asset Database：使用资源数据库 Simulate Groups：模拟组 Use Existing Build：使用现有版本 Default Build Scripts:默认生成脚本 8.Asset Group Templates-资源组模板: Packed Asset：打包资源,定义可用于创建新组的模板列表,创建新模板时，必须先将其添加到此列表中，然后才能使用它,Addressables包包含一个模板,其中包含默认构建脚本使用的模式。您可以在AddressableAssetData/AssetGroupTemplates文件夹中找到该模板。 9.Initialization Objects-初始化对象列表：配置初始化对象，可以在Project右键Create&gt;Addressables&gt;Initialization(初始化)&gt;Cache Initialization Setting（缓存初始化设置）； Compress Bundles：是否压缩包 Cache Directory Override：缓存目录覆盖 [Obsolete]Expiration Delay：过期延迟（过时了） Limit Cache Size：限制缓存的大小 Maximum Cache Size：最大缓存大小 Packed Assets打包资源配置1.Content Packing &amp; Loading： Build &amp; Load Paths：配置文件路径对，定义可寻址构建系统在哪个路径为此组创建内容，以及可寻址系统在运行时在何处加载这些内容，只有定义为Custom时才会出现下面的选项； Build Path-打包路径： LocalBuildPath-本地路径 RemoteBuildPath-远程路径 Load Path-加载路径： LocalLoadPath-本地路径 RemoteLoadPath-远程路径 Path Preview：路径预览 2.Advanced Options-高级选项: (1*).Asset Bundle Compression：AB包的压缩方式，默认为LZ4，它通常是最有效的选项，建议使用; Uncompressed：不压缩，包较大，不推荐; LZ4：压缩，相对LZMA大一点点，建议使用，用什么解压什么，内存占用低; LZMA：压缩最小，解压慢，用一个资源要解压所有; (2*).Include In Build：包含在构建中，是否在内容生成中包含此组中的资源。如果取消勾选，那么在选择打包时，不会打包该组内容; (3)Force Unique Provider：强制唯一提供者，Addressable是否对此组使用资源提供程序类的唯一实例。如果您有此组中的资产类型的自定义提供程序实现，并且这些提供程序的实例不能在组之间共享，则启用此选项。 (4*).Use Asset Bundle Cache：使用AB包缓存，是否缓存远程分发的包; (5*).Asset Bundle CRC-是否在加载前验证AB包的完整性: Disabled：永远不检查完整性 Enabled，Including Cached：检查完整性，包括缓存也检查 Enabled，Excluding Cached：检查完整性，但是不检查缓存的包 (6).Use UnityWebRequest for Local Asset Bundle：加载AB包时，使用UnityWebRequestAssetBundle.GetAssetBundle而不是AssetBundle.LoadFromFileAsync； (7).Request Timeout：下载远程包时超时的间隔时间; (8).Use Http Chunked Transfer：下载包时是否使用HTTP/1.1块传输编码方法(在2019.3+中被废弃和忽略); (9).Http Redirect Limit：下载包时允许重定向的次数。无限制设置为-1; (10).Retry Count：重试失败下载的次数; (11).Include Addresses in Catalog：是否将地址字符串包括在目录中。如果不使用地址字符串在组中加载资产，则可以通过不包括它们来减小目录的大小; (12*).Include GUIDs in Catalog：是否在目录中包含GUID字符串。您必须包含guid字符串才能使用资产参考。如果不使用AssetReferences或GUID字符串在组中加载资产，则可以通过不包括它们来减小目录的大小; (13*).Include Labels in Catalog：是否在目录中包含标签字符串。如果不使用标签在组中加载资产，则可以通过不包括这些资产来缩小目录的大小; (14*).Internal Asset Naming Mode-如何在内部命名目录中的资源: Full Path：全路径 FileName：文件名 GUID：资源的Guid字符串 Dynamic：Addressables根据组中的资源选择最小的内部名称 (15).Internal Bundle Id Mode-确定如何构造资产绑定的内部ID。例如，当您设置群GUID选项，Addressables通过将组名与包guid字符串组合来创建包ID: Group Guid：组的Guid Group Guid Project Id Hash：组的ID和工程ID的哈希 Group Guid Project Id Entries Hash：组的ID和工程ID项的哈希 (16*).Cache Clear Behavior-确定安装的应用程序何时从缓存中清除AB包: Clear When Space Is Needed In Cache：在缓存中需要空间时清除; Clear When When new Version Loaded：加载新版本时清楚; (17*).Bundle Mode-打包模式，如何将此组中的资产打包到包中： Pack Together：创建包含所有资产的单个包； Pack Separately：为组中的每个主要资产创建一个包。如精灵图片中的精灵图片被包装在一起。添加到组中的文件夹中的资产也打包在一起； Pack Together by Label：为共享相同标签组合的资产创建一个包； (18).Bundle Naming Mode-如何构造AB包的文件名: Filename：文件名 Append Hash to Filename：将哈希附加到文件名 Use Hash of AssetBundle：使用AB包的哈希 Use Hash of FileName：使用文件名的哈希 (19*).Asset Load Mode-资源加载模式: Requested Asset And Dependencies：请求的资源和依赖项; All Packed Assets And Dependencies：所有包中的资源和依赖项; (20).Asset Provider-资源提供者,定义提供程序类Addressable用于从该组生成的AssetBundles加载资产。将此选项设置为Bundles供应商的资产除非您有一个自定义提供程序实现来从资产绑定中提供资产: Content Catalog Provider：内容目录提供器 AssetBundle Provider：AB包提供器 Assets from AssetDatabase Provider：资源来自资源数据库提供器 Sprites from Atlases Provider：精灵来自图集提供器 Assets from bundles provider：资源来自绑定提供器 Json Asset Provider：Json资源提供器 Assets from Legacy Resources:资源来自遗留的Resources提供器 Text Data Provider：文本数据提供器 Virtual AssetBundle Provider：虚拟AB包提供器 Assets from Virtual Bundles：资源来自虚拟绑定 (21).Asset Bundle Provider：AB包提供器,定义由该组生成的提供程序类Addressable用于加载AssetBundles。将此选项设置为资产束提供者除非您有一个自定义提供程序实现来提供资产绑定; 3.Content Update Restricion-内容更新限制: Can Change Post Release：可以改变发行后内容，该模式不移动任何资源，如果包中的任何资源发生了更改，则重新构建整个包; Cannot Change Post Release：无法改变发布后内容，如果包中任何资源已经改变，则[检查内容更新限制]工具会将其移动到为更新创建的新组中。在进行更新构建时，从这个新组创建的AssetBundles中的资产将覆盖现有包中的版本; 4.Add Schema（添加模式）-你可以将任意数量的架构模式分配给一个组,我们甚至可以通过继承AddressableAssetGroupSchema定义自己的架构模式; Content Packing Loading：内容打包加载相关; Content Update Restriction：内容更新限制; Resources and Built In Scenes：在内置数据中显示哪些类型的内置资源，可以选择是否显示 资源和内置场景; 资源打包（发布）1.资源打包注意事项： 场景资源始终有自己单独的包：当一个可寻址包中有场景资源和普通资源时，场景资源和其它资源始终会被分开打包； 资源依赖的注意事项：类似于AssetBundle，如果资源a和资源b都使用了资源c，但是资源a和b是可寻址资源但不在一个组中，而c不是可寻址资源，那么这时资源c分别会被打进a和b的包，相当于这时的c就被重复利用了，浪费了空间，较好的解决方案是:将c也作为可寻址资源， a-A包 b-B包 c-C包， 这时c不会被打进A、B包，A、B包只会依赖于C，而Addressable会自动帮助我们处理依赖问题； 合理安排可寻址资源分组：同类型，同作用放一起，比如角色组、怪物组、武器组、衣服组、登录UI组、装备UI组、音效组、可变贴图组、图集组等等； 关于包的数量（分组的数量）：要根据实际情况来对资源进行布局，包(分组)过多、包(分组)过大都不太好，要根据自己的实际情况进行组的安排； 2.本地资源发布：所有组的加载和发布都选择本地路劲，LocalBuildPath-打包路径，LocalLoadPath-加载路径（注意：使用默认设置，当发布应用程序时，会自动帮我们将AB包放入StreamingAssets文件夹中，如果修改了路径，我们需要自己将内容放入StreamingAssets文件夹中）； 3.远程资源发布：在远端的电脑上搭建Http服务器，将打包出来的资源上传到对应服务器上即可，资源加载组时会自动判断是本地资源还是远端资源，无需向AssetBundle一样进行手动设置； 4.资源更新：当项目正式发布后，对于远程加载的资源，我们可以通过改变资源服务器上的AB包来更新游戏，和AssetBundle不同的是，Addressables会自动帮助我们判断哪些资源更新了，并加载最新的内容； 整包更新：组设置为 Can Change Post Release，直接在Build中点击资源更新而不是发布，之后会让选择一个更新日志文件，覆盖即可，整包更新指，某一个分组的资源发生变化后，我们需要将其整体进行打包，这种方式适用于大范围资源更新时使用； 局部更新：组设置为 Cannot Change Post Release，首先先在Tools工具下检查更新，然后再Build中更新资源，这步同上，当资源有变化时，我们可以单位发生变化的内容变成AB包，之后使用该资源，Addressables会自动加载最新的内容，它相对整包更新来说，更节约时间和流量； 补充知识资源加载相关根据资源定位信息加载资源1.加载资源Addressables做的事情： 1.查找指定键的资源位置； 2.收集依赖项列表； 3.下载所需的所有远程AB包； 4.将AB包加载到内存中； 5.设置Result资源对象的值； 6.更新Status状态变量参数并且调用完成事件Completed（如果我们启用了 Log Runtime Exceptions选项 会在Console窗口打印信息）； 2.资源定位信息API使用： Addressables.LoadResourceLocationsAsync(基本和资源加载一样)，使用它可以获取一些额外信息，可以利用这些信息处理一些特殊需求，并且资源定位信息加载资源并不会加大我们的开销； PrimaryKey：资源主键（资源名）； InternalId：资源内部ID（资源路径）； ResourceType：资源类型（Type可以获取资源类型名）；异步加载的其他方式 1.协同程序： IEnumerator LoadAsset() { handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(\"Cube\"); //一定是没有加载成功 再去 yield return if(!handle.IsDone) yield return handle; //加载成功 那么久可以使用了 if (handle.Status == AsyncOperationStatus.Succeeded) { print(\"协同程序创建对象\"); Instantiate(handle.Result); } else Addressables.Release(handle); } 2.异步函数（async和await ） async void Load() { handle = Addressables.LoadAssetAsync&lt;GameObject&gt;(\"Cube\"); AsyncOperationHandle&lt;GameObject&gt; handle2 = Addressables.LoadAssetAsync&lt;GameObject&gt;(\"Sphere\"); //单任务等待 //await handle.Task; //多任务等待 await Task.WhenAll(handle.Task, handle2.Task); print(\"异步函数的形式加载的资源\"); Instantiate(handle.Result); Instantiate(handle2.Result); } 关于AsyncOperationHandle1.无类型句柄转换 AsyncOperationHandle&lt;Texture2D&gt; handle = Addressables.LoadAssetAsync&lt;Texture2D&gt;(\"Cube\"); AsyncOperationHandle temp = handle; //把无类型句柄 转换为 有类型的泛型对象 handle = temp.Convert&lt;Texture2D&gt;(); 2.获取加载进度 while (!handle.IsDone) { DownloadStatus info = handle.GetDownloadStatus(); //进度 print(info.Percent); //字节加载进度 代表 AB包 加载了多少 //当前下载了多少内容 / 总体有多少内容 单位是字节数 print(info.DownloadedBytes + \"/\" + info.TotalBytes); yield return 0; } 自定义更新目录和下载AB包1.目录的作用 //目录文件的本质是Json文件和一个Hash文件 //其中记录的主要内容有 //Json文件中记录的是： //1.加载AB包、图集、资源、场景、实例化对象所用的脚本（会通过反射去加载他们来使用） //2.AB包中所有资源类型对应的类（会通过反射去加载他们来使用） //3.AB包对应路径 //4.资源的path名 //等等 //Hash文件中记录的是： //目录文件对应hash码（每一个文件都有一个唯一码，用来判断文件是否变化） //更新时本地的文件hash码会和远端目录的hash码进行对比 //如果发现不一样就会更新目录文件 //当我们使用远端发布内容时，在资源服务器也会有一个目录文件 //Addressables会在运行时自动管理目录 //如果远端目录发生变化了(他会通过hash文件里面存储的数据判断是否是新目录) //它会自动下载新版本并将其加载到内存中 2.手动更新目录 //1.如果要手动更新目录 建议在设置中关闭自动更新 //2.自动检查所有目录是否有更新，并更新目录API Addressables.UpdateCatalogs().Completed += (obj) =&gt; { Addressables.Release(obj); }; //3.获取目录列表，再更新目录 //参数 bool 就是加载结束后 会不会自动释放异步加载的句柄 Addressables.CheckForCatalogUpdates(true).Completed += (obj) =&gt; { //如果列表里面的内容大于0 证明有可以更新的目录 if(obj.Result.Count &gt; 0) { //根据目录列表更新目录 Addressables.UpdateCatalogs(obj.Result, true).Completed += (handle) =&gt; { //如果更新完毕 记得释放资源 //Addressables.Release(handle); //Addressables.Release(obj); }; } }; 3.预加载包 //建议通过协程来加载 StartCoroutine(LoadAsset()); //定义协程 IEnumerator LoadAsset() { //1.首先获取下载包的大小 //可以传资源名、标签名、或者两者的组合 AsyncOperationHandle&lt;long&gt; handleSize = Addressables.GetDownloadSizeAsync(new List&lt;string&gt;() { \"Cube\", \"Sphere\", \"SD\" }); yield return handleSize; //2.预加载 if(handleSize.Result &gt; 0) { //这样就可以异步加载 所有依赖的AB包相关内容了 AsyncOperationHandle handle = Addressables.DownloadDependenciesAsync(new List&lt;string&gt;() { \"Cube\", \"Sphere\", \"SD\" }, Addressables.MergeMode.Union); while(!handle.IsDone) { //3.加载进度 DownloadStatus info = handle.GetDownloadStatus(); print(info.Percent); print(info.DownloadedBytes + \"/\" + info.TotalBytes); yield return 0; } Addressables.Release(handle); } } 引用计数规则1.引用计数规则说明：Addressables内部会通过引用计数帮助我们管理内存，我们只需要保证 加载和卸载资源配对使用即可，以下分俩步来解释； 计数说明：当我们通过加载使用可寻址资源时，Addressables会在内部帮助我们进行引用计数，使用资源时，引用计数+1，释放资源时，引用计数-1，当可寻址资源的引用为0时，就可以卸载它了，同时，AB包也有自己的引用计数（Addressables把它也视为可寻址资源），和资源计数类似但是分开计算； 资源释放说明：为了避免内存泄露（不需要使用的内容残留在内存中），我们要保证加载资源和卸载资源是配对使用的，释放的资源不一定立即从内存中卸载，在卸载资源所属的AB包之前，不会释放资源使用的内存(比如自己所在的AB包 被别人使用时，这时AB包不会被卸载，所以自己还在内存中)，我们可以使用Resources.UnloadUnusedAssets卸载资源（建议在切换场景时调用）； 常见问题说明1.用多包策略还是大包策略？ //1.AB包太多(太小)的问题 // 1-1:每个包都会有内存开销，如果加载过多的包可能会带来更多的内存消耗 // 1-2:并发下载的问题，如果包小而多，以为着下载包时可能需要更多的时间 // 1-3:目录文件会因为过多的包而变大，因为它要记录更多的包信息 // 1-4:复用资源的可能性更大，比如多个包使用同样一个资源，但是该资源不是寻址资源，那么在每个包中都会有该资源 //2.AB包太少(太大)的问题 // 1-1:过大的包如果下载失败，下次会重新下载，因为使用UnityWebRequest下载包时不会恢复失败的下载 // 比如100MB的包，下了50MB，玩家中断下载了，下次又得重新下 // 1-2:能单独加载，但是不能单独卸载，更大的包意味着包中有更多资源，比如加载了1个大包中100个资源 // 但是现在用完了99个，还剩一个再用，即使99都卸载了，但是由于引用计数这个大包也不会卸载 // 就会造成内存的浪费 //所以没有最好的策略，只有根据自己的项目需求合理安排分组打包 //要根据资源的使用情况来合理设置资源分组，在分组时权衡好各方面的问题 2.哪种压缩方式更好？ //AB包的压缩方式：不压缩、LZ4、LZMA //一般情况LZ4用于本地资源，LZMA用于远端资源 //主要原因是LZMA的压缩内容更小，更节约下载时间和流量 //注意：压缩不会影响加载内存的大小，只会影响包体大小，下载时间等 //但是也要根据实际情况 //比如： //1.不压缩：包体并不大的单机游戏，使用不压缩最好，没有包体大小的压力，加载也是最快的，因为不用解压 //2.LZ4：它是基于块的压缩，所以提供了加载文件的能力，加载资源时不用全加载AB包，只加载使用的内容，相对LZMA来说更节约内存 //3.LZMA：不建议用它在本地内容中，因为它虽然包最小，但是加载最慢，用它只是为了节约下载时间和极限压缩包体大小 //综合来说，也没有最优的方式，还是要根据实际情况来选择 //个人认为LZ4压缩方式，是相对比较优秀的一种方式 3.减小目录文件大小 //当我们想要极限压缩包体大小时，可能希望优化目录文件的大小 //1.压缩本地目录 // AddressableAssetSettings &gt; Catalog &gt; Compress Local Catalog //2.禁用内置场景和资源（Built In Data禁用） // 默认Addressables提供了从Resources等内置资源文件夹中加载资源以及加载内置场景 // 如果你不通过Addressables加载他们，可以禁用，这样目录文件就不会包含其中信息 // 但是我们就只能使用老方法加载同名 // 个人建议取消，因为一般我们不会通过Addressables去加载非寻址资源 4.其他事项 //1.关于AB包最大的限制，老版本不支持大于4G的包，虽然新版本中已经没有这个限制 //但是为了兼容性，还是建议大小控制在4G以下 //2.活用可寻址资源上的Groups View中的两个功能 //Show Sprite and Subobject Addresses:当窗口中内容特别多时，禁用它可以提升窗口加载的性能 //Group Hierarchy with Dashes：启用带破折号的层级结构 // 可以让我们在内容特别多时以层级结构查看分组信息","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Addressables","slug":"Addressables","permalink":"https://wwy.wwywy.com/tags/Addressables/"}]},{"title":"Git版本控制工具使用","slug":"00100-Git版本控制工具使用","date":"2021-07-01T13:00:00.000Z","updated":"2022-07-10T03:10:03.124Z","comments":true,"path":"posts/64.html","link":"","permalink":"https://wwy.wwywy.com/posts/64.html","excerpt":"","text":"Git的介绍1.Git是什么：Git是目前世界上最先进的分布式版本控制系统，工作流程，Workspace（工作区）——Index / Stage（暂存区）——Repository（本地仓库）——Remote（远程仓库）； 2.SVN与Git的最主要的区别： SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了； Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了； 3.Git的安装和配置：在Windows下安装Git如下步骤 从官网下载Git安装，并且打开Git Bash，打开成功说明安装成功； 安装后进行配置，git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，配置用户名（user.name）以及配置邮箱（user.email）； 基本操作1.版本库的说明：什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”； 在任意目录下，使用命令git init把这个目录变成git可以管理的仓库； 使用命令git add 文件名.后缀名添加到暂存区中； 再用命令git commit -m ‘注释’ 将文件提交到仓库； 提交文件前可以用git status查看下状态 2.版本回退： 用git log可以查看历史记录，查看的记录都是注释的，所以养成注释的良好习惯,参数加–pretty=oneline只显示版本信息； git reflog来显示所有的操作，这样即使回滚了也能看到； 使用git reset –hard HEAD^将版本回退到上一个版本，HEAD指的是当前分支； ^代表的是上个版本，如果上上个就是^^； 也可以在hard后面直接接版本号信息，直接恢复到那个状态； 3.工作区和暂存区的区别：、 工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴； 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD 4.Git撤销修改和删除文件操作： 撤销修改：目前来说有俩种方法，一是手动更改add再commit，第二种恢复上一个版本,但是如果俩种都不想使用，可以使用git checkout – 文件名 来丢弃工作区的修改（注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了）； 删除：使用rm 文件名命令就可以了，彻底删除再执行commit，没有commit用撤销修改命令就可以了； 远程仓库1.远程仓库说明：在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置： 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令，ssh-keygen -t rsa –C “youremail@example.com”，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人； 第二步：登录github，点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容； 2.远程仓库的操作： 创建远程仓库：登录github上，然后在右上角找到“create a new repo”创建一个新的仓库； 本地关联远程：使用git remote add origin 远程仓库名； 本地推送远程（先本地库后远程库）：使用git push [-u] origin master 命令把当前master分支推送到远端，加上-u参数，不仅进行推送，还会进行分支关联； 本地克隆远程（先远程库后本地库）：使用git clone 远程仓库名； 分支管理1.分支的相关操作： 查看分支：git branch 创建分支：git branch 分支名 切换分支：git checkout 分支名 创建+切换分支：git checkout –b 分支名 合并某分支到当前分支：git merge 分支名 删除分支：git branch –d 分支名 2.分支冲突：Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容； 3.分支管理策略： 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式，git merge –no-ff 分支名； 其次master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来； 4.Bug分支：使用git stash隐藏工作现场； 小乌龟Git教程git小乌龟的使用 - 走看看 (zoukankan.com) 命令大全新建代码库#在当前目录新建一个Git代码库 $ git init #新建一个目录，将其初始化为Git代码库 $ git init [project-name] #下载一个项目和它的整个代码历史 $ git clone [url] 配置# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他# 生成一个可供发布的压缩包 $ git archive","categories":[{"name":"其他","slug":"其他","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://wwy.wwywy.com/tags/Git/"}]},{"title":"常用排序算法","slug":"01041-常用排序算法","date":"2021-06-30T13:00:00.000Z","updated":"2022-07-10T03:11:01.463Z","comments":true,"path":"posts/545.html","link":"","permalink":"https://wwy.wwywy.com/posts/545.html","excerpt":"","text":"列举一些常用的排序算法 #冒泡排序 /// &lt;summary&gt; /// 冒泡排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void BubbleSort(int[] array, int count) { //设置标识符，如果为false意为当前数组为有序，不需要再排序了 bool shouldSorted = true; for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++) { shouldSorted = false; for (int j = count - 1; j &gt; i; j--) { if (array[j - 1] &gt; array[j]) { shouldSorted = true; Utilities.Swap(ref array[j - 1], ref array[j]); } } } } #选择排序 /// &lt;summary&gt; /// 选择排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void SelectSort(int[] array, int count) { int min; for (int i = 0; i &lt; count - 1; i++) { min = i; for (int j = i + 1; j &lt; count; j++) { if (array[min] &gt; array[j]) { min = j; } } if (min != i) { Utilities.Swap(ref array[min], ref array[i]); } } } #插入排序 /// &lt;summary&gt; /// 插入排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void InserSort(int[] array, int count) { int guard; //哨兵，用于暂存需要交换的值 for (int i = 0; i &lt; count - 1; i++) { if (array[i] &gt; array[i + 1]) { guard = array[i + 1]; int j; for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--) { array[j + 1] = array[j]; //赋值操作（依次后移） } array[j + 1] = guard; } } } #希尔排序 /// &lt;summary&gt; /// 希尔排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void ShellSort(int[] array, int count) { int i, j, guard; int increment = count; do { increment = increment / 3 + 1; //增量序列 for (i = increment + 1; i &lt; count; i++) { if (array[i] &lt; array[i - increment]) { guard = array[i]; //暂存在哨兵处 for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment) { array[j + increment] = array[j]; //记录后移，查找插入位置 } array[j + increment] = guard; //插入 } } } while (increment &gt; 1); } #堆排序 /// &lt;summary&gt; /// 堆排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void HeapSort(int[] array, int count) { for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆 { HeapAdjust(array, i, count - 1); } for (int i = count - 1; i &gt; 0; i--) { Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换 HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆 } } /// &lt;summary&gt; /// 堆排序_构造大顶堆函数 /// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义 /// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"startIndex\"&gt;起始位置&lt;/param&gt; /// &lt;param name=\"endIndex\"&gt;结束位置&lt;/param&gt; public static void HeapAdjust(int[] array, int startIndex, int endIndex) { int temp; temp = array[startIndex]; for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选 { if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1]) { ++i; //i为关键字中较大记录的下标 } if (temp &gt; array[i]) { break; //rc应插入在位置s上 } array[startIndex] = array[i]; startIndex = i; } array[startIndex] = temp; //插入 } #归并排序 /// &lt;summary&gt; /// 归并排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void MergeSort(int[] array, int count) { int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果 int k = 1; while (k &lt; count) { MergePass(array, tempArray, k, count); //array归并到tempArray k = 2 * k; //子序列长度加倍 MergePass(tempArray, array, k, count); //tempArray归并到array k = 2 * k; //子序列长度加倍 } } /// &lt;summary&gt; /// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"srChildLength\"&gt;SR中子序列长度&lt;/param&gt; /// &lt;param name=\"arrayLength\"&gt;原数组长度&lt;/param&gt; public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength) { int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数 while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, hasMergeCount + 2 * srChildLength - 2); //两两归并 hasMergeCount += 2 * srChildLength; } if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1); } else //若最后只剩下单个子序列 { for (int j = hasMergeCount - 1; j &lt; arrayLength; j++) { tr[j] = sr[j]; } } } /// &lt;summary&gt; /// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"sr1StartIndex\"&gt;SR数组子序列1起始位置&lt;/param&gt; /// &lt;param name=\"sr1EndIndex\"&gt;SR数组子序列1结束位置&lt;/param&gt; /// &lt;param name=\"sr2EndIndex\"&gt;SR数组子序列2结束位置&lt;/param&gt; private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex) { int sr2StartIndex, currentProcess; //currentProcess为当前进度 for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex; sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex; currentProcess++) //两个SR有一个被榨干后就要退出循环 { if (sr[sr1StartIndex] &lt; sr[sr2StartIndex]) { tr[currentProcess] = sr[sr1StartIndex++]; } else { tr[currentProcess] = sr[sr2StartIndex++]; } } if (sr1StartIndex &lt;= sr1EndIndex) { for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++) { tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR } } if (sr2StartIndex &lt;= sr2EndIndex) { for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++) { tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR } } } #快速排序 /// &lt;summary&gt; /// 快速排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void QuickSort(int[] array, int count) { QSort(array, 0, count - 1); } /// &lt;summary&gt; /// 快速排序_递归调用 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; private static void QSort(int[] array, int low, int high) { int pivot; while (low &lt; high) { pivot = Partition(array, low, high); QSort(array, low, pivot - 1); //尾递归，可以减少一次递归堆栈深度 low = pivot + 1; } } /// &lt;summary&gt; /// 获取枢轴数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static int Partition(int[] array, int low, int high) { int pivotkey; int m = low + (high - low) / 2; //下面是三数取中优化 //交换左端与右端数据，保证左端较小 if (array[low] &gt; array[high]) { Utilities.Swap(ref array[low],ref array[high]); } //交换中间与右端数据，保证中间较小 if (array[m] &gt; array[high]) { Utilities.Swap(ref array[m],ref array[high]); } //交换中间与左端数据，保证左端较小 if (array[m] &gt; array[low]) { Utilities.Swap(ref array[low],ref array[m]); } //默认选取当前数组的第一个值作为枢轴值 pivotkey = array[low]; //枢轴备份 int pivotkeyback = pivotkey; while (low &lt; high) { while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey) { high--; } array[low] = array[high]; while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey) { low++; } array[high] = array[low]; } //将枢轴数值替换回array[low] array[low] = pivotkeyback; //返回当前枢轴下标 return low; } #各种排序时空复杂度n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"大学知识/CS基础/数据结构和算法","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"游戏MVC系列框架","slug":"04003-游戏MVC系列框架","date":"2021-06-15T13:00:00.000Z","updated":"2022-07-09T16:20:23.554Z","comments":true,"path":"posts/2051.html","link":"","permalink":"https://wwy.wwywy.com/posts/2051.html","excerpt":"","text":"MVC基本概念：MVC全名是Model View Controller是模型(model)－视图(view)－控制器(controller)的缩写,是一种软件设计规范，用一种业务逻辑、数据、界面显示 分离的方法,组织代码,将业务逻辑聚集到一个部件里面，在改进和个性化定制,界面及用户交互的同时，不需要重新编写业务逻辑; 流程：View（界面）触发事件—Controller（业务）处理了业务触发数据更新—更新Model的数据—Model（带着数据）回到了View—View更新数据; 总结：MVC主要用于软件和WEB开发；在游戏中时非必须的UI系统开发框架； 不使用MVC的逻辑： public class PlayerLevPanel : MonoBehaviour { public Button btnLevUp; public Button btnClose; //展示UI面板 public static void ShowMe() { //todo } //隐藏UI面板 public static void HideMe() { //todo } void Start() { //2.监听事件 btnClose.onClick.AddListener(ClickClose); btnLevUp.onClick.AddListener(ClickLevUp); } public void ClickClose() { Debug.Log(\"关闭\"); HideMe(); } public void ClickLevUp() { Debug.Log(\"升级\"); //存储数据 //同步更新面板上的数据 UpdateInfo(); //更新主面板的内容 MainPanel.Panel.UpdateInfo(); } //3.更新面板 public void UpdateInfo() { //更新数据 } } 不使用MVC总结：所有的逻辑都在一个类中，小项目可以这么做，但是当项目累计到一定的程度，面板类变多时，耦合会非常高，牵一发而变全身，并且不适合团队开发； 使用MVC：Model层：负责增删查改获取界面上需要的数据 public class PlayerLevModel{ //定义数据 private int lev; //外界只能获取字段 public int Lev { get { return lev; } } //通知外部更新的事件 //通过它和外部建立联系 而不是直接获取外部的面板 private event UnityAction&lt;PlayerLevModel&gt; updateEvent; //在外部第一次获取这个数据 如何获取 //通过单例模式 来达到数据的唯一性 和数据的获取 private static PlayerLevModel data = null; public static PlayerLevModel Data { get { if( data == null ) { data = new PlayerLevModel(); data.Init(); } return data; } } //数据相关的操作 // 初始化 public void Init() { lev = PlayerPrefs.GetInt(\"PlayerLev\", 1); } } public void LevUp() { //升级 改变内容 lev += 1; //改变过后保存 SaveData(); } public void SaveData() { //把这些数据内容 存储到本地 PlayerPrefs.SetInt(\"PlayerLev\", lev); UpdateInfo(); } public void AddEventListener(UnityAction&lt;PlayerModel&gt; function) { updateEvent += function; } public void RemoveEventListener(UnityAction&lt;PlayerModel&gt; function) { updateEvent -= function; } //通知外部更新外部数据的方法 private void UpdateInfo() { //找到对应的 使用数据的脚本 去更新数据 updateEvent?Invoke(this); } 视图层：负责获取控件，更新控件信息 public class PlayerLevView : MonoBehaviour{ //1.找控件 public Button btnClose; public Button btnLevUp; //2.提供面板更新的相关方法给外部 public void UpdateInfo(PlayerModel data) { txtLev.text = \"LV.\" + data.Lev; } } 控制层：负责业务逻辑处理（界面事件监听，触发数据更新，触发界面更新） public class PlayerLevController : MonoBehaviour{ //视图实例，这里视图和控制在一个物体上 private PlayerLevView roleView; private static PlayerLevController controller = null; //控制层单例 public static PlayerLevController Controller { get { return controller; } } public static void ShowMe() { if (controller == null) { //实例化面板对象 //设置它的父对象 为Canvas } //如果是隐藏的形式hide 在这要显示 controller.gameObject.SetActive(true); } public static void HideMe() { if (controller != null) { //方式一 直接删 //方式二 设置可见为隐藏 } } void Start() { //这里视图和控制在一个物体上 roleView = this.GetComponent&lt;RoleView&gt;(); //第一次更新面板 roleView.UpdateInfo(PlayerLevModel.Data); roleView.btnClose.onClick.AddListener(ClickCloseBtn); roleView.btnLevUp.onClick.AddListener(ClickLevUpBtn); //告知数据模块 当更新时 通知哪个函数做处理 PlayerModel.Data.AddEventListener(UpdateInfo); } private void ClickCloseBtn() { HideMe(); } private void ClickLevUpBtn() { //通过数据模块 进行升级 达到数据改变 PlayerLevModel.Data.LevUp(); } private void UpdateInfo( PlayerModel data ) { if( roleView != null ) { roleView.UpdateInfo(data); } } private void OnDestroy() { PlayerLevModel.Data.RemoveEventListener(UpdateInfo); } } 好处：1.各司其职，互不干涉 —— 编程思路更清晰2.有利开发中的分工 —— 多人协同开发时，同步并行3.有利于组件重用 —— 项目换皮时，功能变化小时，提高开发效率缺点：1.增加了程序文件的体量 —— 脚本由一变三2.增加了结构的复杂性 —— 对于不清楚MVC原理的人不友好2.效率相对较低 —— 对象之间的相互跳转，始终伴随着一定开销（UI影响不大） MV*的概念MVC美中不足：M和V之间存在联系，也就是数据和界面存在耦合，数据结构改变会牵扯界面逻辑改变； 所以我们必须要改变这一现状，但是M和V层是必须的，所以可以通过改变X元素来优化原来的M和V，也就是改变联系和处理M和V的方式。 MVP 切断View和Model的耦合，让Presenter处理一切,在MVC中View会直接从Model中读取数据而不是通过 Controller,而在MVP中View并不直接使用Model，它们之间的通信是通过Presenter,来进行的，所有的交互都发生在Presenter内部. Model层:不变 View层:不能直接传入Model模型来更新 Presenter(主持人)：在该层将Model的数据更新View层,暴力点可以直接在该层得到V的控件，将M层一个个传入； MVVM（MP） MVVM的由来是MVP模式和WPF（MAML配置）结合应用的一种新型框架，是MVP的升级版，让ViewModel和V进行双向数据绑定，更新VM等同于更新V，反之同理，但是在unity中不太适合，没有合适的UI配置文件，强硬的绑定V和VM，工作量很大，好处却不明细； 了解的话可以看看这些第三方MVVM框架：loxodon-Framework:vovgou/loxodon-framework：一个MVVM和Databinding框架，可以使用C#和Lua来开发游戏 (github.com)uMVVM:MEyes/uMVVM：一个简单的统一 mvvm 框架 (github.com) 所以，unity中，并不是特别推荐MVVM的格式，不要为了框架而框架，MVVM框架主要是V和VM的数据双向绑定，我们可以尝试将V和VM合二为一，且将界面和逻辑某种意义上解耦即可—MP，这里还要用到之前的基本框架，用到事件中心； MVE E就是事件中心，用EventCenter事件中心来分发消息，个人框架的一种变种，之前监听数据都是在M层进行监听，控制层进行注册和注销，但是随着M层的不断增加，控制层注册事件也会随之变得复杂，要针对不同的M注册不同的事件，引入事件中心后，可以在事件中心注册事件，M层根据事件名监听事件即可； 商业框架PureMVC官网：PureMVC 框架PureMVC基本结构：MVC+代理模式、中介者模式、外观模式、命令模式、观察者模式、单例模式；Model（数据模型）：关联Proxy(代理)对象，负责处理数据；View（界面）：关联Mediator(中介)对象，负责处理界面；Controller（业务控制）:管理Command(命令)对象，负责处理业务逻辑；Facade（外观）：是MVC三者的经纪人，统管全局，可以获取代理、中介、命令；Notification：通知，负责传递信息；","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"MVC","slug":"MVC","permalink":"https://wwy.wwywy.com/tags/MVC/"}]},{"title":"C#各版本知识补充","slug":"02005-C#补充","date":"2021-06-06T13:00:00.000Z","updated":"2022-07-10T03:12:28.399Z","comments":true,"path":"posts/1029.html","link":"","permalink":"https://wwy.wwywy.com/posts/1029.html","excerpt":"","text":"C#版本和Unity的关系1.各Unity支持的的C#版本说明：主要是不同Unity版本 使用的 C#编译器和脚本运行时版本不同，所以随着Unity的更新，它一般会采用较新的 编译器和运行时版本，新版本的脚本运行时将为Unity带来了大量的新版C#功能和.NET的功能，就意味着它可以支持更高版本的C#，以下是各版本支持的C#版本； Unity 2021.2 —— C# 9； Unity 2020.3 —— C# 8； Unity 2019.4 —— C# 7.3； Unity 2018.3 —— C# 7 Unity 2017 —— C# 6； Unity 5.5 —— C# 4； Unity - 手动：C# 编译器 (unity3d.com) 2.Unity的.Net API兼容级别：在PlayerSetting-&gt;Other Setting-&gt;Api Compatibility Level中，我们可以设置.Net API的兼容级别： .Net 4.x（特殊需求时）:具备较为完整的.Net API，甚至包含了一些无法跨平台的API，如果你的应用主要针对Windows平台，并且会使用到.Net Standard 2.0中没有的功能时，选择使用它； .Net Standard 2.0（建议使用）:是一个.Net标准API集合，相对.Net 4.x包含更少的内容，可以减小最终可执行文件大小，它具有更好的跨平台支持； C# 1~4功能和语法1.C#1~4语法说明： C# 1 —— 委托、事件（C#进阶） C# 2 —— 泛型、匿名方法、迭代器、可空类型（C#进阶） C# 3 ——隐式类型、对象集合初始化、Lambda表达式、匿名类型（C#进阶）；自动实现属性、拓展方法、分部类（C#核心）；Linq相关的表达式树（有时间再学）； C# 4 ——泛型的协变和逆变（C#进阶）以及命名和可选参数和动态类型（下面讲的）； 2.C#4中的命名和可选参数：有了命名参数，我们将不用匹配参数在所调用方法中的顺序，每个参数可以按照参数名字进行指定，例如Test(f:3.3f,i:5,b:false)，命名参数可以配合可选参数使用,让我们做到跳过其中的默认参数直接赋值后面的默认参数，可以让我们更方便的调用函数，少写一些重载函数； 3.C#4中的动态类型：动态类型可以节约代码量，可以理解成是当不确定对象类型，但是确定对象成员时，可以使用动态类型； 关键词：dynamic； 作用：通过dynamic类型标识变量的使用和对其成员的引用绕过编译时类型检查，改为在运行时解析这些操作，在大多数情况下，dynamic类型和object类型行为类似，任何非Null表达式都可以转换为dynamic类型，dynamic类型和object类型不同之处在于，编译器不会对包含类型 dynamic 的表达式的操作进行解析或类型检查，编译器将有关该操作信息打包在一起，之后这些信息会用于在运行时评估操作，在此过程中，dynamic 类型的变量会编译为 object 类型的变量，因此，dynamic 类型只在编译时存在，在运行时则不存在； 注意事项说明： 使用dynamic功能 需要将Unity的.Net API兼容级别切换为.Net 4.x； IL2CPP 不支持 C# dynamic 关键字。它需要 JIT 编译，而 IL2CPP 无法实现 动态类型是无法自动补全方法的，我们在书写时一定要保证方法的拼写正确性 C# 5功能和语法1.C# 5新增语法说明： 调用方信息特性（C#进阶——特性） 异步方法async和await（C#进阶） C# 6功能和语法1.C# 6新增语法说明： =&gt;运算符（C#进阶——特殊语法 =&gt;）； .Null 传播器（C#进阶——特殊语法 ?）； 字符串内插（C#进阶——特殊语法 $）； 静态导入（下面提及）； 异常筛选器（下面提及）； nameof运算符（下面提及）； 2.C# 6静态导入：例如using static UnityEngine.Mathf简化后面的使用; 用法：在引用命名空间时，在using关键字后面加入static关键词； 作用：无需指定类型名称即可访问其静态成员和嵌套类型； 好处：节约代码量，可以写出更简洁的代码 3.C# 6异常筛选器：例如when (e.Message.Contains(“404”))判断是否包含404字符串； 用法：在异常捕获语句块中的Catch语句后通过加入when关键词来筛选异常&lt;when（表达式）该表达式返回值必须为bool值，如果为ture则执行异常处理，如果为false，则不执行; 作用：用于筛选异常; 好处：帮助我们更准确的排查异常，根据异常类型进行对应的处理 4.C# 6nameof运算符：例如print(nameof(list.Count))打印的是Count这个字符串； 用法：nameof(变量、类型、成员)通过该表达式，可以将他们的名称转为字符串； 作用：可以得到变量、类、函数等信息的具体字符串名称，可以配合反射使用； C# 7功能和语法1.C# 7新增语法说明： 字面值改进（下面提及）； out参数相关 和 弃元知识点（下面提及）； ref 返回值（下面提及）； 本地函数（下面提及）； 抛出表达式（下面提及）； 元组（下面提及）； 模式匹配（下面提及）； 2.C# 7字面值改进：例如int i = 9_9123_1239更加方便观看，但是不影响实际数值； 基本概念：在声明数值变量时，为了方便查看数值，可以在数值之间插入_作为分隔符； 主要作用：方便数值变量的阅读； 3.C# 7out参数相关 和 弃元知识点： 用法：不需要再使用带有out参数的函数之前，声明对应变量，例如Calc(out int x)直接声明，后面也可以使用; 结合var类型更简便(但是这种写法在存在重载时不能正常使用,必须明确调用的是谁)，例如Calc(out var b)； 可以使用_弃元符号 省略不想使用的参数，例如Calc(out _)； 作用：简化代码，提高开发效率 4.C# 7ref 返回值： 基本概念：使用ref修饰临时变量和函数返回值，可以让赋值变为引用传递，如下主要使用几种场景： 修饰值类型临时变量：例如ref int testI2 = ref testI = 900，值类型的改变和引用类型改值一样了； 获取对象中的参数： ref int atk = ref r.atk = 99，同上说明； 函数返回值：同上做法； 作用：用于修改数据对象中的某些值类型变量 5.C# 7本地函数： 基本概念：在函数内部声明一个临时函数，如下注意： 本地函数只能在声明该函数的函数内部使用； 本地函数可以使用声明自己的函数中的变量； 作用：方便逻辑的封装； 建议：把本地函数写在主要逻辑的后面，方便代码的查看； 抛出表达式1.throw表达式回顾：抛出表达式，就是指抛出一个错误，一般的使用方式都是throw后面 new 一个异常类，异常基类是Exception，例如throw new NullReferenceException(“出错了”)，以下是常见的异常类； IndexOutOfRangeException：当一个数组的下标超出范围时运行时引发； NullReferenceException：当一个空对象被引用时运行时引发； ArgumentException：方法的参数是非法的； ArgumentNullException： 一个空参数传递给方法，该方法不能接受该参数； ArgumentOutOfRangeException： 参数值超出范围； SystemException：其他用户可处理的异常的基本类； OutOfMemoryException：内存空间不够； StackOverflowException 堆栈溢出； ArithmeticException：出现算术上溢或者下溢； ArrayTypeMismatchException：试图在数组中存储错误类型的对象； BadImageFormatException：图形的格式错误； DivideByZeroException：除零异常； DllNotFoundException：找不到引用的DLL； FormatException：参数格式错误； InvalidCastException：使用无效的类； InvalidOperationException：方法的调用时间错误 MethodAccessException：试图访问思友或者受保护的方法； MissingMemberException：访问一个无效版本的DLL； NotFiniteNumberException：对象不是一个有效的成员； NotSupportedException：调用的方法在类中没有实现； InvalidOperationException：当对方法的调用对对象的当前状态无效时，由某些方法引发。 2.C# 7新增的更多表达式错误抛出： 空合并操作符后用throw：例如str ?? throw new ArgumentNullException(nameof(str)); 三目运算符后面用throw：例如index ? strs[index] : throw new IndexOutOfRangeException(); =&gt;符号后面直接throw：例如Action action = () =&gt; throw new Exception(“错了，不准用这个委托”); 元组1.元组说明： 基本概念:多个值的集合，相当于是一种快速构建数据结构类的方式，一般在函数存在多返回值时可以使用元组 (返回值1类型,返回值2类型,….) 来声明返回值，在函数内部返回具体内容时通过 (返回值1,返回值2,….) 进行返回； 主要作用：提升开发效率，更方便的处理多返回值等需要用到多个值时的需求； 2.使用案例： 1.无变量名元组的声明(获取值：Item'N'作为从左到右依次的参数，N从1开始) (int, float,bool,string) yz = (1, 5.5f, true, \"123\"); print(yz.Item1); 2.有变量名元组的声明 (int i, float f, bool b, string str) yz2 = (1, 5.5f, true, \"123\"); print(yz2.i); 3.元组可以进行等于和不等于的判断 //数量相同才比较，类型相同才比较，每一个参数的比较是通过==比较 如果都是true 则认为两个元组相等 if (yz == yz2) print(\"相等\"); else print(\"不相等\"); 4.元组的应用——函数返回值 //利用元组定义一个多返回的函数 private (string str, int i, float f) GetInfo(){return (\"123\", 2, 5.5f);} //元组的解构赋值 (string myStr,int myInt,float myFloat) = GetInfo(); //丢弃参数,利用传入 下划线_ 达到丢弃该参数不使用的作用 (string ss, _, _) = GetInfo(); 5. 元组的应用——字典 //字典中的键 需要用多个变量来控制 Dictionary&lt;(int i, float f), string&gt; dic = new Dictionary&lt;(int i, float f), string&gt;(); dic.Add((1, 2.5f), \"123\"); 模式匹配1.模式匹配说明： 基本概念：“模式匹配”是一种测试表达式是否具有特定特征的方法，在编程里指的是，把一个不知道具体数据信息的内容，通过一些固定的语法格式来确定模式数据的具体内容的过程，是一种语法元素，可以测试一个值是否满足某种条件，并可以从值中提取信息，在C#7中，模式匹配增强了两个现有的语言结构： is表达式可以在右侧写一个模式语法，而不仅仅是一个类型； switch语句中的case ； 主要作用：节约代码量，提高编程效率 2.详细案例 1.常量模式(is 常量)：用于判断输入值是否等于某个值 object o = 1.5f; if(o is 1) { print(\"o是1\"); } if(o is null) { print(\"o是null\"); } 2.类型模式(is 类型 变量名、case 类型 变量名)：用于判断输入值类型，如果类型相同，将输入值提取出来 //判断某一个变量是否是某一个类型，如果满足会将该变量存入你申明的变量中 if (o is int i)print(i); switch (o) { case int value: print(\"int:\" + value); break; case float value: print(\"float:\" + value); break; case null: print(\"null\"); break; default: break; } 3.var模式：用于将输入值放入与输入值相同类型的新变量中，相当于是将变量装入一个和自己类型一样的变量中； if (GetInt() is var k &amp;&amp; k &gt;= 0 &amp;&amp; k &lt;= 10) C# 8功能和语法1.C# 8新增语法说明: 静态本地函数（下面提及）； Using 声明（下面提及）； Null 合并赋值（下面提及）； 解构函数Deconstruct （下面提及）； 模式匹配增强功能（下面提及）； 2.C# 8静态本地函数：和本地函数基本一致； 基本概念：静态本地函数就是在本地函数前方加入静态关键字，让本地函数不能够使用访问封闭范围内（也就是上层方法中）的任何变量； 作用：让本地函数只能处理逻辑，避免让它通过直接改变上层变量来处理逻辑造成逻辑混乱； 3.C# 8Using 声明：例如using StreamWriter s2 = new StreamWriter(“文件路径”)； 回顾using()语法：using(对象声明){}，当语句块结束 会自动帮助我们调用 对象的 Dispose这个方法 让其进行销毁； 基本概念：Using 声明就是对using（）语法的简写，会在上层语句块执行结束时释放该对象； 注意事项： 使用该简化关键字前提是有上层语句块，if，函数都是； 使用using语法用在自定义类时，声明的对象必须继承System.IDisposable接口，因为必须具备Dispose方法，所以当声明没有继承该接口的对象时会报错； 4.C# 8Null 合并赋值：例如str ??= “1111”; 基本概念：类似复合运算符，左边值 ??= 右边值，当左侧为空时才会把右侧值赋值给变量； 注意事项：由于左侧为空才会讲右侧赋值给变量，所以不为空的变量不会改变； 5.C# 8解构函数Deconstruct（C# 7就有了）：例如类中定义了该函数的话直接解构 (string name, bool sex) = p; 语法：在类的内部申明函数public void Deconstruct(out 变量类型 变量名, out 变量类型 变量名…..)； 基本概念：我们可以在自定义类当中声明解构函数，这样我们可以将该自定义类对象利用元组的写法对其进行变量的获取，相当于把不同的成员变量拆分到不同的临时变量中； 特点：一个类中可以有多个Deconstruct，但是参数数量不能相同； 模式匹配增强功能1.模式匹配增强功能——Switch表达式： //switch表达式是对有返回值的switch语句的缩写 //用=&gt;表达式符号代替case:组合 //用_弃元符号代替default //它的使用限制，主要是用于switch语句当中只有一句代码用于返回值时使用 //语法： // 函数声明 =&gt; 变量 switch //{ //常量=&gt;返回值表达式, //常量=&gt;返回值表达式, //常量=&gt;返回值表达式, //.... //_ =&gt; 返回值表达式, //} //例如一个根据枚举获取方向的方法 public Vector2 GetPos(PosType type) =&gt; type switch { PosType.Top_Left =&gt; new Vector2(0, 0), PosType.Top_Right =&gt; new Vector2(1, 0), PosType.Bottom_Left =&gt; new Vector2(0, 1), PosType.Bottom_Right =&gt; new Vector2(1, 1), _ =&gt; new Vector2(0, 0) }; 2.模式匹配增强功能——属性模式： //就是在常量模式的基础上判断对象上各属性 //用法：变量 is {属性:值, 属性:值} if (info is { discount: \"6折\", isDiscount: true })print(\"信息相同\"); //可以利用属性模式 结合 switch表达式 判断n个条件是否满足 public float GetMoney(DiscountInfo info, float money) =&gt; info switch { { discount: \"5折\", isDiscount: true } =&gt; money * .5f, { discount: \"6折\", isDiscount: true } =&gt; money * .6f, { discount: \"7折\", isDiscount: true } =&gt; money * .7f, _ =&gt; money }; 3.模式匹配增强功能——元组模式： //属性模式我们可以在switch表达式中判断多个变量同时满足再返回什么 //但是它必须是一个数据结构类对象，判断其中的变量 //而元组模式可以更简单的完成这样的功能，我们不需要声明数据结构类，可以直接利用元组进行判断 //元组模式简单用法 if((ii, bb) is (11, true)) //元组结合switch模式使用 public float GetMoney(string discount, bool isDiscount, float money) =&gt; (discount, isDiscount) switch { (\"5折\", true) =&gt; money * .5f, (\"6折\", true) =&gt; money * .6f, (\"7折\", true) =&gt; money * .7f, _ =&gt; money }; 4.模式匹配增强功能——位置模式： //如果自定义类中实现了解构函数 //那么我们可以直接用对应类对象与元组进行is判断 if(info is (\"5折\", true)) //同样我们也可以配合switch表达式来处理逻辑 public float GetMoney(DiscountInfo info, float money) =&gt; info switch { //补充：配合when关键字进行逻辑处理 (\"5折\", true) when money &gt; 100 =&gt; money * .5f, (\"6折\", true) =&gt; money * .6f, (\"7折\", true) =&gt; money * .7f, _ =&gt; money }; C# 其他知识补充日期和时间","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"Excel编辑器工具","slug":"04050-Excel编辑器工具","date":"2021-04-16T13:00:00.000Z","updated":"2022-07-11T03:16:54.682Z","comments":true,"path":"posts/2088.html","link":"","permalink":"https://wwy.wwywy.com/posts/2088.html","excerpt":"","text":"Excel介绍1.Excel的本质：Excel表本质上也是一堆数据，只不过它有自己的存储读取规则，如果我们想要通过代码读取它，那么必须知道它的存储规则，官网是专门提供了对应的DLL文件用来解析Excel文件的； 2.获取Excel数据信息的意义： 可以根据表中数据来动态的生成相关数据，如数据结构类、容器类、二进制数据类； 转成二进制数据也可以提升读取效率，提升数据安全性； Excel官方工具使用//主要知识点： //1.FileStream读取文件流 //2.IExcelDataReader类，从流中读取Excel数据 //3.DataSet 数据集合类 将Excel数据转存进其中方便读取 //4.DataTable 数据表类 表示Excel文件中的一个表 //5.DataRow 数据行类 表示某张表中的一行数据 [MenuItem(\"GameTool/读取Excel里的具体信息\")] private static void ReadExcel() { using (FileStream fs = File.Open(Application.dataPath + \"/ArtRes/Excel/PlayerInfo.xlsx\", FileMode.Open, FileAccess.Read)) { IExcelDataReader excelReader = ExcelReaderFactory.CreateOpenXmlReader(fs); DataSet result = excelReader.AsDataSet(); for (int i = 0; i &lt; result.Tables.Count; i++) { //得到其中一张表的具体数据 DataTable table = result.Tables[i]; Debug.Log(\"表名：\" + result.Tables[i].TableName); Debug.Log(\"行数：\" + result.Tables[i].Rows.Count); Debug.Log(\"列数：\" + result.Tables[i].Columns.Count); //得到其中一行的数据 DataRow row = table.Rows[0]; //得到行中某一列的信息 Debug.Log(row[1].ToString()); DataRow row; for (int j = 0; j &lt; table.Rows.Count; j++) { //得到每一行的信息 row = table.Rows[j]; Debug.Log(\"*********新的一行************\"); for (int k = 0; k &lt; table.Columns.Count; k++) { //得到每一列的信息 Debug.Log(row[k].ToString()); } } } fs.Close(); } } 制定规则1.Excel读取规则： 数据类型生成要知道字段名，容器（一般字典）要知道主键，二进制要知道从哪行哪列开始； 第一行是字段名，第二行是数据类型，第三行容器可以再加一个key表示主键（也可以默认第一列），第四行是中文解释（给策划写的，不会生成进去）； 下方的表名作为生成的类型名； Excel工具编写","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"工具链","slug":"Game-Play/技术架构/工具链","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E5%B7%A5%E5%85%B7%E9%93%BE/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Excel","slug":"Excel","permalink":"https://wwy.wwywy.com/tags/Excel/"}]},{"title":"Unity进阶-ScriptableObject","slug":"03014-Unity进阶-ScriptableObject","date":"2021-04-13T13:00:00.000Z","updated":"2022-07-09T16:17:19.201Z","comments":true,"path":"posts/1548.html","link":"","permalink":"https://wwy.wwywy.com/posts/1548.html","excerpt":"","text":"ScriptableObject概述1.ScriptableObject说明：ScriptableObject是Unity提供的一个数据配置存储基类，它是一个可以用来保存大量数据的数据容器，就像是可以自定义的数据预制物资源文件，需要我们继承它来进行使用，它的主要作用是如下： 数据复用（多个对象用同一个数据） 配置文件（配置游戏中的数据） 编辑模式下的数据持久化 2.ScriptableObject优点：如下 我们可以直接在Inspector窗口编辑配置数据，可以利用它来做配置文件； 处理重复数据，减少数据拷贝时造成的内存占用，可以利用它来做公共数据； 可以更方便的处理数据带来的多态行为； 3.ScriptableObject持久化注意点：通过代码修改数据对象中内容，会影响数据文件，相当于达到了编辑器中数据持久化的目的(该数据持久化 只是在编辑模式下的持久,发布运行时并不会保存数据)； ScriptableObject数据文件创建1.自定义ScriptableObject数据容器 //1.继承ScriptableObject类 //2.在该类中声明成员（变量、方法等） //注意：声明后，我们边可以在Inspector窗口中看到变化 // 我们可以在其中进行设置，但是这些设置都是默认数据，并没有真正使用他们 // 这些关联信息都是通过脚本文件对应的Unity配置文件meta进行记录的 // 目前该数据只是一个数据容器模板 // 有了它我们之后才能根据它的信息创建对应的数据资源文件 2.根据自定义的ScriptableObject数据容器创建数据文件 //注意： //该创建功能，其实就是根据自定义数据容器类创建了一个配置文件 //该文件中记录了对应的数据容器类信息，以及其中变量关联的信息 //之后我们在使用它时，本质上也是通过反射创建对象进行使用 //具体的方法有两种： //1.为类添加CreateAssetMenu通过菜单创建资源特性 //[CreateAssetMenu(fileName = \"默认文件名\", menuName = \"在Asset/Create菜单中显示的名字\", order = 再Asset/Create菜单中的位置(多个时可以通过它来调整顺序))] //2.利用ScriptableObject的静态方法创建数据对象 //书写创建数据资源文件的代码 MyData asset = ScriptableObject.CreateInstance&lt;MyData&gt;(); //通过编辑器API 根据数据创建一个数据资源文件 AssetDatabase.CreateAsset(asset, \"Assets/Resources/MyDataTest.asset\"); //保存创建的资源 AssetDatabase.SaveAssets(); //刷新界面 AssetDatabase.Refresh(); ScriptableObject数据文件使用1.ScriptableObject数据文件的使用 //1.通过Inspector中的public变量进行关联 //1-1.创建一个数据文件 //1-2.在继承MonoBehaviour类中申明数据容器类型的成员 // 在Inspector窗口进行关联 //2.通过资源加载的信息关联 //加载数据文件资源 //注意：Resources、AB包、Addressables都支持加载继承ScriptableObject的数据文件 data = Resources.Load&lt;MyData&gt;(\"MyDataTest\"); //注意：如果多个对象关联同一个数据容器文件，他们共享的是一个对象 // 因为是引用对象，所以在其中任何地方修改后，其它地方也会发生改变 2.ScriptableObject的生命周期函数 //ScriptableObject和MonoBehavior很类似 //它也存在生命周期函数 //但是生命周期函数的数量更少 //主要做了解，一般我们使用较少 //Awake 数据文件创建时调用 //OnDestroy ScriptableObject 对象将被销毁时调用 //OnDisable ScriptableObject 对象销毁时、即将重新加载脚本程序集时 调用 //OnEnable ScriptableObject 创建或者加载对象时调用 //OnValidate 编辑器才会调用的函数，Unity在加载脚本或者Inspector窗口中更改值时调用 ScriptableObject的非持久化和持久化1.ScriptableObject的非持久化数据说明：指的是不管在编辑器模式还是在发布后都 不会持久化的数据，我们可以根据自己的需求随时创建对应数据对象进行使用，就好像直接new一个数据结构类对象； 2.利用ScriptableObject生成非持久化的数据：利用ScriptableObject中的静态方法 CreateInstance&lt;&gt;()，通过这种方式创建出来的数据对象 它里面的默认值 不会受到脚本中设置的影响，该对象只存在于内存当中，可以被GC； 3.非持久化数据存在的意义：只是希望在运行时能有一组唯一的数据可以使用，但是这个数据又不太希望保存为数据资源文件浪费硬盘空间，那么ScriptableObject的非持久化数据就有了存在的意义（只在运行时使用，在编辑器模式下也不会保存在本地） 4.ScriptableObject真正意义的持久化：持久化（硬盘&lt;=&gt;内存），首先要理解的是ScriptableObject的主要意义并不是用来进行持久化的，但是我们也可以利用持久化的相关知识来进行运行时读取； ScriptableObject的应用配置数据1.ScriptableObject配置说明：ScriptableObject适合用来作配置文件，结合List使用或者字典使用（集合类型遵守Unity规则，加上序列化标签），也可以在Excel中作配置，然后编辑器导出ScriptableObject文件； 复用数据1.ScriptableObject复用数据说明：游戏实体中定义的数据是不同地址的，但是对于只用不变的数据，以面向对象的思想去声明是会存在内存浪费的，特别是像子弹这种类型，所以我们刻意利用ScriptableObject静态数据来进行共享使用，更加节约内存； 数据带来的多态行为1.ScriptableObject的多态：当数据不一样时带来的多态行为，依赖于抽象，而不依赖于实现，调用继承自ScriptableObject的数据类方法，但是实际调用的子类的多态方法（例如角色碰撞道具获得效果，基类只管获取道具的方法，具体是加血还是加攻击由子类决定）","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"ScriptableObject","slug":"ScriptableObject","permalink":"https://wwy.wwywy.com/tags/ScriptableObject/"}]},{"title":"人工智能导论","slug":"01005-人工智能导论","date":"2021-03-02T13:00:00.000Z","updated":"2022-07-09T16:13:41.241Z","comments":true,"path":"posts/517.html","link":"","permalink":"https://wwy.wwywy.com/posts/517.html","excerpt":"","text":"绪论人工智能基本概念1.自然界四大奥秘：物质的本质、宇宙的起源、生命的本质、智能的发生； 2.智能的定义：智能是只是和智力的总和； 3.智能的特征： 感知能力（游戏AI必须品）：主动信息的输入，实现视觉、听觉、触觉、嗅觉等感觉器官； 记忆力和思维能力：信息的存储和信息的模拟，记忆存储由感知器官感知到的外部信息以及由思维所产生的知识，思维能力对记忆的信息进行处理； 逻辑思维（抽象思维）：例如理科生通过逻辑去肢解一道数学题； 形象思维（直感思维）：例如人的第五感； 顿悟思维（灵感思维）：例如牛顿如何发现了力学； 学习能力：被动信息的输入，学习既可能是自觉的、有意识的，也可能是不自觉的、无意识的；既可以是有教师指导的，也可以是通过自己实践的； 行为能力（表达能力）：信息的输入，人工智能实现的目的； 人工智能发展简史人工智能发展史：了解就好了，知乎看看就好；人工智能发展史 - 知乎 (zhihu.com) 人工智能研究的基本内容1.知识表达：将人类知识形式化或者模型化，方法有符号表示法、连接机制表示法，简单点说就是建立一个能把人懂的东西弄成机器能懂的东西的东西； 2.机器感知：使机器（计算机）具有类似于人的感知能力。以机器视觉(machine vision)与机器听觉为主； 3.机器思维：对通过感知得来的外部信息及机器内部的各种工作信息进行有目的的处理； 4.机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识； 5.机器行为：计算机的表达能力，即“说”、“写”、“画”等能力； 人工智能的主要研究领域主要领域：自动定理证明、博弈、模式识别、机器视觉 、自然语言理解、机器翻译、智能信息检索 、数据挖掘与知识发现、专家系统、自动程序设计、机器人、组合优化问题、人工神经网络； 其他领域：分布式人工智能与多智能体、智能控制、智能仿真、智能CAD 、智能CAI 、智能管理与智能决策 、智能多媒体系统 、智能操作系统、智能计算机系统 、智能通信 、智能网络系统、人工生命 ； 知识表示与知识图谱知识和知识表示知识的概念1.知识的定义：把有关信息关联在一起所形成的信息结构； 2.知识的作用：反映了客观世界中事物之间的关系； 3.知识的特性： 相对正确性：知识在一定的条件及环境下产生的才是正确的； 不确定性： 随机性引起的不确定性 ：清明一般都会下雨，但是也有不下雨的时候； 模糊性引起的不确定性 ：根据人的外貌去判断年龄； 经验引起的不确定性：经历丰富的人相对知识也更加丰富； 不完全性引起的不确定性：比如对人类对宇宙的了解并不完整； 可表示性和可利用性：知识可以用适当形式表示和利用； 知识表示的概念1.知识表示的定义：将人类的知识形式化或者模型化（人类划重点）； 2.知识表示的作用：计算机可以接受的描述知识的数据结构 3.知识选择方法的原则：有利于知识的充分表示和分利用、便于组织、维护、管理、理解和实现； 一阶谓词逻辑表示法非专业作了解： 人工智能一阶谓词逻辑表示法 产生式表示法非专业作了解：产生式表示法 框架表示法非专业作了解：知识表示之框架表示法 知识图谱（推荐学习）定义：是一种揭示实体之间关系的语义网络；目的：知识图谱的目的是为了提高搜索引擎的能力，改善用户的搜索质量以及搜索体验； 1.知识图谱的逻辑结构： 数据层：主要是由一系列的事实组成，而知识以事实为单位进行存储。 模式层：构建在数据层之上，是知识图谱的核心。 2.知识图谱的原始数据类型： 结构化数据：是指知识定义和表示都比较完备的数据，如关系数据库； 半结构化数据：是指部分数据是结构化的，但存在大量结构化程度较低的数据，如XML、JSON； 非结构化数据：是指没有定义和规范约束的“自由”数据，如文本、视频、音频、图片； 了解更多：通俗易懂解释知识图谱 确定性推导方法非专业作了解：确定性推理方法 不确定性推导方法非专业作了解：不确定推理方法 搜索求解策略搜索的概念1.搜索算法主要解决问题： 是否一定能找到一个解。 找到的解是否是最佳解。 时间与空间复杂性如何。 是否终止运行或是否会陷入一个死循环 2.搜索方向： 从初始给出的条件出发； 从目的地出发，进行逆推算； （A*算法）从开始状态出发作正向搜索，同时又从目的状态出发作逆向搜索，直到两条路径在中间的某处汇合为止；状态空间的搜索策略非专业作了解：状态空间表示法 盲目的图搜索策略回溯策略1.回溯策略的数据结构： Pass集合：记录寻路算法中的可走路径，保存搜索路径的状态，如果找到了目的，该集合就是解； Open集合：等待搜索或者待访问的状态集合； Close集合：已经被访问的状态集合； 广度优先搜索策略1.算法特点：如下俩点 每次选择深度最浅的节点首先扩展，搜索是逐层进行的，如图5.6所示； 一种高价搜索，会遍历所有节点，但若有解存在，则必能找到它，且是最短路径（可以理解很多人沿着不同的方向走，人多力量大）； 2.算法描述如下： a：选择一个未访问的顶点入队； b：从队里选出一个顶点V出队，并且标记为已经访问； c：将顶点V的所有未被访问的邻接顶点入队并且设置该节点父节点为顶点V； d：重复步骤a~b，直到所有顶点都已经被访问； e：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条） 3.核心算法实现： /// &lt;summary&gt; /// 广度优先算法BFS /// &lt;/summary&gt; /// &lt;param name=\"originNode\"&gt;起点位置&lt;/param&gt; /// &lt;param name=\"targetNode\"&gt;目标位置&lt;/param&gt; /// &lt;param name=\"passNodeList\"&gt;可走路径&lt;/param&gt; public static void BFSSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeList) { Queue&lt;Node&gt; openQue = new Queue&lt;Node&gt;(); openQue.Enqueue(originNode); while (openQue.Count &gt; 0) { Node head = openQue.Dequeue(); //获取该节点周围的节点 List&lt;Node&gt; neighborLst = Program.GetNeighbor(head); //检查周围的节点 for (int i = 0; i &lt; neighborLst.Count; i++) { Node neighborNode = neighborLst[i]; //节点被访问或者是障碍物的直接继续 if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue; //记录节点被访问 neighborNode.isVisit = true; //记录父节点 neighborNode.parent = head; openQue.Enqueue(neighborNode); //这个时候整个地图已经遍历完了 if (neighborNode.Equals(targetNode)) { //反向输出父节点，就是要找的路径 while (!neighborNode.Equals(originNode)) { neighborNode = neighborNode.parent; passNodeList.Add(neighborNode); neighborNode.nodeType = NodeType.Pass; } //最后添加目标点（其实直接返回目标节点也是可以的） passNodeList.Add(targetNode); targetNode.nodeType = NodeType.Pass; return; } } } } 深度优先搜索策略1.算法特点： 扩展最深的节点的结果使得搜索沿着状态空间某条单一的路径从起始节点向下进行下去；仅当搜索到达一个没有后裔的状态时，才考虑另一条替代的路径； 为了保证找到解，应选择合适的深度限制值，或采取不断加大深度限制值的办法，反复搜索，直到找到解； 深度优先搜索并不能保证第一次搜索到的某个状态时的路径是到这个状态的最短路径，如果路径距离很重要的话，它应该尝试保留最短路径； 2.算法描述如下： a：选择传入的起始顶点，并将顶点标记已经访问； b：访问邻接顶点，直到某个顶点没有邻接顶点再继续下一步； c：回溯到上一层顶点，重复b步，直到所有顶点都被访问； d：反向输出父节点，就是要找的路径（当然可能有多条，但是只返回一条）； 3.核心算法实现： /// &lt;summary&gt; /// 深度优先算法BFS（简单实现，非最优路径） /// &lt;/summary&gt; /// &lt;param name=\"currentNode\"&gt;当前位置&lt;/param&gt; /// &lt;param name=\"originNode\"&gt;起点位置&lt;/param&gt; /// &lt;param name=\"targetNode\"&gt;目标位置&lt;/param&gt; /// &lt;param name=\"passNodeList\"&gt;可走路径&lt;/param&gt; public static void DFSSearch(Node currentNode, Node originNode, Node targetNode,ref List&lt;Node&gt; passNodeList) { //标记该节点已经被访问 currentNode.isVisit = true; //获取该节点周围的节点 List&lt;Node&gt; neighborLst = Program.GetNeighbor(currentNode); for(int i = 0; i &lt; neighborLst.Count; i++) { Node neighborNode = neighborLst[i]; //节点被访问或者是障碍物的直接继续 if (neighborNode.isVisit || neighborNode.nodeType == NodeType.Block) continue; //记录父节点 neighborNode.parent = currentNode; //递归调用,先深再广 DFSSearch(neighborNode, originNode, targetNode, ref passNodeList); //这个时候已经找到目标节点了 if (neighborNode.Equals(targetNode)) { //反向输出父节点，就是要找的路径 while (!neighborNode.Equals(originNode)) { neighborNode = neighborNode.parent; passNodeList.Add(neighborNode); neighborNode.nodeType = NodeType.Pass; } //最后添加目标点（其实直接返回目标节点也是可以的） passNodeList.Add(targetNode); targetNode.nodeType = NodeType.Pass; return; } } } 启发式图搜索策略启发式策略1.启发式信息定义：用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息； 2.启发式策略特点：重排Open表，选择最有希望的节点加以扩展； 3.启发信息分类：按以下俩种情况考虑 按运用的方法分类： 陈述性启发信息：用于更准确、更精炼地描述状态； 过程性启发信息：用于构造操作算子； 控制性启发信息：表示控制策略的知识； 按作用分类： 用于扩展节点的选择，即用于决定应先扩展哪一个节点，以免盲目扩展； 用于生成节点的选择，即用于决定要生成哪些后继节点，以免盲目生成过多无用的节点； 用于删除节点的选择，即用于决定删除哪些无用节点，以免造成进一步的时空浪费； 估价函数1.估价函数公式：用来估算初始节点经过 n节点到达目标节点的路径的最小代价，如下推理 估价函数值f(n) ==&gt; g(n) + h(n); g(n) ==&gt; 从当前节点到待访问节点n的实际代价（其实就是距离） h(n) ==&gt; 从待访问节点n到终点的估算代价（其实就是方向） h(n) 比重大：降低搜索工作量，但可能导致找不到最优解； h(n) 比重小：一般导致工作量加大，极限情况下变为盲目搜索，但可能可以找到最优解； A*算法1.核心算法实现 /// &lt;summary&gt; /// A*启发式寻路算法 /// &lt;/summary&gt; /// &lt;param name=\"originNode\"&gt;起点&lt;/param&gt; /// &lt;param name=\"targetNode\"&gt;目标节点&lt;/param&gt; /// &lt;param name=\"passNodeLst\"&gt;通行路径&lt;/param&gt; public static bool AstarSearch(Node originNode, Node targetNode, ref List&lt;Node&gt; passNodeLst) { //如果当前节点等于目标节点直接返回 if (originNode.Equals(targetNode)) { passNodeLst.Add(originNode); return true; } //下一次准备搜索的列表 List&lt;Node&gt; openLst = new List&lt;Node&gt;(); //关闭搜索节点列表 List&lt;Node&gt; closeLst = new List&lt;Node&gt;(); Node currentNode=originNode; openLst.Add(currentNode); while (openLst.Count &gt; 0) { currentNode = GetMinF(openLst , currentNode, targetNode); //这个时候已经找到目标节点了 if (currentNode.Equals(targetNode)) { //反向输出父节点，就是要找的路径 while (!currentNode.Equals(originNode)) { passNodeLst.Add(currentNode); currentNode = currentNode.parent; currentNode.nodeType = NodeType.Pass; } //最后添加目标点（其实直接返回目标节点也是可以的） passNodeLst.Add(originNode); originNode.nodeType = NodeType.Pass; targetNode.nodeType = NodeType.Pass; return true; } openLst.Remove(currentNode); closeLst.Add(currentNode); foreach (Node neighborNode in Program.GetNeighbor(currentNode)) { if (openLst.Contains(neighborNode) || neighborNode.nodeType == NodeType.Block|| closeLst.Contains(neighborNode)) continue; openLst.Add(neighborNode); } } return false; } /// &lt;summary&gt; /// 估值函数（A*算法核心） /// &lt;/summary&gt; /// &lt;param name=\"openLst\"&gt;开放节点&lt;/param&gt; /// &lt;param name=\"closeLst\"&gt;关闭节点&lt;/param&gt; /// &lt;param name=\"currentNode\"&gt;当前节点&lt;/param&gt; /// &lt;param name=\"targetNode\"&gt;目标节点&lt;/param&gt; /// &lt;returns&gt;返回估值后最小F的节点&lt;/returns&gt; public static Node GetMinF(List&lt;Node&gt; openLst, Node currentNode, Node targetNode) { if(openLst.Count &lt;= 1)return currentNode; int minFVal = int.MaxValue; Node? nextNode = null; foreach (Node node in openLst) { int fVal = GetG(currentNode, node) + GetH(node, targetNode); if (fVal &gt;= minFVal) continue; minFVal = fVal; nextNode = node; } if(nextNode != null) nextNode.parent = currentNode; return nextNode; } /// &lt;summary&gt; /// 获取G(M)值 /// &lt;/summary&gt; public static int GetG(Node currentNode,Node nextNode) { if (currentNode.xIndex == nextNode.xIndex || currentNode.yIndex == nextNode.yIndex) return 10; else return 14; } /// &lt;summary&gt; /// 获取H(M)值(这里采用欧式距离) /// &lt;/summary&gt; public static int GetH(Node currentNode, Node targetNode) { int a=Math.Abs(currentNode.xIndex-targetNode.xIndex); int b=Math.Abs(currentNode.yIndex-targetNode.yIndex); return 10*(int)Math.Sqrt(a*a+b*b); }","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"人工智能","slug":"大学知识/CS基础/人工智能","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"Unity进阶-AssetBundle","slug":"03016-Unity进阶-AssetBundle","date":"2021-02-13T13:00:00.000Z","updated":"2022-07-10T03:13:40.933Z","comments":true,"path":"posts/1550.html","link":"","permalink":"https://wwy.wwywy.com/posts/1550.html","excerpt":"","text":"AssetBundle介绍1.AB包说明：特定的平台资产压缩包，有点类似压缩文件，资源有模型、贴图、预制物、音效、材质球； 2.相对于Resources的优点： 资源压缩，直接打包后包体更小； 可以进行资源热更新，游戏资源先下包再更新； AssetBundle资源打包1.标签说明 在Inspector窗口下将要打包的资源选择或命名一个标签； 2.API打包：BuildPipeline.BuildAssetBundles() 方法三个参数 Bundle输出路径：打包路径； BuildAssetBundleOptions：不压缩、LZMA压缩、LZ4压缩（如下打包工具详细介绍）； BuildTarget：打包平台； 3.官方打包工具：AssetBundleBrowser打包关键参数说明； BuildTarget:目标平台 Output Path:目标输出路径 Clear Folders：是否清空文件夹 重新打包 Copy To StreamingAssets：是否拷贝到StreamingAssets Compression NoCompression：不压缩，解压快，包较大 不推荐 LZMA：压缩最小，解压慢（缺点：用一个资源，要解压所有） LZ4：压缩，相对LZMA大一点点（建议使用，用什么解压什么，内存占用低） ETI：在资源包中 不包含资源的类型信息 FR：重新打包时需要重新构建包（和ClearFolders不同，它不会删除不再存在的包） ITTC：增量构建检查时，忽略类型数的更改 Append Hash：将文件哈希值附加到资源包名上 SM：严格模式，如果打包时报错了，则打包直接失败无法成功 DRB：运行时构建 4.打包后文件说明：打包出来的文件有AB资源文件和 AB包文件：资源文件； manifest配置文件：当加载时，提供了对应包的关键信息、资源信息，依赖关系，版本信息等等； 关键AB包（和目录名一样的包）：是主包且存储了AB包的依赖关系； 使用AB包资源文件1.加载包的方法 //1.从内存加载资源 //数据是使用LZMA的压缩格式，那么在加载的时候会进行解压的操作 //LZ4格式的数据则会保持其压缩的状态 //第一个参数是字节数组 AssetBundle.LoadFromMemoryAsync() //2.从本地加载资源 //在加载非压缩文件或者LZ4压缩类型文件的时候，该接口效率极高 //对于LZMA压缩格式的文件，也会在加载的时候执行解压的操作 //参数一是路径 AssetBundle.LoadFromFile() //3.从网络下载资源 //参数是路径 //首先进行创建并且发送消息 UnityWebRequest request = UnityWebRequest.GetAssetBundle() //然后进行调用获取资源 DownloadHandlerAssetBundle.GetContent(request); 2.加载包中资源 //1.同步加载,支持泛形 //参数一是资源名，参数二是类型（因为Lua没有泛形） ab.LoadAsset&lt;T&gt;() //2.异步加载,基本同上，但是需要配合协程使用 AssetBundleRequest abq = ab.LoadAssetAsync&lt;T&gt;() 3.加载依赖包 //AB包的依赖说明 //多个资源用到别的未打包的资源，那么多个资源都会同时把该引用资源打包到自己包中（浪费内存） //一个资源用到别的包的资源，必须加载别的包的资源才可以，否则资源丢失（节省内存，但是需要合理管理，所以这里需要用到主包） //1.加载主包 AssetBundle abMain = AssetBundle.LoasFromFile(路径) //2.加载主包中的固定文件 AssetBundleManifest abManifest = abMain.LoadAsset&lt;AssetBundleManifest&gt;(主包名) //3.从固定文件中得到参数包依赖包名 String[] str = abManifest.GetAllDependencies(包名) 4.卸载资源 //1.卸载全部资源包 //第一个参数可以控制是否把加载资源也卸载 //填false其实就是切断连接，下次再加载资源包，会重新加载一个新的 AssetBundle.UnloadAllAssetBundles() //2.卸载当个资源包，参数同上 ab.Unload()","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://wwy.wwywy.com/tags/AssetBundle/"}]},{"title":"Behavior-Tree行为树","slug":"04350-Behavior-Tree行为树","date":"2021-02-12T13:00:00.000Z","updated":"2022-07-10T03:15:21.319Z","comments":true,"path":"posts/2280.html","link":"","permalink":"https://wwy.wwywy.com/posts/2280.html","excerpt":"","text":"行为树概念1.介绍：行为树Behavior Tree简称BT，是一颗包含了层级节点的树结构，一般用来控制AI的决策行为，但其逻辑清晰的可视化效果现在也可以用来做各种配置； 2.原理：行为树通过自顶向下的遍历方式，通过一些条件来搜索这颗树，最终根据当前条件确定需要做的行为（叶子节点），来执行它，达到AI决策的效果； 行为树组成 行为树主要由组合节点、装饰节点、条件节点、行为节点四种抽象节点抽象而成； 1.组合节点(Composites)：主要包含Sequence顺序组合节点、Selector选择组合节点、Parallel并行组合节点，这些节点之间也可以相互之间进行搭配组合，组成新的组合节点； 2.修饰节点(Decorator)：连接树叶的树枝，各种类型的修饰节点，这些节点决定了AI如何从树的顶端根据不同的情况来沿着不同的路径来到最终的叶子这一过程；让子节点循环操作或者让子节点一直运行知道返回某个运行状态，或者对结果取反； 3.条件节点(Conditinals)：用来判断条件是否成立；行为树的设计也遵守职责单一的原则，将判断也专门做一个节点独立处理，比如判断目标是否在视野内，这种功能在Action节点中也可以写，但是会影响Action的单一原则；一般条件节点在组合节点的中，后面紧跟的是条件成立得Action节点； 4.行为节点(Action)：行为节点是树得最末端，属于叶子节点，一般是AI实际做事情的命令； 工作流程1.工作流(Flow)：行为树由多种不同类型的节点构成，它们都拥有一个共同的核心功能，即它们会返回三种状态中其中一个作为结果，这三种状态是： 成功：Success; 失败：Failure； 运行中：Running； 根节点实例(BtNode) 根节点的实现很简单，但是其中要定义好相关的状态，这里我们用枚举来表示，之后所有的节点都继承自该节点； public abstract class BtNode { public virtual BtResultEnum DoAction() { return BtResultEnum.None; } } public enum BtResultEnum { None = 0, Successful = 1, Fail = 2, Running = 3, } 组合节点实例(BtComposite) 组合节点只是一个中间节点，它的出现只是为了过滤执行下面的子节点，我们实现一个父类节点，里面用一个List集合来储存子节点，之后所有的组合节点都继承自该节点, 后面的组合节点有多种实例，我们一个个分开讨论；： public class BtComposite : BtNode { protected List&lt;BtNode&gt; childrenLst; public BtComposite() { childrenLst = new List&lt;BtNode&gt;(); } public void AddChild(BtNode node) { this.childrenLst.Add(node); } } 顺序组合节点(BtSequence) 顺序节点是按顺序从左到右执行每一个子节点，当有子节点返回Fail，就返回Fail，不再实行后面的子节点，全部返回成功才返回成功： public class BtSequence : BtComposite { private int index; public BtSequence() { } private void Reset() { index = 0; } public override BtResultEnum DoAction() { //不存在子节点时直接返回Fail if (this.childrenLst == null || this.childrenLst.Count == 0) { return BtResultEnum.Fail; } if (this.index &gt;= this.childrenLst.Count) { Reset(); } BtResultEnum _result = BtResultEnum.None; for(int length = this.childrenLst.Count; index &lt; length; ++index) { _result = this.childrenLst[index].DoAction(); //有一个节点返回Fail，则直接返回Fail，不执行后面的子节点 if (_result == BtResultEnum.Fail) { Reset(); return _result; } else if (_result == BtResultEnum.Running) { return _result; } else { continue; } } Reset(); return BtResultEnum.Successful; } } 选择组合节点(BtSelect) 选择节点和顺序节点刚好相反，从左到右每帧执行一个子节点，当有子节点返回成功时，直接返回成功，不再执行后买你的子节点你，如果全部返回失败，才返回失败： public class BtSelect : BtComposite { private int index; public BtSelect() { Reset(); } private void Reset() { index = 0; } public override BtResultEnum DoAction() { if (this.childrenLst == null || this.childrenLst.Count == 0) { return BtResultEnum.Fail; } if (index &gt;= this.childrenLst.Count) { Reset(); } BtResultEnum _result = BtResultEnum.None; for(int length = this.childrenLst.Count; index &lt; length;index++) { _result = this.childrenLst[index].DoAction(); //有一个节点返回Successful，则直接返回Successful，不执行后面的子节点 if (_result == BtResultEnum.Successful) { Reset(); return _result; }else if (_result==BtResultEnum.Running) { return _result; } else { continue; } } Reset(); return BtResultEnum.Fail; } } 并行组合节点(BtParallel) 并行节点一帧将全部子节执行一遍，无论该节点你返回成功还是失败，都不影响其余节点的执行，但是该节点也需要根据每个子节点的返回状态决定自己的返回状态； public class BtParallel : BtComposite { public BtParallel() { } } 并行顺序组合节点(BtParallelSequence) 一帧将全部子节点执行一遍，全部返回False才返回False，否则返回True; public class BtParallelSequence : BtParallel { private List&lt;BtNode&gt; m_pWaitNodes; private bool m_pIsSuccess; public BtParallelSequence() { m_pWaitNodes = new List&lt;BtNode&gt;(); m_pIsSuccess = false; } public override BtResultEnum DoAction() { if (this.childrenLst == null || this.childrenLst.Count == 0) { return BtResultEnum.Successful; } BtResultEnum _result = BtResultEnum.None; List&lt;BtNode&gt; _waitNodes = new List&lt;BtNode&gt;(); List&lt;BtNode&gt; _mainNodes = new List&lt;BtNode&gt;(); _mainNodes = this.m_pWaitNodes.Count &gt; 0 ? this.m_pWaitNodes : this.childrenLst; for (int i = 0, length = _mainNodes.Count; i &lt; length; i++) { _result = _mainNodes[i].DoAction(); switch (_result) { case BtResultEnum.Successful: m_pIsSuccess = true; break; case BtResultEnum.Running: _waitNodes.Add(_mainNodes[i]); break; default: break; } } if (_waitNodes.Count &gt; 0) { this.m_pWaitNodes = _waitNodes; return BtResultEnum.Running; } _result = checkResult(); Reset(); return _result; } private BtResultEnum checkResult() { return m_pIsSuccess ? BtResultEnum.Successful : BtResultEnum.Fail; } private void Reset() { m_pWaitNodes.Clear(); m_pIsSuccess = false; } } 并行选择组合节点(BtParallelSelector) 一帧将全部子节点执行一遍，全部返回True才返回True，否则返回False； public class BtParallelSelector : BtParallel { private List&lt;BtNode&gt; m_pWaitNodes; private bool m_pIsFail; public BtParallelSelector() { m_pWaitNodes = new List&lt;BtNode&gt;(); m_pIsFail = false; } public override BtResultEnum DoAction() { if (this.childrenLst == null || this.childrenLst.Count == 0) { return BtResultEnum.Fail; } BtResultEnum _result = BtResultEnum.None; List&lt;BtNode&gt; _waitNodes = new List&lt;BtNode&gt;(); List&lt;BtNode&gt; _mainNodes = new List&lt;BtNode&gt;(); _mainNodes = this.m_pWaitNodes.Count &gt; 0 ? this.m_pWaitNodes : this.childrenLst; for(int i = 0, length = _mainNodes.Count; i &lt; length; i++) { _result = _mainNodes[i].DoAction(); switch (_result) { case BtResultEnum.Successful: break; case BtResultEnum.Running: _waitNodes.Add(_mainNodes[i]); break; default: m_pIsFail = true; break; } } if (_waitNodes.Count &gt; 0) { this.m_pWaitNodes = _waitNodes; return BtResultEnum.Running; } _result = checkResult(); Reset(); return _result; } private BtResultEnum checkResult() { return m_pIsFail ? BtResultEnum.Fail : BtResultEnum.Successful; } private void Reset() { m_pWaitNodes.Clear(); m_pIsFail = false; } } 装饰节点(BtDecorator) 该节点只包含一个子节点，并未该子节点添加一些特殊的功能，如让子节点循环操作或者让子task一直运行直到其返回某个运行状态值，或者将task的返回值取反等等，之后所有定义的装饰节点继承自该节点; public class BtDecorator : BtNode { private BtNode child; public BtDecorator() { child = null; } protected void SetChild(BtNode node) { child = node; } } 条件节点(BtCondition) 用于判断某条件是否成立。目前看来，是Behavior Designer为了贯彻职责单一的原则，将判断专门作为一个节点独立处理，比如判断某目标是否在视野内，其实在攻击的Action里面也可以写，但是这样Action就不单一了，不利于视野判断处理的复用，之后所有节点继承自该节点； public class BtCondition : BtNode { public override BtResultEnum DoAction() { return BtResultEnum.Fail; } } 行为节点(BtAction) 行为节点是真正做事的节点，其为叶节点。一般来说行为节点是有我们自己编写的节点，之后所有该节点继承自该节点; public class BtAction : BtNode { //处理具体的行为逻辑 } 简单的案例Behabior Designer插件使用","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"AI","slug":"Game-Play/AI","permalink":"https://wwy.wwywy.com/categories/Game-Play/AI/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://wwy.wwywy.com/tags/AI/"},{"name":"Behavior-Tree","slug":"Behavior-Tree","permalink":"https://wwy.wwywy.com/tags/Behavior-Tree/"}]},{"title":"C++入门","slug":"02500-C++入门","date":"2021-01-28T13:00:00.000Z","updated":"2022-07-10T03:02:59.435Z","comments":true,"path":"posts/1344.html","link":"","permalink":"https://wwy.wwywy.com/posts/1344.html","excerpt":"","text":"C++基本概念简介1.语言的发展：二进制值类==&gt;汇编语言==&gt;中高级语言(C,C++,Java) 2.C++说明：C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程，C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点，C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序； 3.C++发展时间： 1998：C++98，第一个C++标准； 2003：C++03，第二个C++标准； 2011：C++11，第三个C++标准； 2014：C++14，第四个C++标准； 2017：C++17，第五个C++标准； 环境的建立1.C++编译器： GCC编译器： Visual Studio IDEA： C++基本语法1.编译&amp;执行： 打开一个文本编辑器，添加上述代码； 保存文件为 hello.cpp； 打开命令提示符，进入到保存文件所在的目录； 键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件； 现在，键入 ‘ a.out’ 来运行程序； 您可以看到屏幕上显示 ‘ Hello World ‘； 2.C++ 标识符：C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9），C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符； 3.C++关键字： C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com) 4.C++注释：和C#一致； 变量和常量变量类型 类型 关键字 初始化默认值 位 范围 字符型 char ‘\\0’ 1 个字节 -128 到 127 或者 0 到 255 无符号字符型 unsigned char 0 1 个字节 0 到 255 有符号字符型 signed char 0 1 个字节 -128 到 127 整形 int 0 4 个字节 -2147483648 到 2147483647 无符号整形 unsigned int 0 4 个字节 0 到 4294967295 有符号整形 signed int 0 4 个字节 -2147483648 到 2147483647 短整形 short int 0 2 个字节 -32768 到 32767 无符号短整形 unsigned short int 0 2 个字节 0 到 65,535 有符号短整形 signed short int 0 2 个字节 -32768 到 32767 长整形 long int 0 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 无符号长整形 signed long int 0 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 有符号长整形 unsigned long int 0 8 个字节 0 到 18,446,744,073,709,551,615 单精度浮点型 float 0 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) 双精度浮点型 double 0 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) 双精度长浮点型 long double 0 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 宽字符型 wchar_t ‘\\0’ 2 或 4 个字节 1 个宽字符（等价==&gt;typedef short int wchar_t） 无类型 void - - 表示类型的缺失 变量作用域1.作用域说明：主要是三个地方可以定义变量 局部变量：在函数或一个代码块内部声明的变量； 全局变量：在所有函数外部声明的变量； 形式参数：在函数参数的定义中声明的变量，而调用方则被称为实际参数； 常量1.C++声明常量：常量最好全大写 #define 预处理器：语法格式#define 预处理名 常量值； const 关键字：语法格式const 数据类型 变量名 = 常量值； 修饰符类型1.修饰符：修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型；修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀（例如：unsigned long int，其中int可以省略）； signed：有符号类型； unsigned：无符号类型； long：长类型； short：短类型； 2.类型限定符：类型限定符提供了变量的额外信息： const：const 类型的对象在程序执行期间不能被修改改变； volatile：修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率； restrict：由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict； 存储类(型)1.存储类说明：存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期，这些说明符放置在它们所修饰的类型之前，下面列出 C++ 程序中可用的存储类（从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用） auto(C++17删除)：根据初始化表达式自动推断被声明的变量的类型，用于两种情况，声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符； register：用于定义存储在寄存器中而不是 RAM 中的局部变量，这意味着变量的最大尺寸等于寄存器的大小，且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）； static： extern： mutable： thread_local (C++11)： 运算符分支语句循环语句","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"计算机操作系统原理笔记","slug":"01001-计算机操作系统","date":"2021-01-08T13:00:00.000Z","updated":"2022-07-09T16:13:34.548Z","comments":true,"path":"posts/513.html","link":"","permalink":"https://wwy.wwywy.com/posts/513.html","excerpt":"","text":"1 操作系统绪论1.1 操作系统概念定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。 特征：并发、共享、虚拟、异步。 1.2 操作系统发展历程手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。 1.2.1单道批处理原理：计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。 特征：内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。 1.2.2多道批处理原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。 特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。 1.2.3分时系统特征：多路性、独立性、及时性、交互性。 1.2.4实时系统特征：多路性、独立性、及时性、交互性、可靠性。 2 操作系统用户界面2.1 作业定义：分用户和系统角度去理解 a) 用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业； b) 系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL) 2.2 一般用户输入输出方式2.2.1联机输入输出方式2.2.2脱机输入输出方式2.2.3直接耦合方式2.2.4Spooling系统原理：todo。 特点：系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。 2.2.5网络联机方式2.3 系统调用定义：系统调用是操作系统留给编程人员的唯一接口。 原理：todo 2.3.1系统调用指令int和trap指令进行系统调用。 call和jmp指令进入普通过程调用(子调用)。 3 进程管理3.1 进程的概念组成：进程=程序+数据+进程控制块(进程状态信息PCB) 定义：进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 目的：对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性； 优缺点：引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。 3.2 进程和程序的区别a) 进程是动态的，程序是静态的； b) 进程是暂时的，程序是永久的； c) 组成不同，进程的组成包括程序； d) 对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序； e) 进程可以并行，具有独立性、异步性。 f) 进程是竞争计算机资源的基本单位。 3.3 进程控制块(PCB)进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。 3.3.1描述信息3.3.2控制信息3.3.3资源管理信息3.3.4CPU保护现场结构3.4 进程上下文切换原因：进程中断、超时、进程调用。 步骤： a) 保存被切换进程的正文部分到有关存储区。 b) 进程有关调度和资源分配程序执行，选取新的进程。 c) 新进程正文部分从存储区取出，激活选中进程执行。 3.5 进程的状态和进程转换3.5.1进程状态初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止)) 3.5.2进程状态转换3.6 进程控制3.6.1进程创建和撤销3.6.2进程阻塞和唤醒3.6.3进程的挂起和激活3.7 进程互斥和同步3.7.1临界区和临界资源临界资源是一次仅允许一个进程使用的共享资源。 临界区是每个进程访问临界资源的那段代码。 3.7.2信号量和PV原语信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。 信号量的数值仅能由P、V原语操作改变。 3.7.3互斥的概念定义：不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。 3.7.4同步的概念定义：对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。 3.8 进程通信Todo 3.9 死锁问题3.9.1死锁的概念定义： 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。 起因：并发进程的资源竞争 条件：同时具备互斥条件、不剥夺条件、部分分配、环路条件。 3.9.2死锁的解决方案3.9.2.1 死锁预防3.9.2.2 死锁避免最具代表性的避免算法-银行家算法 3.9.2.3 死锁的检测和恢复3.10 线程3.10.1 线程的基本概念定义：引入线程后，线程是操作系统调度和分配的基本单位。 组成：线程=？+线程控制块(TCB) 3.10.2 线程状态和线程控制块(TCB)线程状态：执行状态、就绪状态、阻塞(等待)状态 线程控制块数据结构包括： a) 线程标识符 b) 一组寄存器 c) 线程执行状态 d) 优先级 e) 线程专有存储区 f) 信号屏蔽 g) 堆栈指针 3.10.3 线程和进程的区别从以下六点讨论 a) 调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。 b) 并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。 c) 拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。 d) 独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。 e) 系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。 f) 支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。 4 处理机调度4.1 调度层级一个作业提交后，往往会经历三种层级（加线程四种） 4.1.1作业调度又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。 4.1.1.1 周转时间相关周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间 平均周转时间=所有作业周转时间之和/总作业数 带权周转时间=作业周转时间/作业执行时间 平均带权周转时间=所有带权作业周转时间之和/总作业数 4.1.1.2 响应时间，截止时间和系统吞吐量响应时间是提交请求和返回该请求的响应之间使用的时间截止时间是某任务必须开始执行或者必须完成的最迟时间吞吐量是对单位时间内完成的工作量的量度 4.1.2交换调度又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存 4.1.3进程调度又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式 4.1.3.1 非抢占方式一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。 4.1.3.2 抢占方式系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程 a) 优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU b) 短作业优先原则：就绪的短进程有权抢占长进程的CPU c) 时间片原则：一个时间片用完后，系统重新进行进程调度 4.1.4线程调度Todo 4.2 作业和进程的关系系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。 4.3 调度算法宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。 ​ 微观调度：轮转法、优先级法、多级反馈轮转法。 5 存储管理5.1 存储器结构由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。 5.1.1寄存器寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。 5.1.2高速缓存它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。 5.1.3主存输器简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。 5.1.4磁盘缓存目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。 5.2 程序的处理阶段主要有编译，链接，装入，下面主要讲链接和装入。 5.2.1程序的链接源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。链接又可分为静态链接，装入时动态链接，运行时动态链接。 5.2.2程序的装入分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。 5.3 地址变换5.3.1静态地址重定向原理：Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。 5.3.2动态地址重定位关系：MA(物理地址)=BR(基址地址)+VR(虚拟地址)。 原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。 5.4 分区存储管理分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。 5.4.1固态分区法原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。 优点:易于实现，开销小。 缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。 5.4.2动态分区法原理：动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。 优点：没有内碎片； 缺点：有外碎片； 算法：根据情况有以下俩种，着重介绍三种 a) 基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法 b) 基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法 5.4.2.2 最先适应法5.4.2.3 最佳适应法5.4.2.4 最坏适应法5.4.3页式管理（离散分配）基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。 5.4.3.1 静态页式管理原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。 5.4.3.2 动态页式管理5.4.4段式和段页式管理基本思想：todo 5.4.4.1 段式管理原理：todo 5.4.4.2 段页式管理原理：todo 5.4.5覆盖和交换技术5.5 虚拟存输器5.5.1虚拟存储的实现方式虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式： 5.5.1.1 分页请求系统在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。 硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上 5.5.1.2 请求分段系统在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页” 5.5.2页面置换算法5.5.2.1 随机淘汰算法随机地选择某个用户地页面并将其换出。 5.5.2.2 最佳置换算法（理想型淘汰算法OPT）其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。 5.5.2.3 先进先出置换算法（FIFO）总是先淘汰最先进入内存的页面。 5.5.2.4 最近最久未使用算法（LRU）选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。 5.5.2.5 最少使用置换算法（LFU）在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。 5.5.2.6 Clock置换算法是一种LRU算法每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面； 6 文件系统6.1 文件系统基本概念目的：文件系统地出现是为了更好地管理软件资源 文件系统的定义：操作系统中与管理文件有关的软件和数据称为文件系统 文件的定义：文件时一段程序和数据的集合 文件的分类：按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。 6.2 文件的逻辑结构和存取方式6.2.1逻辑结构字符流的无结构文件：管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。 记录式的有结构文件：把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。 6.2.1.1 连续结构6.2.1.2 多重结构6.2.1.3 转置结构6.2.1.4 顺序结构6.2.2逻辑存储方法6.2.2.1 顺序存输方法6.2.2.2 随机存输方法6.2.2.3 按关键字存输方法多用于复杂文件系统。 6.2.3逻辑搜索方式文件的获取是要找到文件内容所在的逻辑地址 6.2.3.1 线性搜索法6.2.3.2 散列法6.2.3.3 二分搜索法6.3 文件的物理结构和存储设备6.3.1文件物理结构6.3.1.1 连续文件连续文件采用连续分配方式： 特点：为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。优点：顺序访问容易; 顺序访问速度快;缺点：要求有连续的存储空间; 必须事先知道文件的长度; 6.3.1.2 串联文件串联文件采用链接分配 特点：文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；优点：没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。缺点：存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间; 6.3.1.3 索引文件索引文件采用索引分配 特点：每个文件都有自己的索引块，这是一个磁盘块地址的数组。 6.3.2文件存储设备存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。 6.3.2.1 顺序存取存储设备—磁带特点：只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。 影响因素：信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。 6.3.2.2 直接存取存储设备—磁盘6.4 文件存储空间管理文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。 6.4.1空闲目录管理6.4.2空闲链块法6.4.3位示图6.5 文件目录管理从文件管理角度看，一个文件包括文件说明和文件体。 6.5.1文件目录的种类6.5.1.1 单级文件目录在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。 6.5.1.2 两级文件目录目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB； 6.5.1.3 树形结构目录多级目录结构又称为树型目录结构；主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点； 6.5.2文件目录的共享从系统管理的方式来看，有三种方法可以实现文件共享 6.5.2.1 绕道法6.5.2.2 链接法6.5.2.3 基本文件目录表（BFD）6.5.3目录管理文件目录管理应该存放在磁盘，其他的没理解todo 6.6 文件存取控制用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。 6.6.1存取控制矩阵6.6.2存取控制表6.6.3口令方式6.6.4密码方式密码方式是保密性最好的验证方式。 7 设备管理7.1 设备的分类在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。 7.2 数据传输控制方式设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。 7.2.1程序直接控制方式由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。 7.2.2中断方式I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。 7.2.3DMA方式在外围设备和内存之间开辟直接的数据交换通道。 7.2.4通道控制方式以内存为中心，实现设备和内存直接交换数据的控制的方式。 7.3 中断技术原理：中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。 过程：判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点 7.3.1中断技术的分类中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。 7.3.1.1 外中断一般是来自处理机和内存外部的中断 7.3.1.2 内中断（陷阱）一般是来自处理机和内存内部的中断 7.3.1.3 软中断是通信进程之间模拟硬中断的一种信号通信方式 7.4 缓冲技术目的：缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。 分类：缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。 7.4.1缓冲池的结构缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。 7.4.2缓冲池管理Todo","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"计算机操作系统","slug":"大学知识/CS基础/计算机操作系统","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Python语言","slug":"02800-Python语言","date":"2021-01-05T13:00:00.000Z","updated":"2022-07-10T03:16:31.216Z","comments":true,"path":"posts/02800.html","link":"","permalink":"https://wwy.wwywy.com/posts/02800.html","excerpt":"","text":"Python简介1.Python的说明： Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言； Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码； Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术； Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏； 2.Python的版本区别：初学者直接使用Python3即可 Python2： Python3: Python的基本语法1.编程方式： 交互式编程：交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码； 脚本编程：通过脚本参数调用解释器开始执行脚本，直到脚本执行完毕。当脚本执行完成后，解释器不再有效，Python的后缀名一般以py结尾； 2.行和缩进：Python不使用{}来进行逻辑包裹，而是使用缩进来进行编写模块，缩进的空白数必须严格执行； 3.多行语句： Python语句中一般以新行作为语句的结束符，但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下1所示； 语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下2实例； Python同一行显示多条语句是可以用;作为分割的，这和其他语言语法一致；1.示例一 total = item_one + \\ item_two + \\ item_three 2.示例二 days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] 4.Python引号：Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须是相同类型的，其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释； 1.示例一 word = 'word' sentence = \"这是一个句子。\" paragraph = \"\"\"这是一个段落。 包含了多个语句\"\"\" 5.Python注释： 单行注释使用#; 多行注释使用”””或者’’’； 6.Python空行：函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始，空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。（记住：空行也是程序代码的一部分） 7.用户输入和输出： 输入：该语句 raw_input(“按下 enter 键退出，其他任意键显示…\\n”)，其中\\n 实现换行。一旦用户按下 enter(回车) 键退出，其它键显示； 输出：print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 ,; Python变量类型基本变量类型说明1.Numbers（数字）： 包括了int、long、float、complex类型; 他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象，当你指定一个值时，Number 对象就会被创建； 可以使用del语法进行删除引用； 2.String（字符串）： 由数字、字母、下划线组成的一串字符； python的字串列表有2种取值顺序，从左到右索引默认0开始的，最大范围是字符串长度少1，从右到左索引默认-1开始的，最大范围是字符串开头； -以下 实例一是对字符串的一些操作；1.示例一 str = 'Hello World!' print str # 输出完整字符串 print str[0] # 输出字符串中的第一个字符 print str[2:5] # 输出字符串中第三个至第六个之间的字符串 print str[2:] # 输出从第三个字符开始的字符串 print str * 2 # 输出字符串两次 print str + \"TEST\" # 输出连接的字符串 3.List（列表）： 列表用 [ ] 标识，是 python 最通用的复合数据类型，列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套），只有当个值时后面也要加逗号； 索引和字符串类似，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾 如下示例一代表对列表的操作：1.示例一 list = [ 'runoob', 786 , 2.23, 'john', 70.2 ] tinylist = [123, 'john'] print list # 输出完整列表 print list[0] # 输出列表的第一个元素 print list[1:3] # 输出第二个至第三个元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素 print tinylist * 2 # 输出列表两次 print list + tinylist # 打印组合的列表 4.Tuple（元组） 元组是另一个数据类型，类似于 List（列表），元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表，这点很重要，只有当个值时后面也要加逗号； 如下示例一代表对元组的操作：1.实例一 tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 ) tinytuple = (123, 'john') print tuple # 输出完整元组 print tuple[0] # 输出元组的第一个元素 print tuple[1:3] # 输出第二个至第四个（不包含）的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素 print tinytuple * 2 # 输出元组两次 print tuple + tinytuple # 打印组合的元组 5.Dictionary（字典） 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型，列表是有序的对象集合，字典是无序的对象集合； 两者之间的区别在于字典当中的元素是通过键来存取的，而不是通过偏移存取； 字典用”{ }”标识。字典由索引(key)和它对应的值value组成； 以下示例一代表对字典的操作1.示例一 dict = {} dict['one'] = \"This is one\" dict[2] = \"This is two\" tinydict = {'name': 'runoob','code':6734, 'dept': 'sales'} print dict['one'] # 输出键为'one' 的值 print dict[2] # 输出键为 2 的值 print tinydict # 输出完整的字典 print tinydict.keys() # 输出所有键 print tinydict.values() # 输出所有值 数据类型的转换 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值； 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 Python运算符算数运算符 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//24&gt;&gt;&gt; -9//2-5 关系运算符 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等。python3 已废弃。 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 赋值运算符 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 位运算符 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 运算符优先级 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 Python分支语句1.语法格式 num = 5 if num == 3: # 判断num的值 print 'boss' elif num == 2: print 'user' elif (num &gt;= 0 and num &lt;= 5) or (num &gt;= 10 and num &lt;= 15): print 'worker' elif num &lt; 0: # 值小于零时输出 print 'error' else: print 'roadman' # 条件均不成立时输出 Python循环语句：While循环语句1.语法格式 count = 0 while count &lt; 5: // print count, \" is less than 5\" count = count + 1 else: #循环条件为 false 时执行 else 语句块 print count, \" is not less than 5\" For循环语句1.语法格式 for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print ('%d 等于 %d * %d' % (num,i,j)) break # 跳出当前循环 else: # 循环的 else 部分 print ('%d 是一个质数' % num) Python数字详解1.math和cmath模块说明：Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中，Python math 模块提供了许多对浮点数的数学运算函数，Python cmath 模块包含了一些用于复数运算的函数，cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算，要使用 math 或 cmath 函数必须先导入 Import math 或者 import cmath; 2.Python数学函数： 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 [round(x ,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根 3.Python随机数函数：随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 [randrange (start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 [seed(x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 4.Python三角函数： 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 5.Python数学常量： 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。 Python字符串详解1.转义字符：在需要在字符中使用特殊字符时，python 用反斜杠 \\ 转义字符： 转义字符 描述 (在行尾时) 续行符 \\ 反斜杠符号 ' 单引号 \" 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 \\xyy 十六进制数，以 \\x 开头，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 2.字符运算符 操作符 描述 实例 + 字符串连接 &gt;&gt;&gt;a + b’HelloPython’ * 重复输出字符串 &gt;&gt;&gt;a * 2’HelloHello’ [] 通过索引获取字符串中字符 &gt;&gt;&gt;a[1]’e’ [ : ] 截取字符串中的一部分 &gt;&gt;&gt;a[1:4]’ell’ in 成员运算符 - 如果字符串中包含给定的字符返回 True &gt;&gt;&gt;”H” in aTrue not in 成员运算符 - 如果字符串中不包含给定的字符返回 True &gt;&gt;&gt;”M” not in aTrue r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r’\\n’\\n&gt;&gt;&gt; print R’\\n’\\n % 格式字符串 下节点详细说明 3.Python格式化字符串： 语法格式实例：print “My name is %s and weight is %d kg!” % (‘Zara’, 21) 也可以使用str.format()，它增强了字符串格式化功能； 字符串格式化符号 描述 符 号 格式化字符及其ASCII码 %c 格式化字符串 %s 格式化整数 %d 格式化无符号整型 %u 格式化无符号八进制数 %o 格式化无符号十六进制数 %x 格式化无符号十六进制数（大写） %X 格式化浮点数字，可指定小数点后的精度 %f 用科学计数法格式化浮点数 %e 作用同%e，用科学计数法格式化浮点数 %E %f和%e的简写 %g %F 和 %E 的简写 %G 用十六进制数格式化变量的地址 %p 格式化操作符辅助指令 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) 4.字符串内建函数：这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的； 方法 描述 string.capitalize() 把字符串的第一个字符大写 string.center(width) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 string.count(str, beg=0, end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 string.decode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ string.encode(encoding=’UTF-8’, errors=’strict’) 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ string.endswith(obj, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. string.expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。 string.find(str, beg=0, end=len(string)) 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 string.format() 格式化字符串 string.index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在 string中会报一个异常. string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False string.isdecimal() 如果 string 只包含十进制数字则返回 True 否则返回 False. string.isdigit() 如果 string 只包含数字则返回 True 否则返回 False. string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False string.isnumeric() 如果 string 中只包含数字字符，则返回 True，否则返回 False string.isspace() 如果 string 中只包含空格，则返回 True，否则返回 False. string.istitle() 如果 string 是标题化的(见 title())则返回 True，否则返回 False string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 string.ljust(width) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 string.lower() 转换 string 中所有大写字符为小写. string.lstrip() 截掉 string 左边的空格 string.maketrans(intab, outtab) maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 string.partition(str) 有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string. string.replace(str1, str2, num=string.count(str1)) 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. string.rfind(str, beg=0,end=len(string) ) 类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。 string.rindex( str, beg=0,end=len(string)) 类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。 string.rjust(width) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 string.rpartition(str) 类似于 partition()函数,不过是从右边开始查找 string.rstrip() 删除 string 字符串末尾的空格. string.split(str=””, num=string.count(str)) 以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+1 个子字符串 [string.splitlines(keepends]) 按照行(‘\\r’, ‘\\r\\n’, ‘\\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 string.startswith(obj, beg=0,end=len(string)) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查. string.strip([obj]) 在 string 上执行 lstrip()和 rstrip() string.swapcase() 翻转 string 中的大小写 string.title() 返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) string.translate(str, del=””) 根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中 string.upper() 转换 string 中的小写字母为大写 string.zfill(width) 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0 Python列表详解1.列表脚本操作符：列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表； Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 2.列表截取： Python 表达式 结果 描述 L[2] ‘Taobao’ 读取列表中第三个元素 L[-2] ‘Runoob’ 读取列表中倒数第二个元素 L[1:] [‘Runoob’, ‘Taobao’] 从第二个元素开始截取列表 3.列表函数： 序号 函数 1 cmp(list1, list2)比较两个列表的元素 2 len(list)列表元素个数 3 max(list)返回列表元素最大值 4 min(list)返回列表元素最小值 5 list(seq)将元组转换为列表 4.列表方法 序号 方法 1 list.append(obj)在列表末尾添加新的对象 2 list.count(obj)统计某个元素在列表中出现的次数 3 list.extend(seq)在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj)从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj)将对象插入列表 6 [list.pop(index=-1])移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj)移除列表中某个值的第一个匹配项 8 list.reverse()反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False)对原列表进行排序 Python元组详解1.元组运算符：与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组； Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 2.元组索引和截取：因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素； Python 表达式 结果 描述 L[2] ‘SPAM!’ 读取第三个元素 L[-2] ‘Spam’ 反向读取，读取倒数第二个元素 L[1:] (‘Spam’, ‘SPAM!’) 截取元素 3.无关闭分隔符：任意无符号的对象，以逗号隔开，默认为元组，例如 print ‘abc’, -4.24e93, 18+6.6j, ‘xyz’ 和 x, y = 1, 2； 4.元组内置函数 序号 方法及描述 1 cmp(tuple1, tuple2)比较两个元组元素。 2 len(tuple)计算元组元素个数。 3 max(tuple)返回元组中元素最大值。 4 min(tuple)返回元组中元素最小值。 5 tuple(seq)将列表转换为元组。 Python字典详解1.字典内置函数： 序号 函数及描述 1 cmp(dict1, dict2)比较两个字典元素。 2 len(dict)计算字典元素个数，即键的总数。 3 str(dict)输出字典可打印的字符串表示。 4 type(variable)返回输入的变量类型，如果变量是字典就返回字典类型。 2.字典内置方法： 序号 函数及描述 1 dict.clear()删除字典内所有元素 2 dict.copy()返回一个字典的浅复制 3 [dict.fromkeys(seq, val])创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4 dict.get(key, default=None)返回指定键的值，如果值不在字典中返回default值 5 dict.has_key(key)如果键在字典dict里返回true，否则返回false 6 dict.items()以列表返回可遍历的(键, 值) 元组数组 7 dict.keys()以列表返回一个字典所有的键 8 dict.setdefault(key, default=None)和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2)把字典dict2的键/值对更新到dict里 10 dict.values()以列表返回字典中的所有值 11 [pop(key,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem()返回并删除字典中的最后一对键和值。 Python日期和时间1.time时间模块内置函数： 既有时间处理，也有转换时间格式的； 包含俩个重要属性，如下 time.timezone : 是当时时区距离0时区的偏移秒数； time.tzname：包含一对根据情况的不同而不同的字符串； 序号 函数及描述 1 time.altzone返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 2 [time.asctime(tupletime])接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 3 time.clock( )用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 4 [time.ctime(secs])作用相当于asctime(localtime(secs))，未给参数相当于asctime() 5 [time.gmtime(secs])接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 6 [time.localtime(secs])接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 7 time.mktime(tupletime)接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 8 time.sleep(secs)推迟调用线程的运行，secs指秒数。 9 [time.strftime(fmt,tupletime])接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 10 time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)根据fmt的格式把一个时间字符串解析为时间元组。 11 time.time( )返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 12 time.tzset()根据环境变量TZ重新初始化时间相关设置。 2.calendar日历模块： 此模块的函数都是日历相关的，例如打印某月的字符月历； 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数； 序号 函数及描述 1 *calendar.calendar(year,w=2,l=1,c=6)**返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21 W+18+2* C。l是每星期行数。 2 **calendar.firstweekday( )**返回当前每周起始日期的设置。默认情况下，首次载入 calendar 模块时返回 0，即星期一。 3 **calendar.isleap(year)**是闰年返回 True，否则为 False。&gt;&gt;&gt; import calendar&gt;&gt;&gt; print(calendar.isleap(2000))True&gt;&gt;&gt; print(calendar.isleap(1900))False 4 **calendar.leapdays(y1,y2)**返回在Y1，Y2两年之间的闰年总数。 5 *calendar.month(year,month,w=2,l=1)**返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7 w+6。l是每星期的行数。 6 **calendar.monthcalendar(year,month)**返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 7 **calendar.monthrange(year,month)**返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 8 **calendar.prcal(year,w=2,l=1,c=6)**相当于 **print calendar.calendar(year,w=2,l=1,c=6)**。 9 calendar.prmonth(year,month,w=2,l=1)**相当于 **print calendar.month(year,month,w=2,l=1) 。 10 **calendar.setfirstweekday(weekday)**设置每周的起始日期码。0（星期一）到6（星期日）。 11 **calendar.timegm(tupletime)**和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 12 **calendar.weekday(year,month,day)**返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 python函数1.用户自定义函数：以下是定义函数的规则 函数代码以def关键词开头，后接函数标识符名词和圆括号(); 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数； 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明； 函数内容以冒号起始，并且缩进； return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None； 2.参数传递：Python中类型属于对象，变量没有类型，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象； 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身； 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象； 3.参数类型： 必备参数：定义形参时只有参数名，传入实参时只有参数值，必须按顺序输入； 关键字参数：定义形参时只有参数名，传入实参时有参数名并且有参数值，可以不按顺序输入； 默认参数：在定义形参时，定义参数名并且有参数值； 不定长参数：定义形参时，可以在参数名前加*，相当于C#的不定长参数，取值时遍历取出； 4.匿名函数： 语法：lambda [arg1 [,arg2,…..argn]] ：表达式； lambda只是一个表达式,而不是一个代码块，函数体比def简单很多，仅仅能在lambda表达式中封装有限的逻辑进去; lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数； 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率； Python模块1.模块的说明：是一个Python文件，以.py结尾，模块能定义函数、类和变量； 2.模块引入说明： import语句语法：import module1[, module2[,… moduleN]]； from…import语句语法：from modname import name1[, name2[, … nameN]]； from…import：将一个模块所有内容都导入就是在后面加\\; 3.搜索路径：模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录，当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 1：当前目录 2：如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 3：如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。 4.PYTHONPATH：环境变量，由装在一个列表里的许多目录组成； Windows 系统路径：set PYTHONPATH=c:\\python27\\lib； UNIX 系统路径：set PYTHONPATH=/usr/local/lib/python； 5.命名空间和作用域：命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典；如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量，每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样；函数内部会优先访问局部变量，如果函数要访问全局变量，需要加global关键字； 内置命名空间：启动解释器时自动加载内存的各种名字所在的空间； 全局命名空间：从上到下定义的变量名和函数名； 局部命名空间：函数内部执行开辟的空间，存放了各种函数内部的各种名字； 6.模块关键函数： dir()函数：一个排好序的字符串列表，返回的列表容纳了在一个模块里定义的所有模块； globals()函数：返回的字典是所有在该函数里能访问的全局名字； 返回的字典是所有能在该函数里访问的命名 reload()函数：当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块，参数传的是模块名字，而并非字符串； 7.包：包其实就是文件夹，但是文件夹下面必须存在_init_.py文件，文件内容可以为空，该文件只是标志当前文件夹是一个包，导入包下的模块时，只需要通过包名点出模块名即可； Python文件I/O流File文件1.基础的输入和输出： print()内置函数：最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式； raw_input()内置函数：标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）； input()内置函数： input 和raw_input不同的是可以接收一个Python表达式作为输入，并将运算结果返回 2.open()函数：用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写 file_name：file_name变量是一个包含了你要访问的文件名称的字符串值； access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)； buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认； encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。 mode 参数有： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 3.close()方法： 语法：flie变量.close(); 刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入； 4.write()方法： 语法：flie变量.write(string)； write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字，write()方法不会在字符串的结尾添加换行符(‘\\n’)； 5.read()方法： 语法：file.read([count]) 从一个打开的文件读取一个字符串，字符串亦可以是二进制数据与； 6.文件定位： tell()方法：获取当前打开文件的位置下标； seek()方法：改变当前文件夹的位置，第一个参数Offset变量表示要移动的字节数。第二个参数From变量指定开始移动字节的参考位置；如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置； 7.重命名和删除文件： rename()方法：第一个参数当前文件名和新文件名（这样有点离谱）； remove()方法：提供文件名参数来作为删除； 8.file对象函数： 序号 方法及描述 1 file.close()关闭文件。关闭后文件不能再进行读写操作。 2 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。 5 file.next()返回文件下一行。 6 [file.read(size])从文件读取指定的字节数，如果未给定或为负则读取所有。 7 [file.readline(size])读取整行，包括 “\\n” 字符。 8 [file.readlines(sizeint])读取所有行并返回列表，若给定sizeint&gt;0，则是设置一次读多少字节，这是为了减轻读取压力。 9 [file.seek(offset, whence])设置文件当前位置 10 file.tell()返回文件当前位置。 11 [file.truncate(size])截取文件，截取的字节通过size指定，默认为当前文件位置。 12 file.write(str)将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 OS目录 序号 方法及描述 1 os.access(path, mode)检验权限模式 2 os.chdir(path)改变当前工作目录 3 os.chflags(path, flags)设置路径的标记为数字标记。 4 os.chmod(path, mode)更改权限 5 os.chown(path, uid, gid)更改文件所有者 6 os.chroot(path)改变当前进程的根目录 7 os.close(fd)关闭文件描述符 fd 8 os.closerange(fd_low, fd_high)关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 9 os.dup(fd)复制文件描述符 fd 10 os.dup2(fd, fd2)将一个文件描述符 fd 复制到另一个 fd2 11 os.fchdir(fd)通过文件描述符改变当前工作目录 12 os.fchmod(fd, mode)改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 13 os.fchown(fd, uid, gid)修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 14 os.fdatasync(fd)强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 15 [os.fdopen(fd, mode[, bufsize]])通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 16 os.fpathconf(fd, name)返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 17 os.fstat(fd)返回文件描述符fd的状态，像stat()。 18 os.fstatvfs(fd)返回包含文件描述符fd的文件的文件系统的信息，像 statvfs() 19 os.fsync(fd)强制将文件描述符为fd的文件写入硬盘。 20 os.ftruncate(fd, length)裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 21 os.getcwd()返回当前工作目录 22 os.getcwdu()返回一个当前工作目录的Unicode对象 23 os.isatty(fd)如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 24 os.lchflags(path, flags)设置路径的标记为数字标记，类似 chflags()，但是没有软链接 25 os.lchmod(path, mode)修改连接文件权限 26 os.lchown(path, uid, gid)更改文件所有者，类似 chown，但是不追踪链接。 27 os.link(src, dst)创建硬链接，名为参数 dst，指向参数 src 28 os.listdir(path)返回path指定的文件夹包含的文件或文件夹的名字的列表。 29 os.lseek(fd, pos, how)设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 30 os.lstat(path)像stat(),但是没有软链接 31 os.major(device)从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 32 os.makedev(major, minor)以major和minor设备号组成一个原始设备号 33 [os.makedirs(path, mode])递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 34 os.minor(device)从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 35 [os.mkdir(path, mode])以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 36 [os.mkfifo(path, mode])创建命名管道，mode 为数字，默认为 0666 (八进制) 37 [os.mknod(filename, mode=0600, device])创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 38 [os.open(file, flags, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的 39 os.openpty()打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 40 os.pathconf(path, name)返回相关文件的系统配置信息。 41 os.pipe()创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 42 [os.popen(command, mode[, bufsize]])从一个 command 打开一个管道 43 os.read(fd, n)从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 44 os.readlink(path)返回软链接所指向的文件 45 os.remove(path)删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 46 os.removedirs(path)递归删除目录。 47 os.rename(src, dst)重命名文件或目录，从 src 到 dst 48 os.renames(old, new)递归地对目录进行更名，也可以对文件进行更名。 49 os.rmdir(path)删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 50 os.stat(path)获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 51 [os.stat_float_times(newvalue])决定stat_result是否以float对象显示时间戳 52 os.statvfs(path)获取指定路径的文件系统统计信息 53 os.symlink(src, dst)创建一个软链接 54 os.tcgetpgrp(fd)返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 55 os.tcsetpgrp(fd, pg)设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 56 [os.tempnam(dir[, prefix]])返回唯一的路径名用于创建临时文件。 57 os.tmpfile()返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 58 os.tmpnam()为创建一个临时文件返回一个唯一的路径 59 os.ttyname(fd)返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 60 os.unlink(path)删除文件路径 61 os.utime(path, times)返回指定的path文件的访问和修改的时间。 62 [os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])](https://www.runoob.com/python/os-walk.html)输出在文件夹中的文件名通过在树中游走，向上或者向下。 63 os.write(fd, str)写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 64 os.path 模块获取文件的属性信息。 Python异常处理","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"编程语言/Python","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://wwy.wwywy.com/tags/Python/"}]},{"title":"Unity进阶-数据持久化二进制","slug":"03010-Unity进阶-数据持久化二进制","date":"2020-12-24T13:00:00.000Z","updated":"2022-07-10T03:18:02.335Z","comments":true,"path":"posts/1544.html","link":"","permalink":"https://wwy.wwywy.com/posts/1544.html","excerpt":"","text":"概述1.二进制说明：2进制是计算技术中广泛采用的一种数制。2进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”；计算机中存储的数据本质上都是2进制数的存储，在计算机中位（bit）是最小的存储单位，1位就是一个0或者一个1； 2.XML和Json的缺点：xml和json安全性和效率较低，如下分析 清晰易懂是他们的共同好处，但是也是一把双刃剑，比如如果我们用xml或者json存储数据，只要玩家找到对应的存储信息， 就能够快速修改其中的内容； 而且由于他们把数据转换成了对应的xml或者json字符串，我们最终在存储数据时存储的都是字符串数据，在读写时效率较低，内存和硬盘空间占用较大； 3.二进制数据持久化的优点： 安全性较高； 效率较高； 网络通信铺垫； 基础知识各类型转字节数组1.二进制读写的本质 //它就是通过将各类型变量转换为字节数组 //将字节数组直接存储到文件中 //一般人是看不懂存储的数据的 //不仅可以节约存储空间，提升效率 //还可以提升安全性 //而且在网络通信中我们直接传输的数据也是字节数据（2进制数据） 2.各类型数据和字节数据相互转换 //C#提供了一个公共类帮助我们进行转化 //我们只需要记住API即可 //类名：BitConverter //命名空间：using System //1.将各类型转字节 byte[] bytes = BitConverter.GetBytes(256); //2.字节数组转各类型 int i = BitConverter.ToInt32(bytes, 0); 3.字符串类型和字节数据相互转换 // 在C#中有一个专门的编码格式类 来帮助我们将字符串和字节数组进行转换 // 类名：Encoding // 需要引用命名空间：using System.Text; //1.将字符串以指定编码格式转字节 byte[] bytes2 = Encoding.UTF8.GetBytes(\"唐老狮\"); //2.字节数组以指定编码格式转字符串 string s = Encoding.UTF8.GetString(bytes2); 4.标准编码格式 //编码是用预先规定的方法将文字、数字或其它对象编成数码，或将信息、数据转换成规定的电脉冲信号。 //为保证编码的正确性，编码要规范化、标准化，即需有标准的编码格式。 //常见的编码格式有ASCII、ANSI、GBK、GB2312、UTF - 8、GB18030和UNICODE等。 // 说人话 // 计算机中数据的本质就是2进制数据 // 编码格式就是用对应的2进制数 对应不同的文字 // 由于世界上有各种不同的语言，所有会有很多种不同的编码格式 // 不同的编码格式 对应的规则是不同的 // 如果在读取字符时采用了不统一的编码格式，可能会出现乱码 // 游戏开发中常用编码格式 UTF-8 // 中文相关编码格式 GBK // 英文相关编码格式 ASCII 文件操作相关——文件1.文件操作相关说明 //在电脑上我们可以在操作系统中创建删除修改文件 //可以增删查改各种各样的文件类型 //代码中的文件操作就是通过代码来做这些事情 //C#提供了一个名为File（文件）的公共类 //让我们可以快捷的通过代码操作文件相关 //类名：File //命名空间： System.IO 2.文件操作File类的常用内容 //1.判断文件是否存在 if(File.Exists(Application.dataPath + \"/UnityTeach.tang\")) //2.创建文件 FileStream fs = File.Create(Application.dataPath + \"/UnityTeach.tang\"); //3.写入文件 //将指定字节数组 写入到指定路径的文件中 byte[] bytes = BitConverter.GetBytes(999); File.WriteAllBytes(Application.dataPath + \"/UnityTeach.tang\", bytes); //将指定的string数组内容 一行行写入到指定路径中 string[] strs = new string[] { \"123\", \"唐老狮\", \"123123kdjfsalk\", \"123123123125243\"}; File.WriteAllLines(Application.dataPath + \"/UnityTeach2.tang\", strs); //将指定字符串写入指定路径 File.WriteAllText(Application.dataPath + \"/UnityTeach3.tang\", \"唐老狮哈\\n哈哈哈哈123123131231241234123\"); //4.读取文件 //读取字节数据 bytes = File.ReadAllBytes(Application.dataPath + \"/UnityTeach.tang\"); print(BitConverter.ToInt32(bytes, 0)); //读取所有行信息 strs = File.ReadAllLines(Application.dataPath + \"/UnityTeach2.tang\"); for (int i = 0; i &lt; strs.Length; i++) { print(strs[i]); } //读取所有文本信息 print(File.ReadAllText(Application.dataPath + \"/UnityTeach3.tang\")); //5.删除文件 //注意 如果删除打开着的文件 会报错 File.Delete(Application.dataPath + \"/UnityTeach.tang\"); //6.复制文件 //参数一：现有文件 需要是流关闭状态 //参数二：目标文件 //参数三：是否覆盖 File.Copy(Application.dataPath + \"/UnityTeach2.tang\", Application.dataPath + \"/唐老狮.tanglaoshi\", true); //7.文件替换 //参数一：用来替换的路径 //参数二：被替换的路径 //参数三：备份路径 File.Replace(Application.dataPath + \"/UnityTeach3.tang\", Application.dataPath + \"/唐老狮.tanglaoshi\", Application.dataPath + \"/唐老狮备份.tanglaoshi\"); //8.以流的形式 打开文件并写入或读取 //参数一：路径 //参数二：打开模式 //参数三：访问模式 FileStream fs = File.Open(Application.dataPath + \"/UnityTeach2.tang\", FileMode.OpenOrCreate, FileAccess.ReadWrite); 文件操作相关——文件流1.什么是文件流 //在C#中提供了一个文件流类 FileStream类 //需要引用命名空间：System.IO //它主要作用是用于读写文件的细节 //我们之前学过的File只能整体读写文件 //而FileStream可以以读写字节的形式处理文件 //说人话： //文件里面存储的数据就像是一条数据流（数组或者列表） //我们可以通过FileStream一部分一部分的读写数据流 //比如我可以先存一个int（4个字节）再存一个bool（1个字节）再存一个string（n个字节） //利用FileStream可以以流式逐个读写 2. FileStream文件流类常用方法 (1)打开或创建指定文件 //方法一：new FileStream //参数一：路径 //参数二：打开模式 // CreateNew:创建新文件 如果文件存在 则报错 // Create:创建文件，如果文件存在 则覆盖 // Open:打开文件，如果文件不存在 报错 // OpenOrCreate:打开或者创建文件根据实际情况操作 // Append:若存在文件，则打开并查找文件尾，或者创建一个新文件 // Truncate:打开并清空文件内容 //参数三：访问模式 //参数四：共享权限 // None 谢绝共享 // Read 允许别的程序读取当前文件 // Write 允许别的程序写入该文件 // ReadWrite 允许别的程序读写该文件 FileStream fs = new FileStream(Application.dataPath + \"/Lesson3.tang\", FileMode.Create, FileAccess.ReadWrite); //方法二：File.Create //参数一：路径 //参数二：缓存大小 //参数三：描述如何创建或覆盖该文件（不常用） // Asynchronous 可用于异步读写 // DeleteOnClose 不在使用时，自动删除 // Encrypted 加密 // None 不应用其它选项 // RandomAccess 随机访问文件 // SequentialScan 从头到尾顺序访问文件 // WriteThrough 通过中间缓存直接写入磁盘 FileStream fs2 = File.Create(Application.dataPath + \"/Lesson3.tang\"); //方法三：File.Open //参数一：路径 //参数二：打开模式 FileStream fs3 = File.Open(Application.dataPath + \"/Lesson3.tang\", FileMode.Open); (2)重要属性和方法 //文本字节长度fs.Length //是否可写fs.CanRead //是否可读fs.CanWrite //将字节写入文件 当写入后 一定执行一次 fs.Flush() //关闭流 当文件读写完毕后 一定执行fs.Close() //缓存资源销毁回收 fs.Dispose() （3）写入字节 //方法：Write //参数一：写入的字节数组 //参数二：数组中的开始索引 //参数三：写入多少个字节 fs.Write(bytes, 0, bytes.Length); (4).读取字节 a:挨个读取字节数组 //读取第一个整形 byte[] bytes2 = new byte[4]; //参数一：用于存储读取的字节数组的容器 //参数二：容器中开始的位置 //参数三：读取多少个字节装入容器 //返回值：当前流索引前进了几个位置 int index = fs2.Read(bytes2, 0, 4); int i = BitConverter.ToInt32(bytes2, 0); print(\"取出来的第一个整数\" + i);//999 print(\"索引向前移动\" + index + \"个位置\"); //读取第二个字符串 //读取字符串字节数组长度 index = fs2.Read(bytes2, 0, 4); print(\"索引向前移动\" + index + \"个位置\"); int length = BitConverter.ToInt32(bytes2, 0); //要根据我们存储的字符串字节数组的长度 来声明一个新的字节数组 用来装载读取出来的数据 bytes2 = new byte[length]; index = fs2.Read(bytes2, 0, length); print(\"索引向前移动\" + index + \"个位置\"); //得到最终的字符串 打印出来 print(Encoding.UTF8.GetString(bytes2)); fs2.Dispose(); b:一次性读取再挨个读取 //一开始就申明一个 和文件字节数组长度一样的容器 byte[] bytes3 = new byte[fs3.Length]; fs3.Read(bytes3, 0, (int)fs3.Length); fs3.Dispose(); //读取整数 print(BitConverter.ToInt32(bytes3, 0)); //得去字符串字节数组的长度 int length2 = BitConverter.ToInt32(bytes3, 4); //得到字符串 print(Encoding.UTF8.GetString(bytes3, 8, length2)); 3.更加安全的使用文件流对象 //using关键字重要用法 //using (申明一个引用对象) //{ //使用对象 //} //无论发生什么情况 当using语句块结束后 //会自动调用该对象的销毁方法 避免忘记销毁或关闭流 //using是一种更安全的使用方法 //强调：目前我们对文件流进行操作 为了文件操作安全 都用using来进行处理最好 文件操作相关——文件夹1.文件夹操作说明 //平时我们可以在操作系统的文件管理系统中 //通过一些操作增删查改文件夹 //我们目前要学习的就是通过代码的形式 //来对文件夹进行增删查改的操作 //类名:Directory //命名空间：using System.IO 2.C#提供给我们的文件夹操作公共类 //1.判断文件夹是否存在 if( Directory.Exists(Application.dataPath + \"/数据持久化\")) //2.创建文件夹 DirectoryInfo info = Directory.CreateDirectory(Application.dataPath + \"/数据持久化四\"); //3.删除文件夹 //参数一：路径 //参数二：是否删除非空目录，如果为true，将删除整个目录，如果是false，仅当该目录为空时才可删除 //Directory.Delete(Application.dataPath + \"/数据持久化四\"); //4.查找文件夹和文件 //得到指定路径下所有文件夹名 string[] strs = Directory.GetDirectories(Application.dataPath); //得到指定路径下所有文件名 strs = Directory.GetFiles(Application.dataPath); //5.移动文件夹 //如果第二个参数所在的路径 已经存在了一个文件夹 那么会报错 //移动会把文件夹中的所有内容一起移到新的路径 Directory.Move(Application.dataPath + \"/数据持久化四\", Application.dataPath + \"/123123123\"); 3.DirectoryInfo和FileInfo //DirectoryInfo目录信息类 //我们可以通过它获取文件夹的更多信息 //它主要出现在以下几个地方 //1.创建文件夹方法的返回值 DirectoryInfo dInfo = Directory.CreateDirectory(Application.dataPath + \"/数据持久化123\"); //2.查找上级文件夹信息 dInfo = Directory.GetParent(Application.dataPath + \"/数据持久化123\"); //全路径 print(dInfo.FullName); //文件名 print(dInfo.Name); //所有子文件夹的目录信息 DirectoryInfo[] dInfos = dInfo.GetDirectories(); //FileInfo文件信息类 //我们可以通过DirectoryInfo得到该文件下的所有文件信息 FileInfo[] fInfos = dInfo.GetFiles(); C#类对象的序列化和反序列化1.序列化类对象第一步—申明类对象 //注意：如果要使用C#自带的序列化2进制方法 //申明类时需要添加[System.Serializable]特性 2.序列化类对象第二步—将对象进行2进制序列化 （1）方法一：使用内存流得到2进制字节数组 //主要用于得到字节数组 可以用于网络传输 //新知识点 //1.内存流对象 //类名：MemoryStream //命名空间：System.IO //2.2进制格式化对象 //类名：BinaryFormatter //命名空间：System.Runtime.Serialization.Formatters.Binary、 //主要方法：序列化方法 Serialize using (MemoryStream ms = new MemoryStream()) { //2进制格式化程序 BinaryFormatter bf = new BinaryFormatter(); //序列化对象 生成2进制字节数组 写入到内存流当中 bf.Serialize(ms, p); //得到对象的2进制字节数组 byte[] bytes = ms.GetBuffer(); //存储字节 File.WriteAllBytes(Application.dataPath + \"/Lesson5.tang\", bytes); //关闭内存流 ms.Close(); } （2）方法二：使用文件流进行存储 //主要用于存储到文件中 using (FileStream fs = new FileStream(Application.dataPath + \"/Lesson5_2.tang\", FileMode.OpenOrCreate, FileAccess.Write)) { //2进制格式化程序 BinaryFormatter bf = new BinaryFormatter(); //序列化对象 生成2进制字节数组 写入到内存流当中 bf.Serialize(fs, p); fs.Flush(); fs.Close(); } 3.反序列化 （1）反序列化网络传输过来的2进制数据 //主要类 //MemoryStream内存流类 //BinaryFormatter 2进制格式化类 //主要方法 //Deserizlize //目前没有网络传输 我们还是直接从文件中获取 byte[] bytes = File.ReadAllBytes(Application.dataPath + \"/Lesson5_2.tang\"); //申明内存流对象 一开始就把字节数组传输进去 using (MemoryStream ms = new MemoryStream(bytes)) { //申明一个 2进制格式化类 BinaryFormatter bf = new BinaryFormatter(); //反序列化 Person p = bf.Deserialize(ms) as Person; ms.Close(); } （2）反序列化文件中数据 //主要类 //FileStream文件流类 //BinaryFormatter 2进制格式化类 //主要方法 //Deserizlize //通过文件流打开指定的2进制数据文件 using (FileStream fs = File.Open(Application.dataPath + \"/Lesson5_2.tang\", FileMode.Open, FileAccess.Read)) { //申明一个 2进制格式化类 BinaryFormatter bf = new BinaryFormatter(); //反序列化 Person p = bf.Deserialize(fs) as Person; fs.Close(); } 二进制数据加密1.加密说明：加密只能起到提升一定的安全性，通过各种尝试始终是可以破解加密规则的，只是时间问题，一定记住加密只是提高破解门槛，没有100%保密的数据； 2.常用加密算法：MD5算法、SHA1算法、HMAC算法、AES/DES/3DES算法； 1.异或加密 Person p = new Person(); byte key = 199; using (MemoryStream ms = new MemoryStream()) { BinaryFormatter bf = new BinaryFormatter(); bf.Serialize(ms, p); byte[] bytes = ms.GetBuffer(); //异或加密 for (int i = 0; i &lt; bytes.Length; i++) { bytes[i] ^= key; } File.WriteAllBytes(Application.dataPath + \"/Lesson7.tang\", bytes); } //解密 byte[] bytes2 = File.ReadAllBytes(Application.dataPath + \"/Lesson7.tang\"); for (int i = 0; i &lt; bytes2.Length; i++) { bytes2[i] ^= key; } using (MemoryStream ms = new MemoryStream(bytes2)) { BinaryFormatter bf = new BinaryFormatter(); Person p2 = bf.Deserialize(ms) as Person; ms.Close(); } 知识补充","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"二进制","slug":"二进制","permalink":"https://wwy.wwywy.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"Unity进阶-数据持久化Json","slug":"03009-Unity进阶-数据持久化Json","date":"2020-11-24T13:00:00.000Z","updated":"2022-07-09T16:16:31.106Z","comments":true,"path":"posts/03009.html","link":"","permalink":"https://wwy.wwywy.com/posts/03009.html","excerpt":"","text":"Json概述1.Json说明：Json是国际通用的一种轻量级的数据交换格式，主要在网络通讯中用于传输数据，或本地数据存储和读取，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率； 2.Json和XML的区别： 共同点： 都是纯文本； 都有层次结构； 都具有描述性； 不同点： Json配置更加简单； Json在某些情况读写更快速； Json文件格式Json配置规则 1.注释规则：和C#一模一样； 2.符号含义： 大括号{}：对象； 中括号[]：数组； 冒号:：键值对对应关系； 逗号,：数据分割； 双引号””：键名/字符串； Excel转Json的网站1.Excel转Json的网站在线Excel、CSV转JSON格式-BeJSON.com 2.自己写编辑器工具去转换 C#存取Json文件JsonUtlity1.JsonUtlity是什么？ //JsonUtlity 是Unity自带的用于解析Json的公共类 //它可以 //1.将内存中对象序列化为Json格式的字符串 //2.将Json字符串反序列化为类对象 2.必备知识点——在文件中存读字符串 //1.存储字符串到指定路径文件中 //第一个参数 填写的是 存储的路径 //第二个参数 填写的是 存储的字符串内容 //注意：第一个参数 必须是存在的文件路径 如果没有对应文件夹 会报错 File.WriteAllText(Application.persistentDataPath + \"/Test.json\", \"存储的json文件\"); print(Application.persistentDataPath); //2.在指定路径文件中读取字符串 string str = File.ReadAllText(Application.persistentDataPath + \"/Test.json\"); 3.使用JsonUtlity进行序列化 //序列化：把内存中的数据 存储到硬盘上 //方法：JsonUtility.ToJson(对象) //Jsonutility提供了现成的方法 可以把类对象 序列化为 json字符串 string jsonStr = JsonUtility.ToJson(t); File.WriteAllText(Application.persistentDataPath + \"/MrTang.json\", jsonStr); //注意： //1.float序列化时看起来会有一些误差 //2.自定义类需要加上序列化特性[System.Serializable] //3.想要序列化私有变量 需要加上特性[SerializeField] //4.JsonUtility不支持字典 //5.JsonUtlity存储null对象不会是null 而是默认值的数据 4.使用JsonUtlity进行反序列化 //反序列化：把硬盘上的数据 读取到内存中 //方法： //JsonUtility.FromJson(字符串) //读取文件中的 Json字符串 jsonStr = File.ReadAllText(Application.persistentDataPath + \"/MrTang.json\"); //使用Json字符串内容 转换成类对象 MrTang t2 = JsonUtility.FromJson(jsonStr, typeof(MrTang)) as MrTang; MrTang t3 = JsonUtility.FromJson&lt;MrTang&gt;(jsonStr); //注意： //如果Json中数据少了，读取到内存中类对象中时不会报错 5.注意事项 //1.JsonUtlity无法直接读取数据集合，要用一个类去包裹数组可以（如下图） jsonStr = File.ReadAllText(Application.streamingAssetsPath + \"/RoleInfo2.json\"); print(jsonStr); //List&lt;RoleInfo&gt; roleInfoList = JsonUtility.FromJson&lt;List&lt;RoleInfo&gt;&gt;(jsonStr); RoleData data = JsonUtility.FromJson&lt;RoleData&gt;(jsonStr); //2.文本编码格式需要时UTF-8 不然无法加载 LitJsonLitJSON下载地址(github.com) 1.LitJson是什么 //它是一个第三方库，用于处理Json的序列化和反序列化 //LitJson是C#编写的，体积小、速度快、易于使用 //它可以很容易的嵌入到我们的代码中 //只需要将LitJson代码拷贝到工程中即可 2.使用LitJson进行序列化 //方法：JsonMapper.ToJson(对象) string jsonStr = JsonMapper.ToJson(t); print(Application.persistentDataPath); File.WriteAllText(Application.persistentDataPath + \"/MrTang2.json\", jsonStr); //注意： //1.相对JsonUtlity不需要加特性 //2.不能序列化私有变量 //3.支持字典类型,字典的键 建议都是字符串 因为 Json的特点 Json中的键会加上双引号 //4.需要引用LitJson命名空间 //5.LitJson可以准确的保存null类型 3.使用LitJson反序列化 //方法：JsonMapper.ToObject(字符串) jsonStr = File.ReadAllText(Application.persistentDataPath + \"/MrTang2.json\"); //JsonData是LitJson提供的类对象 可以用键值对的形式去访问其中的内容 JsonData data = JsonMapper.ToObject(jsonStr); print(data[\"name\"]); print(data[\"age\"]); //通过泛型转换 更加的方便 建议使用这种方式 MrTang2 t2 = JsonMapper.ToObject&lt;MrTang2&gt;(jsonStr); //注意： //1.类结构需要无参构造函数，否则反序列化时报错 //2.字典虽然支持 但是键在使用为数值时会有问题 需要使用字符串类型 4.注意事项 //1.LitJson可以直接读取数据集合（记住最后不用写逗号） jsonStr = File.ReadAllText(Application.streamingAssetsPath + \"/RoleInfo.json\"); RoleInfo2[] arr = JsonMapper.ToObject&lt;RoleInfo2[]&gt;(jsonStr); List&lt;RoleInfo2&gt; list = JsonMapper.ToObject&lt;List&lt;RoleInfo2&gt;&gt;(jsonStr); jsonStr = File.ReadAllText(Application.streamingAssetsPath + \"/Dic.json\"); Dictionary&lt;string, int&gt; dicTest = JsonMapper.ToObject&lt;Dictionary&lt;string, int&gt;&gt;(jsonStr); //2.文本编码格式需要是UTF-8 不然无法加载 俩种方法对比1.JsonUtlity和LitJson相同点 //1.他们都是用于Json的序列化反序列化 //2.Json文档编码格式必须是UTF-8 //3.都是通过静态类进行方法调用 2.JsonUtlity和LitJson不同点 //1.JsonUtlity是Unity自带，LitJson是第三方需要引用命名空间 //2.JsonUtlity使用时自定义类需要加特性,LitJson不需要 //3.JsonUtlity支持私有变量(加特性),LitJson不支持 //4.JsonUtlity不支持字典,LitJson支持(但是键只能是字符串) //5.JsonUtlity不能直接将数据反序列化为数据集合(数组字典),LitJson可以 //6.JsonUtlity对自定义类不要求有无参构造，LitJson需要 //7.JsonUtlity存储空对象时会存储默认值而不是null，LitJson会存null 3.如何选择两者 //根据实际需求 //建议使用LitJson //原因：LitJson不用加特性，支持字典，支持直接反序列化为数据集合，存储null更准确","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"Json","slug":"Json","permalink":"https://wwy.wwywy.com/tags/Json/"}]},{"title":"Unity进阶-数据持久化XML","slug":"03008-Unity进阶-数据持久化XML","date":"2020-10-24T13:00:00.000Z","updated":"2022-07-09T16:16:20.628Z","comments":true,"path":"posts/03008.html","link":"","permalink":"https://wwy.wwywy.com/posts/03008.html","excerpt":"","text":"XML概述1.XML说明：可扩展标记语言，XML是国际通用的，它是用来传输和存储数据的一种文本特殊格式，后缀名一般为.xml，xml是一种树形结构； XML文件格式XML基本语法1.编码格式：不同的字符，在内存中的二进制是不一样的，每一个字符对应一个数字，不同的编码格式字符对应的二进制是不一样的，否则会出现乱码； 2.注释：； 3.固定语法：； 4.基本语法：&lt;元素标签&gt;元素内容&lt;/元素标签&gt;，多层嵌套包裹，形成树形结构，如下规则 每个元素都必须有关闭标签； 元素命名规则基本遵照C#中变量名命名规则； XML标签对大小写敏感； XML文档必须有根元素 特殊的符号应该用实体引用 &amp;lt — &lt; 小于 &amp;gt — &gt;大于 &amp;amp — &amp;和号 &amp;apos — ‘ 单引号 &amp;quot — “ 引号 XML 教程 | 菜鸟教程 (runoob.com) XML属性1.属性语法：&lt;元素标签 子元素名=”值” &gt;元素内容&lt;/元素标签&gt; or &lt;元素标签 子元素名=”值” /&gt; 2.查语法错误：可以使用专门的xml软件，也可以在菜鸟验证对错; XML 验证器 | 菜鸟教程 (runoob.com) C#中XML存取使用unit中xml文件存取位置1.只读不取：可以放在Resources或者StreamingAssets文件夹下，一般作为配置文件使用； 2.动态存储：放在Application.presistentDataPath路径下； C#读取XML1.C#读取XML的方法 //1.XmlDocument (把数据加载到内存中，方便读取) //2.XmlTextReader (以流形式加载，内存占用更少，但是是单向只读，使用不是特别方便，除非有特殊需求，否则不会使用) //3.Linq (以后专门讲Linq的时候讲) //使用XmlDocument类读取是较方便最容易理解和操作的方法 2.读取API //1.读取XML文件 //XmlDocument xml = new XmlDocument(); //读取文本方式1-xml.LoadXml(先用资源加载出来为TextAsset文件，再传入xml文本字符串) //读取文本方式2-xml.Load(传入路径) //2.读取元素和属性 //获取单个节点 : XmlNode node = xml.SelectSingleNode(节点名) //获取多个节点 : XmlNodeList nodeList = xml.SelectNodes(节点名) //获取节点元素内容：node.InnerText //获取节点元素属性： //1.item.Attributes[\"属性名\"].Value //2.item.Attributes.GetNamedItem(\"属性名\").Value //通过迭代器遍历或者循环遍历XmlNodeList对象 可以获取到各单个元素节点 C#存储XML1.Unity推荐储存 //注意：存储xml文件 在Unity中一定是使用各平台都可读可写可找到的路径 // 1.Resources 可读 不可写 打包后找不到 × // 2.Application.streamingAssetsPath 可读 PC端可写 找得到 × // 3.Application.dataPath 打包后找不到 × // 4.Application.persistentDataPath 可读可写找得到 √ 2.C#存取 //2.存储xml关键类 //XmlDocument 文件 // 创建节点 CreateElement() // 创建固定内容方法 CreateXmlDeclaration() // 添加节点 AppendChild() // 保存 Save() //XmlDeclaration 版本 //XmlElement 元素节点 // 设置属性方法SetAttribute() //3.修改 //RemoveChild()移除节点 //可以通过 /的形式 来表示 子节点的子节点","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"https://wwy.wwywy.com/tags/XML/"}]},{"title":"计算机网络技术","slug":"01030-计算机网络技术","date":"2020-09-15T13:00:00.000Z","updated":"2022-07-09T16:13:12.720Z","comments":true,"path":"posts/536.html","link":"","permalink":"https://wwy.wwywy.com/posts/536.html","excerpt":"","text":"计算机网络概叙基本概念1.定义：一些互连的、独立自治的计算机集合； 2.目的：资源共享、数据通信、负载均衡和分布式计算、数据信息集中处理； 3.一般分类： 按通信媒体：有线网络、无线网络； 按使用对象：公众网络、专用网络、接入网； 网络传输技术：广播式网络、点到点网络； 按地理覆盖（常用）： 局域网：几十米到几千米之间； 城域网：几千米到几十千米； 广域网 ：几十千米到几千千米，例如Internet； 网络拓扑结构1.常见的拓扑结构： 总线型拓扑结构：结构简单、易于阔充、属于广播网络； 星型拓扑结构：结构简单、易于实现和管理、但是耗费电缆、中心出问题会带动其他地方； 树形拓扑结构：易于分级管理和控制； 环形拓扑结构：结构简单、易于实现、传输时延确定和路径选择简单； 网状拓扑结构：充分利用网络资源，但是成本高； 计算机网络性能指标1.比特的概念：比特(bit)意思是一个二进制数字（0或1）。 B为字节(Byte)，b为比特(bit)，一字节为8比特，即1B = 8b。 网络技术中的数率指的是数据的传送速率，当数据率较高时，常常在bit/s前面加上字母，比如k = $10^3$,M = $10^6$,G = $10^9$,T = $10^{12}$等。 （注意区分网络传输和文件系统中的数据后缀字母，文件系统一般是字节。比如一个100MB的文件，这里的M就是$2^{20}$，传输率为100Mbit/s，这里的M为$10^6$） 2.数据传输率：又叫比特率，指连接在网络上的主机在数字信道上传送数据的速率。 速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等； 3.信道容量：信道容量即是指最大的数据传输速率，通常说数字通信系统所说的带宽与数据传输速率相等，注意这个数据传输速率是实际的传输速率，实际与最大的数据传输速率二者之间满足香农公式，具体如下俩种情况 在有噪声的情况下即信道不是理想信道，信道容量是信道能够达到的最大数据速率，此时数字信道的带宽W与信道容量C满足香农公式C=W${Log}_{2}$（1+S/N） ; 理想信道时，根据奈奎斯特定理，C=最大的数据传输速率=2W； 4.带宽：分以下俩种情况 对于模拟通信或传输介质，带宽指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）； 而数字通信系统中“带宽”，理论上是指传输信道的信道容量，也即信道中传递信息的最大值，单位为“比特/秒”。由于数字系统中的信道多指逻辑信道，而信道容量又是理论上的最大值(不可能达到)，所以平时我们使用的“带宽”一词，是指信道中数据的实际传输速率； 5.误码率：误码指信号传输过程中受干扰的和衰减的数据传输错误，是衡量传输可靠性的主要观测点，误码率${P}_{e}$=接受的错位数 除以 传输总数； 6.时延： 发送时延：发送数据时，数据帧从结点进入到传输媒体所需要的时间。 $\\mathrm{发送时延};=;\\frac{\\mathrm{数据帧长度}(b)}{\\mathrm{发送速率}(b/s)}$ 传播时延：电磁波在信道中需要传播一定的距离而花费的时间。 $\\mathrm{传播时延};=;\\frac{\\mathrm{信道长度}(米)}{\\mathrm{信号在信道上的传输速率}(b/s)}$ 处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间； 排队时延：结点缓存队列中分组排队所经历的时延. 总时延：总时延 = 发送时延+传播时延+处理时延+处理时延 7.利用率：信道利用率指出某信道有百分之几的时间是被利用的。 网络利用率则是全网络的信道利用率的加权平均值. $D;=;\\frac{D_0}{1;-;U}$ $D_0$为网络空闲时的时延，$D$为当前时延，U为利用率。 计算机网络的体系结构ISO/OSI七层模型1.专业术语 实体和对等实体：每一层中，用于实现该层功能的活动元素被称为实体，不同机器同一层、完成相同功能的实体称为对等实体； 协议：对等实体之间交换数据的约定； 服务和接口：下层为上层提供的功能叫服务，通过上下层之间的接口实现； 2.OSI理想模型层级（由上到下）： 应用层（APDU）：负责为用户程序提供网络服务； 表示层（PPDU）：表示层以下关心可靠的数据传输，而表示层关心传输数据的语法和语义； 会话层（SPDU）：在俩个节点之间建立、维护和释放用户连接； 传输层（分段）：该层负责两台主机中进程之间的通信，而传输层上三层主要面向用户提供服务，下三层面向网络通信； 网络层（分组）：端到端的主机通信； 数据链路层（帧）：解决相邻节点的数据传输等问题； 物理层（比特流）：直接面向原始比特流的传输； TCP/IP模型1.TCP\\IP模型层级（从上到下）：应用层、传输层、网络层、网络访问层； 2.OSI模型和TCP/IP模型比较： 相同点： 均采用层次结构，并具有可比的运输层和网络层； 都基于协议数据单元的包交换网络，且分别作为概念模型和事实标准； 不同点： OSI七层，TCP四层，TCP应用层中包含了OSI上三层的功能，网络访问层包含了下俩层的功能； OSI对分层很好的说明服务、协议、接口的概念，是最重要的计算机网络概念模型，但是每层都存在寻址、流量控制、差错控制等机制，所以比较复杂，缺乏实现上的操作性； TCP/IP层次较少，显得更加简洁，容易实现，但是服务、协议、接口区分并不是很清晰。 五层结构（OSI和TCP/IP折中方案）1.五层结构（从上到下）： 应用层：是体系中的最高层，任务是通过应用进程间的交互来完成特定网络应用，把应用层交互的数据单元称为报文。 运输层：负责两台主机中进程之间的通信提供通用的数据传输服务。主要用到以下两种协议; TCP：传输控制协议（Transmission Control Protocol），提供面向连接，可靠地数据传输服务，其数据传输的单位是报文段。 UDP：用户数据报协议（User Datagram Protocol）,提供无连接的，尽最大努力的数据传输服务，是不可靠的。其数据传输的单位是用户数据报。 网络层：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。在TCP/IP体系中使用IP协议，因此分组也叫做IP数据报。 数据链路层：两台主机之间的数据传输，总是在一段一段的链路上进行传送的，需要使用专门的链路层协议，在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点之间的链路上传送帧。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样数据链路层在接收到一个帧后，就可以从中提取出数据部分，上交给网络层。 物理层：物理层上所传数据的单位是比特。传递信息所用的载体（比如双绞线，光缆等）不属于物理层，是物理层下面一层。 分组交换技术☆1.介绍：提高信道利用率，提高抗毁性 端到端数据流被划分为若干数据块，添加首部形成若干分组，分组首部中携带地址、长度等控制信息 主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。 路由器的用途则是用来转发分组的，即进行分组交换的，分组交换也称包交换，它是将用户传送的数据划分成一定的长度，每个部分叫做一个分组。在每个分组的前面加上一个分组头，用以指明该分组发往何地址，然后由交换机根据每个分组的地址标志，将他们转发至目的地，这一过程称为分组交换。进行分组交换的通信网称为分组交换网。从交换技术的发展历史看，数据交换经历了电路交换、报文交换、分组交换和综合业务数字交换的发展过程。分组交换实质上是在“存储—转发”基础上发展起来的。它兼有电路交换和报文交换的优点。分组交换在线路上采用动态复用技术传送按一定长度分割为许多小段的数据—分组。每个分组标识后，在一条物理线路上采用动态复用的技术，同时传送多个数据分组。把来自用户发端的数据暂存在交换机的存储器内，接着在网内转发。到达接收端，再去掉分组头将各数据字段按顺序重新装配成完整的报文。分组交换比电路交换的电路利用率高，比报文交换的传输时延小，交互性好，如下图所示； 2.存储转发：路由器在输入链路上接收整个分组 存储接收的分组 然后选择输出链路，并以最大传输速率向输出链路转发； 3.优点： 高效：动态分配传输带宽，对通信链路是逐段占用； 灵活：以分组为传送单位和查找路由； 迅速：不必先建立连接就能向其他主机发送分组； 可靠：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性； 物理层物理层概述1.说明：物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 2.物理层主要问题： 信号和信道类型选择 传输媒体选择 提高传输媒体的利用率 关于衰减和噪音影响的处理 通信方式的选择 物理互通的实现 3.物理层传输质量的评估：通过数据传输速率和误码率作为评估主要标准； 基带传输和数字数据编码1.基本概念：二进制数字数据利用脉冲信号（数字信号和信道）来进行传输和编码，数字信号是离散的电压或电流脉冲序列，常用方法是使用脉冲信号来表示二进制数字字符“0”和“1”； 2.数字信号编码方式：如下 不归零制：正电平代表1，负电平代表0； 归零制：正脉冲代表1，负脉冲代表0； 曼彻斯特编码：位周期中心的向上跳代表0，位周期中心的向下跳代表1，也可以反过来定义； 差分曼彻斯特编码：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1； 频带传输和调制解调1.频带传输基本概念：基带传输受到距离限制，所以远距离一般采用模拟通信； 2.调制解调方法：如下三种 幅度调制 频率调制 相位调制 传输媒体1.分类：如下几种 有线传输媒体： 双绞线：最古老又最常用、价格便宜，但是对电磁干扰敏感，主要用于室内； 同轴电缆：新标准已经不再推荐； 光纤：传输带宽大，传输损耗小，中继距离长，抗干扰能力强（雷电和电磁干扰），保密性好（不易被窃听）体积小，重量轻。精确对接困难。 无线传输媒体： 无线电波：通过空间电磁传播、无需安装物理线路，频率范围再30kHz到30000MHz之间，波长10km~0.1mm； 微波（卫星）： 带宽高，容量大，不受环境影响，且不需实现铺好电缆，但是需要相关部门许可； 红外线：通过空间电磁传播、不受电磁干扰和射频干扰，但是必须再直线视距之间，且数据传输速率相对较低； 激光通信：短距离传输，但是受天气影响大； 2.传输媒体的比较和选用：如下图 多路复用技术1.基本概念：指在一条物理线路上建立多条通信信道； 2.分类： 频分复用（FDM）：将线路带宽划分成若干较小带宽来达到多路复用目的，用户在分配在一定频宽后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽资源。 时分复用（TDM）：将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占领固定序号的时隙，时分复用的所有用户是在不同的时间占用同样的频带宽度，时分复用分为同步（STDM）和异步（ATDM）技术。 波分复用（WDM）：采用光波波长的分隔的多路复用方法； 码分复用（CDM）：是一种移动通信系统的复用技术，基于码型分割信道，每个用户可以在同样时间使用同样频带进行通信，具有很强的抗干扰性。 通信方式1.串行通信和并行通信： 串行通信：指发送端所发送和的数据，按照数据位的先后顺序，依次通过信源和信宿之间的单条信道到达接收端； 并行通信：发送端和接受端之间多条并行信道实现一个节拍下多个数据位的并行传送； 2.全双工通信和半双工通信 单工通信：能有一个方向的通信而没有反方向的交互（广播和电视节目）； 半双工通信：通信的双方都可以发送信息，但不能双方同时发送和同时接收（对讲机）； 全双工通信：通信的双方可以同时发送和接收信息（手机）； 常见物理层组件和设备1.常见的物理组件设备：指物理层提供的无源器件，如下所示 端接器件：为网络线缆连接提供良好的端接，不同线缆对应的连接头不能通用； 转换器：用于不同接口或媒体之间进行信号转换； 2.常见的物理组件：用于增强网络覆盖和传输距离的网络互联网设施 中继器：对物理信号进行放大再生，单进单出，网络规模增加时，需要多个中继器； 集线器：拥有多个接端口，但是只能提供一路的信号放大、整形和转发，否则会出问题； 数据链路层数据链路层概念1.基本概念： 使用一对一的点对点通信方式； 数据链路=物理链路+数据链路协议； 数据链路层是为了克服物理层的不足而建立的，旨在实现网络俩个相邻节点之间的无差错传输和信息的定界； 2.待解决的问题： 物理寻址： 数据链路的建立、维持和释放； 数据流的定界； 差错控制； 流量控制； 帧的构造、同步和区分； 主要问题帧与成帧1.帧的概念：帧是数据链路层的协议数据单元，有了帧，数据就有了意义，不再是物理层的原始比特流； 2.帧的构成：在数据的前后添加上帧首和帧尾构成一个帧； 3.帧的定界：就是区分帧开始和帧结束的方法，主要如下三种 字符计数法：使用一个字符计数字段来标明帧内字符数； 带字符填充的首尾界符法：帧头帧尾前面加上一个ASCII的字符标志，此法会有大量的冗余DLE标记字符； 带位填充的首位标志法：与上类似，但是采用特殊的二进制位数来进行标志； 4.零比特填充：在发送端，只要发现有5个连续1，则立即填入一个0；而接受端对帧中比特流进行扫描时，每当发现5个连续1，就把这5个连续1后的一个0删除； 差错控制1.差错原因：在传输过程中可能出现误差，1可能变成0，而0可能变成1； 2.误码率：传输错误的比特占所传输比特总数的比率称为误码率（BER）；误码率和信噪比有很大关系； 3.差错控制机制：计算机网络传输数据时，必须采用如校验码的技术，校验码根据校验能力不同分为纠错码和检错码，如下所说 纠错码：纠错码不仅可以发现所悟，还能进行自动纠正错误，例如汉明码这种典型的纠错码（在计算机组成中有说明） 检错码：而检错码只能发现传输中的错误，常见的如奇偶校验码（在计算机组成中有说明）和循环冗余校验码，目前，数据链路层广泛采用循环冗余检验码； 4.CRC循环冗余检验：以下运算皆使用二进制的模2运算 CRC冗余码的生成：先进行$2^n$乘M(待发送的数码)，相当于在M后面加n个零，M(k位)是原本的数码，然后除以除数P(n+1位)(一般用多项式表示，比如P为1101,用多项式表示就是P(x) = $x^3+x^2+1$，就是对应位)，得到的余数(n位)就是冗余码，把它拼接到尾部即可。 CRC冗余码的检验：将收到的数码(k+n位)除以事先商定好的除数P(n+1位)，得出的余数为R(n位)，如果R为0说明没有差错。 5.反馈重发机制：由于检错码本身不提供自动错误纠错的能力，所以需要一种错误纠正的机制： 停止-等待方式：发出一帧后停下来判断对方是否正确收到，否则，就重发该帧，该模式性能较差； 连续自动请求重发方式：发送帧后，不进行等待，而是连续发送，出现传输差错采取以下措施： 拉回方式：某帧出现问题后，接收方丢弃该帧后所有帧，发送端重发该帧后所有帧； 选择性重传方式：接收方只丢弃该帧，缓存该帧后所有帧，发送端只重发该帧，该方式需要足够的存储缓冲；流量控制 1.流量控制的作用：发送端和接受端接收数据速率不匹配造成的弱端丢帧问题； 2.滑动窗口协议：一种采用滑动窗口机制进行流量控制的方式，通过限制已经发送但还未得到确认的帧数量，滑动窗口协议可以调整发送端的发送速率，由帧序列号、发送窗口和接受窗口组成； 数据链路成协议1.点对点协议PPP：全世界采用最多的数据链路层协议是点对点协议PPP（Point-to-Point Protocol），用户使用拨号电话接入因特网时，一般采用的就是PPP协议； 数据链路层的设备和组件1.网卡：全称网络适配器，主要实现数据的发送和接受、帧的封装和拆封、编码和解码、数据缓存和媒体访问控制；每一个网卡在出厂时都被分配一个全球唯一的地址标识（MAC地址）； 2.网桥：实际中已经不再使用，了解即可； 3.交换机：由网桥发展而来，是一种多功能网桥； 网络层网络层的概述1.网络层说明：数据链路层只解决了相邻之间节点的数据传输问题，而大多数源节点和目标节点并不是相邻节点，网络层由此而生，以下是主要的问题； 节点之间的最佳路径选择问题（又被称为路由）； 路径选择时的超负载和空闲协调； 异构网络的互联问题（异构指网络技术、通信协议、计算机体系和操作系统存在差异）； 跨越互联网的主机寻址问题； 2.网络层提供的服务：网络层向上提供简单灵活、无连接的、尽最大努力的数据报服务； 3.IP协议说明：IP协议是TCP/IP网络层的核心协议，也是整个TCP/IP模型中最重要的核心协议之一，规定该层的协议数据单元的类型和格式（分组packet） IP地址1.IPv4地址结构和分类： 结构：IP地址目前住主要分为IPv4和IPv6，同时移动端也有特殊的“mobile”的协议；IPv4采用32位长度的二进制地址，但为了书写和记忆，又采用了点分十进制来进行记忆， 分类：被分为A、B、C、D和E五类，其中ABC是普通的主机地址，而D是网路组播服务或者网路测试使用的，E类地址保留给实验和未来扩充使用； IPv4地址的分类: IPv4的指派范围: 一般不使用的特殊IP: 2.IP地址逻辑地址和物理地址：物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址(因为IP地址是用软件实现的)。 在发送数据时，数据从高层下到低层，然后才能到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在了MAC帧首部。 IP地址放在IP数据报首部，硬件地址规则放在MAC帧的首部，在网络层以上使用的都是IP地址，在数据链路层及以下使用的都是硬件地址，以MAC地址是不变的，而IP地址可能会随着网络的迁移而变化； 3.地址解析协议ARP：不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。通过地址解析协议ARP即可知道IP地址对应的MAC值。 4. 运输层应用层知名端口","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络技术","slug":"大学知识/CS基础/计算机网络技术","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"计算机网络技术","slug":"计算机网络技术","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"}]},{"title":"数据结构和算法","slug":"01040-数据结构和算法","date":"2020-07-09T13:00:00.000Z","updated":"2022-07-09T16:13:01.901Z","comments":true,"path":"posts/544.html","link":"","permalink":"https://wwy.wwywy.com/posts/544.html","excerpt":"","text":"绪论数据结构概论数据结构的定义1.数据：描述客观事物的数和字符的集合； 2.数据项：数据最小单位； 3.数据对象：性质相同的数据元素集合； 4.数据结构：数据元素之间的关系； 数据逻辑结构：由数据元素之间的逻辑关系组成； 数据的存储结构：数据元素以及其关系的物理结构； 数据的运算：施加在该数据上的操作； 逻辑结构1.定义：数据之间的抽象逻辑关系； 2.表示方法：图表表示、二元组表示； 3.逻辑结构类型： 集合：同属集合，无关系； 线性结构：一对一； 树形结构：一对多； 图：多对多； 存储结构（物理结构）1.定义：指数据的实际存储，逻辑结构在计算机存储实现； 2.物理存输类型： 顺序存储结构：连续存储 链式存储结构：非连续存储 索引存储结构：键值对 哈希（散列）存储：计算关键字哈希值仅存数据数据运算 1.定义：对数据实施的操作； 运算定义和运算实现分离：基于逻辑结构定义运算，基于存储结构实现运算 2.常用数据运算类型：增删改查以及排序； 数据类型和抽象数据类型1.数据类型：值类型，引用类型等； 2.抽象数据类型：从求解问题抽象出来的数据逻辑结构和抽象运算，与具体实现无关（重要特征是数据抽象和数据封装），算法就是抽象运算的实现； 3.抽象数据结构定义： ADT:数据结构名（例如List）； Data:数据结构的描述（例如线性表元素一一对应）； Operation:数据结构定义了哪些操作（例如对线性表的清空、插入、添加、删除、初始化等等）； 算法概论1.算法的定义：对特定问题的一种描叙，是指令的有限序列，应具有以下特征； 有穷性：是可以终止结束的算法； 确定性：相同输入相同输出； 可行性：算法每一步都必须是可行的，每一步都能执行有限次数完成； 有输入输出：输入加工对象，加功得到结果； 2.算法的设计目标：如下几点 正确性：对于非法的数据能够得到满足规格的结果； 可读可使用性：便于阅读、交流和使用； 健壮性：数据不合法时，也能做出相应处理； 时间高效率和低存储：满足时间高效率和低存储； 3.算法的描述：采用计算机语言描叙算法； 算法分析概论1.算法分析的定义：分析算法占用的计算机CPU时间和内存空间的多少； 算法时间性能分析（重点理解）1.时间算法类型： 事后统计法：统计执行时间，必须执行程序且很多因素掩盖了算法本质，如计算机速度、语言、问题规模等； 事前估计法：抛开问题，仅考虑算法本身的效率； 2.算法时间复杂度定义：平均情况下的问题规模n的函数的最高阶表示，推导如下 执行次数T(n) ==&gt; 问题规模n的函数； 总算法执行时间 ==&gt; 原操作+ T(n)(执行次数或算法频率)； 简化算法执行时间 ==&gt; 仅考虑执行次数T(n) ； 上界f(n) ==&gt; 由T(n)对于n的阶级函数的拆解，是问题规模n的某个函数； 问题阶级增率比较 ==&gt; 1(仅原操作)&lt;${log}{2}$n&lt;n&lt;n${log}{2}$n&lt;$n^2$&lt;$n^3$&lt;$2^n$&lt;n!&lt;$n^n$； 渐进时间复杂度（函数渐进增长问题） ==&gt; O(f(n))（O是找出T(n)最高阶或者说最紧凑的上界）； 平均时间复杂度 ==&gt;最好时间复杂度（算法运气好的时间）与最坏时间复杂度（算法运气坏的时候）的折中考虑； 3.推导大O阶的方法： 用常数1取代运行时间中所有加法常数； 修改后的运行次数函数，只保留最高阶数； 去除最高阶的相乘系数，得到的就是大O阶； 4.算法复杂度求和求积： T1(n)+T2(n)=O(Max(fn,g(n))) 例如并列循环 T1(n) * T2(n) = O(f(n)*g(n)) 例如多层嵌套循环 5.递归算法时间复杂度：自己调用自己，不能采用前面的分析方法； 算法空间性能分析1.算法空间复杂度：记作S(n) = O(g(n))，n为问题的规模，f(n)为语句所占用的存储空间函数，解释如下； 局部空间：初始只分配一次空间，参与原操作完继续使用，如果算法只有该形式空间分配，即问题规模n为常数，则该算法为原地工作或就地工作算法，空间复杂度为O(1)； 临时空间：原操作时才分配空间，原操作完即可释放，基本是其算法执行次数的考虑，空间复杂度和时间复杂度相关； 2.递归算法空间复杂度：待记； 程序概论1.程序=数据结构+算法； 2.数据结构和算法的联系：数据存储结构会影响算法的好坏，不能只单单考虑一种，存储强、信息多的存储结构，算法会比较好设计，反而相对简单的存储结构可能要设计一套复杂的算法； 线性表1.线性表定义：具有相同特征的数据元素的一个有限序列； 2.线性表的抽象数据类型： ADT：线性表（List） Data：一个有n个数据元素的数据集合，且元素类型相同，除了第一个和最后一个元素，每一个元素只有一个前驱元素和后继元素，且它之间的关系是一一对应的； Operation：其中i是下标，e是表元素 Init():初始化操作 IsEmpty():判断是否为空 Clear():清空操作 GetElem(i):根据下标获取元素 Locate(e):根据元素获取下标，为-1则表示返回失败； Insert(e,i):在下标位置插入元素 Delete(i):删除下标元素，并且返回其值 Lengtn():获取个数 顺序存储结构1.顺序存储结构定义：线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素，逻辑上相邻的俩个元素在对应得顺序表中它们得存储位置也相邻； 链式存储结构2.链式存储结构定义： 栈和队列串递归数组和广义表数和二叉树图查找内排序外排序","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"大学知识/CS基础/数据结构和算法","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"Unity进阶-GUI","slug":"03004-Unity进阶-GUI","date":"2020-06-10T13:00:00.000Z","updated":"2022-07-09T16:15:40.455Z","comments":true,"path":"posts/1540.html","link":"","permalink":"https://wwy.wwywy.com/posts/1540.html","excerpt":"","text":"GUI概叙基础控件重要参数文本按钮单选框多选框输入框拖动条图像绘制和框复合控件工具栏和选择网格滚动视图和分组窗口自定义整体样式","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"GUI","slug":"GUI","permalink":"https://wwy.wwywy.com/tags/GUI/"}]},{"title":"Unity进阶-数据持久化PlayerPrefs","slug":"03007-Unity进阶-数据持久化PlayerPrefs","date":"2020-05-24T13:00:00.000Z","updated":"2022-03-09T02:22:25.055Z","comments":true,"path":"posts/1543.html","link":"","permalink":"https://wwy.wwywy.com/posts/1543.html","excerpt":"","text":"概述1.数据持久化定义：数据持久化就是将内存中的数据模型和硬盘中的存储模型相互转换的过程； 2.PlayerPrefs是Unity的内置API; 基本知识点基本方法1.存储相关 //PlayerPrefs的数据存储 类似于键值对存储 一个键对应一个值 //提供了存储3种数据的方法 int float string //键: string类型 //值：int float string 对应3种API PlayerPrefs.SetInt(\"myAge\", 18); PlayerPrefs.SetFloat(\"myHeight\", 177.5f); PlayerPrefs.SetString(\"myName\", \"唐老狮\"); //直接调用Set相关方法 只会把数据存到内存里 //当游戏结束时 Unity会自动把数据存到硬盘中 //如果游戏不是正常结束的 而是崩溃 数据是不会存到硬盘中的 //只要调用该方法 就会马上存储到硬盘中 PlayerPrefs.Save(); //PlayerPrefs是有局限性的 它只能存3种类型的数据 //如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储 bool sex = true; PlayerPrefs.SetInt(\"sex\", sex ? 1 : 0); //如果不同类型用同一键名进行存储 会进行覆盖 PlayerPrefs.SetFloat(\"myAge\", 20.2f); 2.读取相关 //注意 运行时 只要你Set了对应键值对 //即使你没有马上存储Save在本地 //也能够读取出信息 //int int age = PlayerPrefs.GetInt(\"myAge\"); print(age); //前提是 如果找不到myAge对应的值 就会返回函数的第二个参数 默认值 age = PlayerPrefs.GetInt(\"myAge\", 100); print(age); //float float height = PlayerPrefs.GetFloat(\"myHeight\", 1000f); print(height); //string string name = PlayerPrefs.GetString(\"myName\"); print(name); //第二个参数 默认值 对于我们的作用 //就是 在得到没有的数据的时候 就可以用它来进行基础数据的初始化 //判断数据是否存在 if( PlayerPrefs.HasKey(\"myName\") ) { print(\"存在myName对应的键值对数据\"); } 3.删除数据 //删除指定键值对 PlayerPrefs.DeleteKey(\"myAge\"); //删除所有存储的信息 PlayerPrefs.DeleteAll(); 存储位置1.PlayerPrefabs各个平台存储位置： Windos存储位置：注册路径：HKEY_Current_User/Software/Unity/[公司名称]/[产品名称]； Android：/data/data/包名/shared_prefs/pkg_name.xml； IOS：/Library/Preferences/[应用ID].plist； 2.PlayerPrefabs中数据的唯一性：储存键值对，数据具有唯一性，要保证数据不丢失要建立一个保证唯一键的规则；","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"https://wwy.wwywy.com/tags/PlayerPrefs/"}]},{"title":"计算机组成原理","slug":"01020-计算机组成原理","date":"2020-05-12T13:00:00.000Z","updated":"2022-07-09T16:13:26.512Z","comments":true,"path":"posts/528.html","link":"","permalink":"https://wwy.wwywy.com/posts/528.html","excerpt":"","text":"计算机概论计算机软硬件概念1.软硬件概念：计算机系统由软件和硬件俩大部分组成，如下； 硬件：是计算机的实体部分； 软件：由各类特殊功能的程序组成，通常存放在计算机的主存或者辅存中，通常分为系统软件和应用软件； 计算机的基本组成1.冯·诺依曼计算机：1945年提出“存储程序”概念设计的计算机，是对图灵机（图灵机）概念模型的实现和升级，冯·诺依曼计算机是以运算器为中心的，现代的计算机已经转化为以存储器为中心，如下图； 2.计算机组成：以下五部分组成 输入设备：将程序和数据以机器所能识别和接受的信息形式输入到计算机内（键盘、鼠标、扫描仪、语音输入设备、手写笔、触摸屏、数码摄像设备等）； 输出设备：将计算机处理的结果以人们所能接受的信息形式或其它系统所要求的信息形式输出（显示器、打印机、绘图仪 、音箱）； 存储器：用于存放程序和数据。存储器是计算机存储信息的核心，一般分为如下主存和外存。 主存储器(主存，内存)：CPU能直接访问，主存分为若干个存储单元，每个单元都有唯一的地址编码，通常是按字节或字节的整数倍编码。存储器总是按地址访问的； 辅助存储器(外存，辅存)：CPU不能直接访问，辅存中的信息必须调入主存后，才能为CPU所使用，辅存速度较慢，但容量大，用于存放CPU暂时不用的程序和数据（软盘、硬盘、光盘、磁带机）； 运算器：用于完成算术和逻辑运算，核心是算术逻辑部件(ALU)，是CPU的核心部件，还有若干寄存器，用于存放操作数、中间结果或最终结果； 控制器：控制器是整个计算机的指挥中心，通过实现编好的程序用于控制整个计算机系统中的各部件有条不紊地进行工作，其控制部件（CU）是CPU的核心部件，运作如下。 程序计数器PC（Program Counter）：存放将要执行的指令的地址（指向存储单元），具有自增功能； 指令寄存器IR（ Instruction Register）： 存放当前正在执行的指令； 指令译码器ID（Instruction Decoder）：分析指令； 时序部件（Sequencer）：分析指令时序； 控制信号发生器：运作； 3.计算机硬件技术指标： 机器字长：数据的位数，一般和CPU寄存器有关； 存储容量：存储器的容量； 运算速度：计算机运行速度； 计算计信息和运算机器数的表示机器数和真值1.机器数：如下分类 定义：计算机中的数据通常存放在寄存器中，通常称寄存器的位数为机器字长，而存储的数据叫机器数； 格式：符号和数值均二进制化，小数点隐含在某一固定位置上，不占存储空间，位数受机器字长的限制。超过机器字长的数值位要舍去； 分类：俩种情况 无符号数：机器字长的所有二进制均表示数值部分； 带符号数：第1个二进制位为符号位，其余为数值部分 ； 2.真值：机器数所表示的实际数值，例：8位机器数为11011011分以下情况 若为无符号整数，其真值为 219； 若为带符号整数，且采用原码表示，则最高位为符号， 1 1011011 表示二进制整数 -1011011，其真值为 -91； 原码表示法1.原码的定义：符号位0表示正数，1表示负数，数值位即真值的绝对值，约定符号位用逗号隔开，小数位用小数点隔开，如下整数和小数的定义式； 整数原码定义式：其中x为真值，n为整数位位数， $ {[x]}_{原} $ = 0,x 当$ 2^n $&gt;x&gt;=0时 （就是等于真值，正数前面加上符号0） $ {[x]}_{原} $ = $2^n$-x 当0&gt;=x&gt;$-2^n$时（就是等于真值，负数前面加上符号1） 小数原码定义式：其中x为真值 $ {[x]}_{原} $ = x 当1&gt;x&gt;=0时（就是等于真值，正数前面加上符号0） $ {[x]}_{原} ​$ = 1-x 当0&gt;=x&gt;-1时（就是等于真值，负数前面加上符号1） 0的表示： 纯小数 ：[+0]原=0.00…0，[-0]原=1.00…0 纯整数：[+0]原=00…0，[-0]原=10…0 2.原码的优缺点： 优点： 表示简单； 和真值转换容易； 缺点： 0有俩种表示，给使用带来不便； 原码表示加减法运算很复杂； 补码表示法1.补数的说明：能找到一个模，让一个数对于模的补数就是正数本身（例如mod10中 -4=6），如下结论 让它的负数可用它的正补数来代替，这个正补数可以用模加上负数本身求得； 一个正数和一个负数互为补数时，它们的绝对相加即为模数； 正数的补数即为正数本身； 2.补码的定义：如下整数和小数的定义式 整数补码定义式：其中x为真值，n为整数位位数 $ {[x]}_{补} $ = 0,x 当$ 2^n $&gt;x&gt;=0时 （正数就是等于原码） $ {[x]}_{补} $ = $2^n+1$+x 当0&gt;=x&gt;$-2^n$时 （根据x的原码，每位取反，末位加一） 小数补码定义式：其中x为真值 $ {[x]}_{补} $ = x 当1&gt;x&gt;=0时 （正数就是等于原码） $ {[x]}_{补} $ = 2+x 当0&gt;=x&gt;-1时 （根据x的原码，每位取反，末位加一） 0的表示： 纯小数 ：[+0]补=[-0]补=0.00…0 纯整数：[+0]补=[-0]补=0,00…0 3.补码的优缺点： 优点： 可以只设加法器，将减法转成加法的形式； 只表示一个0 ; 缺点： 比原码多表示一个-1; 反码表示法1.反码说明：反码通常用来作为原码和反码互转的中间过渡； 2.反码定义：如下整数和小数的定义式 整数补码定义式：其中x为真值，n为整数位位数 $ {[x]}_{反} $ = 0,x 当$ 2^n $&gt;x&gt;=0时 （正数就是等于原码） $ {[x]}_{反} $ = ($2^n+1$-1)+x 当0&gt;=x&gt;$ -2^n $时 （根据x的原码，每位取反） 小数补码定义式：其中x为真值 $ {[x]}_{反} $ = x 当1&gt;x&gt;=0时 （正数就是等于原码） $ {[x]}_{反} $ = (2-$2^-n$)+x 当0&gt;=x&gt;-1时 （根据x的原码，每位取反） 0的表示： 纯小数 ：[+0]反=0.00…0，[-0]反=1.00…0 纯整数：[+0]反=00…0，[-0]反=10…0 移码表示法1.移码定义：移码表示把真值x在数轴上正向平移1(纯小数)或2n(纯整数)，所以移码也称为增码、余码，如下定义式，其中x为真值，n为整数位位数 移码定义式：${[x]}_{移}$ = $ 2^n $+x 当$2^n$&gt;x&gt;=$-2^n$时 （和[x]补互转，符号位取反，数值位不变）； 四种机器数总结1.最高位都表示符号位。原码、反码和补码的符号位均是0表示+，1表示-，移码相反。2.移码、补码和反码的符号位可和数值位一起参加运算；原码的符号位必须分开进行处理。3.对于正数，除移码外，其他码值都等于真值本身，而对于负数各有不同的表示。4.对于真值0，原码和反码各有两种不同的表示形式，而补码和移码只有唯一的一种表示形式。5.原码、反码表示的范围是一样的；补码、移码表示的范围是一样的，且比前二者能多表示一个最负的数：$-2^n$（纯整数）或-1（纯小数）。 数的定点表示和浮点表示科学计数法1.前置知识-科学计数法说明：任何一个数都可以表示为$ {(N)}_R=M\\times R^e $，详细如下 M：尾数。代表数N的有效数字。计算机中一般表示为纯小数； R：尾数基值。计算机中常用的R可取2、8、16等； e：阶码。代表数N的小数点的实际位置。一般表示为纯整数； 根据小数点的位置是否固定，计算机中的数据格式又分为两种：定点表示和浮点表示。 定点表示1.定点表示说明：约定计算机中所有数据的小数点位置是固定不变的，即阶码e的取值固定不变； 2.定点数说明：采用定点表示的数据，机器数确定后，e也就确定了，不能更改，整数和小数不能共存，当运算结果超出机器数所能表示的数据范围时，会出现溢出； 定点整数：小数点位于数值位后面，表示范围-(1-$2^-n$)~(1-$2^-n$)； 定点小数：小数点位于数符和第一数值位之间，表示范围-($2^n$-1)~($2^n$-1)； 3.定点数缺点： 比例因子难以选择，容易溢出或影响精度 表示的数值范围比较小 存储单元利用率低，当存储特别大或者特别小的数时，可能大部分尾数都是0被浪费掉了； 浮点表示1.浮点表示说明：指小数点位置可变的数据表示形式，即e值是可变的； 2.浮点数说明：典型的浮点数格式由阶码e和尾数M组成，一般被表示成$ {(N)}_R=M\\times R^e $； 基数R：用隐含方法表示，数学中一般由数位权决定，二进制通常取R＝2； 阶码e：阶码的二进制数值位决定了表示数的小数点实际位置，也就是数的大小，可用补码或移码表示； 尾数M：表示数的有效数字，符号代表浮点数的正负，其位数反映了浮点数的精度，可用补码或原码表示； 3.浮点数的规格化：尾数最高位为1的数为规格化数，为了提高浮点数的精度，其尾数必须是规格化数； 左规：尾数每左移一位，阶码减一； 右规：同上相反； 4.浮点数的表示范围：阶码用移码，尾数用补码 5.IEEE754浮点数标准：每个浮点数由三部分组成数符S，指数E，尾数M，有以下四种格式 单精度格式（32位）：E=8位，M=23位； 扩展单精度格式：E&gt;=11位，M=31位； 双精度格式（64位）：E=11位，M=52位； 扩展双精度格式：E&gt;=15位，M&gt;=63位； 定点数和浮点数的比较1.定点数和浮点数的比较：如下几点 当浮点机和定点机中数的数位相同时，浮点数表示的范围比定点数大得多； 浮点数为规格化数时，其相对精度远比定点数高； 浮点数运算分阶码和尾数部分，而且运算结果都要求规格化，故浮点运算比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算复杂； 在溢出判断上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断； 定点运算移位运算1.移位运算的说明：计算机中小数点的位置是事先约定的，二进制表示数在相对于小数点作n位左移或者右移时，其本质就是乘以或者除以2^n，这种移位操作可以配合加法相结合，就可以简单的实现乘除运算； 2.算数移位规则：考虑正数负数俩种情况 正数：原码，反码，补码等于真值，故移位后的空位均添加0； 负数：负数时，三种机器数表现形式均不同，所以分开考虑 原码 ：添加代码0； 补码：左移添加0，右移添加1； 反码：添加1； 3.算数移位和逻辑移位的区别： 算数移位：有符号的移位是算数移位，算数位移左右移时，符号位会位移保留，避免移丢； 逻辑位移：无符号的是逻辑移位，逻辑位移左右移时，移往的位置会移丢，反过来添0； 加减法运算1.原码加减法运算规则：符号位不能和数据一起参与运算，符号位和加减法指令共同作为运算的依据，加法采用同号求和，异号求差，减法采用异号求和，同号求差，如下解释： 求和：俩操作数的数值位相加得到和的数值位，数值最高位产生进位，则结果溢出，和的符号位采用第一操作数的（被加数/被减数）的符号； 求差：第一操作数的数值位加上第二操作数（加数/减数）的数值位的补码，分俩种情况考虑； 最高数值位有进位，表明加法结果为正，所得数值位正确，结果的符号位采用第一操作数的符号； 最高数值位无进位，表明加法结果为负（补码形式），应对于求其补，还原为绝对值形式的数值位，结果的符号位位第一操作数的符号变反； 2.补码加减法运算规则： 参与运算的各个操作数均以补码表示，运算结果仍以补码表示； 符号位和数值一起参与运算； 若求和，则将俩补码直接相加，得到俩数之和的补码； 若求差，则将减数变补，然后和被减数相加，得到俩数之差的补码。 补码总是对确定的模而言的，当运算结果超过模，则模自动丢掉； 溢出判断1.一位符号位判断溢出：如下说明 对于加法，只有正正相加或者负负相加才会溢出； 对于减法，只有正减负，或者负减正才会溢出； 减法运算在机器一般都采用加法器实现，故只要实际操作的数符号相同，但又和原操作结果数符号不同，即为溢出； 2.俩位符号位判断溢出（没懂）： 俩位符号位的补码是以4为模的，即变形补码； 变形补码判断的原则是俩位符号位不同时，表示溢出，否则不溢出 不论是否发生溢出，第一位符号位永远代表真正符号； 乘法运算1.补码一位乘法运算规则（没懂）：如下五步 a：参与运算的数均以补码表示，结果仍以补码表示； b：增设yn+1，且初始化为0，部分积初始化为0； c：部分积与被乘数采用双符号位，且符号位参加运算； d：判别ynyn+1，并采取相应的操作。其中，右移指将部分积连同乘数（ 包括yn+1 ）一起算术右移； e：重复d，共做n+1次操作，最后一次不移位； 存储器存储器概述1.存储器分类：以下三种分类 按存储介质分类： 半导体存储器：体积小、功耗低、存取时间短、近年来信息易失的弊端也慢慢被克服，是目前主流的存储器； 磁表面存储器：主要是非易失性，现在计算机已经很少采用了； 磁芯存储器：体积过大，目前已经逐渐被半导体存储器所取代了； 光盘存储器记录密度高、耐用性好、可靠性高，越来越被用于计算机系统； 按存取方式： 随机存储器（RAM）：存储器任何一个存储单元的内容都可以随机读取或者写入，且存取时间和存储单元物理位置无关，主要用于组成主存； 只读存储器（ROM）：只能随机读出而不能随机写入和修改，可作为主存的一部分，通常用来存放固定不变的程序，而且还能作为其他固定存储器，如存放微程序的控制存储器、存放字符点阵图案的字符发生器等； 顺序存取存储器（SAM）：存储器所存的信息是按顺序进行的，没有唯一的对于地址，并且存取时间与存储器的物理位置有关，常用的如磁带存储器； 直接存取储存器（DAM）：介于SAM和RAM之间，也称为半顺序存储器，当进行信息存取时，先进行寻道，属于随机方式，然后在磁道中寻找扇区，属于顺序方式； 按计算机中的作用分类： 主存储器：CPU能直接访问的存储器； 辅助存储器：CPU不能直接访问的存储器； 高速缓冲存储器： 是一种介于主存和CPU之间用于解决CPU和主存速度匹配问题的高速小容量的存储器，Cache用于存放CPU立即要运行或刚使用过的程序和数据； 2.存储器层次结构关系：寄存器&gt;缓存&gt;主存&gt;磁盘&gt;磁带，从右到左，速度越快，价位越高，容量越小（反映了时间空间的矛盾关系）； 主存储器主存的组成和操作1.主存储器组成：以下由小到大： 存储元：能存储一位二进制信息的物理器件，存储元是存储器中最小的存储单位，以下是存储元的必要条件： 由俩个稳定状态，对应二进制的0和1； 在外界的刺激下，能写入0和1； 能够识别器件当前的状态，即可读出所存的0和1； 存储单元：由一组存储元件组成，可以同时进行读写； 存储体：把大量存储单元电路按一定形式排列起来，即构成存储体，存储体一般排列成阵列形式，所以又叫存储阵列； 2.存储器的地址：存储体中每个存储单元被赋予一个唯一的编号，该编号就是存储单元的地址，当访问某存储单元时，必须给出存储单元的地址； 3.存储单元的编址： 按字节编址：相邻的俩个单元就是俩个字节； 按字编制：相邻的俩个单元就是俩个字； 4.主存读写过程： CPU通过地址总线把地址送到主存地址寄存器MAR； CPU通过数据总线向主存数据寄存器MDR发送和写入数据或从主存的MDR接收读出数据； CPU通过控制总线把地址吗向主存发送读写控制信号； 存储器的主要性能指标1.主要性能指标： 存储容量：存储容量是指主存能存放的二进制代码的总位数，存储容量=存储单元个数*存储字节； 在以字节为编址单位的机器中，常用字节表示存储容量，例如4MB表示主存可容纳4兆个字节信息； 对于存储器芯片，用存储单元数×每个单元的位数表示，例如512k×16位，表示主存有512k个单元，每个单元为16位； 存储速度：存储速度是由存取时间和存取周期来表示的； 2.存储容量的主要计量单位和存储器地址线关系: 1K=2^10=1024：需要10根地址线； 1M=2^20=1048576：需要20根地址线； 1G=2^30=1073741824：需要30根地址线； 半导体随机存取存储器1.SRAM（静态随机存取存储器）： 集成度较低（6管）、单片容量较小； 不需要刷新； 速度快，曾在Pentium主板上用作二级高速缓存； 通常是字选方式； 2.DRAM（动态随机存取存储器）： 集成度高（单管），单片容量较大； 需要定时刷新； 速度较慢，多用作主存储器； 通常是位选方式 半导体只读存储器1.只读存储器类型：对于半导体ROM而言，基本器件为俩种，MOS型和TTL型 掩模ROM； PROM； EPROM； 存储器提升和优化1.存储器扩充：单片存储芯片的容量总是有限的，一个存储器由一定数量的存储芯片构成，芯片总片数=（存储器总单元数×位数）/（每片芯片单元数×位数），但是很难满足实际需求，所以将若干存储芯片连接在一起才能组成足够容量的存储器，称为存储容量的扩展，如下几种方式 位扩展：指存储字节的扩展； 字扩展：指增加存储器字的数量； 字、位扩展：以上俩种； 2.存储器和CPU连接：存储芯片和CPU芯片相连时，特别要注意片和片之间的地址线、数据线和控制线的连接； 地址线的连接：存储芯片的容量不同，其地址线数也不同，CPU的地址线往往比存储芯片的地址线多很多，通常是将CPU地址线的地位和存储芯片的地址线相连，而CPU的高位或在存储芯片扩充时用，或做其他途径，如片选信号； 数据线的连接：CPu数据线数与存储芯片的数据线数也不一定相等，也需要对存储芯片扩位，使其数据位数相等； 读写命令线的连接：CPU读写命令线一般可直接与存储芯片读写控制端相连，通常高点平为读，低电平为写； 片选线的连接：存储器的哪一片存储芯片被选中完全取决于该存储芯片的片选控制端CS是否能接受到来自CPU的片选有效信号； 合理选择存储芯片：通常使用ROM存放系统程序、标准子程序和各类常数等，而RAM则是为用户编程而设置的； 3.存储器校验：采用汉明码进行纠正错误； 4.提高访存速度的措施： 单体多字系统：同一个存储周期，从同一个地址取出4条指令，然后再逐条送至CPU执行，即每隔1/4存取周期，主存向CPU发送一条指令，显然增大了单体存储器的带宽； 多体并行系统：采用多体模块组成的存储器，每个模块有相同的容量和存取速度，即同时访问N个模块，同时启动，同时读写，完全并行工作，而主存和哪个部件交换信息由存储器控制部件承担，如下是它的的组成体； 排队器：访问是随机的，为了防止发生俩个以上的请求源同时占用一个存储体，必须设立一个排队器来确定请求的优先级； 存控标记触发器C_M：用来接受排队器的输出的排队信号； 节拍发生器：用来产生固定节拍，与机器主脉冲同步，使控制线路按一定时序发出信号； 控制线路：向存储器的部件发出请求和响应回复； 高性能存储芯片：DRAM如今发展速度很快，几乎每隔三年存储芯片的容量就翻俩番，同时还出现了许多基于DRAM的增强功能，例如SDRAM、RDRAM、CDRAM； 高速缓冲存储器1.高速缓冲存储器说明（Cache）：Cache的提出有以下俩个主要原因； 避免CPU空等现象：在多体并行存储系统中，由于I/O设备向主存请求的级别高于CPU，所以会出现等待I/O设备访存的现象，使CPU空等一段时间； CPU和主存（DRAM）的速度差异：CPU速度平均每年改进百分之60，而组成主存的动态RAM速度每年只改进百分之7，主存的速度始终跟不上CPU的发展； Cache性能指标1.命中率：设$N_c$为访问Cache的总命中次数，$N_m$为访问主存的总次数，则 Cache 命中率为 $h;=;\\frac{N_c}{N_c+N_m}$ 2.平均访问时间：设 $t_c$ 为命中时的Cache访问时间，$t_m$ 为未命中时的主存访问时间，则Cache – 主存系统的 平均访问时间为$t_a=ht_c+(1-h)t_m$（平均访问时间 ta 与 命中率 有关）； 3.访问效率：访问效率 e 与 命中率 有关，$e=\\frac{\\mathrm{访问}Cache\\mathrm{的时间}}{\\mathrm{平均访问时间}}\\times100%$，设 Cache 命中率 为 h，访问 Cache 的时间为 $t_c$ ，访问 主存 的时间为 $t_m$，$e=\\frac{t_c}{h\\times t_c+(1-h)\\times t_m}\\times100%$； Cache命中问题1.缓存命中说明： Cache命中：CPU欲访问的数据已经在Cache中； Cache不命中：CPU欲访问的数据不在Cache内； 命中率：CPU欲访问的信息在Cache中的比率； Cache基本结构1.Cache基本组成： Cache存储体：存储体以快为单元和主存交换信息，且主存大多采用多体结构，且Cache访存的优先级最高； 地址映射机构：是将CPU送来的主存地址转换为Cache地址，有如下几种替换策略 直接映射：固定的映射关系，容易实现，但是不够灵活，降低缓存命中率； 全相联映射：灵活的映射关系，命中率高，但是逻辑电路甚多，成本较高； 组相联映射：上面方案的折中实现； 替换机构：当Cache的内容已满时，无法接受来自主存块的信息时，就有Cache内的替换机构按照一定的替换算法来进行替换，替换的算法如下： 先进先出算法（FIFO）：选择最早进入Cache的字块进行替换，不需要记录各字块的使用情况，比较容易实现，但是没有根据访存的局部性原理，故不能提高Cache的命中率； 近期最少使用算法（LRU）：利用访存的局部性原理，替换出近期用得最少的字块，平均命中率比FIFO高，但是需要记录各字块的使用情况，一般作简化，只记录每个块最近一次使用的时间； 随机法： 随机进行替换，比较简单； ###Cache读写操作1.读操作：如图 2.写操作： 如果Cache命中，那么就需要保持Cache和主存内容一致的问题，如下俩种解决方案： 写直达法：同时写入主存和高速存储器，容易实现，但是增加访问次数； 写回法：只写入高速存储器，但是标记该组被修改过； 如果Cache不命中 ： 按写分配法：写入主存，同时装入该块到Cache； 不按写分配法：直接写入主存，不进行装入； Cache改进（多级缓存）1.Cache改进方式：主要有俩种改进方式 单一缓存和两级缓存：单一缓存指CPU和主存之间只设一个缓存，且随着集成电路的开发，这个缓存直接和CPU制作在同一个芯片上，故称片内缓存（一级缓存），片内缓存速度很快，但是容量往往比较小，所以在主存和片内缓存之间又加了一级缓存，称片外缓存（二级缓存）； 统一缓存和分立缓存：统一缓存指指令和数据都存放在同一个缓存内的Cache中；而分立缓存指指令和数据分别存放在俩个缓存中，一个称为指令缓存，一个称为数据缓存； 辅助存储器1.辅助存储器说明：辅存属于外部存储器，相对于主存而言具有容量大、速度慢、价格低且非易失性的存储器，目前主要使用的辅盘有硬磁盘、软磁盘、磁带和光盘，前三者都属于磁表面存储器； 2.磁表面存储器主要计数指标 记录密度； 存储容量； 平均寻址时间； 数据传输率； 误码率； 指令系统指令的概念1.指令（机器指令）：控制计算机执行某种操作的命令； 2.指令字（指令码）：表示一条指令的二进制代码； 3.机器语言：用机器指令设计的编程语言，是计算机硬件实体直接表示控制信息的语言； 4.机器语言程序，用机器语言编制的程序，任何用其他语言编制的程序，都必须经过”翻译“，翻译为机器语言程序，才能在机器中正确的运行； 编译型语言和解释型语言的区别 5.指令系统（指令集）：一台计算机所能执行的全部指令的集合； 指令的特征和格式1.指令特征： 完备性：指令功能齐全、足够使用； 高效性：所编写的程序占存储空间小、执行速度快； 规整性：所有的寄存器和存储单元都可同等对待，所有指令都可使用各种寻址方式； 匀齐性：可以支持各种数据类型，指令的格式和数据格式的一致性； 兼容性：系列机各种机型具有相同的基本结构和共同的基本指令集； 2.指令的格式：操作码+地址码 操作码：指定指令所要完成的操作； 地址码：操作数的来源，结果去向，下一条指令的地址； 中断机制控制器和中央处理器控制器和中央处理器的概念1.概念说明：控制器是计算机的指挥和控制中心，其主要功能就是根据事先编好并存放在存储器中的解题程序，按所执行指令的具体要求，适时地产生并发出各种控制命令，控制计算机各部件自动、连续、协调地进行工作，直到完成程序的全部功能为止。所以控制器的基本功能就是运行程序； 控制器的工作过程1.工作过程说明： 取指令：根据PC（程序计数器）提供的指令地址，从存储器中取出所要执行的指令放入IR（指令寄存器）； 分析指令：对取出的指令进行译码分析，确定指令应完成的操作，产生相应操作的控制电位，去参与形成该指令功能所需要的全部控制命令（微操作控制信号）；根据寻址方式，形成操作数的有效地址，并按此地址取出操作数据（运算型指令）或形成转移地址（转移类指令），以实现程序转移； 执行指令：根据指令所规定的操作，并根据需要，保存操作结果，一条指令执行结束，若没有异常情况和特殊请求，则按程序顺序，再去取出并执行下一条指令； 输入输出系统输入输出系统概念1.概念： 输入设备：将外部可读数据转换称计算机内部的数字编码设备； 输出设别：将计算机内部的数字编码转换成外部可读的字符，图形或声音的设备； 系统总线系统总线概念1.基本概念：一组可为多个功能部件共享的公共信息传送线路； 2.总线上系统传输的特点：某一时刻只允许一个部件向总线发送信息，而多个部件和同时从总线接收信息； 补充附录数据效验码奇偶效验码1.奇偶校验码定义：在n位的有效信息位AnAn-1…A1中，加一位校验位P，构成n+1位的奇偶校验码AnAn-1…A1P或者PAnAn-1…A1，若P使n+1位的校验码中“1”的个数为奇数或者偶数。则称为奇校验码或者偶校验码，校验位P又记作Peven（Podd）； 海明效验码常用进位计数制1.定义：用进位的原则进行计数称为进位计数制，简称进制； 2.有关的概念： 数码：一组用来表示某种数制的符号，eg：二进制的0和1； 基数：数制所使用的数码个数，常用R表示，称为R进制； 位权：数码在不同位置的权值 eg：十进制的位权就是10的几次方； 十进制1.定义： 数码：1，2，3，4，5，6，7，8，9； 基数：10； 位权：10为底的幂； 写法规则：2022 D （D是DEC，可以省略）； 2.转二进制：转换规则：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来，如下图： 180（十进制）转换二进制为：10110100 3.转八进制：按照8除十进制整数取余，直到商为0为止； 4.转十六进制：转换规则：用16整除十进制整数，可以得到一个商和余数；再用16去除商，又会得到一个商和余数，如此进行； 二进制1.定义： 数码：0，1； 基数： R= 2； 位权：2为底的幂； 写法规则：0B 10010101 B （0B是c#中s使用二进制的前缀，D是BIN，可以省略）； 2.转十进制：把二进制按权展开，相加即得十进制数 3.转八进制：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。 4.转十六进制：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。 八进制1.定义： 数码：0,1,2,3,4,5,6,7； 基数：8； 位权：8为底的幂； 写法规则：0 720 O （0是c#中使用八进制的前缀，O是OCT，可以省略）； 2.转十进制：把八进制数按权展开、相加即得十进制数。 3.转二进制：八进制通过除二取余，得到二进制数，对每个八进制为3个二进制，不足在最左边补零； 4.转十六进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换； 十六进制1.定义： 数码：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F; 基数：16; 位权：16为底的幂； 写法规则：0X 1AF H （0X是c#中使用十六进制的前缀，D是HEX，可以省略）； 2.转十进制：把十六进制数按权展开、相加即得十进制数。 3.转二进制：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。 4.转八进制：八进制与十六进制之间的转换有两种方法第一种：他们之间的转换可以先转成二进制然后再相互转换。第二种：他们之间的转换可以先转成十进制然后再相互转换 CPU类型复杂指令：X86（CISC）精简指令：ARM（RISC） ASCII码（美国信息交换标准代码）1.ASCII 码说明：ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。其中： 0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 。 32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。 65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。 同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1 [1] 。 后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1] 。 2.ASCII码表具体如下所示 : Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释 0000 0000 00 0 0x00 NUL(null) 空字符 0000 0001 01 1 0x01 SOH(start of headline) 标题开始 0000 0010 02 2 0x02 STX (start of text) 正文开始 0000 0011 03 3 0x03 ETX (end of text) 正文结束 0000 0100 04 4 0x04 EOT (end of transmission) 传输结束 0000 0101 05 5 0x05 ENQ (enquiry) 请求 0000 0110 06 6 0x06 ACK (acknowledge) 收到通知 0000 0111 07 7 0x07 BEL (bell) 响铃 0000 1000 010 8 0x08 BS (backspace) 退格 0000 1001 011 9 0x09 HT (horizontal tab) 水平制表符 0000 1010 012 10 0x0A LF (NL line feed, new line) 换行键 0000 1011 013 11 0x0B VT (vertical tab) 垂直制表符 0000 1100 014 12 0x0C FF (NP form feed, new page) 换页键 0000 1101 015 13 0x0D CR (carriage return) 回车键 0000 1110 016 14 0x0E SO (shift out) 不用切换 0000 1111 017 15 0x0F SI (shift in) 启用切换 0001 0000 020 16 0x10 DLE (data link escape) 数据链路转义 0001 0001 021 17 0x11 DC1 (device control 1) 设备控制1 0001 0010 022 18 0x12 DC2 (device control 2) 设备控制2 0001 0011 023 19 0x13 DC3 (device control 3) 设备控制3 0001 0100 024 20 0x14 DC4 (device control 4) 设备控制4 0001 0101 025 21 0x15 NAK (negative acknowledge) 拒绝接收 0001 0110 026 22 0x16 SYN (synchronous idle) 同步空闲 0001 0111 027 23 0x17 ETB (end of trans. block) 结束传输块 0001 1000 030 24 0x18 CAN (cancel) 取消 0001 1001 031 25 0x19 EM (end of medium) 媒介结束 0001 1010 032 26 0x1A SUB (substitute) 代替 0001 1011 033 27 0x1B ESC (escape) 换码(溢出) 0001 1100 034 28 0x1C FS (file separator) 文件分隔符 0001 1101 035 29 0x1D GS (group separator) 分组符 0001 1110 036 30 0x1E RS (record separator) 记录分隔符 0001 1111 037 31 0x1F US (unit separator) 单元分隔符 0010 0000 040 32 0x20 (space) 空格 0010 0001 041 33 0x21 ! 叹号 0010 0010 042 34 0x22 “ 双引号 0010 0011 043 35 0x23 # 井号 0010 0100 044 36 0x24 $ 美元符 0010 0101 045 37 0x25 % 百分号 0010 0110 046 38 0x26 &amp; 和号 0010 0111 047 39 0x27 ‘ 闭单引号 0010 1000 050 40 0x28 ( 开括号 0010 1001 051 41 0x29 ) 闭括号 0010 1010 052 42 0x2A * 星号 0010 1011 053 43 0x2B + 加号 0010 1100 054 44 0x2C , 逗号 0010 1101 055 45 0x2D - 减号/破折号 0010 1110 056 46 0x2E . 句号 0010 1111 057 47 0x2F / 斜杠 0011 0000 060 48 0x30 0 字符0 0011 0001 061 49 0x31 1 字符1 0011 0010 062 50 0x32 2 字符2 0011 0011 063 51 0x33 3 字符3 0011 0100 064 52 0x34 4 字符4 0011 0101 065 53 0x35 5 字符5 0011 0110 066 54 0x36 6 字符6 0011 0111 067 55 0x37 7 字符7 0011 1000 070 56 0x38 8 字符8 0011 1001 071 57 0x39 9 字符9 0011 1010 072 58 0x3A : 冒号 0011 1011 073 59 0x3B ; 分号 0011 1100 074 60 0x3C &lt; 小于 0011 1101 075 61 0x3D = 等号 0011 1110 076 62 0x3E &gt; 大于 0011 1111 077 63 0x3F ? 问号 0100 0000 0100 64 0x40 @ 电子邮件符号 0100 0001 0101 65 0x41 A 大写字母A 0100 0010 0102 66 0x42 B 大写字母B 0100 0011 0103 67 0x43 C 大写字母C 0100 0100 0104 68 0x44 D 大写字母D 0100 0101 0105 69 0x45 E 大写字母E 0100 0110 0106 70 0x46 F 大写字母F 0100 0111 0107 71 0x47 G 大写字母G 0100 1000 0110 72 0x48 H 大写字母H 0100 1001 0111 73 0x49 I 大写字母I 01001010 0112 74 0x4A J 大写字母J 0100 1011 0113 75 0x4B K 大写字母K 0100 1100 0114 76 0x4C L 大写字母L 0100 1101 0115 77 0x4D M 大写字母M 0100 1110 0116 78 0x4E N 大写字母N 0100 1111 0117 79 0x4F O 大写字母O 0101 0000 0120 80 0x50 P 大写字母P 0101 0001 0121 81 0x51 Q 大写字母Q 0101 0010 0122 82 0x52 R 大写字母R 0101 0011 0123 83 0x53 S 大写字母S 0101 0100 0124 84 0x54 T 大写字母T 0101 0101 0125 85 0x55 U 大写字母U 0101 0110 0126 86 0x56 V 大写字母V 0101 0111 0127 87 0x57 W 大写字母W 0101 1000 0130 88 0x58 X 大写字母X 0101 1001 0131 89 0x59 Y 大写字母Y 0101 1010 0132 90 0x5A Z 大写字母Z 0101 1011 0133 91 0x5B [ 开方括号 0101 1100 0134 92 0x5C \\ 反斜杠 0101 1101 0135 93 0x5D ] 闭方括号 0101 1110 0136 94 0x5E ^ 脱字符 0101 1111 0137 95 0x5F _ 下划线 0110 0000 0140 96 0x60 ` 开单引号 0110 0001 0141 97 0x61 a 小写字母a 0110 0010 0142 98 0x62 b 小写字母b 0110 0011 0143 99 0x63 c 小写字母c 0110 0100 0144 100 0x64 d 小写字母d 0110 0101 0145 101 0x65 e 小写字母e 0110 0110 0146 102 0x66 f 小写字母f 0110 0111 0147 103 0x67 g 小写字母g 0110 1000 0150 104 0x68 h 小写字母h 0110 1001 0151 105 0x69 i 小写字母i 0110 1010 0152 106 0x6A j 小写字母j 0110 1011 0153 107 0x6B k 小写字母k 0110 1100 0154 108 0x6C l 小写字母l 0110 1101 0155 109 0x6D m 小写字母m 0110 1110 0156 110 0x6E n 小写字母n 0110 1111 0157 111 0x6F o 小写字母o 0111 0000 0160 112 0x70 p 小写字母p 0111 0001 0161 113 0x71 q 小写字母q 0111 0010 0162 114 0x72 r 小写字母r 0111 0011 0163 115 0x73 s 小写字母s 0111 0100 0164 116 0x74 t 小写字母t 0111 0101 0165 117 0x75 u 小写字母u 0111 0110 0166 118 0x76 v 小写字母v 0111 0111 0167 119 0x77 w 小写字母w 0111 1000 0170 120 0x78 x 小写字母x 0111 1001 0171 121 0x79 y 小写字母y 0111 1010 0172 122 0x7A z 小写字母z 0111 1011 0173 123 0x7B { 开花括号 0111 1100 0174 124 0x7C | 垂线 0111 1101 0175 125 0x7D } 闭花括号 0111 1110 0176 126 0x7E ~ 波浪号 0111 1111 0177 127 0x7F DEL (delete) 删除","categories":[{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"计算机组成原理","slug":"大学知识/CS基础/计算机组成原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"Unity进阶-UGUI","slug":"03005-Unity进阶-UGUI","date":"2020-03-24T13:00:00.000Z","updated":"2022-07-09T16:15:54.192Z","comments":true,"path":"posts/1541.html","link":"","permalink":"https://wwy.wwywy.com/posts/1541.html","excerpt":"","text":"六大基础组件1.Canvas对象上依附的：Canvas：画布组件，主要用于渲染UI控件Canvas Scaler：画布分辨率自适应组件，主要用于分辨率自适应Graphic Raycaster：射线事件交互组件，主要用于控制射线响应相关RectTransform：UI对象位置锚点控制组件，主要用于控制位置和对其方式 2.EventSystem对象上依附的：EventSystem和Standalone Input Module：玩家输入事件响应系统和独立输入模块组件，主要用于监听玩家操作 Canvas画布组件1.Screen Space - Overlay：屏幕空间，覆盖模式，UI始终在前； Pixel Perfect：是否开启无锯齿精确渲染（性能换效果） SortOrder：排序层编号（用于控制多个Canvas时的渲染先后顺序） TargetDisplay：目标设备（在哪个显示设备上显示） Additional Shader Channels：其他着色器通道，决定着色器可以读取哪些数据 2.Screen Space - Camera(不推荐设置成主摄像机)：屏幕空间，摄像机模式，3D物体可以显示在UI之前； RenderCamera：用于渲染UI的摄像机（如果不设置将类似于覆盖模式） Plane Distance：UI平面在摄像机前方的距离，类似整体Z轴的感觉 Sorting Layer：所在排序层 Order in Layer：排序层的序号 3.World Space：世界空间，3D模式； Event Camera：用于处理UI事件的摄像机（如果不设置，不能正常注册UI事件） 画布 - Unity 手册 (unity3d.com) CanvasScaler画布缩放控制器组件 CanvasScaler意思是画布缩放控制器，它是用于分辨率自适应的组件，它主要负责在不同分辨率下UI控件大小自适应，它并不负责位置，位置由之后的RectTransform组件负责； 1.屏幕分辨率（UI画布宽高*缩放系数 = 屏幕分辨率）：当前设备的分辨率，编辑器下Game窗口中可以查看到；2.参考分辨率：在其中一种适配模式中出现的关键参数，参与分辨率自适应的计算；3.画布宽高和缩放系数：分辨率自适应会改变的参数，通过屏幕分辨率和参考分辨率计算而来；4.分辨率大小自适应：通过一定的算法以屏幕分辨率和参考分辨率参与计算得出缩放系数，该结果会影响所有UI控件的缩放大小； 画布缩放器 (Canvas Scaler) - Unity 手册 (unity3d.com) 缩放模式 根据屏幕尺寸进行缩放，随着屏幕尺寸变化来放大缩小（游戏开发中常用）； 1.Reference Resolution：参考分辨率（美术同学出图的标准分辨率）； 缩放模式下的所有匹配模式都会基于参考分辨率进行自适应计算； 2.Screen Match Mode：屏幕匹配模式，当前屏幕分辨率宽高比不适应参考分辨率时，用于分辨率大小自适应的匹配模式； Expand：水平或垂直拓展画布区域，会根据宽高比的变化来放大缩小画布，可能有黑边(缩放系数 = Mathf.Min(屏幕宽/参考分辨率宽，屏幕高/参考分辨率高)); Shrink：水平或垂直裁剪画布区域，会根据宽高比的变化来放大缩小画布，可能会裁剪(缩放系数 = Mathf.Max(屏幕宽/参考分辨率宽，屏幕高/参考分辨率高)); Match Width Or Height：以宽高或者二者的平均值作为参考来缩放画布区(在取平均值之前，我们先取相对宽度和高度的对数,float logWidth = Mathf.Log(屏幕宽 / 参考分辨率宽, 2);float logHeight = Mathf.Log(屏幕高 / 参考分辨率高, 2);,在对数空间中变换是为了获得更好的性能以及更准确的结果,float logWeightedAverage = Mathf.Lerp(logWidth, logHeight, m_MatchWidthOrHeight);scaleFactor = Mathf.Pow(2, logWeightedAverage);); 恒定像素模式 无论屏幕大小如何，UI始终保持相同像素大小。 1.Scale Factor：缩放系数，按此系数缩放画布中的所有UI元素； 2.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单位为100像素），图片设置中的Pixels Per Unit设置，会和该参数一起参与计算； 计算公式：UI原始尺寸 = 图片大小（像素）/ (Pixels Per Unit / Reference Pixels Per Unit） 恒定物理模式 无论屏幕大小和分辨率如何，UI元素始终保持相同物理大小（DPI：（Dots Per Inch，每英寸点数）图像每英寸长度内的像素点数）。 1.Physical Unit：物理单位，使用的物理单位种类 2.Fallback Screen DPI：备用DPI，当找不到设备DPI时，使用此值 3.Default Sprite DPI：默认图片DP 单位种类 与1英寸的关系： Centimeters（厘米cm） 2.54 Millimeters（毫米mm） 25.4 Inches（英寸） 1 Points（点） 72 Picas（皮卡） 计算公式：根据DPI算出新的Reference Pixels Per Unit （单位参考像素） 新单位参考像素 =单位参考像素 * Physical Unit / Default Sprite DPI 再使用模式一：恒定像素模式的公式进行计算 原始尺寸 =图片大小（像素）/ (Pixels Per Unit / 新单位参考像素) ##3D模式 当Canvas的渲染模式设置为，世界空间3D渲染模式时，这时Canvas Scaler 的缩放模式会强制变为，World 3D世界模式； 1.Dynamic Pixels Per Unit：UI中动态创建的位图（例如文本）中，单位像素数（类似密度） 2.Reference Pixels Per Unit：单位参考像素，多少像素对应Unity中的一个单位（默认一个单 位为100像素） Graphic Raycaster图像射线投射器 Graphic Raycaster意思是图形射线投射器,它是用于检测UI输入事件的射线发射器,它主要负责通过射线检测玩家和UI元素的交互,判断是否点击到了UI元素; 1.Ignore Reversed Graphics：是否忽略反转图形 2.Blocking Objects：射线被哪些类型的碰撞器阻挡（在覆盖渲染模式下无效） 3.Blocking Mask：射线被哪些层级的碰撞器阻挡（在覆盖渲染模式下无效） 图形射线投射器 - Unity 手册 (unity3d.com) RectTransform RectTransform意思是矩形变换，它继承于Transform，是专门用于处理UI元素位置大小相关的组件，Transform组件只处理位置、角度、缩放，RectTransform在此基础上加入了矩形相关，将UI元素当做一个矩形来处理，加入了中心点、锚点、长宽等属性，其目的是更加方便的控制其大小以及分辨率自适应中的位置适应； 1.Pivot：轴心(中心)点，取值范围0~1 2.Anchors(相对父矩形锚点)： 3.Min是矩形锚点范围X和Y的最小值 4.Max是矩形锚点范围X和Y的最大值 取值范围都是0~1 5.Pos(X,Y,Z)：轴心点(中心点)相对锚点的位置 6.Width/Height：矩形的宽高 7.Left/Top/Right/Bottom：矩形边缘相对于锚点的位置；当锚点分离时会出现这些内容 8.Rotation：围绕轴心点旋转的角度 9.Scale：缩放大小 10.Blueprint Mode（蓝图模式）:启用后，编辑旋转和缩放不会影响矩形，只会影响显示内容 11.Raw Edit Mode（原始编辑模式）:启用后，改变轴心和锚点值不会改变矩形位置 矩形变换 - Unity 手册 (unity3d.com) EventSystem Event System意思是事件系统，它是用于管理玩家的输入事件并分发给各UI控件，它是事件逻辑处理模块，所有的UI事件都通过EventSystem组件中轮询检测并做相应的执行，它类似一个中转站，和许多模块一起共同协作，如果没有它，所有点击、拖曳等等行为都不会被响应； 1.First Selected：首先选择的游戏对象，可以设置游戏一开始的默认选择 2.Send Navigation Events：是否允许导航事件（移动/按下/取消） 3.Drag Threshold：拖拽操作的阈值（移动多少像素算拖拽） 事件系统管理器 - Unity 手册 (unity3d.com) Standalone Input Module Standalone Input Module意思是独立输入模块，它主要针对处理鼠标/键盘/控制器/触屏（新版Unity）的输入，输入的事件通过EventSystem进行分发，它依赖于EventSystem组件，他们两缺一不可； 1.Horizontal Axis：水平轴按钮对应的热键名（该名字对应Input管理器） 2.Vertical Axis：垂直轴按钮对应的热键名（该名字对应Input管理器） 3.Submit Button：提交（确定）按钮对应的热建名（该名字对应Input管理器） 4.Cancel Button：取消按钮对应的热建名（该名字对应Input管理器） 5.Input Actions Per Second：每秒允许键盘/控制器输入的数量 6.Repeat Delay：每秒输入操作重复率生效前的延迟时间 7.ForceModule Active：是否强制模块处于激活状态 独立输入模块 - Unity 手册 (unity3d.com) 三大基础控件Text 是UGUI中用于显示文本的关键组件，可以加OutLine组件和Shadow组件配合。 Text参数: Text：文本显示内容 Font：字体 FontStyle：字体样式 Normal：普通 Bold：加粗 Italic：斜体 Bold And Italic：加粗 + 斜体 Font Size：字体大小 Line Spacing：行之间的垂直间距 Rich Text：是否开启富文本 Alignment：对其方式 Align By Geometry：使用字形集合形状范围进行水平对其，而不是字形指标 Horizontal Overflow：处理文本太宽无法放入矩形范围内时的处理方式 Wrap：包裹模式-字体始终在矩形范围内，会自动换行 Overflow：溢出模式-字体可以溢出矩形框 Vertical Overflow：处理文本太高无法放入矩形范围内时的处理方式 Truncate：截断模式-字体始终在矩形范围内，超出部分裁剪 Overflow：溢出模式-字体可以溢出矩形框 Best Fit：忽略字体大小，始终把内容完全显示在矩形框中，会自动调整字体大小 MinSize：最小多小 MaxSize：最大多大 富文本: 加粗&lt;b&gt;文本内容&lt;/b&gt; 斜体&lt;i&gt;文本内容&lt;/i&gt; 大小&lt;size=50&gt;文本内容&lt;/size&gt; 颜色: &lt;color=#ff0000ff&gt;文本内容&lt;/size&gt; &lt;color=red&gt;文本内容&lt;/size&gt; 文本 (Text) - Unity 手册 (unity3d.com) Image 是UGUI中用于显示精灵图片的关键组件，除了背景图等大图，一般都使用Image来显示UI中的图片元素。Image参数 Source Image：图片来源（图片类型必须是”精灵“类型） Color：图像的颜色 Material：图像的材质（一般不修改，会使用UI的默认材质） Raycast Target：是否作为射线检测的目标（如果不勾选将不会响应射线检测） Maskable：是否能被遮罩（之后结合遮罩相关知识点进行讲解） Image Type：图片类型 Simple-普通模式，均匀缩放整个图片 Sliced-切片模式，9宫格拉伸，只拉伸中央十字区域 Pixels Per UnitMultiplier：每单位像素乘数 Fill Center：中心填充 Tiled-平铺模式，重复平铺中央部分 Filled-填充模式 Fill Method：填充方式 Fill Origin：填充原点 Fill Amount：填充量 Clockwise：顺时针方向 Use Sprite Mesh：使用精灵网格，勾选的话Unity会帮我们生成图片网格 Preserve Aspect：确保图像保持其现有尺寸 Set Native Size：设置为图片资源的原始大小 图像 (Image) - Unity 手册 (unity3d.com) RawImage 它和Image的区别是 一般RawImage用于显示大图(背景图，不需要打入图集的图片，网络下载的图等等)。 原始图像 (Raw Image) - Unity 手册 (unity3d.com) 组合控件Button按钮控件 是UGUI中用于处理玩家按钮相关交互的关键组件。参数： Interactable：是否接受输入 Transition：响应用户输入的过渡效果 None：没有状态变化效果 ColorTint：用颜色表示不同状态的变化 TargetGraphic：控制的目标图形 Normal Color：正常状态颜色 Highlighted Color：鼠标进入时显示高亮颜色 Pressed Color：按下颜色 Selected Color：选中的颜色 Disabled Color：禁用时的颜色 Color Multiplier：颜色倍增器，过渡颜色乘以该值 FadeDuration：衰减持续时间，从一个状态进入另一个状态时需要的时间 Sprite Swap：用图片表示不同状态的变化 Highlighted Sprite：鼠标进入时图片 Pressed Sprite：按下时图片 Selected Color：选中时的颜色 Disabled Sprite：禁用时显示的图片 Animation：用动画表示不同状态的变化 Normal Trigger：正常动画触发器 Highlighted Trigger：鼠标进入状态时触发器 Pressed Trigger：按下时触发器 Selected Trigger：选中时触发器 Disabled Trigger：禁用时触发器 Navigation：导航模式，可以设置UI元素如何在播放模式中控制导航 None：无键盘导航 Horizontal：水平导航 Verticval：垂直导航 Automatic：自动导航 Explicit：指定周边控件进行导航 Visualize:可以在场景窗口看到导航连线 OnClick：单击（按下再抬起）执行的函数列表(btn.onClick.AddListenter(事件);) 按钮 (Button) - Unity 手册 (unity3d.com) Toggle开关控件 是UGUI中用于处理玩家单选框多选框相关交互的关键组件，可以通过配合ToggleGroup组件制作为单选框，默认创建的Toggle由4个对象组成，父对象——Toggle组件依附，子对象——背景图（必备）、选中图（必备）、说明文字（可选）。 Toggle参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) IsOn：当前是否处于打开状态 Toggle Transition：在开关值变化时的过渡方式 None：无任何过渡，直接显示隐藏 Fade：淡入淡出 Graphic：用于表示选中状态的图片 Group：单选框分组(需要挂载Toggle Group组件) Allow Switch Off：是否允许不选中任何一个单选框（注意：单选框分组组件可以挂载在任何对象上，只需要将其和一组的单选框关联即可） OnValueChanged：开关状态变化时执行的函数列表（ tog.onValueChanged.AddListener(事件);） 开关 (Toggle) - Unity 手册 (unity3d.com) InputField文本输入控件 是UGUI中用于处理玩家文本输入相关交互的关键组件，默认创建的InputField由3个对象组成，父对象——InputField组件依附对象 以及 同时在其上挂载了一个Image作为背景图，子对象——文本显示组件（必备）、默认显示文本组件（必备）。 InputField参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) TextComponent：用于关联显示输入内容的文本组件 Text：输入框的起始默认值 Character Limit：可以输入字符长度的最大值（0默认无限） Content Type：输入的字符类型限制 Standard：标准模式；可以输入任何字符 Autocorrected：自动更正模式；跟踪未知单词，向用户建议合适的替换候选词 Integer Number：整数模式；用户只能输入整数 Decimal Number：十进制数模式；用于只能输入数字包括小数 Alphanumeric：字母数字模式；只能输入字母和数字 Name：名字模式；自动将每个单子首字母大写 Email Address：邮箱地址模式；允许最多输入一个@符号组成的字符和数字字符串 Password：密码模式；用星号隐藏输入的字符，允许使用字符 Pin：别针模式；用星号隐藏输入的字符，只允许输入整数 Custom：自定义模式；允许自定义行类型，输入类型，键盘类型和字符验证 Line Type：行类型，定义文本格式 Single Line：只允许单行显示 Multi Line Submit：允许使用多行。仅在需要时使用新的一行 Multi Line NewLine：允许使用多行。用户可以按回车键空行 Placeholder：关联用于显示初始内容文本控件 Caret Blink Rate：光标闪烁速率 Caret Width：光标宽 Custom Caret Color：自定义光标颜色 Selection Color：批量选中的背景颜色 Hide Mobile Input：隐藏移动设备屏幕上键盘，仅适用于IOS Read Only：只读，不能改 OnValueChanged：滑动条值改变时执行的函数列表 input.onValueChanged.AddListener(事件） input.onEndEdit.AddListener(事件） 输入字段 (Input Field) - Unity 手册 (unity3d.com) Slider滑动条控件 Slider是滑动条组件，默认创建的Slider由4组对象组成，父对象——Slider组件依附的对象，子对象——背景图、进度图、滑动块三组对象。 Slider参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) FillRect：用于填充的进度条图形 Handle Rect：用于滑动的滑动块图形 Direction：滑动条值增加的方向 Left To Right：从左到右 Right To Left：从右到左 Bottom To Top：从下到上 Top To Bottom：从上到下 Min Value 和 Max Value：最小值和最大值，滑动滚动条时值从最小到最大之间变化（左右、上下极值） Whole Numbers：是否约束为整数值变化 Value：当前滑动条代表的数值 OnValueChanged：滑动条值改变时执行的函数列表（ s.onValueChanged.AddListener(事件)） 滑动条 (Slider) - Unity 手册 (unity3d.com) ScrollBar滚动条控件 是UGUI中用于处理滚动条相关交互的关键组件，默认创建的Scrollbar由2组对象组成，父对象——Scrollbar组件依附的对象，子对象——滚动块对象，一般情况下我们不会单独使用滚动条 ，都是配合ScrollView滚动视图来使用。 ScrollBar参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) Handle Rect：关联滚动块图形对象 Direction：滑动条值增加的方向 Left To Right：从左到右 Right To Left：从右到左 Bottom To Top：从下到上 Top To Bottom：从上到下 Value：滚动条初始位置值（0~1） Value：滚动块在条中的比例大小（0~1） Number Of Steps：允许可以滚动多少次（不同滚动位置的数量） OnValueChanged：滚动条值改变时执行的函数列表（ sb.onValueChanged.AddListener(事件)） 滚动条 (Scrollbar) - Unity 手册 (unity3d.com) ScrollView滚动视图控件 是UGUI中用于处理滚动视图相关交互的关键组件，默认创建的ScrollRect由4组对象组成，父对象——ScrollRect组件依附的对象 还有一个Image组件 最为背景图，子对象——Viewport控制滚动视图可视范围和内容显示、Scrollbar Horizontal 水平滚动条、Scrollbar Vertical 垂直滚动条。 ScrollRect参数: Content：控制滚动视图显示内容的父对象，它的尺寸有多大(滚动视图就能拖多远) Horizontal：启用水平滚动 Vertical：启用垂直滚动 Movement Type：滚动视图元素的运动类型。主要控制拖动时的反馈效果 Unrestricted（一般不使用）：不受限制，随便拖动 Elastic（常用）：回弹效果，当滚出边缘后，会弹回边界 Elasticity：回弹系数，控制回弹效果。值越大回弹越慢 Clamped：夹紧效果，始终限制在范围内，没有回弹效果 Inertia：移动惯性，如果开启，松开鼠标后会有一定的移动惯性 Deceleration Rate：减速率（0~1），0没有惯性，1不会停止 Scroll Sensitivity：滚轮（鼠标中间）和触摸板（笔记本）的滚动事件敏感性 Viewport：关联滚动视图内容视口对象 Horizontal Scrollbar：关联水平滚动条 Visibility：是否在不需要时自动隐藏等模式 Permanent：一直显示滚动条 Auto Hide：自动隐藏滚动条 Auto Hide And Expand Viewport：自动隐藏滚动条并且自动拓展内容视口 Spacing：滚动条和视口之间的间隔空间 OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener(事件)） Dropdow下拉列表控件 是UGUI中用于处理下拉列表相关交互的关键组件，默认创建的DropDown由4组对象组成，父对象——DropDown组件依附的对象 还有一个Image组件 作为背景图，子对象——Label是当前选项描Arrow右侧小箭头、Template下拉列表选单。 Dropdow参数: Interactable：是否接受输入 Transition：响应用户输入的过渡效果(同Button) Navigation：导航模式，可以设置UI元素如何在播放模式中控制器导航(同Button) Template：关联下拉列表对象 Caption Text：关联显示当前选择内容的文本组件 Caption Image：关联显示当前选择内容的图片组件 Item Text：关联下拉列表选项用的文本控件 Item Image：关联下拉列表选项用的图片控件 Value：当前所选选项的索引值 Alpha Fada Speed：下拉列表窗口淡入淡出的速度 Options：存在的选项列表 OnValueChanged：滚动视图位置改变时执行的函数列表（sr.onValueChanged.AddListener(事件)） 下拉选单 (Dropdown) - Unity 手册 (unity3d.com) 进阶知识图集制作 打图集注意的是在游戏场景插入同图集的图会打断批处理，即使在同一个图集也不行，所以要额外注意UI元素的排列顺序。 事件监听接口EventTrigger事件触发器屏幕坐标转UI相对坐标遮罩Mask模型和粒子显示在UI之前异形按钮自动布局组件画布组Canvas Group","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"UGUI","slug":"UGUI","permalink":"https://wwy.wwywy.com/tags/UGUI/"}]},{"title":"Unity核心","slug":"03003-Unity核心","date":"2019-10-05T13:00:00.000Z","updated":"2022-03-03T07:46:38.666Z","comments":true,"path":"posts/1539.html","link":"","permalink":"https://wwy.wwywy.com/posts/1539.html","excerpt":"","text":"2D相关图片导入设置Unity支持的图片格式BMP:是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大; TIF:基本不损失图片信息的图片格式，缺点是体积大; JPG:一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道; PNG:无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道; TGA:支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道; PSD:是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面; 其它:还支持,EXR、GIF、HDR、IFF、PICT等等,其中Unity最常用的图片格式是JPG、PNG、TGA三种格式; 纹理类型设置（Texture Type）1.Default-默认纹理，大部分导入的模型贴图都是该类型 sRGB(Color Texture)：启用可以将纹理存储在伽马空间(见下图一)中（对每一个像素做一次幂函数运算） Alpha Source：指定如何生成纹理的Alpha通道 None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道 Input Texture Alpha：输入纹理中的Alpha From Gray Scale：从输入纹理RGB值的平均值生成Alpha Alpha Is Transparency：启用可以避免边缘上的过滤瑕疵 2.Normal map-法线贴图格式： 法线贴图说明：就是在原物体的凹凸表面的每个点上均作法线法线就是垂直于某个点的切线的方向向量 Create From Grayscale：启用此属性可以从灰度高度贴图创建法线贴图 Bumpiness：控制凹凸程度，值越大凹凸感越强 Filtering：如何计算凹凸值 Smooth：使用标准算法生成法线贴图 Sharp：生成比标准模式更锐利的法线贴图 3.Editor GUI and Legacy GUI：一般在编辑器中或者GUI上使用的纹理 4.Sprite（2D and UI）：2D游戏或者UGUI中使用的格式 Sprite Mode：图像中提取精灵图形的方式 Single：按原样使用精灵图像 Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片 Polygon：网格精灵模式 Pixels Per Unit：世界空间中的一个距离单位对应多少像素 MeshType：网格类型；只有Single和Multiple模式才支持 Full Rect：创建四边形，将精灵显示在四边形上 Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状；任何小于32*32的精灵都使用FullRect模式，即使设置成Tight模式也是； Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小 Pivot：精灵图片的轴心点，Single模式才有此选项，对应九宫格布局的九个点，还可以自定义 Generate Physics Shape：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状，只有Single 和Multiple模式才可使用 Sprite Editor：编辑Sprite，需要安装2D Sprite包，之后单独讲解 5.Cursor：自定义光标 6.Cookie：光源剪影格式 Light Type：应用的光源类型，一般点光源的剪影需要设置为立方体纹理，方向光和聚光灯的剪影设置为2D纹理； Spotlight：聚光灯类型，需要边缘纯黑色纹理 Directional：方向光，平铺纹理 Point：点光源，需要设置为立方体形状 7.Lightmap：光照贴图格式 8.Single Channel：纹理只需要单通道的格式 Channel：希望将纹理处理为Alpha还是Red通道 Alpha：使用Alpha通道，不允许进行压缩 Red：使用红色通道; 图一：线性和伽马颜色空间说明 纹理形状（Texture Shape）1.2D：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上; 2.Cube：立方体贴图，主要用于天空盒和反射探针 Mapping：如何将纹理投影到游戏对象上 Auto：根据纹理信息创建布局 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像 Latitude-Longitude Layout：将纹理映射到2D维度/经度 Mirrored Ball：将纹理映射到类似球体的立方体贴图上 Convolution Type：纹理的过滤类型 None：无过滤 Specular：将立方体作为反射探针 Diffuse：将纹理进行过滤表示辐照度，可作为光照探针 Fixup Edge Seams：Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误； 纹理高级设置 高级设置主要是纹理的一些尺寸规则、读写规则、以及MipMap相关设置 1.Non-Power of 2：如果纹理尺寸非2的幂如何处理(为什么纹理要设置为2的N次方：因为图形学规则，纹理必须是2的幂尺寸) None：纹理尺寸大小保持不变 To nearest：将纹理缩放到最接近2的幂的大小（注意：PVRTC格式要求纹理为正方形） To larger：将纹理缩放到最大尺寸大小值的2的幂的大小 To smaller：将纹理缩放到最小尺寸大小值的2的幂的大小 2.Read/Write Enabled：启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启） 3.Streaming Mipmaps：启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存 Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap 4.Generate Mip Maps：允许生成MipMap(开启MipMap功能后，Unity会帮助我们根据图片信息生成n张不同分辨率的图片,在场景中会根据我们离该模型的距离选择合适尺寸的图片用于渲染，提升渲染效率); Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘 Mip Map Filtering：优化图像质量的过滤方法 Box：随着尺寸减小，级别更加平滑 Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法 Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率 Alpha Cutoff Value：覆盖率参考值 Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色 纹理平铺拉伸设置Wrap Mode：平铺纹理时的方式 Repeat：在区块中重复纹理 Clamp：拉伸纹理的边缘 Mirror：在每个整数边界上镜像纹理以创建重复图案 Mirror Once：镜像纹理一次，然后将拉伸边缘纹理 Per-axis：单独控制如何在U轴和V轴上包裹纹理 Filter Mode：纹理在通过3D变化拉伸时如何进行过度 Point：纹理在靠近时变为块状 Bilinear：纹理在靠近时变得模糊 Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊 Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高 纹理平台打包设置（非常重要）1.Max Size：设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内 2.Resize Algorithm：当纹理尺寸大于指定的Max Size时，使用的缩小算法 Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法 Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多 Format：纹理格式（各平台支持的格式有所不同，如果选择Automatic，会根据平台使用默认设置） 都支持的格式:下图一 移动端和网页端特有格式：下图二 不同平台单独进行设置： IOS：选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。 Andorid：推荐如下图三 由于安卓设备众多，设备标准都不同意，一般会根据不同的设备标准制作多个安装包； 构建一个以 OpenGL ES 3 为目标的 APK，访问 Android 的 Player Settings，菜单：Edit &gt; Project Settings &gt;Player Settings，然后选择 Android 类别），向下滚动到 Graphics APIs 部分，确保 OpenGL ES 2 不在列表中，构建 APK，（菜单：File &gt; Build Settings，然后单击 Build）； 构建一个以 OpenGL ES 2 为目标的单独 APK，访问 Android Player Settings，向下滚动到 Graphics APIs 部分，在列表中添加 OpenGL ES 2，并删除 OpenGL ES 3 和 Vulkan，构建 APK。 3.Compression：选择纹理的压缩类型，帮助Unity正确选择压缩格式，会根据平台和压缩格式的可用性进行压缩； None：不压缩纹理 Low Quality：以低质量格式压缩纹理 Normal Quality：以标准格式压缩纹理 High Quality：以高质量格式压缩纹理 4.Use Crunch Compression：启用后，使用Crunch压缩，Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快； Compressor Quality:压缩质量条，质量越高意味着纹理越大，压缩事件越长。 5.Split Alpha Channel：Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。 6.Override ETC2 fallback：不支持ETC2压缩的设备上，使用的格式。 图一：都支持的格式图二：移动端和网页端特有格式图三：移动端和网页端特有格式 SpriteSprite Editor1.Single图片编辑： 右下角设置窗口： Name：名字 Position：在图片中的偏移位置和宽高 Border：边框，用于设置九宫格的4条边 Pivot：轴心（中心）点位置 Pivot Unit Mode：轴心点单位模式 Normalized：标准化模式，0~1 Pixels：像素模式 Custom Pivot：自定义轴心点 （OutLine）自定义边缘线和(Physics)自定义物理形状： Snap：将控制点贴近在最近的像素 Outline Tolerance：轮廓点的复杂性和准确性，0~1值越大轮廓点越多，越准确 Generate：生成网格轮廓 //1.Sprite Editor // 基础图片设置（右下角窗口） // 主要用于设置单张图片的基础属性 //2.Custom Outline（决定渲染区域） // 自定义边缘线设置，可以自定义精灵网格的轮廓形状 // 默认情况下不修改都是在矩形网格上渲染,边缘外部透明区域会被渲染，浪费性能 // 使用自定义轮廓，可以调小透明区域，提高性能 //3.Custom Physics Shape（决定碰撞判断区域） // 自定义精灵图片的物理形状，主要用于设置需要物理碰撞判断的2D图形 // 它决定了之后产生碰撞检测的区域 //4.Secondary Textures(为图片添加特殊效果) // 次要纹理设置，可以将其它纹理和该精灵图片关联 // 着色器可以得到这些辅助纹理然后用于做一些效果处理 // 让精灵应用其它效果 2.Multiple图集元素分割： 自动分割(Automatic)： Pivot：单张图片轴心点位置 Custom Pivot：自定义轴心点 Method：如何处理现有对象 Delete Existing：替换掉已经选择的任何矩形 Smart：尝试创建新矩形同时保留或调整现有矩形 Safe：添加新矩形而不更改任何已经存在的矩形 按单元格大小分割(Grid By Cell Size)： Pixel Size：单元格宽高 Offset：偏移位置 Padding：和边缘的偏移位置 Keep Empty Rects：是否保留空矩形 按单元格大小分割(Grid By Cell Count) 增加参数Column &amp; Row：行列数 3.Polygon多边形编辑： Sprite Editor - Unity 手册 (unity3d.com) Sprite Renderer 所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的。 参数讲解: 1.Sprite：渲染的精灵图片 2.Color：定义着色，一般没有特殊需求不会修改 3.Filp：水平或竖直翻转精灵图片 4.Draw Mode：绘制模式，当尺寸变化时的缩放方式 Simple：简单模式，缩放时整个图像一起缩放 Sliced：切片模式，9宫格切片模式，十字区域缩放，4个角不变化,一般用于变化不大的纯色图（注意：需要把精灵的网格类型设置为Full Rect） Tiled：平铺模式，将中间部分进行平铺而不是缩放（注意：需要把精灵的网格类型设置为Full Rect） Continuous：当尺寸变化时，中间部分将均匀平铺 Adaptive：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺 5.Mask Interaction：与精灵遮罩交互时的方式 None：不与场景中任何精灵遮罩交互 Visible inside Mask：精灵遮罩覆盖的地方可见，而遮罩外部不可见 Visible Outside Mask：精灵遮罩外部的地方可见，而遮罩覆盖处不可见 6.Sprite Sort Point：计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改 7.Material：材质，可以使用一些自定义材质来显示一些特殊效果,一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse 8.Additional Settings：高级设置 Sorting Layer：排序层选择 Order in Layer：层级序列号，数值越大约会显示在前面 Sprite Renderer - Unity 手册 (unity3d.com) API： 知识点一 代码设置 GameObject obj = new GameObject(); SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;(); //动态的改变图片 sr.sprite = Resources.Load&lt;Sprite&gt;(\"dead1\"); //动态的加载 图集中的图 Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;(\"RobotBoyIdleSprite\"); sr.sprite = sprs[10]; UnityEngine.SpriteRenderer - Unity 脚本 API (unity3d.com) Sprite Creator 我们可以利用Sprite Editor的多边形工具创造出各种多边形,Unity也为我们提供了现成的一些多边形,它的主要作用是2D游戏的替代资源,在等待美术出资源时我们可以用他们作为替代品,有点类似Unity提供的自带几何体(在Project窗口右键创建各种形状的Sprite精灵图片). Sprite Creator - Unity 手册 (unity3d.com) Sprite Mask1.Sprite：遮罩图片; 2.Alpha Cutoff：如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1）; 3.Custom Range：自定义遮罩范围,开启后可以设置遮罩的范围，按照排序层来划分; UnityEngine.SpriteMask - Unity 脚本 API (unity3d.com) Sorting Group 顾名思义，SortingGroup是排序分组的意思,它的主要作用就是对多个精灵图片进行分组排序,Unity会将同一个排序组中的精灵图片一起排序，就好像他们是单个游戏对象一样,主要作用是对于需要分层的2D游戏用于整体排序。 排序组 - Unity 手册 (unity3d.com) Rendering.SortingGroup - Unity 脚本 API (unity3d.com) Sprite Atlas精灵图集制作 在工程设置面板中打开功能:Edit——&gt;Project Setting——&gt;Editor（Sprite Packer(精灵包装器，可以通过Unity自带图集工具生成图集)）；Disabled：默认设置，不会打包图集；Enabled For Build：Unity进在构建时打包图集，在编辑器模式下不会打包；Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集； 1.打图集面板参数相关 1.Type：图集类型 Master：主图集 Include in Build：选中可以在当前构建中包含图集 Allow Rotation：选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度；注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转 Tight Packing：选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度 Padding：图集中各图片的间隔像素 Variant：变体类型的图集 Master Atlas：关联的主图集（图集类型必须是Master） Include in Build：选中可以在当前构建中包含图集 Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果(变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可) 2.Read/Write Enabled：允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它 3.Generate Mip Maps：勾选它会生成Mipmap；Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启 4.SRGB：启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。默认情况下会启用此属性。 5.Filter Mode：纹理在3D变化拉伸时如何进行过滤 Point：纹理靠近时变为块状 Bilinear：纹理靠近时变得模糊 Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊 6.Objects for Packing：关联需要打图集的图片们，注意：一定是Sprite类型的图片 7.Default: Max Texture Size：纹理的最大尺寸，像素为单位 Format：指定纹理的内部表示，在不同平台上会有不同的参数 Compression：纹理压缩类型(质量越高占用内存越多，不压缩质量最好)不压缩、低质量、普通质量、高质量； Use Crunch Compression：使用Crunch压缩，是一种有损压缩格式，压缩耗时长，但是运行时解压速度快 Compressor Quality：压缩质量，质量越高纹理越大，耗时越长 精灵图集 - Unity 手册 (unity3d.com) 2.API使用 知识点一 代码控制 GameObject obj = new GameObject(); SpriteRenderer sr = obj.AddComponent&lt;SpriteRenderer&gt;(); //加载图集资源 SpriteAtlas spriteAtlas = Resources.Load&lt;SpriteAtlas&gt;(\"MyAtlas\"); //加载图集资源中的某一张小图 sr.sprite = spriteAtlas.GetSprite(\"dead1\"); U2D.SpriteAtlas - Unity 脚本 API (unity3d.com) 2D物理系统刚体1.刚体类型参数说明: 1.Dynamic：动态类型（受重力和力的影响移动和旋转） Material：物理材质，在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质，如果不设置，将使用在Physics 2D窗口中设置的默认材质 物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质 Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项； Use Auto Mass：是否使用自动质量 Mass：质量 Linear Dray：影响位置移动的阻力系数 Angular Drag：影响旋转移动的阻力系数 Gravity Scale：受重力影响的程度 Collision Detection：碰撞检测算法 Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过 Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况 Sleeping Mode：对象处于静止状态时进入睡眠模式 Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大 Start Awake：最初处于唤醒状态 Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒 Interpolate：物理更新间隔之间的插值运算 None：不应用移动平滑 Interpolate：根据前一帧进行平滑处理 Extrapolate：根据后一帧位置进行平滑处理 Constraints：约束限制，可以让某一个轴不受力影响位移或者旋转 2.Kinematic：运动学类型，不受力的影响，只能通过代码让其动起来，能和Dynamic 2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数，因此它没有了质量莫摩擦系数等属性，因此它的性能能消耗较低，主要会通过代码来处理其移动旋转； Simulated：如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果，需要启用该选项当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞，如果Use FullKinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞； Use Full Kinematic Contacts：如果希望能和所有2D刚体碰撞，启用它，如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞 3.Static：静态类型完全不动的需要检测碰撞的对象，相当于是无限质量不可移动的对象，它的性能消耗最小，它只能和Dynamic 2D刚体碰撞（和只加碰撞体的区别），和它类似的有只加碰撞器而不加刚体的物体，它们会和刚体物体产生碰撞，但是自己不会动； 2D 刚体 - Unity 手册 (unity3d.com) 2.刚体API说明: 知识点一 刚体API(参考刚体3D) //加力 Rigidbody2D rigid = this.GetComponent&lt;Rigidbody2D&gt;(); rigid.AddForce(new Vector2(0, 100)); //速度 rigid.velocity = new Vector2(1, 0); UnityEngine.Rigidbody2D - Unity 脚本 API (unity3d.com) 碰撞体1.碰撞体参数相关: 1.圆形碰撞器（Circle）: Material：一种物理材质，用于确定碰撞的属性，控制摩擦和弹性 Is Trigger：是否是触发器 Used By Effector：是否被附加的2D效应器使用 Offset：圆心偏移位置 Radius：圆形的半径 2.盒状碰撞器(Box): `Used by Composite：如果勾选，则该碰撞器将附加到2D复合碰撞器使用（勾选后一些属性只能在复合碰撞器中配置） Auto Tiling：如果渲染器组件的Draw Mode设置为Tiled模式，勾选该选项，当改变精灵大小时将自动更新碰撞器尺寸； Size：矩形的宽高 Edge Radius：使四个顶点为圆角 3.多边形碰撞器(Polygon) Points：多边形顶点虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了，都通过Edit Collider编辑，或者让Unity自动识别创建 4.边界碰撞器(Edge地形)：边界碰撞器的编辑主要还是通过Edit Collider一般不会手动去通过数值加点 5. 5.胶囊碰撞器(Capsule) Size：胶囊的宽高 Direction：是竖直胶囊还是水平胶囊 6.复合碰撞器(Composite必须配合刚体使用) Geometry Type：几何学类型，合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型 Outlines：空心轮廓，类似边界碰撞器 Polygons：实心多边形，类似多边形碰撞器 Generation Type：生成类型，复合碰撞器在何时生成新几何体 Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体 Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮 Vertex Distance：从复合碰撞器收集顶点时允许的最小间距值 2D 碰撞体 - Unity 手册 (unity3d.com) 2.碰撞器API：碰撞检测函数 和 3D碰撞检测函数除了名字不同外其他基本一致： 知识点一 碰撞检测函数 private void OnCollisionEnter2D(Collision2D collision) private void OnCollisionExit2D(Collision2D collision) private void OnCollisionStay2D(Collision2D collision) private void OnTriggerEnter2D(Collider2D collision) private void OnTriggerExit2D(Collider2D collision) private void OnTriggerStay2D(Collider2D collision) 物理材质物理材质的使用优先级：2D碰撞器上指定的2D物理材质、2D刚体上指定的2D物理材质、Physics 2D窗口指定的2D默认物理材质物理材质参数相关： Friction：摩擦系数，为0表示没有摩擦力 Bounciness：反弹程度。0表示没有弹力，1表示完美弹力（没有能量损失一直弹） 恒定力（了解即可）恒定力（Constant Force）参数说明： Force：物理更新时施加于2D刚体上的线性力 Relative Force：物理更新时施加的线性力（相对刚体对象坐标系） Torque：物理更新时施加于2D刚体的扭矩力 效应器(Effector)效应器参数相关: 1.区域效应器（Area）：在一个区域内让游戏对象受到力和扭矩力的作用(作浮力和电梯传送带) Use Collider Mask：是否启用碰撞器遮罩，如果开启才会出现下面的Collider Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象 Use Global Angle：勾选将使用世界坐标系角度，如果不勾选，角度为局部角度 Force Angle：施加力的角度 Force Magnitude：施加力的大小 Force Variation：施加力的随机大小变化 会在Force Magnitude基础上根据该值进行随机变化 ForceTarget：效应器在目标对象上施加力的作用点 Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转） Rigidbody：以刚体的当前质心（不会产生扭矩力） Drag：阻力 Angular Drag：扭矩阻力 2.浮力效应器（Buoyancy）：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动 Density：流体密度，密度较大，碰撞体会下沉，密度越小碰撞体会上浮，密度和流体相同的碰撞体会浮在流体中 Surface Level：定义浮力流体的表面位置，对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移 Linear Drag：影响对象在水中移动的阻力系数 Angular Drag：影响对象在水中旋转的阻力系数 Flow Angle：流体流动方向相对世界控件的角度，沿指定方向施加浮力 Flow Magnitude：与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小 Flow Variation：随机改变流体力的值 3.点效应器：模拟磁铁 吸引或者排斥的效果 Force Magnitude：施加力的大小 Force Variation：施加力的大小变化 Distance Scale：效应器和目标之间举例的缩放。计算距离时，会按该比值对距离进行缩放 Force Source：力源来自哪个位置，从该点计算距离。 Collider：碰撞器的位置 Rigidbody：刚体的位置 Force Target：作用力目标位置，用改点计算位置 Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力 Rigidbody：刚体的位置，不会产生扭矩力 Force Mode：计算力的模式 Constant：忽略源和目标之间相隔的距离 Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小 Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力 4.平台效应器（Platform）：2D游戏当中的平台或可往上跳跃的墙壁 Rotational Offset：旋转偏移量，控制平台角度偏移 Use One Way：是否使用单向碰撞行为 Use One Way Grouping：当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为 Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞 Use Side Friction：是否应该在平台两侧使用摩擦 Use Side Bounce：是否应该在平台两侧使用弹性 Side Arc：用于定义左右两侧平台的响应弧度 5.表面效应器（Surface）：模拟传送带 Speed：表面保持的速度 Speed Variation：速度的随机增加值 Force Scale：缩放沿表面移动时施加的力。如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力 Use Contact Force：是否对接触物体表面的出点施加力，如果选择会让对象旋转，如果不开启则不会旋转 Use Friction：是否使用摩擦力 Use Bounce：是否使用弹力 2D 效应器 - Unity 手册 (unity3d.com) SpriteShape SpriteShape是精灵形状的意思（在Package Manager中导入相关工具），它主要是方便我们以节约美术资源为前提，制作2D游戏场景地形或者背景的。类型：开放不封闭的图形、封闭的图形； Sprite Shape Profile精灵形状概述文件Sprite Shape Profile精灵形状概述文件配置： Use Sprite Borders：是否使用精灵边框，用于九宫格拉伸 Texture：用于填充实心部分的纹理（使用的纹理的平铺模式必须是Repeat重复模式） Offset：纹理偏移量 Angle Ranges：角度范围（ 这里的设置主要用于封闭图形在不同角度范围内使用的图片不同，可以达到一个封闭效果） Start：起始角度 End：结束角度 Order：Sprite相交时的优先级，优先级高的显示在前面 Sprites：指定角度范围内的精灵列表，在该角度范围内，可以选择使用的图片资源 Corners：指定角显示的精灵图片，主要用于封闭图形，外部四个角用的图片，内部四个角用的图片 Sprite Shape Renderer和Sprite Shape Controller精灵形状渲染器和控制器Sprite Shape Renderer - Unity 手册 (unity3d.com) 参数相关： 1.Sprite Shape Renderer精灵形状渲染器：该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息 Color：颜色 Mask Interaction：遮罩相互作用规则设置 Fill Material和Edge Material：填充材质和边缘材质 Sorting Layer和Order in Layer：排序相关 2.Sprite Shape Controller精灵形状控制器： Profile：使用的精灵形状概述文件 Detail：精灵形状的质量（高中低三种质量） Is Open Ended：是否是开放的，不封闭的 Adaptive UV：自适应UV，如果开启，会自动帮助我们判断是平铺还是拉伸，开启后只有宽度够才会平铺，如果宽度不够会拉伸，不开启始终平铺，但是可能会出现裁剪效果，一般根据你的实际效果进行选择； Optimize Geometry：优化三角形数量，勾选后会最小化精灵图形中的三角形数量 Enable Tangents：是否启用切线计算功能（如果你的着色器中需要切线信息参与计算，则勾选） Corner Threshold：角阈值，当拐角处的角度达到这个阈值时将使用角图片 Stretch UV：是否拉伸UV，如果勾选纹理的UV将伸展到整个精灵形状的直线上 Pixel Per Unit：禁用拉伸UV时才有，Unity单位对应多少像素，较高的值会较少纹理的大小 Worldspace UV：根据世界控件的UV填充纹理 启用编辑状态后： Tangent Mode ：切线模式（从左至右依次是） 顶点模式-点两侧不构成曲线 切线模式-点两侧构成曲线，并且可以控制切线弧度 左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度 Position：选中点的局部坐标位置 Height：控制点左右两侧精灵图片的高度 Corner：是否使用角度图片 Disabled：不使用角度图片 Automatic：自动 Sprite Variant：选择使用的精灵图片 Snapping：是否开启捕捉设置控制点 Tilemap(过后再来学)动画基础Animation动画窗口面板左侧（说明）： 顶部从左至右： 1.预览模式（开关） 2.录制模式（开关）打开后预览模式默认开启 3.回到动画开头 4.上一关键帧（快捷键：键盘逗号） 5.播放动画（快捷键：键盘Alt+逗号） 6.下一关键帧（快捷键：键盘句号） 7.回到动画结尾（快捷键：键盘Alt+句号） 8.当前处于第几帧 底部Dopesheet：关键帧模式 底部Curves：曲线模式 中部从左至右： 按选择筛选 添加关键帧 添加事件 面板左侧（操作）： 多出一个可以选择当前动画的下拉列表：可以在这里创建新动画和切换动画 多出一个可以添加变化属性的按钮：在这里你可以任意添加你想要在动画中变化的脚本变量 面板右侧（说明）： 动画时间轴面板：当编辑动画时，会在该面板上编辑关键帧等信息 右侧面板（操控）： 时间轴可以拖动（注意）：时间轴上的单位为n秒n帧，一格代表一帧（并不是秒） 选择关键帧右键： Add Key：添加关键帧 Delete Key：删除关键帧 Clamped Auto：切线模式，自动设置切线 Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画 Free Smooth：自由设置切线 Flat：切线设置为水平 Broken：单独控制左右曲线切线 Free：自由设置 Linear：直线 Constant：常量切换 Weighted：权重切换 使用 Animation 视图 - Unity 手册 (unity3d.com) Animation老动画组件 在创建动画之前为对象添加Animation组件之后再制作动画，这时制作出的动画和之前的动画格式是有区别的。Animation组件参数相关： Animation组件：默认播放的动画 Animations：该动画组件可以控制的所有动画 Play AutoMatically：是否一开始就自动播放默认动画 Animate Physics：动画是否与物理交互 Culling Type：决定什么时候不播放动画 Always Animate：始终播放 Based On Renderers：基于默认动画姿势剔除 老动画Animation文件参数相关： Default：读取设置得更高的默认重复模式 Once：播放一次就停止 Loop：从头到尾不停循环播放 PingPong：从头到尾从尾到头不停播放 ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同； 老Animation组件API 知识点一 代码控制播放 //1.播放动画 animation.Play(\"1\"); //2.淡入播放,自动产生过渡效果 //当你要播放的动画的开始状态 和当前的状态 不一样时 //就会产生过渡效果 animation.CrossFade(\"3\"); //3.前一个播完再播放下一个 animation.PlayQueued(\"2\"); animation.CrossFadeQueued(\"2\"); //4.停止播放所有动画 animation.Stop(); //5.是否在播放某个动画 if( animation.IsPlaying(\"1\") ) //6.播放模式设置 animation.wrapMode = WrapMode.Loop; //7.其它（了解即可，新动画系统中会详细讲解） //层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果） //设置层级 animation[\"1\"].layer = 1; //设置权重 animation[\"1\"].weight = 1; //混合模式 叠加还是混合 animation[\"1\"].blendMode = AnimationBlendMode.Additive; //设置混组相关骨骼信息 animation[\"\"].AddMixingTransform(); UnityEngine.Animation - Unity 脚本 API (unity3d.com) Animator动画控制器面板1.左侧面板 Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的 Parameters：参数页签，为动画状态机添加控制状态切换的参数 眼睛图标：显隐左侧面板 2.右侧面板： 网格化布局区域（主要用于编辑状态之前的切换关系）；1.窗口中的每一个矩形表示一个状态；2.窗口中的每一个箭头表示一个切换条件； 矩形说明： 默认三大矩形： 绿色Entry矩形：进入状态机流程 红色Exit矩形：退出状态机流程 Any State：任意状态，代表状态机中的任意状态 人为添加矩形： 橙色矩形：一开始的默认状态动画，和Entry相连，表示一开始播放的动画 灰色矩形：自己添加的某一种动作状态 Animator Controller - Unity 手册 (unity3d.com) Animator新动画组件Animator组件参数相关： Controller：对应的动画控制器（状态机） Avatar：对应的替身配置信息（之后讲解3D模型时详细讲解） Apply Root Motion：是否启用动画位移更新 UpdateMode：更新模式（一般不修改它）: Normal：正常更新 Animate Physics：物理更新 Unscaled Time：不受时间缩放影响； Culling Mode：裁剪剔除模式： Always Animate：始终播放动画，即使在屏幕外也不剔除； Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入； Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用； 新动画文件(.ani)界面参数: Loop Time：是否是循环动画（在动画结尾时重新开始） Loop Pose：无缝循环运动 Cycle Offset：循环动画在其他时间开始时的周期偏移 Animator组件API 知识点一 Animator中的API //我们用代码控制状态机切换主要使用的就是Animator提供给我们的API //我们知道一共有四种切换条件 int float bool trigger //所以对应的API也是和这四种类型有关系的 animator = this.GetComponent&lt;Animator&gt;(); //1.通过状态机条件切换动画 animator.SetFloat(\"条件名\", 1.2f); animator.SetInteger(\"条件名\", 5); animator.SetBool(\"条件名\", true); animator.SetTrigger(\"条件名\"); animator.GetFloat(\"条件名\"); animator.GetInteger(\"条件名\"); animator.GetBool(\"条件名\"); //2.直接切换动画 除非特殊情况 不然一般不使用 animator.Play(\"状态名\"); UnityEngine.Animator - Unity 脚本 API (unity3d.com) 2D动画序列帧动画骨骼动画-2DAnimation骨骼动画-Spine3D模型导入相关模型导出：在 Unity 外部创建资源（模型导出） - Unity 手册 Model模型页签Model模型页签说明 1.Scene场景相关设置： *Scale Factor：当模型中的比例不符合项目中的预期比例时，可以修改此值来改变该模型的全局比例Unity的物理系统希望游戏世界中的1米在导入模型文件中为1个单位； *Convert Units：启用可将模型文件中定义的模型比例转换为Unity的比例，不同的格式的比例如下，.fbx .max .jas = 0.01，.3ds = 0.1，.mb .ma .lxo .dxf .blend .dae = 1； Import BlendShapes：是否允许Unity随网格一起导入混合形状，当导入包含混合形状的网格时，将使用Skinned MeshRenderer组件（注意：1.导入混合形状发现需要在FBX文件中具有平滑组；2.如果想要导入具有法线的混合形状；把下方的Blend Shape Normals属性设置为Import，将使用FBX文件的发现，或者把下方的Blend Shape Normals属性设置为Calculate，Unity使用相同的逻辑来计算网格和混合形状上的法线）； Import Visibility：是否导入可见性，开启后可以从FBX文件中读取可见性属性。，比如模型动作里 有些动作是要隐藏模型形象的，开启后才会生效，一些3D建模软件对可见性属性不支持或者有限制，比如Maya和Blender就对可见性有限制，所以一般这个选项要根据你使用的建模软件决定（一般可以不勾选）； Import Cameras：是否导入摄像机； *Preserve Hierarchy：始终创建一个显示预制体根，通常在导入的时候，FBX会将模型中的空根节点进行优化去掉它，但是如果多个FBX文件中包含同一层级的空跟对象，可以勾选它来保留他们；主要作用是：比如有两个fbx文件，1包含骨骼和网格，2只包含骨骼动画。如果不启用它导入2，那么Unity将剥离根节点，会让层级不匹配让动画不能正常播放； Sort Hierarchy By Name：在层级窗口中根据名字排序子物体，如果不启用，会保留FBX文件中定义的层级顺序； 2.Meshes网格相关设置： *Mesh Compression-网格压缩，设置压缩比级减小网格的文件大小，提高压缩比会降低网格的精度，调整该参数可以优化游戏包的大小： Off：不使用压缩 Low：低压缩比 Medium：中等压缩比 High：高压缩比 *Read/Write Enabled：是否开启读写网格信息，如果开启，Unity将网格数据传给GPU后，在CPU中还会保留可寻址内存，意味着我们可以通过代码访问网格数据进行处理，如果不开启，Unity将网格数据传个GPU后，会将CPU中的可寻址内存中网格数据删除，我们无法再得到网格数据，开启时，会增加内存占用，关闭时，可以节约运行时内存使用量（何时开启？；1.需要在代码中读取或写入网格数据；2.需要运行时合并网格；3.需要使用网格碰撞器时；4.需要运行时使用NavMesh构建组件来烘焙NavMesh时）； Optimize Mesh-确定三角形在网格中列出的顺序以提高GPU性能： Nothing：无优化 Everything：对顶点以及多边形顶点索引进行重新排序 Polygon Order：仅对多边形重新排序 Vertex Order：仅对顶点重新排序 *Generate Colliders：生成碰撞器，启用后会自动附加网格碰撞器的情况下导入你的网格，建议不移动的环境几何体可以开启它，但是需要移动的几何体建议不要开启它； 3.Geometry几何体相关设置： *Keep Quads：保留四边形，启用后，Unity不会将4个顶点的多边形转为三角形，当使用曲面细分着色器时可能需要启用此选项，因为四边形的曲面周色漆比多边形的效率更高； *Weld Vertices：合并在空间中共享相同位置的顶点，前提是这些顶点总体上共享相同的属性（UV，法线，切线等等）（开启后相当于会通过减少网格的总数量来优化网格的顶点计数）；一般都开启，除非你想有意保留这些重复顶点，之后想通过代码去获取他们来进行处理； Index Format：网格索引缓冲区的大小（一般都选择16bits，Auto可以会默认选择16bits，只有在必要时使用32bit，16bits即通用又节约内存）； Legacy Blend Shape Normals：启用后会基于Smoothing Angle值来计算法线； Normals-定义如何计算法线： Import：从文件中导入法线，如果文件中不包含发现信息，将使用Calculate模式计算法线 Calculate：根据Normals Mode、Smoothness Source和Smoothing Angle属性来计算发现 None：不计算法线 Blend Shape Normal：定义如何为混合形状计算法线，只有当Legacy Blend Shape Normals禁用时出现 Normals Mode：计算法线的模式，只有当上方的Normals设置为Import和Calculate才会出现 Unweighted Legacy：2017.1版本之前计算法线的方式，如果是在该版本之前导入的所有FBX模型，默认设置为该模式 Unweighted：法线不加权重 Area Weighted：法线按照图面面积加权重 Angle Weighted：法线按照每个图面上的顶角加权重 Area And Angle Weighted：法线按照每个图面上的图面面积和顶角加权重，这是默认选项 Smoothness Source-如何确定平滑，哪些边应该平滑，哪些应该粗糙，只有当Legacy Blend Shape Normals 禁用时出现： Prefer Smoothing Groups：尽可能使用模型文件中的平滑组 From Smoothing Groups：仅使用模型文件中的平滑组 From Angle：使用Smoothing Angle值来确定哪些边应该是平滑的 None：不拆分硬边的任何顶点 Smoothing Angle：控制是否为硬边拆分顶点，通常，值越大，产生的顶点越少，仅当Normals设置为Calculate时才可用（注意：此设置仅用于非常光滑的或者非常复杂的模型，否则，最好在3D建模软件中手动平滑然后导入，始终建议建模的时候就做好，更加准确）； Tangents-定义如何导入或计算顶点切线，仅当Normals设置为Calculate或Import时，此属性才可用： Import：如果Normals设置为Import，则从FBX文件中导入顶点切线，如果网格没有切线，那么将无法使用法线贴图着色器 Calculate Legacy：使用旧版算法计算切线 Calculate Legacy With Split Tangents：使用旧版算法计算切线，并在UV图表上进行拆分。如果网格上的接缝碰坏了法线贴图光照，请使用此属性 Calculate Mikktspace：使用米克特空间计算切线 None：不导入顶点切线，网格没有切线，则无法使用法线贴图着色器 Swap UVs：在网格中交换UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项 Generate Lightmap UVs：为光照贴图创建第二个UV通道 Model 选项卡 - Unity 手册 (unity3d.com) Rig操纵骨骼页签Animation Type-动画类型说明: 1.None-不存在动画:主要用于一些环境静态模型 2.Humanoid-人形模型,一般情况下，有头和四肢（一个头两条腿两只手）为人形,人形模型需要使用Avatar化身系统,绑定人主要关节的映射关系: Avatar Definition：选择获取Avatar定义的位置 No Avatar：没有化身系统信息 Create From This Model：根据此模型创建Avatar化身信息 Copy from Other Avatar：指向另一个模型上设置的Avatar化身信息 Source：复制另一个具有相同骨架的Avatar化身信息以导入其动画剪辑,使用Copy From Other Avatar时才有 Configure...：打开Avatar化身配置,使用Create From This Model时才有 Skin Weights：设置影响单个顶点的最大骨骼数量 Standard（4 Bones）：使用最多4个骨骼来产生影响。默认值，处于对性能考虑，建议使用此设 Custom：设置自定义的最大骨骼数，选择后会出现下方的两个选项 Max Bones/Vertex：定义每个顶点的最大估个数，值越大性能消耗越大 Max Bone Weight：设置考虑骨骼权重的最低阈值，权重计算时将忽略小于此值的内容 Optimize Game Objects：在Avatar化身系统和Animator动画组件中删除和存储所导入角色的游戏对象骨骼层级信息。如果启用会出现下方的Extra Transforms to Expose选项。角色将使用Unity动画系统的内部骨架，可以提高动画角色的性能 Extra Transforms to Expose：要公开的骨骼层级，在下方打钩将公开该骨骼层级信息 放大镜：通过名称搜索对应骨骼信息 Toggle All：全选或者反选 Collapse All：全部折叠 Expand All：全部展开 3.Generic-通用模型，非人形模型,不是标准的人形模型，可以是任意形状，可能有8只腿两个头等等,这种模型主要需要设置骨骼根节点: Root Node：选择用于此Avatar的根节点的骨骼（仅当选择Create From This Model才会出现） 4.Legacy-旧版动画类型与Unity3.x及更早版本导入和使用动画一般不使用: Generation：动画导入方法 Don't Import：不导入动画 第2~4个选项：已禁用，勿使用 Store in Root（New）：导入动画将其存储在模型的根节点中 Avatar设置说明： 1.Mapping设置-我们需要在这个页签对模型关节进行映射设置，因为人物动画无非就是改变这些关节的角度： 部位设置：身体，头部，左右手，关节映射信息设置 Mapping选项： Clear：清空映射 AutoMap：自动映射 Load：从文件中读取 Save：保存映射信息 Pose选项： Reset：重置姿势 Sample Bind-Pose：绑定姿势示例 Enforce T-Pose：强制T姿势 2.Muscles&amp;Settings设置： Muscle Group Preview-肌肉群预览：可以在这里预览在不同姿势的旋转变化，用来观察之前的关联映射关系是否合理，主要起到预览作用； Per-Muscle Settings-肌肉设置：，用于设置各骨骼在旋转时的范围限制，因为如果不设置限制，在一些极限角度时会非常奇怪，我们可以在这里单独设置限制范围； Additional Settings-高级设置：可以设置手脚的扭转和伸展值，一般不会修改他们，其中Translation DoF比较重要，如果启用，将启用人形角色的移动动画，如果禁用，Unity仅使用旋转对骨骼进行动画化，但是启用后，会提升性能消耗，因为动画需要执行额外步骤来重定向人形动画，除非动画包含角色某些骨骼的动画式移动才会启用，一般情况下禁用即可； Rig 选项卡 - Unity 手册 (unity3d.com) Animation动画页签1.如何导入外部创建的模型资源：在 Unity 外部创建资源 - Unity 手册 2.使用多个模型文件来导入动画：提取动画剪辑 - Unity 手册 动画基础信息设置Import Constraints-从此资源导入约束：启用后，Unity会自动添加相应的约束组件将其关联到正确的游戏对象 Import Animation-从此资源导入动画：如果禁用，下面的都没有，并且不会导入任何动画； Bake Animations：通过反向动力学（IK）或模拟创建的动画以便推进运动关键帧，仅用于Maya、3Dmax和Cinema4D文件 Anim.Compression：导入动画时使用的压缩类型 Off：禁用动画压缩，在导入时Unity不会减少关键帧数量，效果最好性能较低，文件较大，运行时内存占用也大。通常不建议使用 Keyframe Reduction：减少冗余关键帧，仅适用于Generic通用动画类型 Keyframe Reduction and Compression：减少关键帧并在文件中存储动画时压缩关键帧，会影响文件大小，但是内存大小和Keyframe Reduction相同，仅适用于Legacy旧版动画类型 Optimal：让Unity决定如何压缩，仅适用Generic通用和Humanoid人形动画类型 Rotation Error：设置旋转曲线压缩容错度（百分比），原始旋转值和减小值之间的最小角度 Position Error：设置位置曲线压缩容错度（百分比） Scale Error：设置缩放曲线压缩容错度（百分比） （如果原始值和消减值之间的差小于原始值乘以容错百分比，会删除关键帧）这些内容仅在Keyframe Reduction或Optimal压缩时可用； Animated Custom Properties：导入你指定为自定义用户属性的任何FBX属性 动画剪辑选择列表：在这里我们可以看到所有的动画剪辑可以通过+或-来新增剪辑或者删除所选的剪辑，在这里选择一个动画剪辑后，我们可以在下方编辑具体的相关属性信息 动画剪辑属性基本设置动画剪辑属性: 1.动画剪辑名称:可编辑修改 2.时间轴:Start动画剪辑的开始帧,End动画剪辑的结束帧,我们可以在时间轴中定义每个动画剪辑的帧范围; 3.动画重要信心设置: Loop Time：播放动画剪辑时是否循环播放，到结尾时重新开始 Loop Pose：无缝循环运动 Loop Match：循环匹配 Cycle Offset：循环动画在其他时间开始时的周期偏移 Root Transform Rotation：根位置的角度相关 Bake Into Pose：将根旋转烘焙到骨骼移动，禁用此选项将存储为根运动 Based Upon：根旋转的基础 Original：保持源文件中的原始旋转 Root Node Rotation：使用根节点的旋转（仅适用Generic通用动画类型） Body Orientation：保持上半身朝前（仅适用于Humanoid人形动画类型） Offset：根旋转偏移（单位：度） Root Transform Position（Y）：根垂直位置（Y轴方向） Bake Into Pose：将垂直根运动烘焙到骨骼移动。禁用此选项将会存储为根运动 Based Upon（at Start）：垂直方向根位置的基础 Original：保持源文件中的垂直位置 Root Node Position：使用垂直根位置（仅适用Generic通用动画类型） Center Of Mass：保持质心与根位置对其（仅适用Humanoid人形动画类型） Feet（推荐）：保持双脚与根变换位置对齐（仅适用Humanoid人形动画类型） Offset：垂直根位置偏移 Root Transform Position（XZ）：根水平位置（XZ平面） Bake Into Pose：将水平根运动烘焙到骨骼移动。禁用此选项将会存储为根运动 Based Upon：水平根位置的基础 Original：保持源文件中的水平位置 Root Node Position：使用水平根位置（仅适用Generic通用动画类型） Center Of Mass：保持与根位置对其（仅适用Humanoid人形动画类型） Mirror：在此剪辑中进行左右镜像（仅Humanoid人形动画类型才显示） Additive Reference Pose：启用后可以设置附加动画层基础参考姿势的帧。在时间轴中可以看到蓝色标记，附加动画层：在动画控制器（状态机）中可以添加新的动画层： Pose Frame：当启用参考姿势帧时，该项就是选择的具体是哪一帧 动画剪辑属性其它设置其它设置说明: 1.Curves:曲线可以配合Animator作为参数，通过加入曲线值可以利用他标记重要的点,可以修改曲线的名字，名字就类似参数名,可以通过加减来添加或删除曲线信息;(曲线中的值X轴代表标准化时（0~1）代表动画的开始和结尾;Y轴的值可以根据需求自己设置也可以使用下方提供的预设曲线) 2.Events动画事件(不推荐延迟严重):类似之前我们学习的Animation窗口中的动画事件可以在这里为动画剪辑添加一个事件，当动画播放到事件处时会自动找对象脚本中的同名函数,当我们希望在动画某一时刻进行逻辑处理时非常常用,比如某一时刻进行伤害判断 3.Mask动画遮罩:主要作用是当播放该动画时，可以指定哪一部分或者哪些骨骼排除在外不受动作影响,Humanoid（人形动画的快捷设置）,我们分别可以控制,头、左右臂、左右手、左右腿、根等,点击他们让他们变成红色，就代表做该动作时不影响该部位,Transform（明确指定哪些骨骼关节点不受影响） 4.Motion:当导入的动画剪辑包含根运动时,我们可以在这里手动设置特定骨骼关节点作为我们的根运动节点,展开后看到的都是骨骼关节节点 5.Inport Messages:当我们导入动画出现问题，看到黄色的警告符号时,你可以将 Generate Retargeting Quality Report 选中,Unity会帮我们生成更多的有关重定向问题的具体信息,我们便可以看到具体的一些问题(只有看到警告动画不正确时才启用，可以帮助我们排查问题); Animation 选项卡 - Unity 手册 (unity3d.com) Materials材质纹理页签材质纹理页签说明： Material Creation Mode-定义希望Unity如何为模型生成或导入材质： None：不使用此模型中嵌入的任何材质，改用Unity的默认漫反射材质 Standard：导入时，Unity使用默认规则来生成材质 Import via MaterialDescription（Experimental）：导入时，Unity使用FBX文件中嵌入的材质描述来生成材质；（与Standard相比，该方法结果更准确，并且支持更广泛的材质类型。） sRGB Albedo Colors：是否在伽马空间中使用反射率颜色，对于使用线性颜色控件的项目，禁用此选项； Location：定义如何访问材质和纹理 Use Embedded Materials：将导入的材质保持在导入的资源中 Use External Materials（Legacy）：将导入的材质提取为外部资源。旧版材质处理方式，适用于2017.1或更早的Unity版本创建的项目 Extract Textures/Materials：当选择Use Embedded Materials后会出现的内容。这两个按钮可以提取导入的资源中嵌入的所有材质和纹理。 Naming：定义材质的命名规则 By Base Texture Name：使用导入材质的漫反射纹理名称来命名材质。如果未将漫反射纹理分配给材质，Unity将使用导入材质的名称 From Model's Material：使用导入材质的名称来命名材质 Model Name + Model's Material：使用模型文件的名称与导入材质的名称相结合来命名材质 Search：定义在使用Naming选项定义的名称时查找现有材质的位置规则 Local Materials Folder：在本地Materials材质子文件夹（模型文件所在的同一文件夹）中查找现有材质 Recursive-Up：在所有父文件夹（一直向上追溯到Assets文件夹）中所有Materials子文件夹中查找现有材质 Project-Wide：在所有Unity项目文件夹中查找现有材质 重新映射的材质:如果找到了，Unity会自动关联,如果没有找到，我们可以手动进行关联; Materials 选项卡 - Unity 手册 (unity3d.com) 3D动画Animator Controller - Unity 手册 (unity3d.com) 3D动画使用状态参数状态参数说明 Motion：分配给此状态的动画剪辑 Speed：动画的默认速度 Multiplier：控制速度的乘数，如果要使用需要勾选的Parameter选中配合的参数float类型 Motion Time：运动的时间，如果要使用需要勾选的Parameter选中配合的参数float类型 Mirror：是否为状态生成镜像，仅适用于人形动画，如果要配合参数使用选中旁边的Parameter关联参数，参数是bool类型 Cycle Offset：循环偏移时间，如果要配合参数使用选中旁边的Parameter关联参数，参数是float类型 Foot IK：是否遵循Foot IK，适用于人形人形动画 Write Defaults：AnimatorStates 是否为其运动执行未动画化的属性写回默认值。 Solo：仅播放该过渡 Mute：禁用过渡 Solo和Mute如果一起选择，Mute优先执行 Add Behaviour：添加状态机行为脚本，之后会专门讲解 连线参数连线参数 改名框：可以在这里为动画过渡改名，如果不改，对应的名字就是，\"某一状态名\"-&gt;\"某一状态名\"； Has Exit Time：是否有退出时间，如果勾选，当切换动画时，动画一定是播放到下方的Exit Time（百分比）的时间时才过渡到下一个动画 Exit Time：退出时间，当选择上方的Has Exit Time时，该值决定了过渡生效的确切时间。该值可以大于1，如果小于1，比如0.85，表示当动画播放到了85%的动画时，就会过渡。如果大于1，比如4.5，那么动画将循环4.5次后过渡到下一个动画 Fixed Duration：选中后，下方的Trnaition Duration过渡持续时间将以秒为单位解读过渡时间，如果不选中，则以百分比解读过渡时间 Transition Duration(s/%)：过渡持续时间，相当于从该状态切换到下一状态的过渡动画持续的时间，对应下方两个蓝色箭头包裹区域 Transition Offset：过渡到目标状态的起始播放的时间偏移。如果是0则从目标状态开头开始播放，如果是0.5则从目标状态的一半开始播放，你可以理解为切入下一个状态的切入点； Interruption Source：该过渡中断的情况 None：不在添加任何过渡 Current State：将当前状态过渡排队 Next State：使下一个状态的过渡进行排队 Current State Then Next State：将当前状态的过渡和下一个状态的过渡都依次排队 Next State Thne Current State：将下一状态的过渡和当前状态的过渡依次排队 Ordered Interruption：当前过渡是否可在不考虑顺序的情况下被其它过渡中断 选中时，找到有效过渡或当前过渡时，会中断 不选中时，找到有效过渡，会中断 Conditions：过渡条件（如果没有过渡条件，只会考虑Exit Time） AnyState和动作之间连线 Can Transition To self：是否可以过渡到自己 Preview source state：预览各种过渡状态，可以查看从任意状态切换到当前状态的过渡效果； 动画分层和遮罩动画分层设置： Weight：权重，当动画同时播放时，如果选择的是叠加状态，会根据权重决定叠加的比例 Mask：动画遮罩，该层动画全部都会受该遮罩的影响 Blending：混合方式 Override：覆盖方式，播放该层动画时忽略其他层信息 Additive：叠加方式，会和其它层动画叠加播放 Sync：是否同步其它层，主要用于直接从另一个层复制状态过来，在该层中进行修改，适用于比如正常状态下有待机走路跑步等等动作，但是受伤状态下动作会改变，可以利用同步层方便我们进行编辑（选择后会多一个Source Layer表示你要复制哪一层的状态） Timing：当选中Sync同步其它层时，该参数激活，选中，会采用折中方案调整同步层上的动画时长（基于权重计算），不选中，动画时长将使用原始层做为母版 IK Pass：反向动力学，之后讲解IK的时候再讲解 动画混合1.2D Simple Directional 2D简单定向模式 运动表示不同方向时使用 比如向前、后、左、右走；2.2D Freeform Directional 2D自由形式定向模式 同上 运动表示不同方向时使用 但是可以在同一方向上有多个运动 比如向前跑和走；3.2D Freeform Cartesian 2D自由形式笛卡尔坐标模式 运动不表示不同方向时使用 比如向前走不拐弯 向前跑不拐弯 向前走右转 向前跑右转；4.Direct直接模式 自由控制每个节点权重，一般做表情动作等；5.1D混合是用一个参数控制动画的混合，之所以叫1D是因为一个参数可以看做是1维线性的； 动画IK控制知识点一 什么是IK？ //在骨骼动画中，构建骨骼的方法被称为正向动力学 //它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变 //用我们人体举例子 //当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子 //而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思 //它和正向动力学恰恰相反 //它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转 //用我们人体举例子 //当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动 //用父子骨骼理解的话就是子带动了父 知识点二 如何进行IK控制 //1.在状态机的层级设置中 开启 IK 通道 //2.继承MonoBehavior的类中 // Unity定义了一个IK回调函数:OnAnimatorIK // 我们可以在该函数中调用Unity提供的IK相关API来控制IK //3.Animator中的IK相关API //头部IK相关 //weight:LookAt全局权重0~1 //bodyWeight:LookAt时身体的权重0~1 //headWeight:LookAt时头部的权重0~1 //eyesWeight:LookAt时眼镜的权重0~1 //clampWeight:0表示角色运动时不受限制，1表示角色完全固定无法执行LookAt，0.5表示只能够移动范围的一半 SetLookAtWeight 设置头部IK权重 SetLookAtPosition 设置头部IK看向位置 SetIKPositionWeight 设置IK位置权重 SetIKRotationWeight 设置IK旋转权重 SetIKPosition 设置IK对应的位置 SetIKRotation 设置IK对应的角度 AvatarIKGoal枚举 四肢末端IK枚举 知识点三 关于OnAnimatorIK和OnAnimatorMove两个函数的理解 //我们可以简单理解这两个函数是两个和动画相关的特殊生命周期函数 //他们在Update之后LateUpdate之前调用 //他们会在每帧的状态机和动画处理完后调用 OnAnimatorIK在OnAnimatorMove之前调用 OnAnimatorIK中主要处理 IK运动相关逻辑 OnAnimatorMove主要处理 动画移动以修改根运动的回调逻辑 //他们存在的目的只是多了一个调用时机，当每帧的动画和状态机逻辑处理完后再调用 动画目标匹配知识点一 什么是动画目标匹配 //动画目标匹配主要指的是 //当游戏中角色要以某种动作移动，该动作播放完毕后，人物的手或者脚必须落在某一个地方 //比如：角色需要跳过踏脚石或者跳跃并抓住房梁 //那么这时我们就需要动作目标匹配来达到想要的效果 知识点二 如何实现动画目标匹配 //Unity中的Animator提供了对应的函数来完成该功能 //使用步骤是 //1.找到动作关键点位置信息（比如起跳点，落地点，简单理解就是真正可能产生位移的动画表现部分） //2.将关键信息传入MatchTargetAPI中 //参数一：目标位置 //参数二：目标角度 //参数三：匹配的骨骼位置 //参数四：位置角度权重 //参数五：开始位移动作的百分比 //参数六：结束位移动作的百分比 animator.MatchTarget(targetPos.position, targetPos.rotation, AvatarTarget.RightFoot, new MatchTargetWeightMask(Vector3.one, 1), 0.4f, 0.64f); 知识点三 注意 //调用匹配动画的时机有一些限制 //1.必须保证动画已经切换到了目标动画上 //2.必须保证调用时动画并不是处于过度阶段而真正在播放目标动画 //如果发现匹配不正确，往往都是这两个原因造成的 //3.需要开启Apply Root Motion 状态机行为脚本识点一 状态机行为脚本是什么？ //状态机行为脚本时一类特殊的脚本,继承指定的基类 //它主要用于关联到状态机中的状态矩形上 //我们可以按照一定规则编写脚本 //当进入、退出、保持在某一个特定状态时我们可以进行一些逻辑处理 //简单解释就是为Animator Controller状态机窗口中的某一个状态添加一个脚本 //利用这个脚本我们可以做一些特殊功能 //比如 //1.进入或退出某一状态时播放声音 //2.仅在某些状态下检测一些逻辑，比如是否接触地面等等 //3.激活和控制某些状态相关的特效 知识点二 如何使用状态机脚本 //1.新建一个脚本继承StateMachineBehaviour基类 //2.实现其中的特定方法进行状态行为监听 // OnStateEnter 进入状态时，第一个Update中调用 // OnStateExit 退出状态时，最后一个Update中调用 // OnStateIK OnAnimatorIK后调用 // OnStateMove OnAnimatorMove后调用 // OnStateUpdate 除第一帧和最后一帧，每个Update上调用 // OnStateMachineEnter 子状态机进入时调用，第一个Update中调用 // OnStateMachineExit 子状态机退出时调用，最后一个Update中调用 角色控制器知识点一· 角色控制器的使用 //关键参数 //是否接触了地面 if ( cc.isGrounded ) //关键方法 //受重力作用的移动 cc.SimpleMove(Vector3.forward * 10 * Time.deltaTime); //不受重力作用的移动 cc.Move(Vector3.forward * 10 * Time.deltaTime); //当角色控制器想要判断和别的碰撞器产生碰撞时 使用该函数 private void OnControllerColliderHit(ControllerColliderHit hit) { print(hit.collider.gameObject.name); } UnityEngine.CharacterController - Unity 脚本 API (unity3d.com) 导航寻路","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"}]},{"title":"Unity基础","slug":"03002-Unity基础","date":"2019-09-25T13:00:00.000Z","updated":"2022-03-03T07:46:31.422Z","comments":true,"path":"posts/1538.html","link":"","permalink":"https://wwy.wwywy.com/posts/1538.html","excerpt":"","text":"3D数学数学计算Mathf公共类Math：是C#中封装好的用于数学计算的工具)类) —— 位于System命名空间中；Mathf：是Unity中封装好的用于数学计算的工具)结构体) —— 位于UnityEngine命名空间中，Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法，使用Mathf中的方法用于Unity游戏开发中的数学计算即可； API 知识点三 Mathf中的常用方法——一般计算一次 //1.π - PI print(Mathf.PI); //2.取绝对值 - Abs print(Mathf.Abs(-10)); print(Mathf.Abs(-20)); print(Mathf.Abs(1)); //3.向上取整 - CeilToInt float f = 1.3f; int i = (int)f; print(i); print(Mathf.CeilToInt(f)); print(Mathf.CeilToInt(1.00001f)); //4.向下取整 - FloorToInt print(Mathf.FloorToInt(9.6f)); //5.钳制函数 - Clamp print(Mathf.Clamp(10, 11, 20)); print(Mathf.Clamp(21, 11, 20)); print(Mathf.Clamp(15, 11, 20)); //6.获取最大值 - Max print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8)); print(Mathf.Max(1, 2)); //7.获取最小值 - Min print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123)); print(Mathf.Min(1.1f, 0.4f)); //8.一个数的n次幂 - Pow print(\"一个数的n次方\" + Mathf.Pow(4, 2)); print(\"一个数的n次方\" + Mathf.Pow(2, 3)); //9.四舍五入 - RoundToInt print(\"四舍五入\" + Mathf.RoundToInt(1.3f)); print(\"四舍五入\" + Mathf.RoundToInt(1.5f)); //10.返回一个数的平方根 - Sqrt print(\"返回一个数的平方根\" + Mathf.Sqrt(4)); print(\"返回一个数的平方根\" + Mathf.Sqrt(16)); print(\"返回一个数的平方根\" + Mathf.Sqrt(64)); //11.判断一个数是否是2的n次方 - IsPowerOfTwo print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(4)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(8)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(3)); print(\"判断一个数是否是2的n次方\" + Mathf.IsPowerOfTwo(1)); //12.判断正负数 - Sign print(\"判断正负数\" + Mathf.Sign(0)); print(\"判断正负数\" + Mathf.Sign(10)); print(\"判断正负数\" + Mathf.Sign(-10)); print(\"判断正负数\" + Mathf.Sign(3)); print(\"判断正负数\" + Mathf.Sign(-2)); 知识点四 Mathf中的常用方法——一般不停计算 //插值运算 - Lerp //Lerp函数公式 result = Mathf.Lerp(start, end, t); //t为插值系数，取值范围为 0~1 result = start + (end - start)*t //插值运算用法一 //每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置 start = Mathf.Lerp(start, 10, Time.deltaTime); //插值运算用法二 //每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果 time += Time.deltaTime; result = Mathf.Lerp(start, 10, time); UnityEngine.Mathf - Unity 脚本 API (unity3d.com) 三角函数1.角度和弧度都是度量角的单位：角度：1°弧度：1 radian圆一周的角度：360°圆一周的弧度：2π radian 2.角度和弧度的转换关系：π rad = 180°1 rad = (180 / π)°=&gt; 1 rad = 180 / 3.14 ≈ 57.3°；1°= (π / 180) rad =&gt; 1°= 3.14 / 180 ≈ 0.01745 rad；由此可以得出弧度 * 57.3 = 对应角度角度 * 0.01745 = 对应弧 3.角度弧度相关API： 知识点一 弧度、角度相互转化 //弧度转角度 float rad = 1; float anger = rad * Mathf.Rad2Deg; //角度转弧度 anger = 1; rad = anger * Mathf.Deg2Rad; 知识点二 三角函数)可以让物体做曲线运动) //注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 知识点三 反三角函数 //注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 rad = Mathf.Asin(0.5f); print(rad * Mathf.Rad2Deg); rad = Mathf.Acos(0.5f); print(rad * Mathf.Rad2Deg); 坐标系说明1.世界坐标系：原点：世界的中心点轴向：世界坐标系的三个轴向是固定的 2.物体坐标系：原点：物体的中心点)建模时决定)轴向：物体右方为x轴正方向物体上方为y轴正方向物体前方为z轴正方向 3.屏幕坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向最大宽高：Screen.widthScreen.height 4.视口坐标系：原点：屏幕左下角轴向：向右为x轴正方向向上为y轴正方向特点：左下角为)0,0)右上角为)1,1)和屏幕坐标类似，将坐标单位化 汇总 知识点一 世界坐标系 //目前学习的和世界坐标系相关的 //this.transform.position; //this.transform.rotation; //this.transform.eulerAngles; //this.transform.lossyScale(全局缩放大小，只能得); //修改他们 会是相对世界坐标系的变化 知识点二 物体坐标系 //相对父对象的物体坐标系的位置 本地坐标 相对坐标 //this.transform.localPosition; //this.transform.localEulerAngles; //this.transform.localRotation; //this.transform.localScale; //修改他们 会是相对父对象物体坐标系的变化 知识点三 屏幕坐标系 //Input.mousePosition //Screen.width; //Screen.height; 知识点四 视口坐标系 //摄像机上的 视口范围 坐标转换相关 //世界转本地 //this.transform.InverseTransformDirection //this.transform.InverseTransformPoint //this.transform.InverseTransformVector //本地转世界 //this.transform.TransformDirection //this.transform.TransformPoint //this.transform.TransformVector //世界转屏幕 //Camera.main.WorldToScreenPoint //屏幕转世界 //Camera.main.ScreenToWorldPoint //世界转视口 //Camera.main.WorldToViewportPoint //视口转世界 //Camera.main.ViewportToWorldPoint //视口转屏幕 //Camera.main.ViewportToScreenPoint //屏幕转视口 //Camera.main.ScreenToViewportPoint; Vector3向量UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 向量模长和单位向量1.标量：有数值大小，没有方向 2.向量：有数值大小，有方向的矢量 3.两点决定一向量：A点：(Xa,Ya,Za)B点：(Xb,Yb,Zb)从A指向B的向量为AB向量B-A = (Xb-Xa, Yb-Ya, Zb-Za)从B指向A的向量为BA向量A-B = (Xa-Xb, Ya-Yb, Za-Zb)口诀：终点减起点 4.零向量和负向量：零向量(0,0,0)零向量是唯一一个大小为0的向量负向量(x,y,z)的负向量为(-x,-y,-z)负向量和原向量大小相等负向量和原向量方向相反 5.向量的模长：向量的模长就是向量的长度向量是由两个点算出，所以向量的模长就是两个点的距离模长公式：A向量(x,y,z)模长 = √x² + y² + z² 6.单位向量：模长为1的向量为单位向量任意一个向量经过归一化就是单位向量只需要方向，不想让模长影响计算结果时使用单位向量归一化公式：A向量(x,y,z)模长 = √x² + y² + z²单位向量 = (x/模长, y/模长, z/模长) 7.向量模长和单位向量相关API： 知识点一 向量 //三维向量 - Vector3 //Vector3有两种几何意义 //1.位置 —— 代表一个点 print(this.transform.position); //2.方向 —— 代表一个方向 print(this.transform.forward); print(this.transform.up); Vector3 v = new Vector3(1, 2, 3); Vector2 v2 = new Vector2(1, 2); 知识点二 两点决定一向量 //A和B此时 几何意义 是两个点 Vector3 A = new Vector3(1, 2, 3); Vector3 B = new Vector3(5, 1, 5); //求向量 //此时 AB和 BA 他们的几何意义 是两个向量 Vector3 AB = B - A; Vector3 BA = A - B; 知识点三 零向量和负向量 print(Vector3.zero); print(Vector3.forward); print(-Vector3.forward); 知识点四 向量的模长 //Vector3中提供了获取向量模长的成员属性 //magnitude print(AB.magnitude); Vector3 C = new Vector3(5, 6, 7); print(C.magnitude); print(Vector3.Distance(A, B)); 知识点五 单位向量 //Vector3中提供了获取单位向量的成员属性 //normalized print(AB.normalized); print(AB / AB.magnitude); 总结 //模长相当于可以得到 两点之间的距离 单位向量 主要是用来进行移动计算的 它不会影响我们想要的移动效果 向量加减乘除1.向量加法：向量A + 向量B = (Xa + Xb, Ya + Yb)；位置+位置：两个位置相加没有任何几何意义向量+向量：两个向量相加得到一个新向量；向量 + 向量 = 向量)向量相加，首尾相连)位置+向量：位置加向量得到一个新位置；位置 + 向量 = 位置；向量 + 位置 = 位置)位置和向量相加=平移位置) 2.向量减法向量A - 向量B = (Xa - Xb, Ya - Yb, Za);位置-位置：两个位置相减得到一个新向量；位置 - 位置 = 向量)两点决定一向量，终点 - 起点)；向量-向量：两个向量相减得到一个新向量；向量 - 向量 = 向量)向量相减，头连头，尾指尾，A - B = B头指A头)；位置-向量：位置减向量相当于 加负向量；位置 + (-向量)=位置)位置减向量 = 平移位置)；向量-位置：向量减位置没有任何几何意义 3.向量乘除向量只会和标量进行乘除法运算向量A标量a = (xa, ya, za);向量A/标量a = (x/a, y/a, z/a);向量 *or/ 标量 = 向量;向量 *or/ 正数，方向不变，放大缩小模长;向量 *or/ 负数，方向相反，放大缩小模长;向量 * 0，得到零向量; 4.知识点： 知识点一 向量加法 //this.transform.position += new Vector3(1, 2, 3); this.transform.Translate(Vector3.forward * 5); 知识点二 向量减法 //this.transform.position -= new Vector3(1, 2, 3); this.transform.Translate(-Vector3.forward * 5); 知识点三 向量乘除标量 this.transform.localScale *= 2; this.transform.localScale /= 2; 向量点乘1.点乘计算公式：向量A·向量B = XaXb + YaYb + Za*Zb=标量；点乘可以得到一个向量：在自己向量上投影的长度)我们可以用这个规律判断敌方的大致方位)；点乘结果 &gt; 0 两个向量夹角为锐角；点乘结果 = 0 两个向量夹角为直角；点乘结果 &lt; 0 两个向量夹角为钝； 2.公式推导：Cosβ = 直角边 / 单位向量B模长直角边 = Cosβ * 单位向量B模长)直角边 = 单位向量A · 单位向量B);↓Cosβ * 单位向量B模长 = 单位向量A · 单位向量B;↓Cosβ = 单位向量A · 单位向量B;↓推出结果：β = Acos(单位向量A · 单位向量B); 3.点乘API 知识点一 通过点乘判断对象方位)判断前后) //Vector3 提供了计算点乘的方法 Debug.DrawRay(this.transform.position, this.transform.forward, Color.red); Debug.DrawRay(this.transform.position, target.position - this.transform.position, Color.red); //得到两个向量的点乘结果 //向量 a 点乘 AB 的结果 float dotResult = Vector3.Dot(this.transform.forward, target.position - this.transform.position); if( dotResult &gt;= 0 ) { print(\"它在我前方\"); } else { print(\"它在我后方\"); } 知识点二 通过点乘推导公式算出夹角)判断夹角，但是夹角为0-180之间，不能判断左右) //步骤 //1.用单位向量算出点乘结果 dotResult = Vector3.Dot(this.transform.forward, (target.position - this.transform.position).normalized); //2.用反三角函数得出角度 print(\"角度-\" + Mathf.Acos(dotResult) * Mathf.Rad2Deg); //Vector3中提供了 得到两个向量之间夹角的方法 print(\"角度2-\" + Vector3.Angle(this.transform.forward, target.position - this.transform.position)); 向量叉乘1.叉乘计算公式：向量A x 向量B = (YaZb - ZaYb,ZaXb - XaZb,XaYb - YaX)=向量； 2.几何意义A x B 得到的向量同时垂直A和B；A x B 向量垂直于A和B组成的平面；A x B = -(B x A)； 3.叉乘API 知识点一 叉乘计算 print(Vector3.Cross(A.position, B.position)); 知识点二 叉乘几何意义 //假设向量 A和B 都在 XZ平面上 //向量A 叉乘 向量 B //y大于0 证明 B在A右侧 //y小于0 证明 B在A左侧 Vector3 C = Vector3.Cross(A.position, B.position); if( C.y &gt; 0) { print(\"B在A的右侧\"); } else { print(\"B在A的左侧\"); } 向量插值运算插值API: 知识点一 线性插值 //公式result = start + (end - start) * t //1.先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置 A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); //2.匀速 每帧改变时间 当t&gt;=1时 得到结果 //这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 //应该相当于Vector3.MoveToWards() if(nowTarget != target.position) { nowTarget = target.position; time = 0; startPos = B.position; } time += Time.deltaTime; B.position = Vector3.Lerp(startPos, nowTarget, time); 知识点二 球形插值 //做弧线运动，可以做弓箭射击，太阳东升西落 C.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up*0.1f, time*0.01f); Quaternion四元数UnityEngine.Quaternion - Unity 脚本 API (unity3d.com) 为什么使用四元数1.欧拉角)transform.eulerAngles)：由三个角度(x,y,z)组成，遵守heading-pitch-bank旋转序列约定)heading:物体绕自身的对象坐标系的Y轴，旋转的角度；pitch:物体绕自身的对象坐标系的X轴，旋转的角度；bank:物体绕自身的对象坐标系的Z轴，旋转的角度)；1.1.优点：直观、易理解；存储空间小)三个数表示)；可以进行从一个方向到另一个方向旋转大于180度的角度；1.2缺点：同一旋转的表示不唯一；万向节死锁； 2.万向节死锁：当某个特定轴达到某个特殊值时，绕一个轴旋转可能会覆盖住另一个轴的旋转，从而失去一维自由度；Unity中X轴达到90度时，会产生万向节死锁； 四元数是什么1.轴-角对：在3D空间中，任意旋转都可以表示，绕着某个轴旋转一个旋转角得到； 2.四元数：对于给定旋转，假设为绕着n轴，旋转β度，n轴为(x,y,z)；四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z]； 3.四元数基本API 知识点一 四元数 Quaternion //四元数Q = [cos(β/2), sin(β/2)x, sin(β/2)y, sin(β/2)z] //计算原理 //Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); //提供的轴角对 初始化 四元数的方法 Quaternion q = Quaternion.AngleAxis(60, Vector3.right); 知识点二 四元数和欧拉角转换 //1.欧拉角转四元数 Quaternion q2 = Quaternion.Euler(60, 0, 0); GameObject obj2 = GameObject.CreatePrimitive(PrimitiveType.Cube); obj2.transform.rotation = q2; //2.四元数转欧拉角 print(q2.eulerAngles); 知识点三 四元数弥补的欧拉角缺点 //1.同一旋转的表示不唯一 四元数旋转后 转换后的欧拉角 始终是 -180~180度 //2.万向节死锁 通过四元数旋转对象可以避免万向节死锁 //必备知识点：四元数相乘代表旋转四元数 this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up); 四元数常用方法知识点一 单位四元数 print(Quaternion.identity); //testObj.rotation = Quaternion.identity; Instantiate(testObj, Vector3.zero, Quaternion.identity); 知识点二 插值运算 //在四元数中Lerp和Slerp只有一些细微差别 //由于算法不同,Slerp的效果会好一些 //Lerp的效果相比Slerp更快但是如果旋转范围较大效果较差,所以建议使用Slerp进行插值运算 //无限接近 先快后慢 A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime); //匀速变化 time&gt;=1到达目标 time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 识点三 LookRotation //Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position); //lookA.rotation = q; lookA.MyLookAt(lookB); 四元数计算知识点一 四元数相乘 //两个四元数相乘得到一个新的四元数,代表两个旋转量的叠加,相当于旋转(旋转相对的坐标系 是物体自身坐标系) Quaternion q = Quaternion.AngleAxis(20, Vector3.up); this.transform.rotation *= q; 知识点二 四元数乘向量 //四元数乘向量返回一个新向量,可以将指定向量旋转对应四元数的旋转量,相当于直接旋转向量 Vector3 v = Vector3.forward; v = Quaternion.AngleAxis(45, Vector3.up) * v; Mono重要内容延迟(延时)函数知识点一 什么是延迟函数 //延迟函数顾名思义 //就是会延时执行的函数 //我们可以自己设定延时要执行的函数和具体延时的时间 //是MonoBehaviour基类中实现好的方法 知识点二 延迟函数的使用 1.延迟函数 //Invoke //参数一：函数名 字符串 //参数二：延迟时间 秒为单位 Invoke(\"DelayDoSomething\", 1); //注意： //1-1.延时函数第一个参数传入的是函数名字符串 //1-2.延时函数没办法传入参数 只有包裹一层 //1-3.函数名必须是该脚本上申明的函数 2.延迟重复执行函数 //InvokeRepeating //参数一：函数名字符串 //参数二：第一次执行的延迟时间 //参数三：之后每次执行的间隔时间 InvokeRepeating(\"DelayRe\", 5, 1); //注意： //它的注意事项和延时函数一致 3.取消延迟函数 //3-1取消该脚本上的所有延时函数执行 CancelInvoke(); //3-2指定函数名取消 //只要取消了指定延迟 不管之前该函数开启了多少次 延迟执行 都会统一取消 CancelInvoke(\"DelayDoSomething\"); 4.判断是否有延迟函数 if( IsInvoking()) { print(\"存在延迟函数\"); } if( IsInvoking(\"DelayDoSomething\") ) { print(\"存在延迟函数DelayDoSomething\"); } 知识点三 延迟函数受对象失活销毁影响 //脚本依附对象失活 或者 脚本自己失活 //延迟函数可以继续执行 不会受到影响的 //脚本依附对象销毁或者脚本移除 //延迟函数无法继续执行 协同程序1.Unity支持多线程，只是新开线程无法访问主线程中Unity相关内容(注意：Unity中的多线程 要记住关闭);2.协同程序不是多线程，它是将线程中逻辑进行分时执行，避免卡顿,继承MonoBehavior的类都可以使用协程;3.协程只有当组件单独失活时不受影响，其它情况协程会停止4.API 知识点一 协程的使用 //继承MonoBehavior的类 都可以开启 协程函数 //第一步：申明协程函数 // 协程函数2个关键点 // 1-1返回值为IEnumerator类型及其子类 // 1-2函数中通过 yield return 返回值; 进行返回 //第二步：开启协程函数 //协程函数 是不能够 直接这样去执行的！！！！！！！ //这样执行没有任何效果 //MyCoroutine(1, \"123\"); //常用开启方式 //IEnumerator ie = MyCoroutine(1, \"123\"); //StartCoroutine(ie); Coroutine c1 = StartCoroutine( MyCoroutine(1, \"123\") ); Coroutine c2 = StartCoroutine( MyCoroutine(1, \"123\")); Coroutine c3 = StartCoroutine( MyCoroutine(1, \"123\")); //第三步：关闭协程 //关闭所有协程 //StopAllCoroutines(); //关闭指定协程 //StopCoroutine(c1); 知识点二 yield return 不同内容的含义 //1.下一帧执行 //yield return 数字; //yield return null; //在Update和LateUpdate之间执行 //2.等待指定秒后执行 //yield return new WaitForSeconds(秒); //在Update和LateUpdate之间执行 //3.等待下一个固定物理帧更新时执行 //yield return new WaitForFixedUpdate(); //在FixedUpdate和碰撞检测相关函数之后执行 //4.等待摄像机和GUI渲染完成后执行 //yield return new WaitForEndOfFrame(); //在LateUpdate之后的渲染相关处理完毕后之后 //5.一些特殊类型的对象 比如异步加载相关函数返回的对象 //之后讲解 异步加载资源 异步加载场景 网络加载时再讲解 //一般在Update和LateUpdate之间执行 //6.跳出协程 //yield break; 协同程序原理1.协程的本质 就是利用 C#的迭代器函数”分步执行”的特点+协程调度逻辑 实现的一套分时执行函数的规则; 2.代码实现： 知识点一 协程的本质 //协程可以分成两部分 //1.协程函数本体 //2.协程调度器 //协程本体就是一个能够中间暂停返回的函数 //协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数 //Unity只实现了协程调度部分 //协程的本体本质上就是一个 C#的迭代器方法 知识点二 协程本体是迭代器方法的体现 //1.协程函数本体 //如果我们不通过 开启协程方法执行协程 //Unity的协程调度器是不会帮助我们管理协程函数的 IEnumerator ie = Test(); //但是我们可以自己执行迭代器函数内容 ie.MoveNext();//会执行函数中内容遇到 yield return为止的逻辑 print(ie.Current);//得到 yield return 返回的内容 //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //print(ie.Current); //ie.MoveNext(); //TestClass tc = ie.Current as TestClass; //print(tc.time); //MoveNext 返回值 代表着 是否到了结尾)这个迭代器函数 是否执行完毕) //2.协程调度器 //继承MonoBehavior后 开启协程 //相当于是把一个协程函数)迭代器)放入Unity的协程调度器中帮助我们管理进行执行 //具体的yield return 后面的规则 也是Unity定义的一些规则 #Resources资源动态加载 Unity中的特殊文件夹知识点一 工程路径获取 //注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用 //我们不会在实际发布游戏后 还使用该路径 //游戏发布过后 该路径就不存在了 print(Application.dataPath); 知识点二 Resources 资源文件夹 //路径获取： //一般不获取 //只能使用Resources相关API进行加载 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Resources\"); //注意： //需要我们自己将创建 //作用： //资源文件夹 //1-1.需要通过Resources相关API动态加载的资源需要放在其中 //1-2.该文件夹下所有文件都会被打包出去 //1-3.打包时Unity会对其压缩加密 //1-4.该文件夹打包后只读 只能通过Resources相关API加载 知识点三 StreamingAssets 流动资源文件夹 //路径获取： print(Application.streamingAssetsPath); //注意： //需要我们自己将创建 //作用： //流文件夹 //2-1.打包出去不会被压缩加密，可以任由我们摆布 //2-2.移动平台只读，PC平台可读可写 //2-3.可以放入一些需要自定义动态加载的初始资源 知识点四 persistentDataPath 持久数据文件夹 //路径获取： print(Application.persistentDataPath); //注意： //不需要我们自己将创建 //作用： //固定数据文件夹 //3-1.所有平台都可读可写 //3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中 知识点五 Plugins 插件文件夹 //路径获取： //一般不获取 //注意： //需要我们自己将创建 //作用： //插件文件夹 //不同平台的插件相关文件放在其中 //比如IOS和Android平台 知识点六 Editor 编辑器文件夹 //路径获取： //一般不获取 //如果硬要获取 可以用工程路径拼接 print(Application.dataPath + \"/Editor\"); //注意： //需要我们自己将创建 //作用： //编辑器文件夹 //5-1.开发Unity编辑器时，编辑器相关脚本放在该文件夹中 //5-2.该文件夹中内容不会被打包出去 知识点七 默认资源文件夹 Standard Assets //路劲过去： //一般不获取 //注意： //需要我们自己将创建 //作用： //默认资源文件夹 //一般Unity自带资源都放在这个文件夹下 //代码和资源优先被编译 UnityEngine.Application - Unity 脚本 API (unity3d.com) Resources同步加载知识点一 常用资源类型 //1.预设体对象——GameObject)要实例化) //2.音效文件——AudioClip //3.文本文件——TextAsset //4.图片文件——Texture //5.其它类型——需要什么用什么类型 知识点二 资源同步加载 普通方法 //在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源 //打包时 Resources文件夹 里的内容 都会打包在一起 //1.预设体对象 想要创建在场景上 记住实例化 // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj = Resources.Load(\"Cube\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj); // 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中) Object obj2 = Resources.Load(\"Sphere\"); //第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化 Instantiate(obj2); //2.音效资源 //第一步：就是加载数据 Object obj3 = Resources.Load(\"Music/BKMusic\"); //第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可 audioS.clip = obj3 as AudioClip; audioS.Play(); //3.文本资源 //文本资源支持的格式 //.txt //.xml //.bytes //.json //.html //.csv //..... TextAsset ta = Resources.Load(\"Txt/Test\") as TextAsset; //文本内容 print(ta.text); //字节数据组 //print(ta.bytes); //4.图片 tex = Resources.Load(\"Tex/TestJPG\") as Texture; GUI.DrawTexture(new Rect(0, 0, 100, 100), tex);)(画出图片) //5.其它类型 需要什么类型 就用什么类型就行 //6.问题：资源同名怎么办 //Resources.Load加载同名资源时 无法准确加载出你想要的内容 //可以使用另外的API //6-1加载指定类型的资源 //tex = Resources.Load(\"Tex/TestJPG\", typeof(Texture)) as Texture; ta = Resources.Load(\"Tex/TestJPG\", typeof(TextAsset)) as TextAsset; //print(ta.text); //6-2加载指定名字的所有资源 Object[] objs = Resources.LoadAll(\"Tex/TestJPG\"); 知识点三 资源同步加载 泛型方法 TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(\"Tex/TestJPG\"); print(ta2.text); tex = Resources.Load&lt;Texture&gt;(\"Tex/TestJPG\"); Resources异步加载知识点一 Resources异步加载方法 //注意： //异步加载 不能马上得到加载的资源 至少要等一帧 //1.通过异步加载中的完成事件监听 使用加载的资源 //这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载 //ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); //马上进行一个 资源下载结束 的一个事件函数监听 //rq.completed += LoadOver; print(Time.frameCount); //这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的 //一定要等加载结束过后 才能使用 //rq.asset ×××××××××××× //2.通过协程 使用加载的资源 StartCoroutine(Load()); IEnumerator Load() { //迭代器函数 当遇到yield return时 就会 停止执行之后的代码 //然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时 ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(\"Tex/TestJPG\"); print(Time.frameCount); //第一部分 //Unity 自己知道 该返回值 意味着你在异步加载资源 //yield return rq; //Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码 print(Time.frameCount); //判断资源是否加载结束 while(!rq.isDone) { //打印当前的 加载进度 (0-1浮点型值) print(rq.progress); yield return null; } tex = rq.asset as Texture; } 总结： //1.完成事件监听异步加载 //好处：写法简单 //坏处：只能在资源加载结束后 进行处理 //“线性加载” //2.协程异步加载 //好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新 //坏处：写法稍麻烦 //“并行加载” //注意： //理解为什么异步加载不能马上加载结束，为什么至少要等1帧 //理解协程异步加载的原理 Resources卸载资源知识点一 Resources重复加载资源会浪费内存吗？ //其实Resources加载一次资源过后 //该资源就一直存放在内存中作为缓存 //第二次加载时发现缓存中存在该资源 //会直接取出来进行使用 //所以 多次重复加载不会浪费内存 //但是 会浪费性能)每次加载都会去查找取出，始终伴随一些性能消耗) 知识点二 如何手动释放掉缓存中的资源 //1.卸载指定资源 //Resources.UnloadAsset 方法 //注意： //该方法 不能释放 GameObject对象 因为它会用于实例化对象 //它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等 //一般情况下 我们很少单独使用它 //GameObject obj = Resources.Load&lt;GameObject&gt;(\"Cube\"); //即使是没有实例化的 GameObject对象也不能进行卸载 //Resources.UnloadAsset(obj); //2.卸载未使用的资源 //注意： //一般在过场景时和GC一起使用 Resources.UnloadUnusedAssets(); GC.Collect(); UnityEngine.Resources - Unity 脚本 API (unity3d.com) 场景切换 需要把要加载的场景Build Settings中。 知识点一 场景同步切换 //在切换场景时 //Unity会删除当前场景上所有对象 //并且去加载下一个场景的相关信息 //如果当前场景 对象过多或者下一个场景对象过多 //这个过程会非常的耗时 会让玩家感受到卡顿 SceneManager.LoadScene(\"Lesson20Test\"); 知识点二 场景异步切换 //场景异步加载和资源异步加载 几乎一致 有两种方式 //1.通过事件回调函数 异步加载 //AsyncOperation ao = SceneManager.LoadSceneAsync(\"Lesson20Test\"); //当场景异步加载结束后 就会自动调用该事件函数 我们如果希望在加载结束后 做一些事情 那么久可以在该函数中 //写处理逻辑 //ao.completed += (a) =&gt; //{ // print(\"加载结束\"); //}; //ao.completed += LoadOver; //2.通过协程异步加载 //需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了 //所以 协程中的部分逻辑 可能是执行不了的 //解决思路 //让处理场景加载的脚本依附的对象 过场景时 不被移除 //该脚本依附的对象 过场景时 不会被 移除 DontDestroyOnLoad(this.gameObject); StartCoroutine(LoadScene(\"Lesson20Test\")); IEnumerator LoadScene(string name) { //第一步 //异步加载场景 AsyncOperation ao = SceneManager.LoadSceneAsync(name); //Unity内部的 协程协调器 发现是异步加载类型的返回对象 那么就会等待 //等待异步加载结束后 才会继续执行 迭代器函数中后面的步骤 print(\"异步加载过程中 打印的信息\"); //协程的好处 是异步加载场景时 我可以在加载的同时 做一些别的逻辑 //yield return ao; //第二步 print(\"异步加载结束后 打印的信息\"); //比如 我们可以在异步加载过程中 去更新进度条 //第一种 就是利用 场景异步加载 的进度 去更新 但是 不是特别准确 一般也不会直接用 //while(!ao.isDone) //{ // print(ao.progress); // yield return null; //} //离开循环后 就会认为场景加载结束 //可以把进度条顶满 然后 隐藏进度条 //第二种 就是根据你游戏的规则 自己定义 进度条变化的条件 yield return ao; //场景加载结束 更新20%进度 //接着去加载场景中 的其它信息 //比如 //动态加载怪物 //这时 进度条 再更新20% //动态加载 场景模型 //这时 就认为 加载结束了 进度条顶满 //隐藏进度条 } SceneManagement.SceneManager - Unity 脚本 API (unity3d.com) 画线功能Linerenderer组件知识点一 LineRenderer是什么 //LineRenderer是Unity提供的一个用于画线的组件 //使用它我们可以在场景中绘制线段 //一般可以用于 //1绘制攻击范围 //2武器红外线 //3辅助功能 //4其它画线功能 知识点二ineRender代码相关 //动态添加一个线段 GameObject line = new GameObject(); line.name = \"Line\"; LineRenderer lineRenderer = line.AddComponent&lt;LineRenderer&gt;(); //首尾相连 lineRenderer.loop = true; //开始结束宽 lineRenderer.startWidth = 0.02f; lineRenderer.endWidth = 0.02f; //开始结束颜色 lineRenderer.startColor = Color.white; lineRenderer.endColor = Color.red; //设置材质 m = Resources.Load&lt;Material&gt;(\"M\"); lineRenderer.material = m; //设置点 //一定注意 设置点 要 先设置点的个数 lineRenderer.positionCount = 4; //接着就设置 对应每个点的位置 lineRenderer.SetPositions(new Vector3[] { new Vector3(0,0,0), new Vector3(0,0,5), new Vector3(5,0,5)}); lineRenderer.SetPosition(3, new Vector3(5, 0, 0)); //是否使用世界坐标系 //决定了 是否随对象移动而移动 lineRenderer.useWorldSpace = false; //让线段受光影响 会接受光数据 进行着色器计算 lineRenderer.generateLightingData = true; UnityEngine.LineRenderer - Unity 脚本 API (unity3d.com) 核心系统UnityEngine.Physics - Unity 脚本 API (unity3d.com) 物理系统之范围检测知识点二 如何进行范围检测 //必备条件：想要被范围检测到的对象 必须具备碰撞器 //注意点： //1.范围检测相关API 只有当执行该句代码时 进行一次范围检测 它是瞬时的 //2.范围检测相关API 并不会真正产生一个碰撞器 只是碰撞判断计算而已 //范围检测API //1.盒状范围检测 //参数一：立方体中心点 //参数二：立方体三边大小 //参数三：立方体角度 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) print(LayerMask.NameToLayer(\"UI\")); Collider[] colliders = Physics.OverlapBox( Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up), 1 &lt;&lt; LayerMask.NameToLayer(\"UI\") | 1 &lt;&lt; LayerMask.NameToLayer(\"Default\"), QueryTriggerInteraction.UseGlobal); //0000 0001 //0010 0000 //重要知识点： //关于层级 //通过名字得到层级编号 LayerMask.NameToLayer //我们需要通过编号左移构建二进制数 //这样每一个编号的层级 都是 对应位为1的2进制数 //我们通过 位运算 可以选择想要检测层级 //好处 一个int 就可以表示所有想要检测的层级信息 //层级编号是 0~31 刚好32位 //是一个int数 //每一个编号 代表的 都是二进制的一位 //0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1 //1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2 //2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4 //3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8 //4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16 //5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32 //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapBoxNonAlloc() if(Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) //2.球形范围检测 //参数一：中心点 //参数二：球半径 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer(\"Default\")); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapSphereNonAlloc if( Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0 ) //3.胶囊范围检测 //参数一：半圆一中心点 //参数二：半圆二中心点 //参数三：半圆半径 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：在该范围内的触发器)得到了对象触发器就可以得到对象的所有信息) colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer(\"UI\"), QueryTriggerInteraction.UseGlobal); //另一个API //返回值：碰撞到的碰撞器数量 //参数：传入一个数组进行存储 //Physics.OverlapCapsuleNonAlloc if ( Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders ) != 0 ) 物理系统之射线检测知识点一 射线对象 //1.3D世界中的射线 //假设有一条 //起点为坐标(1,0,0) //方向为世界坐标Z轴正方向的射线 //注意： //理解参数含义 //参数一：起点 //参数二：方向)一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量) //目前只是申明了一个射线对象 对于我们来说 没有任何的用处 Ray r = new Ray(Vector3.right, Vector3.forward); //Ray中的参数 print(r.origin);//起点 print(r.direction);//方向 //2.摄像机发射出的射线 // 得到一条从屏幕位置作为起点 // 摄像机视口方向为 方向的射线 Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition); 知识点三 碰撞检测函数 //Physics类中提供了很多进行射线检测的静态函数 //他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了 //注意： //射线检测也是瞬时的 //执行代码时进行一次射线检测 //1.最原始的射线检测 // 准备一条射线 Ray r3 = new Ray(Vector3.zero, Vector3.forward); // 进行射线检测 如果碰撞到对象 返回true //参数一：射线 //参数二: 检测的最大距离 超出这个距离不检测 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal //返回值：bool 当碰撞到对象时 返回 true 没有 返回false if (Physics.Raycast(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向 if (Physics.Raycast(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //2.获取相交的单个物体信息 //物体信息类 RaycastHit RaycastHit hitInfo; //参数一：射线 //参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中 //参数三：距离 //参数四：检测指定层级)不填检测所有层) //参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal if( Physics.Raycast(r3, out hitInfo, 1000, 1&lt;&lt;LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) ) { //碰撞器信息 print(\"碰撞到物体的名字\" + hitInfo.collider.gameObject.name); //碰撞到的点 print(hitInfo.point); //法线信息 print(hitInfo.normal); //得到碰撞到对象的位置 print(hitInfo.transform.position); //得到碰撞到对象 离自己的距离 print(hitInfo.distance); //RaycastHit 该类 对于我们的意义 //它不仅可以得到我们碰撞到的对象信息 //还可以得到一些 碰撞的点 距离 法线等等的信息 } //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 if (Physics.Raycast(Vector3.zero, Vector3.forward, out hitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal)) //3.获取相交的多个物体 //可以得到碰撞到的多个对象 //如果没有 就是容量为0的数组 //参数一：射线 //参数二：距离 //参数三：检测指定层级)不填检测所有层) //参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal RaycastHit[] hits = Physics.RaycastAll(r3, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断 //之前的参数一射线 通过两个点传入 hits = Physics.RaycastAll(Vector3.zero, Vector3.forward, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal); //还有一种函数 返回的碰撞的数量 通过out得到数据 if(Physics.RaycastNonAlloc(r3, hits, 1000, 1 &lt;&lt; LayerMask.NameToLayer(\"Monster\"), QueryTriggerInteraction.UseGlobal) &gt; 0 ) UnityEngine.Ray - Unity 脚本 API (unity3d.com) UnityEngine.RaycastHit - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"}]},{"title":"Unity入门","slug":"03001-Unity入门","date":"2019-08-30T13:00:00.000Z","updated":"2022-03-06T13:57:03.403Z","comments":true,"path":"posts/1537.html","link":"","permalink":"https://wwy.wwywy.com/posts/1537.html","excerpt":"","text":"将之前的笔记整理下来 Unity概叙 Unity是一个游戏开发的集成工具，降低了游戏开发的门槛，提高了开发效率。 工程文件夹Assets：工程资源文件夹(美术资源脚本)Library:库文件夹Logs:日志文件夹obj:编译中间文件Packages:包配置信息ProjectSettings:工程设置信息 Unity界面基础Inspector检查窗口：用于设置游戏对象具体信息Console控制台窗口：用于显示调试信息，报错、警告、打印信息等Scene场景窗口：所有游戏对象所在地Hierarchy层级窗口：所有游戏的对象名单Game游戏窗口：玩家看到的游戏画面Project工程窗口：所有游戏资源和脚本内容 Scence场景和Hierarchy层级窗口Hierarchy 我们可以在Hierarchy窗口中创建或拖入各种游戏对象。Hierarchy层级窗口快捷键：F2：对象改名Ctrl+C：复制Ctrl+V：粘贴Ctrl+D：克隆一个Delete：删除 Scence 我们可以在Scene窗口中查看所有游戏对象设置所有游戏对象。窗口上方工具条内容：1.渲染模式2.2D、3D视图切换3.光源、音效、特效显示开启4.辅助线显示5.辅助功能，控制场景上提示图标等6.搜索7.场景轴向 关于Unity中的3D世界坐标轴：红色为X轴正向绿色为Y轴正向蓝色为Z轴正向 以屏幕为参照物：垂直屏幕向内为Z正方向平行屏幕向右为X正方向平行屏幕向上为Y正方向 场景中的操作：左键相关： 鼠标单击：选中单个物体 鼠标框选：选中多个物体 Ctrl+鼠标单击：多选物体 长按ALT键+鼠标左键+移动鼠标：相对观察视口中心点旋转 选中物体之后，按F键：居中显示物体(或者在层级窗口中双击对象) 右键相关： 鼠标右键按下+移动鼠标：旋转视口 鼠标右键按下+WASD：漫游场景 鼠标右键按下+WASD+Shift：快速漫游场景长按ALT键+鼠标右键+移动鼠标：相对屏幕中心点拉近拉远 中键相关：滚动鼠标中间：相对屏幕中心点拉近拉远鼠标中间按下+移动鼠标：平移观察视口长按ALT键+滚动鼠标中间：鼠标指哪就朝哪拉近拉 Game游戏和Project工程Game 游戏画面窗口，玩家能看到的画面内容. Project 工程资源窗口，所有的工程资源都会在该窗口中显示，显示的内容为Assets文件夹中的所有内容. Project工程窗口关键功能:1.窗口设置2.创建相关资源文件3.查找4.按资源类型查找5.按名字查找 资源类型:图片格式：jpg、png、tga模型格式：fbx、max、maya音效：wav、mp3、ogg文本：txt、json、bytes视频：mp4 Inspector检查和Console控制台Inspector 查看场景中游戏对象关联的C#脚本信息. Console 用于查看调试信息的窗口报错、警告、测试打印都可以显示在其中,默认未开启可以在Window——&gt;General中开启或者使用快捷键：Ctrl+Shift+C，该窗口将显示代码编译过程中或者游戏运行过程中的报错、警告、测试信息主要用于查错和调试用。 Console控制台窗口：1.清空控制台2.相同内容折叠显示3.运行时清空4.构建时清空5.报错暂停运行6.是否显示错误信息7.是否显示警告信息8.是否显示打印信息 工具栏和父子关系工具栏从左到右：1.文件操作：新建工程，新建场景，工程打包等等2.编辑操作：对象编辑操作相关，工程设置，引擎设置相关3.资源操作：基本等同于Project窗口中右键相关功能4.对象操作：基本等同于Hierarchy窗口中右键相关功能5.脚本操作：Unity自带的脚本，可以添加各系统中的脚本7.窗口：可以打开Unity各核心系统的窗口9.帮助：检查更新，查看版本等等功能 File中的重要选项：BuildSetting(工程发布打包)Edit中的重要选项：Project Setting(工程各系统设置)、Preferences(首选项，可以设置编程软件)、GameObject中的重要选项：MoveToView、Align With View、Align View to Selected(几种快捷设置位置的功能) 父子关系 对象之间产生父子关系后，如何相互影响？爸爸干嘛，儿子干嘛；儿子干嘛，爸爸不管。Scene上方作用：pivot：以本身为中心点；center：以整体为中心点；local：以本身旋转为朝向；global：以世界坐标为朝向； Unity工作原理 使用它时是处于运行中的，我们是在一个运行中的软件里制作游戏的，Unity开发的本质就是在Unity引擎的基础上,利用反射和引擎提供的各种功能进行的拓展开发。 反射机制和游戏场景反射机制的体现：除了Transform这个表示位置的标配剧本外，我们可以为这个演员(GameObject)关联各种剧本(C#脚本)，让它按照我们剧本中(代码逻辑中)的命令来处理事情，而为演员添加剧本的这个过程，就是在利用反射new一个新的剧本对，象和演员(GameObject)对象进行关联，让其按我们的命令做事； 利用反射举例体现：1.修改Inspector面板中Transform的内容：已知对象，类名，变量名，通过反射为该对象设置变量值；2.新建一个脚本后，添加给一个指定的GameObject对象：已知类名，可以获取所有公共成员，故可以在Inspector面板上创建各公共字段信息 游戏场景的本质：游戏场景文件后缀为.unity，它的本质就是一个配置文件，Unity有一套自己识别处理它的机制，但是本质就是把场景对象相关信息读取出来，通过反射来创建各个对象关联各个脚本对象； 预设物和资源包的导入导出后缀名：.prefab，Prefabs放该类型文件;预制物删除变红处理：点击预制物右键Unpack Prefab;Project右键：导入导出包(.unitypackage); Unity脚本基础默认脚本内容：Editor\\Data\\Resources\\ScriptTemplates 脚本基本规则1.创建规则： 1.不在VS中创建脚本了 2.可以放在Assets文件夹下的任何位置(建议同一文件夹管理) 3.类名和文件名必须一致,不然不能挂载(因为反射机制创建对象，会通过文件名去找Type) 4.建议不要使用中文名命名 5.没有特殊需求 不用管命名空间 6.创建的脚本默认继承MonoBehavior 2.MonoBehavior基类： 1.创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 2.继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 3.继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 4.继承了MonoBehavior的脚本可以在一个对象上挂多个(如果没有加DisallowMultipleComponent特性) 5.继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 3.不继承MonoBehavior的类 1.不继承Mono的类 不能挂载在GameObject上 2.不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 3.不继承Mono的类 一般是单例模式的类(用于管理模块) 或者数据结构类(用于存储数据) 4.不继承Mono的类 不用保留默认出现的几个函数 生命周期函数总结：这些生命周期函数 如果你不打算在其中写逻辑 那就不要使用这些命周期函数。我们要知道，虽然建议大家不在继承MonoBehavior的类中写构造函数；但是不意味着我们不能写，当我们在继承MonoBehavior的类中写无参构造函数时，你会发现在编辑模式下或者运行后，只要该脚本挂载在场景中，那么该无参构造函数是会被自动执行的。因为Unity的工作原理中提到的反射机制，Unity实际上通过反射帮助我们实例化了该脚本对象，既然要实例化那么肯定是需要new的，只不过Unity中不需要我们自己new继承了MonoBehavior的类，只要挂载后Unity帮助我们做了这件事。那么为什么不建议大家写构造函数呢？1.Unity的规则就是，继承MonoBehavior的脚本不能new只能挂载2.生命周期函数的Awake是类似构造函数的存在，当对象出生就会自动调用3.写构造函数反而在结构上会破坏Unity设计上的规范 打印方式：普通：Debug.Log(“123”);报错：Debug.LogError(“出错了！！！！！”);警告：Debug.LogWarning(“警告！！！”); Inspector窗口可编辑变量知识点一: 私有和保护无法显示编辑，公共的可以显示编辑；知识点二 ：[SerializeField]让私有的和保护的也可以被显示；知识点三：[HideInInspector]公共的也不让其显示编辑；知识点四：[System.Serializable] 让自定义类型可以被访问；//加在类前，而字典怎么都不行知识点七： 辅助特性1.[Header(“分组说明”)] ：分组说明特性，为成员分组；2.[Tooltip(“说明内容”)] //悬停注释，为变量添加说明；3.[Space()]：间隔特性，让两个字段间出现间隔4.[Range(最小值, 最大值)] //修饰数值的滑条范围；5.[TextArea(3, 4)] ：滚动条显示字符串，默认不写参数就是超过3行显示滚动条；6.[ContextMenuItem(“显示按钮名”, “方法名”)] ：为变量添加快捷方法，参数1 显示按钮名，参数2 方法名 不能有参数；7.[Multiline(4)] ：多行显示字符串 默认不写参数显示3行8.[ContextMenu(“测试函数”)] ：方法添加特性能够在Inspector中执行 继承自MonoBehavior重要内容重要成员1.获取依附的GameObject：this.gameObject;2.获取依附的GameObject的位置信息：-print(this.transform.position);//位置-print(this.transform.eulerAngles);//角度-print(this.transform.lossyScale);//缩放大小3.获取脚本是否激活： this.enabled； 重要方法1:得到依附对象上挂载的其它脚本 //1.得到自己挂载的单个脚本,获取脚本的方法 如果获取失败 就是没有对应的脚本 会默认返回空 this.GetComponent(\"脚本名\"); //2.得到自己挂载的多个脚本 this.GetComponents&lt;泛形类型&gt;(); //3.得到子对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) //函数是有一个参数的 默认不传 是false 意思就是 如果子对象失活 是不会去找这个对象上是否有某个脚本的 //如果传true 及时 失活 也会找 //得子对象 挂载脚本 单个 this.GetComponentInChildren&lt;泛形类型&gt;(true); this.GetComponentsInChildren&lt;泛形类型&gt;(true); //4.得到父对象挂载的脚本(它默认也会找自己身上是否挂载该脚本) this.GetComponentInParent&lt;泛形类型&gt;(); this.GetComponentsInParent&lt;泛形类型&gt;(); //5.尝试获取脚本 //提供了一个更加安全的 获取单个脚本的方法 如果得到了 会返回true //然后在来进行逻辑处理即可 this.TryGetComponent&lt;泛形类型&gt;(out 赋值变量) Unity重要组件和APIGameObject最小单位直接实例化：new GameObject(“实体名”，typeof(要添加的组件名)…….) ； 注意事项：1.建议使用Destroy方法，它是异步的，不会马上删除对象，只是给对象加一个标识，一般情况下下一帧才会把对象从内存一处。；2.如果继承自mono，可以省略GameObject字段；3.对象失活也是可以用一些方式获取的；4.广播方法效率很低，不建议使用； 知识点一 GameObject中的成员变量 //名字 print(this.gameObject.name); this.gameObject.name = \"Lesson4唐老狮改名\"; print(this.gameObject.name); //是否激活 print(this.gameObject.activeSelf); //是否是静态 print(this.gameObject.isStatic); //层级 print(this.gameObject.layer); //标签 print(this.gameObject.tag); transform this.transform 上一节课讲解的 通过Mono去得到的依附对象的GameObject的位置信息 //他们得到的信息是一样 都是依附的GameObject的位置信息 print(this.gameObject.transform.position); 知识点二 GameObject中的静态方法 //创建自带几何体 //只要得到了一个GameObject对象 我就可以得到它身上挂在的任何脚本信息 //通过obj.GetComponent来得去 GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.name = \"唐老狮创建的立方体\"; //查找对象相关的知识 //两种找单个对象的共同点: //1.无法找到失活的对象的 // 只能找到 激活的对象 //2.如果场景中 存在多个满足条件的对象 // 我们无法准确确定找到的是谁 //1查找单个对象 //通过对象名查找 //这个查找效率比较低下 因为他会在场景中的所有对象去查找 //没有找到 就会返回null GameObject obj2 = GameObject.Find(\"唐老狮\"); //通过tag来查找对象 GameObject obj3 = GameObject.FindWithTag(\"Player\"); //和上面的方法一样，名字不一样而已 GameObject obj3 = GameObject.FindGameObjectWithTag(\"Player\"); //得到某一个单个对象 目前有2种方式了 //1.是public从外部面板拖 进行关联 //2.通过API去找 //2查找多个对象 //找多个对象的API 只能是通过tag去找多个 通过名字 是没有找多个的方法的 //通过tag找到多个对象 //它也是 只能找到 激活对象 无法找到失活对象 GameObject obj3 = GameObject.FindGameObjectsWithTag(\"Player\"); //还有几个查找对象相关是用的比较少的方法 是GameObject父类 Object提供的方法 //引出额外知识点 Unity中的Object和C#中的万物之父的区别 //Unity里面的Object 不是指的万物之父object //Unity里的Object 命名空间在UnityEngine中的 Object类 也是集成万物之父的一个自定义类 //C#中的Object 命名空间是在System中的 //它可以找到场景中挂载的某一个脚本对象 //效率更低 上面的GameObject.Find 和通过FindWithTag找 只是遍历对象 //这个方法 不仅要遍历对象 还要遍历对象上挂载的脚本 Lesson4 o = GameObject.FindObjectOfType&lt;Lesson4&gt;(); print(o.gameObject.name); //实例化对象(克隆对象)的方法 //实例化(克隆)对象 它的作用 是根据一个GameObject对象 创建出一个和它一模一样的对象 GameObject obj5 = GameObject.Instantiate(myObj); //以后学了更多知识点 就可以在这操作obj5 //如果你继承了 MonoBehavior 其实可以不用写GameObject一样可以使用 //因为 这个方法时Unity里面的 Object基类提供给我们的 所以可以直接用 Instantiate(myObj); //删除对象的方法 GameObject.Destroy(myObj2); //第二个参数 代表延迟几秒钟删除 GameObject.Destroy(obj5, 5); Destroy不仅可以删除对象 还可以删除脚本 GameObject.Destroy(this); //删除对象有两种作用 //1.是删除指定的一个游戏对象 //2.是删除一个指定的脚本对象 //注意：这个Destroy方法 不会马上移除对象 只是给这个对象加了一个移除标识 // 一般情况下 它会在下一帧时把这个对象移除并从内存中移除 //如果没有特殊需求 就是一定要马上移除一个对象的话 //建议使用上面的 Destroy方法 因为 是异步的 降低卡顿的几率 //下面这个方法 就是立即把对象 从内存中移除了 GameObject.DestroyImmediate(myObj); //如果是继承MonoBehavior的类 不用写GameObject Destroy(myObj2); DestroyImmediate(myObj); //过场景不移除 //默认情况 在切换场景时 场景中对象都会被自动删除掉 //如果你希望某个对象 过场景不被移除 //下面这句代码 就是不想谁过场景被移除 就传谁 //一般都是传 依附的GameObject对象 //比如下面这句代码的意思 就是自己依附的GameObject对象 过场景不被删除 GameObject.DontDestroyOnLoad(this.gameObject); //如果继承MOnoBehavior也可以直接写 DontDestroyOnLoad(this.gameObject); 知识点三 GameObject中的成员方法 //创建空物体 //new一个GameObject就是在创建一个空物体 GameObject obj6 = new GameObject(); GameObject obj7 = new GameObject(\"唐老狮创建的空物体\"); GameObject obj8 = new GameObject(\"顺便加脚本的空物体\", typeof(Lesson2),typeof(Lesson1)); //为对象添加脚本 //继承MOnoBehavior的脚本 是不能够去new //如果想要动态的添加继承MonoBehavior的脚本 在某一个对象上 //直接使用GameObject提供的方法即可 Lesson1 les1 = obj6.AddComponent(typeof(Lesson1)) as Lesson1; //用泛型更方便 Lesson2 les2 = obj6.AddComponent&lt;Lesson2&gt;(); //通过返回值 可以得到加入的脚本信息 //来进行一些处理 //得到脚本的成员方 和继承Mono的类得到脚本的方法 一模一样 //标签比较 //下面两种比较的方法 是一样的 if(this.gameObject.CompareTag(\"Player\")) { print(\"对象的标签 是 Player\"); } if(this.gameObject.tag == \"Player\") { print(\"对象的标签 是 Player\"); } //设置激活失活 //false 失活 true 激活 obj6.SetActive(false); obj7.SetActive(false); obj8.SetActive(false); //次要的成员方法 了解即可 不建议使用 //强调 //下面讲的方法 都不建议大家使用 效率比较低 //通过广播或者发送消息的形式 让自己或者别人 执行某些行为方法 //通知自己 执行什么行为 //命令自己 去执行这个TestFun这个函数 会在自己身上挂在的所有脚本去找这个名字的函数 //它会去找到 自己身上所有的脚本 有这个名字的函数去执行 this.gameObject.SendMessage(\"TestFun\"); this.gameObject.SendMessage(\"TestFun2\", 199); //广播行为 让自己和自己的子对象执行 this.gameObject.BroadcastMessage(\"函数名\"); //向父对象和自己发送消息 并执行 this.gameObject.SendMessageUpwards(\"函数名\"); UnityEngine.GameObject - Unity 脚本 API (unity3d.com) Time时间相关作用：主要 用于游戏中参与位移、记时、时间暂停等；重要内容: //知识点一 时间缩放比例 //时间停止 Time.timeScale = 0; //回复正常 Time.timeScale = 1; //2倍速 Time.timeScale = 2; //知识点二 帧间隔时间 //帧间隔时间 主要是用来计算位移 //路程 = 时间*速度 //根据需求 选择参与计算的间隔时间 //如果希望 游戏暂停时就不动的 那就使用 Time.deltaTime; //如果希望 不受暂停影响 Time.unscaledDeltaTime; //帧间隔时间：最近的一帧 用了多长时间(秒) //受scale影响 print(\"帧间隔时间\" + Time.deltaTime); //不受scale影响的帧间隔时间 print(\"不受scale影响的帧间隔时间\" + Time.unscaledDeltaTime); 知识点三 游戏开始到现在的时间 //它主要用来计时 单机游戏中计时 //受scale影响 print(\"游戏开始到现在的时间:\" + Time.time); //不受scale影响 print(\"不受scale影响的游戏开始到现在的时间:\" + Time.unscaledTime); 知识点四 物理帧间隔时间 FixedUpdate //受scale影响 Time.fixedDeltaTime; //不受scale影响 Time.fixedUnscaledDeltaTime; 知识点五 帧数 //从开始到现在游戏跑了多少帧(次循环) print(Time.frameCount); UnityEngine.Time - Unity 脚本 API (unity3d.com) Transform-位置和位移Vector3常用： //常用变量 print(Vector3.zero);//000 print(Vector3.right);//100 print(Vector3.left);//-100 print(Vector3.forward);//001 print(Vector3.back);//00-1 print(Vector3.up);//010 print(Vector3.down);//0-10 //常用方法 (后续加) //计算两个点之间的距离的方法 print(Vector3.Distance(v1, v12)); //返回float 两个向量之间的角度(以度为单位) Vector3.Angle(); UnityEngine.Vector3 - Unity 脚本 API (unity3d.com) 位置(注意：位置的赋值不能直接改变x，y，z 只能整体改变)位移方式： //知识点一：位置 //相对世界坐标系 this.gameObject.transform； //相对父对象 this.transform.localPosition； //世界正朝向 Vector3.forwad; //本身正朝向 transform.forward； //知识点二 位移 //坐标系下的位移计算公式：路程 = 方向 * 速度 * 时间 //方式一 自己计算 //想要变化的 就是 position //用当前的位置 + 我要动多长距离 得出最终所在的位置 this.transform.position = this.transform.position + this.transform.up * 1 * Time.deltaTime; //因为我用的是 this.transform.forward 所以它始终会朝向相对于自己的面朝向去动 this.transform.position += this.transform.forward * 1 * Time.deltaTime; //方向非常重要 因为 它决定了你的前进方向 this.transform.position += Vector3.forward * 1 * Time.deltaTime; //方式二 API //参数一：表示位移多少 路程 = 方向 * 速度 * 时间 //参数二：表示 相对坐标系 默认 该参数 是相对于自己坐标系的 //1相对于世界坐标系的 Z轴 动 始终是朝 世界坐标系 的 Z轴正方向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); //2相对于世界坐标的 自己的面朝向去动 始终朝自己的面朝向移动 this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World); //3相对于自己的坐标系 下的 自己的面朝向向量移动 (一定不会这样让物体移动) XXXXXXX this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.Self); //4相对于自己的坐标系 下的 Z轴正方向移动 始终朝自己的面朝向移动 this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self); UnityEngine.Transform - Unity 脚本 API (unity3d.com) Tramsfrom-角度和旋转知识点一 角度相关 相对世界坐标角度：transform.eulerAngles； 相对父对象角度：transform.localEulerAngles； 知识点二 旋转相关 //自己计算(省略 和位置一样 不停改变角度即可) //API计算 //自转 //每个轴 具体转多少度 //第一个参数 相当于 是旋转的角度 每一帧 //第二个参数 默认不填 就是相对于自己坐标系 进行的旋转 this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime); this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World); //相对于某个轴 转多少度 //参数一：是相对哪个轴进行转动 //参数二：是转动的 角度 是多少 //参数三：默认不填 就是相对于自己的坐标系 进行旋转 // 如果填 可以填写相对于 世界坐标系进行旋转 this.transform.Rotate(Vector3.right, 10 * Time.deltaTime); this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World); //相对于某一个点转 //参数一：相当于哪一个点 转圈圈 //参数二：相对于那一个点的 哪一个轴转圈圈 //参数三：转的度数 旋转速度 * 时间 this.transform.RotateAround(Vector3.zero, Vector3.right, 10 * Time.deltaTime); Transfrom-缩放和看向知识点一 缩放 //相对世界坐标系 print(this.transform.lossyScale); //相对本地坐标系(父对象) print(this.transform.localScale); //注意： //1.同样缩放不能只改xyz 只能一起改(相对于世界坐标系的缩放大小只能得 不能改) //所以 我们一般要修改缩放大小 都是改的 相对于父对象的 缩放大小 localScale this.transform.localScale = new Vector3(3, 3, 3); //2.Unity没有提供关于缩放的API //之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有 //如果你想要 让 缩放 发生变化 只能自己去写(自己算) this.transform.localScale += Vector3.one * Time.deltaTime; 知识点二 看向 //让一个对象的面朝向 可以一直看向某一个点或者某一个对象 //看向一个点 相对于世界坐标系的 this.transform.LookAt(Vector3.zero); //看向一个对象 就传入一个对象的 Transform信息 this.transform.LookAt(lookAtObj); Transfrom-父子关系知识点一 获取和设置父对象 //获取父对象 print(this.transform.parent.name); //设置父对象 断绝父子关系 this.transform.parent = null; //设置父对象 认爸爸 this.transform.parent = GameObject.Find(\"Father2\").transform; //通过API来进行父子关系的设置 this.transform.SetParent(null);//断绝父子关系 this.transform.SetParent(GameObject.Find(\"Father2\").transform);//认爸爸 //参数一：我的父亲 //参数二：是否保留世界坐标的 位置 角度 缩放 信息 // true 会保留 世界坐标下的状态 和 父对象 进行计算 得到本地坐标系的信息 // false 不会保留 会直接把世界坐标系下的 位置角度缩放 直接赋值到 本地坐标系下 this.transform.SetParent(GameObject.Find(\"Father3\").transform, false); 知识点二 抛妻弃子 //就是和自己的所有儿子 断绝关系 没有父子关系了 this.transform.DetachChildren(); 知识点三 获取子对象 //按名字查找儿子 //找到儿子的 transform信息 //Find方法 是能够找到 失活的对象的 ！！！！！ GameObject相关的 查找 是不能找到失活对象的 print(this.transform.Find(\"Cube (1)\").name); //他只能找到自己的儿子 找不到自己的孙子 ！！！！！！ print(this.transform.Find(\"GameObject\").name); //虽然它的效率 比GameObject.Find相关 要高一些 但是 前提是你必须知道父亲是谁 才能找 //遍历儿子 //如何得到有多少个儿子 //1.失活的儿子也会算数量 //2.找不到孙子 所以孙子不会算数量 print(this.transform.childCount); //通过索引号 去得到自己对应的儿子 //如果编号 超出了儿子数量的范围 那会直接报错的 //返回值 是 transform 可以得到对应儿子的 位置相关信息 this.transform.GetChild(0); 知识点四 儿子的操作 //判断自己的爸爸是谁 //一个对象 判断自己是不是另一个对象的儿子 if(son.IsChildOf(this.transform)) { print(\"是我的儿子\"); } //得到自己作为儿子的编号 print(son.GetSiblingIndex()); //把自己设置为第一个儿子 son.SetAsFirstSibling(); //把自己设置为最后一个儿子 son.SetAsLastSibling(); //把自己设置为指定个儿子 //就算你填的数量 超出了范围(负数或者更大的数) 不会报错 会直接设置成最后一个编号 son.SetSiblingIndex(1); Transfrom-坐标转换知识点一 世界坐标转本地坐标 print(Vector3.forward); //世界坐标系 转本地坐标系 可以帮助我们大概判断一个相对位置 //世界坐标系的点 转换 为相对本地坐标系的点 //受到缩放影响 print(\"转换后的点 \" + this.transform.InverseTransformPoint(Vector3.forward)); //世界坐标系的方向 转换 为相对本地坐标系的方向 //不受缩放影响 print(\"转换后的方向\" + this.transform.InverseTransformDirection(Vector3.forward)); //受缩放影响 print(\"转换后的方向(受缩放影响)\" + this.transform.InverseTransformVector(Vector3.forward)); 知识点二 本地坐标转世界坐标 //本地坐标系的点 转换 为相对世界坐标系的点 受到缩放影响 print(\"本地 转 世界 点\" + this.transform.TransformPoint(Vector3.forward)); //本地坐标系的方向 转换 为相对世界坐标系的方向 //不受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformDirection(Vector3.forward)); //受缩放影响 print(\"本地 转 世界 方向\" + this.transform.TransformVector(Vector3.forward)); Input输入相关//知识点一 鼠标在屏幕位置 Input.mousePosition //知识点二 检测鼠标输入 //鼠标按下一瞬间 进入 //0左键 1右键 2中键 Input.GetMouseButtonDown(0) //中键滚动 //返回值的 y -1往下滚 0没有滚 1往上滚 //它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值 print(Input.mouseScrollDelta); //知识点三 检测键盘输入 //传入字符串的重载 //这里传入的 字符串 不能是大写的 不然会报错 //只能传入小写字符串 Input.GetKeyDown(\"q\") //推荐枚举型 Input.GetKey(KeyCode.W) //知识点四 检测默认轴输入 //我们学习鼠标 键盘输入 主要是用来 //控制玩家 比如 旋转 位移等等 //所以Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转 //键盘AD按下时 返回 -1到1之间的变换 //相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转 float h = Input.GetAxis(\"Horizontal\"); //键盘SW按下时 返回 -1到1之间的变换 //得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转 print(Input.GetAxis(\"Vertical\")); //鼠标横向移动时 -1 到 1 左 右 print(Input.GetAxis(\"Mouse X\")); //鼠标竖向移动时 -1 到 1 下 上 print(Input.GetAxis(\"Mouse Y\")); //我们默认的 GetAxis方法 是有渐变的 会总 -1~0~1之间 渐变 会出现小数 //GetAxisRaw方法 和 GetAxis使用方式相同 //只不过 它的返回值 只会是 -1 0 1 不会有中间值 //知识点三 其它的监听 //是否有任意键或鼠标长按 if(Input.anyKey) //是否有任意键或鼠标按下 if(Input.anyKeyDown) //这一帧的键盘输入 print(Input.inputString); //手柄输入相关 //得到连接的手柄的所有按钮名字 string[] strs = Input.GetJoystickNames(); //某一个手柄键按下 if( Input.GetButtonDown(\"Jump\") ) //某一个手柄键抬起 if (Input.GetButtonUp(\"Jump\")) //某一个手柄键长按 if (Input.GetButton(\"Jump\")) //移动设备触摸相关 if(Input.touchCount &gt; 0) { Touch t1 = Input.touches[0]; //位置 print(t1.position); //相对上次位置的变化 print(t1.deltaPosition); } //是否启用多点触控 Input.multiTouchEnabled = false; //陀螺仪(重力感应) //是否开启陀螺仪 必须开启 才能正常使用 Input.gyro.enabled = true; //重力加速度向量 print(Input.gyro.gravity); //旋转速度 print(Input.gyro.rotationRate); //陀螺仪 当前的旋转四元数 //比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响 //手机怎么动 它怎么动 print(Input.gyro.attitude); UnityEngine.Input - Unity 脚本 API (unity3d.com) Screen屏幕相关//知识点一 静态属性 //常用 //当前屏幕分辨率 Resolution r = Screen.currentResolution; print(\"当前屏幕分辨率的宽\" + r.width + \"高\" + r.height); //屏幕窗口当前宽高 //这得到的 是当前 窗口的 宽高 不是设备分辨率的宽高 //一般写代码 要用窗口宽高 做计算时 就用他们 print(Screen.width); print(Screen.height); //屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; //不常用 //运行时是否全屏模式 Screen.fullScreen = true; //窗口模式 //独占全屏FullScreenMode.ExclusiveFullScreen //全屏窗口FullScreenMode.FullScreenWindow //最大化窗口FullScreenMode.MaximizedWindow //窗口模式FullScreenMode.Windowed Screen.fullScreenMode = FullScreenMode.Windowed; //移动设备屏幕转向相关 //允许自动旋转为左横向 Home键在左 Screen.autorotateToLandscapeLeft = true; //允许自动旋转为右横向 Home键在右 Screen.autorotateToLandscapeRight = true; //允许自动旋转到纵向 Home键在下 Screen.autorotateToPortrait = true; //允许自动旋转到纵向倒着看 Home键在上 Screen.autorotateToPortraitUpsideDown = true; //指定屏幕显示方向 Screen.orientation = ScreenOrientation.Landscape; 知识点二 静态方法 //设置分辨率 一般移动设备不使用 Screen.SetResolution(1920, 1080, false); UnityEngine.Screen - Unity 脚本 API (unity3d.com) Camera摄像机相关1.*Clear Flags： 如何清除背景： skybox天空盒(3D) Solid Color颜色填充(2D) Depth only 只画该层，背景透明(叠加渲染) Don't Clear 不移除，覆盖渲染 2.*Culling Mask 选择性渲染部分层级：可以指定只渲染对应层级的对象 3.*Projection 2.1Perspective 透视模式 FOV Axis：视场角 轴-决定了光学仪器的视野范围 Field of view：视口大小 Physical Camera：物理摄像机、勾选后可以模拟真实世界中、摄像机、焦距、传感器尺寸、透镜移位等等 Focal Length：焦距 Sensor Type：传感器类型 Sensor Size：传感器尺寸 Lens Shift：透镜移位 Gate Fit：闸门配合 2.2orthographic 正交摄像机(一般用于2D游戏制作) Size：摄制范围 4.*Clipping Planes： 裁剪平面距离(近和远) 5.Viewport Rect： 视口范围屏幕上将绘制该摄像机视图的位置： 主要用于双摄像机游戏 0~1 相当于宽高百分比 6.*Depth: 渲染顺序上的深度(多个摄像机，越小的越先渲染，大的覆盖小的) 7.Redering path: 渲染路径 8.*Target Texture: 渲染纹理: 可以把摄像机画面渲染到一张图上:主要用于制作小地图(摄像机渲染到这张图上) 在Project右键创建 Render Texture 9.*Occlusion Culling: 是否启用剔除遮挡(性能优化) 10.Allow HDR: 是否允许高动态范围渲染 11.Allow MSAA: 是否允许抗锯齿 12.Allow Dynamic Resolution: 是否允许动态分辨率呈现 13.Target Display: 用于哪个显示器:主要用来开发有多个屏幕的平台游戏 摄像机 - Unity 手册 (unity3d.com) 代码相关： 知识点一 重要静态成员 //1.获取摄像机 //如果用之前的知识 来获取摄像机 //主摄像机的获取 //如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机 print(Camera.main.name); //获取摄像机的数量 print(Camera.allCamerasCount); //得到所有摄像机 Camera[] allCamera = Camera.allCameras; print(allCamera.Length); //2.渲染相关委托 //摄像机剔除前处理的委托函数 Camera.onPreCull += (c) =&gt; { }; //摄像机 渲染前处理的委托 Camera.onPreRender += (c) =&gt; { }; //摄像机 渲染后 处理的委托 Camera.onPostRender += (c) =&gt; { }; 知识点二 重要成员 //1.界面上的参数 都可以在Camera中获取到 //比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置 Camera.main.depth = 10; //2.世界坐标转屏幕坐标 //转换过后 x和y对应的就是屏幕坐标 z对应的 是 这个3D物体 里我们的摄像机有多远 //我们会用这个来做的功能 最多的 就是头顶血条相关的功能 Vector3 v = Camera.main.WorldToScreenPoint(this.transform.position); print(v); //3.屏幕坐标转世界坐标 //只所以改变Z轴 是因为 如果不改 Z默认为0 //转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点 //如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点 Vector3 v = Input.mousePosition; v.z = 5; obj.position = Camera.main.ScreenToWorldPoint(v); //print(Camera.main.ScreenToWorldPoint(v)); UnityEngine.Camera - Unity 脚本 API (unity3d.com) 核心系统光源系统基础Light组件1.*Type:光源类型 Spot:聚光灯 Range:发光范围距离 Spot Angle:光锥角度 Directional:方向光(环境光) Point:点光源 Area:面光源(烘焙下用) 2.*Color: 颜色 3.*Mode:光源模式 Realtime: 实时光源 每帧实时计算，效果好，性能消耗大 Baked: 烘焙光源 事先计算好，无法动态变化 Mixed: 混合光源 预先计算+实时运算 4.*Intensity: 光源亮度 5.Indirect Multiplier: 改变间接光的强度 低于1，每次反弹会使光更暗大于1，每次反弹会使光更亮 6.*Shadow Type: NoShadows:关闭阴影 HardShadows:生硬阴影 SoftShadows:柔和阴影 7.RealtimeShadows Strength:阴影暗度 0~1之间，越大越黑 Resolution:阴影贴图渲染分辨率，越高越逼真，消耗越高 Bias:阴影推离光源的距离 Normal Bias:阴影投射面沿法线收缩距离 Near Panel:渲染阴影的近裁剪面 8.*Cookie: 投影遮罩(用图制作光照的样子) 9.Cookie Size： 大小设置 10.Draw Halo: 球形光环开关(光晕) 11.*Flare: 耀斑(工程文件可以自己右键创建该类型文件，想再Game显示，摄像机添加Flare Layer脚本) 12.Render Mode:渲染模式 Auto:运行时确定 Important:以像素质量为单位进行渲染，效果逼真，消耗大 Not Important:以快速模式进行渲染 13.*Culling Mask:剔除遮罩层，决定哪些层的对象受到该光源影响 光源 - Unity 手册 (unity3d.com) UnityEngine.Light - Unity 脚本 API (unity3d.com) 光窗口1.Environment-环境相关设置 Skybox Material-天空盒材质：可以改变天空盒(创建天空盒创建一个材质球将种类设置为skybox) Sun Source-太阳来源：不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting-环境光设置： Source-环境光光源颜色： Skybox：天空和材质作为环境光颜色 Gradient：可以为天空、地平线、地面单独选择颜色和他们之间混合 Intensity Multiplier-环境光亮度； Ambient Mode-全局光照模式只有启用了实时全局和全局烘焙时才有用： Realtime(已弃用) Baked 2.OtherSettings-其它设置： Fog-雾开关(性能消耗)： Color-雾颜色： Mode-雾计算模式： Linear-随距离线性增加： Start：离摄像机多远开始有雾 End：离摄像机多远完全遮挡 Exponential-随距离指数增加：-Density-强度； Exponential Qquare-随距离比指数更快的增加-Density：强度； Halo Texture：光源周围挥着光环的纹理 Halo Strength：光环可见性 Flare Fade Speed：耀斑淡出时间最初出现之后淡出的时间； Flare Strength：耀斑可见性 Spot Cookie：聚光灯默认剪影纹理 Lighting 窗口 - Unity 手册 (unity3d.com) 物理系统之碰撞检测Rigidbody组件重点：碰撞产生的必要条件，两个物体都有碰撞器，至少一个物体有刚体。 1.RigidBody组件信息： Mass：质量(默认为千克)质量越大惯性越大； Drag：空气阻力根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力； Angular Drag：根据扭矩旋转对象时影响对象的空气阻力大小。0 表示没有空气阻力； Use Gravity：是否受重力影响 Is Kinematic：如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用； Interpolate-(物理帧时间长时使用)插值运算，让刚体物体移动更平滑： None：不应用插值运算； Interpolate：根据前一帧的变换来平滑变换； Extrapolate：差值运算，根据下一帧的估计变换来平滑变换； Constraints-约束，对刚体运动的限制： Freeze Position：有选择地停止刚体沿世界 X、Y 和 Z 轴的移动； Freeze Rotation：有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转； Collision Detection(碰撞检测模式)-用于防止快速移动的对象穿过其它对象而不检测碰撞： Discrete(离散检测)：对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞(这是默认值)； Continuous(连续检测)：对动态碰撞体(具有刚体)使用离散碰撞检测，并对静态碰撞体(没有刚体)使用连续碰撞检测；设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。(此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置)，其他刚体将使用离散碰撞检测。 Continuous Speculative(连续推测检测)：对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 刚体 - Unity 手册 (unity3d.com) API: //知识点一 刚体自带添加力的方法 //给刚体加力的目标就是 //让其有一个速度 朝向某一个方向移动 //1.首先应该获取刚体组件 rigidBody = this.GetComponent&lt;Rigidbody&gt;(); //2.添加力 //相对世界坐标 //世界坐标系 Z轴正方向加了一个里 //加力过后 对象是否停止移动 是由阻力决定的 //如果阻力为0 那给了一个力过后 始终 是不会停止运动 rigidBody.AddForce(Vector3.forward * 10); //如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动 rigidBody.AddForce(this.transform.forward * 10); //相对本地坐标 rigidBody.AddRelativeForce(Vector3.forward * 10); //3.添加扭矩力，让其旋转 //相对世界坐标 rigidBody.AddTorque(Vector3.up * 10); //相对本地坐标 rigidBody.AddRelativeTorque(Vector3.up * 10); //4.直接改变速度 //这个速度方向 是相对于 世界坐标系的 //如果要直接通过改变速度 来让其移动 一定要注意这一点 rigidBody.velocity = Vector3.forward * 5; //5.模拟爆炸效果 //模拟爆炸的力 一定是 所有希望产生爆炸效果影响的对象 //都需要得到他们的刚体 来执行这个方法 才能都有效果 rigidBody.AddExplosionForce(100, Vector3.zero, 10); //知识点二 力的几种模式 //第二个参数 力的模式 主要的作用 就是 计算方式不同而已 //由于4中计算方式的不同 最终的移动速度就会不同 rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration); //动量定理 //Ft = mv // v = Ft/m; //F:力 //t：时间 //m:质量 //v:速度 //1.Acceleration //给物体增加一个持续的加速度，忽略其质量 //v = Ft/m //F:(0,0,10) //t:0.02s //m:默认为1 //v = 10*0.02/ 1 = 0.2m/s //每物理帧移动0.2m/s*0.02 = 0.004m //2.Force //给物体添加一个持续的力，与物体的质量有关 //v = Ft/m //F:(0,0,10) //t:0.02s //m:2kg //v = 10*0.02/ 2 = 0.1m/s //每物理帧移动0.1m/s*0.02 = 0.002m //3.Impulse //给物体添加一个瞬间的力，与物体的质量有关,忽略时间 默认为1 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:2kg //v = 10*1/ 2 = 5m/s //每物理帧移动5m/s*0.02 = 0.1m //4.VelocityChange //给物体添加一个瞬时速度，忽略质量，忽略时间 //v = Ft/m //F:(0,0,10) //t:默认为1 //m:默认为1 //v = 10*1/ 1 = 10m/s //每物理帧移动10m/s*0.02 = 0.2m //知识点三 力场脚本(Unity封装好了的组件) ConstantForce组件 //补充 刚体的休眠 //获取刚体是否处于休眠状态 如果是 if (rigidBody.IsSleeping()) { //就唤醒它 rigidBody.WakeUp(); } UnityEngine.Rigidbody - Unity 脚本 API (unity3d.com) 碰撞器碰撞器面板说明： 1.3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 2.共同参数： Is Trigger：是否是触发器，如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略，主要用于进行没有物理效果的碰撞检测； Material：物理材质(工程右键可以创建一个物理材质.material文件)，可以确定碰撞体和其它对象碰撞时的交互(表现)方式。 Center：碰撞体在对象局部空间中的中心点位置 3.常用碰撞器： BoxCollider-盒状碰撞器-Size：碰撞体在X、Y、Z方向上的大小； Sphere Collider-球状碰撞器-Radius：球形碰撞体的半径大小； Capsule Collider-胶囊碰撞器： Radius：胶囊体的半径 Height：胶囊体的高度 Direction：胶囊体在对象局部空间中的轴向 4.异形物体使用多种碰撞器组合：刚体对象的子对象碰撞器信息参与碰撞检测； 5.不常用碰撞器： Mesh Collider-网格碰撞器： Convex：勾选此复选框可启用 Convex。如果启用此属性，该 Mesh Collider 将与其他 Mesh Collider 发生碰撞。Convex Mesh Collider 最多 255 个三角形。 Cooking Options-启用或禁用影响物理引擎对网格处理方式的网格烹制选项： -None：禁用下方列出的所有 Cooking Options -Everything：启用下方列出的所有 Cooking Options。 -Cook for Faster Simulation：使物理引擎烹制网格以加快模拟速度。启用此设置后，这会运行一些额外步骤，以保证生成的网格对于运行时性能是最佳的。这会影响物理查询和接触生成的性能。禁用此设置后，物理引擎会使用更快的烹制速度，并尽可能快速生成结果。因此，烹制的 Mesh Collider 可能不是最佳的。 -Enable Mesh Cleaning：使物理引擎清理网格。启用此设置后，烹制过程会尝试消除网格的退化三角形以及其他几何瑕疵。此过程生成的网格更适合于在碰撞检测中使用，往往可生成更准确的击中点。 -Weld Colocated Vertices：使物理引擎在网格中删除相等的顶点。启用此设置后，物理引擎将合并具有相同位置的顶点。这对于运行时发生的碰撞反馈十分重要。 Mesh：引用需要用于碰撞的网格。 Wheel Collider-环状 碰撞器： Mass：车轮的质量 Radius：车轮的半径 Wheel Damping Rate：这是应用于车轮的阻尼值 Suspension Distance：车轮悬架的最大延伸距离(在局部空间中测量)。悬架始终向下延伸穿过局部 Y 轴。 Force App Point Distance：此参数定义车轮上的受力点。此距离应该是距车轮底部静止位置的距离(沿悬架行程方向)，以米为单位。当 forceAppPointDistance = 0 时，受力点位于静止的车轮底部。较好的车辆会使受力点略低于车辆质心。 Suspension Spring：悬架尝试通过增加弹簧力和阻尼力来到达目标位置 (Target Position) -Spring：弹簧力尝试到达目标位置。值越大，悬架达到目标位置就越快 -Damper：抑制悬架速度。值越大，悬架弹簧移动就越慢 -Target Position：悬架沿悬架距离 (Suspension Distance) 的静止距离。1 对应于完全展开的悬架，0 对应于完全压缩的悬架。默认值为 0.5，与常规汽车的悬架行为匹配。 Forward Friction-车轮向前滚动时轮胎摩擦的特性；Sideways Friction车轮侧向滚动时轮胎摩擦的特性—： -Extremum Slip：曲线的极值点。 -Extremum Value：曲线的极值点。 -Asymptote Slip：曲线的渐近点。 -Asymptote Value：曲线的渐近点。 -Stiffness：Extremum Value 和 Asymptote Value 的乘数(默认值为 1)。改变摩擦力的刚度。将此值设置为零将完全禁用车轮的所有摩擦力。通常在运行时修改刚度以使用脚本来模拟各种地面材质。 注意事项：不必通过转动或滚动 WheelCollider 对象来控制汽车；附加了 WheelCollider 的对象应始终相对于汽车本身固定； Terrain Collider-地形碰撞器 Terrain Data：地形数据 Enable Tree Colliders：选中此属性时，将启用树碰撞体 碰撞体 - Unity 手册 (unity3d.com) 物理材质物理材质参数说明 Dynamic Friction：已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止(除非用很大的力或重力推动对象) Static Friction：当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness：表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine-两个碰撞对象的摩擦力的组合方式： -Average：对两个摩擦值求平均值。 -Minimum：使用两个值中的最小值。 -Maximum：使用两个值中的最大值。 -Multiply：两个摩擦值相乘。 unce Combine：两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同 碰撞检测函数注意：碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用. //知识点一 物理碰撞检测响应函数 //碰撞触发接触时会 自动执行这个函数 private void OnCollisionEnter(Collision collision) { //Collision类型的 参数 包含了 碰到自己的对象的相关信息 //关键参数 //1.碰撞到的对象碰撞器的信息 //collision.collider //2.碰撞对象的依附对象(GameObject) //collision.gameObject //3.碰撞对象的依附对象的位置信息 //collision.transform //4.触碰点数相关 //collision.contactCount //接触点 具体的坐标 //ContactPoint[] pos = collision.contacts; //只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息 print(this.name + \"被\" + collision.gameObject.name + \"撞到了\"); } //碰撞结束分离时 会自动执行的函数 private void OnCollisionExit(Collision collision) { print(this.name + \"被\" + collision.gameObject.name + \"结束碰撞了\"); } //两个物体相互接触摩擦时 会不停的调用该函数 private void OnCollisionStay(Collision collision) { print(this.name + \"一直在和\" + collision.gameObject.name + \"接触\"); } //知识点二 触发器检测响应函数 //触发开始的函数 当第一次接触时 会自动调用 protected virtual void OnTriggerEnter(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"触发了\"); } //触发结束的函数 当水乳相融的状态结束时 会调用一次 private void OnTriggerExit(Collider other) { print(this.name + \"被\" + other.gameObject.name + \"结束水乳相融的状态了\"); } //当两个对象 水乳相融的时候 会不停调用 private void OnTriggerStay(Collider other) { print(this.name + \"和\" + other.gameObject.name + \"正在水乳相融\"); } 音效系统音频文件导入1.导入参数设置 常用格式：wav、mp3、ogg、aiff； 音频文件属性设置 Force To Mono：多声道转单声道； Normalize：强制为单声道时，混合过程中被标准化； Load In Background：在后台加载，不阻塞主线程； Ambisonic：立体混响声 ，非常适合 360 度视频和 XR 应用程序，如果音频文件包含立体混响声编码的音频，请启用此选项； LoadType-加载类型： Decompress On Load：不压缩形式存在内存，加载块，但是内存占用高(适用于小音效文件)； Compress in memory：压缩形式存在内存，加载慢，内存小(仅适用于较大音效文件) Streaming：以流形式存在，使用时解码。内存占用最小，cpu消耗高(性能换内存) Preload Audio Data：预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format-压缩方式： PCM：音频以最高质量存储 Vorbis：相对PCM压缩的更小，根据质量决定 ADPCM：包含噪音，会被多次播放的声音，如碰撞声 Quality：音频质量，确定要应用于压缩剪辑的压缩量。(不适用于 PCM/ADPCM/HEVAG 格式) Sample Rate Setting-PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率： Preserve Sample Rate：此设置可保持采样率不变(默认值)； Optimize Sample Rate：此设置根据分析的最高频率内容自动优化采样率； Override Sample Rate：此设置允许手动覆盖采样率，因此可有效地将其用于丢弃频率内容； 音频源和音频监听组件组件面板说明： AudioSource-音频源： AudioClip：声音剪辑文件(音频文件) Output：默认将直接输出到场景中的音频监听器，可以更改为输出到混音器(音乐游戏可能会用)； Mute：静音开关； Bypass Effect：开关滤波器效果； Bypass Listener Effects：快速开关所有监听器； Bypass Reverb Zones：快速开关所有混响区 Play On Awake：对象创建时就播放音乐，也就是开关启动游戏就播放； Loop：循环 Priority：优先级(越大越不容易被其他音效覆盖) Volume：音量大小 Pitch：音高 Stereo Pan：2D声音立体声位置。相当于左右声道 Spatial Blend：音频受3D空间的影响程度(设置是2d游戏还是3d音效) Reverb Zone Mix：到混响区的输出信号量 3D Sound Settings-和Spatial Blend参数成正比应用： Doppler Level：多普勒效果等级 Spread：扩散角度设置为3D立体声还是多声道 Volume Rolloff-声音衰减速度： Logarithmic Rolloff：靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff：与音频源的距离越远，听到的声音越小。 Custom Rolloff：音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance：最小距离内，声音保持最大响度；最大距离外，声音开始减弱； AudioListener-音频监听脚本； 音频源 - Unity 手册 (unity3d.com) 音频源代码控制//知识点一 代码控制播放停止 //播放音效 audioSource.Play(); //延迟播放 填写的是秒数 audioSource.PlayDelayed(5); //停止音效 audioSource.Stop(); //暂停 audioSource.Pause(); //停止暂停 和暂停后 Play效果是一样的 都会继续播放现在的音效 audioSource.UnPause(); 知识点二 如何检测音效播放完毕 //如果你希望某一个音效播放完毕后 想要做什么事情 //那就可以在Update生命周期函数中 不停的去检测 它的 该属性 //如果是false就代表播放完毕了 audioSource.isPlaying 知识点三 如何动态控制音效播放 //1.直接在要播放音效的对象上挂载脚本 控制播放 //2.实例化挂载了音效源脚本的对象 //这种方法 其实用的比较少 //Instantiate(obj); //3.用一个AudioSource来控制播放不同的音效 //AudioSource aus = this.gameObject.AddComponent&lt;AudioSource&gt;(); //aus.clip = clip; //aus.Play(); //潜在知识点 //一个GameObject可以挂载多个 音效源脚本AudioSource //使用时要注意 如果要挂载多个 那一定要自己管理他们 控制他们的播放 停止 不然 我们没有办法准确的获取 //谁是谁 UnityEngine.AudioClip - Unity 脚本 API (unity3d.com) 麦克风输入相关知识点一 获取设备麦克风信息 string[] strs = Microphone.devices; 知识点二 开始录制 //参数一：设备名 传空使用默认设备 //参数二：超过录制长度后 是否重头录制 //参数三：录制时长 //参数四：采样率 clip = Microphone.Start(null, false, 10, 44100); 知识点三 结束录制 Microphone.End(null); 知识点四 获取音频数据用于存储或者传输 //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[clip.channels * clip.samples]; clip.GetData(f, 0); print(f.Length); UnityEngine.Microphone - Unity 脚本 API (unity3d.com)","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"}]},{"title":"C#进阶","slug":"02004-C#进阶","date":"2019-08-02T13:00:00.000Z","updated":"2022-03-22T06:17:22.528Z","comments":true,"path":"posts/1028.html","link":"","permalink":"https://wwy.wwywy.com/posts/1028.html","excerpt":"","text":"CLR中简单数据结构类命名空间：System.Collections； ArrayList语法:new ArrayList();建议：本质是一个自动扩容的object数值，存在装箱拆箱，尽量少用；C# 动态数组(ArrayList) |菜鸟教程 (runoob.com) Stack(栈)语法：new Stack();建议：存在装箱拆箱；C# 堆栈(Stack) | 菜鸟教程 (runoob.com) Queue(队列)语法：new Queue();建议：存在装箱拆箱；C# 队列(队列) |菜鸟教程 (runoob.com) Hashtable(哈希表)定义：又叫散列表，是基于键的哈希代码组织起来的键值对，主要用来提高数据查询效率；语法：new Hashtable();迭代器遍历法: IDictionaryEnumerator me=哈希表对象名.GetEnumerator(); while(me.MoveNext()){ } 建议：存在装箱拆箱；C# 哈希表(Hashtable) |菜鸟教程 (runoob.com) CLR中的泛形命名空间：System.Collections.Generic 泛形定义：通过类型参数来实现代码操作多种类型；原理：相当于占位符，定义类或者方法是用替代符代替变量类型，当真正使用时再指定具体类型； 泛形约束关键字：where，可以多个使用;种类：6种如下：1.值类型 where 泛形字母:struct；2.引用类型 where 泛形字母:class；3.存在无参公共构造函数 where 泛形字母:new()；4.某个类本身或者派生类 where 泛形字母:类名；5.每个接口的派生 where 泛形字母:接口名；6.另一个泛形类型或者派生类型 where 泛形字母:另一个泛形字母； List定义：表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。语法：new List&lt;&gt;();List 类 (System.Collections.Generic) | Microsoft Docs Dictionary定义：表示键和值的集合。语法：new Dictionart&lt;键,值&gt;();Dictionary 类 (System.Collections.Generic) | Microsoft Docs LinkedList定义：表示双重链接列表。语法：new LinkedList&lt;&gt;();LinkedList 类 (System.Collections.Generic) | Microsoft Docs 泛形队列定义：表示对象的先进先出泛形集合。语法：new Queue&lt;&gt;();Queue 类 (System.Collections.Generic) | Microsoft Docs 泛形栈定义：表示相同指定类型的实例可变大小的后进先出 (LIFO) 集合。语法：new Stack&lt;&gt;();Stack 类 (System.Collections.Generic) | Microsoft Docs 委托和事件委托定义：C# 中的委托(Delegate)类似于 C 或 C++ 中函数的指针,本质时一个类。委托(Delegate) 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变，专门用来装载函数的容器。语法： //定义 访问修饰符 delegate 返回值类型 委托名&lt;泛形类型&gt;(参数列表) //实例化 委托名 变量名=new 委托名(); //赋值,参数要一致 变量名[+或-]=方法名() //使用 委托变量名(对应参数): 系统自带的委托：Action&lt;泛形类型,……泛形类型&gt;和Func&lt;泛形类型,…..返回值&gt;;(d都支持16个泛形类型) 事件定义:让委托使用更加安全，事件是一种特殊的变量类型语法：访问修饰符 event 委托类型 事件名和委托区别：不能再类外部赋值(可以加减)，不能在类外部调用，只能在类内部封装调用； 匿名函数定义：没有名字的函数，要配合委托和事件使用；缺点：没有名字，无法通过+-移除；语法： Action a=delegate(参数列表){ } Lambad表达式定义：可以理解成是匿名函数的简写； (参数列表)=&gt;{ } 多线程和任务前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存 多线程(Thread)命名空间：using System.Threading语法: //启动线程，将要执行的代码逻辑封装到一个函数语句块中 Thread 线程名=new Thread(委托方法); //启动线程 线程名.start(); //设置为后台线程,当进程结束后台线程结束 线程名.IsBackground=true; //关闭释放一个死循环进程，有俩中方法 //为线程死循环加一个标志变量 //通过线程提供的方法(在.net core版本会无法中止报错),可以加异常捕捉 线程名.Abort(); //线程休眠 线程名.Sleep(时间/ms); C# 多线程 | 菜鸟教程 (runoob.com) 共享数据问题：多线程操作同一内存区域可能出现问题，可以通过加锁的形式避免问题 lock(同一引用类型变量){ } 线程池(ThreadPoll)命名空间：using System.Threading定义:ThreadPoll是线程池(享元设计模式)，其目的是为了减少开启新线程消耗的资源(使用线程池中的空闲线程，不必在开启新线程，以及统一管理线程(线程池中的线程执行完毕后，回归到线程池里，等待新任务).优缺点：ThreadPoll性能优于Thread，但是Thread和ThreadPoll对线程的控制都不是很好，例如线程等待(线程执行一段时间无响应后，直接停止线程，释放资源 等 都没有直接的API来控制 只能通过硬编码来实现，同时ThreadPool使用的是线程池全局队列，全局队列中的线程依旧会存在竞争共享资源的情况，从而影响性能。语法： //快速启动 ThreadPool.QueueUserWorkItem(委托方法); //获取线程池中辅助线程的最大数量(workerThreadsMax)和线程池中异步I/O线程的最大数量(completionPortThreadsMax) ThreadPool.GetMaxThreads(out int workerThreadsMax, out int completionPortThreadsMax); //获取线程池中辅助线程的最小数量(workerThreadsMin)和线程池中异步I/O线程的最小数量(completionPortThreadsMin) ThreadPool.GetMinThreads(out int workerThreadsMin, out int completionPortThreadsMin); //设置最大线程数量 和 设置最小线程数量，在进程内是全局的。在一个地方设置了，后面所有的请求中都是这个数量了 //委托异步调用、Task、Parallel、async/await 都使用的是线程池的线程； new Thread()不受限制，但是会占用线程池的数量。 ThreadPool.SetMaxThreads(12, 12);//不能低于当前电脑的线程数；比如四核八线程，就不能低于8，否则无效 ThreadPool.SetMinThreads(1, 1); //线程等待，需要使用ManualResetEvent来完成 ManualResetEvent mre = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem((obj) =&gt; { DoSomething(\"\"); mre.Set(); } ); mre.WaitOne()； 任务(Task)命名空间：using System.Threading.Tasks特点：Task是基于任务的异步编程模型,Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。建议：使用Task的时候应该尽量结合async和await关键字来使用。避免使用.Result 和 .Wait()来阻塞等待;.Result 和 .Wait()会占用线程资源，直到任务完成；而await的基于异步回调的，不会浪费CPU资源；async和await是语法糖，本质上其实是ContinueWith()。基本语法： 1.创建无返回值Task的三种方式（加上泛形就有返回值） //(1).通过new一个Task对象传入委托函数并启动 Task&lt;int&gt; t1 = new Task&lt;int&gt;(() =&gt; { //用一个参数来控制暂停 while (isRuning){}//todo return 1; }); t1.Start(); //(2).通过Task中的Run静态方法传入委托函数（返回值,后面可以不写） Task t2 = Task.Run&lt;string&gt;(() =&gt; { return \"你好\"; }); //(3).通过Task.Factory中的StartNew静态方法传入委托函数（返回值,可以都不写） Task t3 = Task.Factory.StartNew(() =&gt; { return 4.5f; }); //获取返回值 t3.Result； //注意：Resut获取结果时会阻塞线程，即如果task没有执行完成，会等待task执行完成获取到Result，然后再执行后边的代码,也就是说 执行到这句代码时 由于我们的Task中是死循环，所以主线程就会被卡死 2.同步执行Task（只做了解） //如果你希望Task能够同步执行 //只需要调用Task对象中的RunSynchronously方法 //注意：需要使用 new Task对象的方式，因为Run和StartNew在创建时就会启动 Task t = new Task(() =&gt; { Thread.Sleep(1000); }); t.RunSynchronously(); 3.Task中线程阻塞的方式（任务阻塞） //(1).Wait成员方法，主线程只有等调用方线程执行完毕才能继续执行 t3.Wait(); //(2).WaitAny静态方法：传入任务中任意一个任务结束就继续执行 Task.WaitAny(); //(3).WaitAll静态方法：任务列表中所有任务执行结束就继续执行 Task.WaitAll(); 4.Task完成后继续其它Task（任务延续） //(1).WhenAll静态方法 + ContinueWith方法：传入任务完毕后再执行某任务 Task.WhenAll(t1, t2).ContinueWith((t) =&gt;{}); //(2).WhenAny静态方法 + ContinueWith方法：传入任务只要有一个执行完毕后再执行某任务 Task.WhenAny(t1, t2).ContinueWith((t) =&gt;{}); 5.取消Task执行 //(1).方法一：通过加入bool标识 控制线程内死循环的结束 //(2).方法二：通过CancellationTokenSource取消标识源类 来控制 //CancellationTokenSource对象可以达到延迟取消、取消回调等功能 CancellationTokenSource c = new CancellationTokenSource(); //取消执行 c.Cancel(); //延迟取消 c.CancelAfter(5000); //取消回调 c.Token.Register(() =&gt;{}); //任务声明 Task.Run(() =&gt; { //设置任务取消参数 while (!c.IsCancellationRequested){} }); 异步方法async/await关键字1.同步和异步说明：需要处理的逻辑严重影响主线程的执行流畅时，我们需要使用异步编程，比如复杂逻辑计算、网络下载、网络通讯、资源加载，同步和异步主要用来修饰方法： 同步方法：同一个方法被调用，调用者需要等待该方法执行完毕后才能继续执行； 异步方法：当一个方法被调用时立即返回，并且获取一个线程执行该方法内部的逻辑，调用者不用等待该方法执行完毕； 2.async和await关键字说明：类似Unity的协程，async和await一般需要配合Task进行使用，async用于修饰函数、lambda表达式、匿名函数，await用于在函数中和async配对使用,主要作用是等待某个逻辑结束，此时逻辑会返回函数外部继续执行，直到等待的内容执行结束后，再继续执行异步函数内部逻辑，在一个async异步函数中可以有多个await等待关键字，如下使用建议说明： async关键字（修饰异步方法）： 在异步方法中使用await关键字（不使用编译器会给出警告但不报错），否则异步方法会以同步方式执行 ; 异步方法名称建议以Async结尾; 异步方法的返回值只能是void、Task、Task&lt;&gt;； 异步方法中不能声明使用ref或out关键字修饰的变量； await关键字（等待异步内容执行完毕）：遇到await关键字时如下流程； (1).异步方法将被挂起； (2).将控制权返回给调用者； (3).当await修饰内容异步执行结束后，继续通过调用者线程执行后面内容； 3.async和await关键字案例 1.复杂逻辑计算（利用Task新开线程进行计算 计算完毕后再使用 比如复杂的寻路算法） public async void CalcPathAsync(GameObject obj, Vector3 endPos) { print(\"开始处理寻路逻辑\"); int value = 10; await Task.Run(() =&gt; { //处理复杂逻辑计算 我这是通过 休眠来模拟 计算的复杂性 Thread.Sleep(1000); value = 50; //是多线程 意味着我们不能在 多线程里 去访问 Unity主线程场景中的对象 //这样写会报错 //print(obj.transform.position); }); print(\"寻路计算完毕 处理逻辑\" + value); obj.transform.position = Vector3.zero; } 2.计时器或者资源加载(Addressables的资源异步加载是可以使用async和await的) public async void Timer() { UnityWebRequest q = UnityWebRequest.Get(\"\"); source = new CancellationTokenSource(); int i = 0; while (!source.IsCancellationRequested) { print(i); await Task.Delay(1000); ++i; } } 4.Unity使用建议：Unity中大部分异步方法是不支持异步关键字async和await的，我们只有使用协同程序进行使用，但是存在第三方的工具（插件）可以让Unity内部的一些异步加载的方法 支持 异步关键字，或者使用.Net 库中提供的一些API时，可以考虑使用异步方法，一般.Net 提供的API中 方法名后面带有 Async的方法 都支持异步方法： Web访问：HttpClient； 文件使用：StreamReader、StreamWriter、JsonSerializer、XmlReader、XmlWriter等等； 图像处理：BitmapEncoder、BitmapDecoder；svermeulen/Unity3dAsyncAwaitUtil: A bunch of code to make using async-await easier in Unity3D (github.com) 预处理器指令什么是编译器源语言程序：某种程序设计语言写的，像c#、c、c++、java等；目标语言程序：计算机可以识别的二进制数程序；编译器：是一种翻译程序(编译原理 )，将源语言程序翻译成目标语言程序； 什么是预处理器指令定义：指导编译器，在实际编译开始时对信息进行预处理，都是以#开始，不是指令，所以不以；结束； 常见的预处理器指令//写在脚本最前面，配合if指令或特性使用1.#define：定义一个符号，类似一个没有值的变量2.#undef：取消define定义的符号3.#if、#elif、#else、#endif：和if语法规则一样，用于告诉编译器进行编译代码的流程控制；4.#warning、#error：告诉编译器是报警告还是报错； 反射和特性程序集：由编译器编译(.exe或者.dll)，供编译执行的中间产物；元数据：数据的数据； 反射概念：程序正在运行时可以查看其他程序集或者自己的元数据这就叫反射；type定义：类的信息类，是访问元数据的主要方式，反射的技术；语法：获取的type指向的内存都是一样的 //1.通过object.GetType()获取对象的Type Type t1=object.GetType(); //2.通过typeof关键字获取类的Type Type t2=typeof(int); //3.通过类名获取，但是必须有命名空间 Type p3=Type.GetType(\"System.Int32\"); //程序集获取 t1.Assembly; //获取类的所有公共成员 MemberInfo[] infos=t1.GetMembers(); //获取类所有构造函数并调用 ConstructorInfo[] ctors=t1.GetConstructors(); //获取构造函数传入 Type数组 数组中按顺序是参数类型，执行构造函数传入 object数组 表示按顺序传入的参数； //得到无参构造 ConstructorInfo info =t1.GetConstructor(new Type[]); info.Invoke(null) as 类名; //得到有参构造 ConstructorInfo info =t1.GetConstructor(new Type[]{typeof(int)}); info.Invoke(new object[]{2}) as 类名; //得到所有成员变量 FieldInfo[] fieldINfos=t1.GetFields(); //得到指定名称的公共成员变量 FieldInfo infoj=t1.GetField(\"变量名\")； //通过反射获取变量值 infoj.GetValue(类实例); //通过反射设置变量值 infoj.SetValue(类实例,要赋的值)； //获得类的公共成员方法 MethodInfo[] methods=t1.GetMethods(); //获取指定方法 MethodInfo method=t1.GetMethod(\"方法名\"，new Type[]{反射参数类型同上}); method.Invoke(参数)； 特性定义：本质是个类，可以利用特性类为元数据添加额外信息，之后可以用反射获取这些额外信息，类、变量、函数前都可以添加；自定义特性：继承特性基类 Attribute(使用自定义特性时类名后面会省略Attribute这几个字);语法 //1.定义特性 class 特性类名：Attribute{ } //2.特性使用 [特性名(参数列表)] //类、函数、变量上一行 //3.判断是否使用了某个特性 //参数一：特性的类型 参数二：是否搜索继承链(属性和时间忽略) if(类type类型.IsDefind(typeof(特性类型)，false)){} //4.获取Type元数据中的所有特性 t.GetCustomAttributes(ture); //5.为特性类加特性，限制自定义特性 //参数一：AttributeTargets--特性可以用在哪里 //参数二：AllowMultiple--是否允许多个特性在同一个目标上 //参数三：Inherited--特性是否能被派生类和重写成员继承 [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple=true,Inherited=true)] //6.系统自带特性 //6.1过时特性 [Obsolete(\"过时特性，后面是ture直接报错，否则警告\"，false)] //6.2调用者信息特性 用处不大，省略，用工具就可以了 //6.3条件编译特性 //和#define配套使用，必须有该参数名的预指令符号才会执行修饰成员 using System.Runtime.CompilerServices [Conditional(\"Fun\")] //6.4外部Dll包函数特性 //用来标记非.Net的函数，表明在一个外部的DLL中定义，用来调用c或者c++得DLL包写好的方法 using System.Runtime.InteropServices [DllImport(\"程序集全名\")] public static extern int 外部DLL元数据函数名() 其他补充lock和using语句块lock定义：确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。注意：1.lock不能锁定空值，但Null是不需要被释放的。2.lock不能锁定string类型，虽然它也是引用类型的。因为字符串类型被CLR“暂留”。即整个程序中任何给定字符串都只有一个实例，具有相同内容的字符串都代表着同一个实例。因此，只要在应用程序进程中的任何位置处具有相同内容的字符串上放置了锁，就将锁定应用程序中与该字符串具有相同内容的字符串。因此，最好锁定不会被暂留的私有或受保护成员。 using作用：1.自动释放，避免缓存，内存溢出2.简化try catch 得到在此定义域内自动释放所新建的对象，以简化代码； 协变逆变协变：out逆变：in作用一：用out修饰的泛形只能作为返回值，用in修饰的泛形只能作为参数作用二：用out和in修饰的泛形委托可以i互相装载(有父子关系的委托) //结合里氏替换原则理解 //协变 父类总是能被子类替代 TestOut&lt;Son&gt; os=()=&gt;{ } TestOut&lt;Father&gt; of=os;//参数必须声明out of();//实际上os装的函数返回的是Son的 //逆变 子类装父类委托 TestIn&lt;Father&gt; of=()=&gt;{ } TestIn&lt;Son&gt; os=of;//参数必须声明in os();//实际上os装的函数返回的是Father的 迭代器(iterator)概念：又称为光标(cursor)，是程序设计的软件设计模式，是可以在遍历访问的接口，设计人员无需关心容器的内存细节，能用foreach遍历的类，都实现了迭代器；关键接口：IEnumerator(迭代器实现),IEnumerable(foreach实现，有方法即可);命名空间：using System.Collections;yield return：是c#提供的语法糖(糖衣语法)，可以将复杂逻辑简单化，增加程序可读性，yield关键字可以理解为暂时返回，保留当前状态； 特殊语法# 隐藏类型var 可以用来表示任何类型的变量，一般用来临时变量，但是不能再更改类型。 # 设置对象初始值 可以直接通过大括号来进行赋值。 # 设置集合初始值 可以直接通过大括号来进行赋值。 # 匿名类型 var变量可声明为自定义的匿名类型，但是只能有变量。语法 var v=new {age=10,name=\"小明}; # 可空类型//1.数值类型使用，声明时再值类型后面加？可以赋值为空 int? lue=null; //又如 int[] os=null; int? x=os?[0]; //2.引用类型使用，相当于一种语法糖，自动判断是否为空,例如判断委托是否为不为空才执行 o?Invoke(); //3.判断值类型是否为空 值变量名.HasValue； //4.安全获取值类型默认值(可以指定默认值) 值变量名.GetValueOrDefault(默认值); # 空和并操作符定义：左边值？？右边值，左边为null返回右边值，否则左边； # 内插字符串 用关键字$，类似于Format拼接字符串。语法 Console.WriteLine($\"你好，{name}”); # 单句逻辑简略写法 逻辑语句只有一句代码的话可以省略{}，而属性只有一句getset可以写成get=&gt;返回值;set=&gt;变量名=要赋的值，方法同理。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"C#核心","slug":"02003-C#核心","date":"2019-07-15T13:00:00.000Z","updated":"2022-03-03T07:45:15.887Z","comments":true,"path":"posts/1027.html","link":"","permalink":"https://wwy.wwywy.com/posts/1027.html","excerpt":"","text":"面向对象基本概念其他编程方式：面向过程编程；三大特征：封装+继承+多态；七大原则：1.单一原则：一个类只处理自己应该处理的。应该各司其职，例如把每个移动技能都尽量写出一个类，方便修改。2.开闭原则：新功能尽量是加处理而不是改代码。继承就是最明显的开闭原则，不要修改模板的内容，例如定义属性要用方法定义， getset，方便修改，修改类时或者改别人的方法，不清楚逻辑的就再写一个类。3.依赖倒置原则：不依赖于具体实现，要依赖抽象(接口)。要依赖于抽象，不要依赖于具体实现，可以先了解需求，再画图，最后变成代码。4.接口隔离原则：一个接口一个行为。接口里的单一原则，需要分的事件要分清楚。5.里氏替换原则：用父类容器装载子类，任何地方子类都能替换父类。不要修改别人的代码，可以继承他的代码去重写(注：多态：父类的指针指向子类，而调用子类的方法)6.合成复用原则：尽量用组合复用的形式。继承关系中，父类要可以解决子类共同的问题，子类时解决特与的问题，能用现有的类，就别再自己创建类。7.迪米特法则：一个类尽量减少对别的类引用。又叫最少知识原则，减少耦合性，类自己能解决的，尽量不要牵扯别的类，比如A类引用B类的方法，但是B类方法参数改了，A类也要改。 面向对象三特征-封装一般类定义： 类和对象class 类名{ 类名 对象名=new 类名; } 类一般成员和封装成员变量：成员变量是声明在类中的变量，可以是任意类型；成员方法(函数)：类的成员函数是一个在类定义中有它的定义或原型的函数;访问修饰符种类：public(接口成员、命名空间、枚举默认)、private(类成员)、protected、internal(类、结构、接口、委托默认)； 构造函数构造函数：类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行，构造函数的名称与类的名称完全相同，它没有任何返回类型默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，以下是它的特殊写法： public 类名(参数1，参数2):this(参数1){ //默认会先调用无参构造(this)或者父类构造函数(换成base) } ##析构函数析构函数：类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行，析构函数的名称是在类的名称前加上一个波浪形(~)作为前缀，它不返回值，也不带任何参数，析构函数用于在结束程序(比如关闭文件、释放内存等)之前释放资源，就是当引用类型的堆被回收时被调用，析构函数不能继承或重载。 垃圾回收机制定义:简称GC，当堆(Heap)中的变量没有被任何对象引用时，就会被自动回收；算法：引用计数、标记清除、标记整理、复制集合；注意事项：GC只负责堆的垃圾回收,而栈(stack)的内存时系统自动管理的，值类型有自己的生命周期，会自动分配和释放；原理：C#会把堆中的内存分为0代内存、1代内存、2代内存(代是分代算法，代系数越大速度越慢，内存越大)，新分配的对象会配置在0代内存，每次分配都可能会进行垃圾回收释放内存(0代内存或者1代内存满时)，垃圾回收机制确认堆中的垃圾，首先会标记对象，发现是否有引用，标记后可达对象，未标记未不可达对象(垃圾)，然后就将对象压缩堆(挂起执行托管代码线程)释放垃圾，搬迁可达对象地址到下一代内存(到第二代内存不会在搬迁)，大对象(83kb以上)总认为是第二代内存。手动触发代码：GC.Collect();一般Loading过场景调用 成员属性语法： 访问修饰符 属性类型 属性名{ 访问修饰符 get{}//自动属性可以省略{} 访问修饰符 set{}//自动属性可以省略{} } 索引器概念:让对象可以像数组一样通过索引访问元素，索引器可以重载；语法： 访问修饰符 返回值 this[参数1、参数2]{ get{} set{} } 静态类和静态成员static静态类：不能被实例化，只能有静态成员；静态变量：当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本；静态函数：这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在；静态构造函数：不能使用访问修饰符，不能有参数，使用静态类或者普通类的成员时会自动且仅调用一次； 拓展方法特点：一定是写在静态类，一定是静态函数，第一个参数为拓展目标，第一个参数用this修饰；语法： 访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数1，参数2){ } 运算符重载概念：使用operator关键字让自定义类和结构体可以使用运算符；特点：一定是公告静态方法，返回值在operator前(条件运算要成对出现，一个符号可以多个重载，不能使用ref和out);语法： public static 返回类型 operator 运算符(参数列表){ } 不可重载的运算符:逻辑与&amp;&amp; 、逻辑非||、索引符[]、强转符号()、点.、三目运算符?:、赋值符号=； 内部类和分部类内部类定义:在一个类中再声明一个类，使用时要外部类点出自己；分部类：用partial把类分成几部分,注意访问修饰符要一样;分部方法:用partial将方法声明和实现分离，强制私有，只能在分部类声明，不能有返回值，不能用out关键字； 面向对象三特征-继承继承基本规则语法： class 类名 ：被继承的类{ } 里氏替换原则概念:任何父类出现的地方，子类都可以替代语法: 父类 变量名=new 子类()； ###is关键字定义:判断一个对象是否为指定类对象，返回bool值语法:对象 is 类名 ###as关键字定义:将一个对象转换为指定类对象，没有返回null语法:对象 as 类名 继承中的构造函数特点:实例化时先执行父类构造函数,再执行子类构造函数； 万物之父和装箱拆箱万物之父关键字:object装箱:例如object存储值类型发生，把值类型从栈中迁移到堆中，变成引用类型；拆箱:例如把object转为值类型发生，把引用类型从堆中迁移到栈中，变成值类型； 密封类概念:使用sealed关键字使类无法再被继承； 面向对象三特征-多态vob关键字：virtual(虚函数)和override(重写); 抽象类和抽象方法关键字：abstract(抽象函数)；特点：抽象类不能被实例化，但是遵守里氏替换原则，抽象方法没有方法体； 接口关键字:interface；特点：不包含成员变量，只有抽象方法、属性、索引器、事件，成员不能被实现，不能是私有成员，类可以继承多个接口，接口也遵守里氏替换原则；作用：不作为实体基类,但是可以作为一个行为基类;命名规则:帕斯卡命名法前面加I; ###显示实现接口作用：当实现俩个接口后，其中有相同方法时；语法：用接口名点出方法名; 密封方法关键字:sealed修饰不能再被重写； 面向对象相关知识点命名空间特点：命名空间可以包裹命名空间;语法： namespace 命名空间名{ } 万物之父中的方法静态方法Equals:判断俩个对象是否相等,值类型比较数值，引用类型比较地址;静态方法RefereceEquals：判断俩个对象引用是否相等，主要用于应用类型，值类型返回始终false;普通方法GetType():获取对象运行时的类型(反射相关);普通方法MemberwiseClone：拷贝对象,引用对象指向相同地址;虚方法Equals:相当于RefereceEquals,但是在种类中ValueType中重写了,可以用来比较值相等；虚方法GetHashCode：获取对象哈希值(对象唯一编码，但是也可能u不同对象哈希码一样)；虚方法ToString：返回对象代表的字符串; string注意事项：string大部分方法需要赋值再使用，因为会实例化一个新的字符串；字符串名[]：字符串索引器;(静态)string.Format()：字符串拼接(替代);字符串名.IndexOf()：正向查找字符位置;字符串名.LastIndexOf()：反向查找字符位置;字符串名.Remove()：移除指定位置的字符;字符串名.Replace()：替换指定字符串;字符串名.ToUpper()：字符串全部大写；字符串名.ToLower()：字符串全部小写;字符串名.Substring()：字符串截取；字符串名.Split()：字符串切割； StringBuilder作用：修改字符串而不创建新的对象字符串.Capacity:获取容量；字符串.Append:增；字符串.AppendFormat():拼接；字符串.Insert():插入；字符串.Remove():删；字符串.Clear():清空；索引-字符串[]:用来查和改；str.Replace():替换； 字符串拼接的方式直接通过+拼接 会有性能问题，字符串少还好，越多GC越严重。 通过StringBuilder拼接字符串 字符串数量越多性能相对直接+拼接方法越高。 通过StringBuffer拼接字符串 区别：线程安全版的StringBuilder，但是性能不如StringBuilder; string.Format原理：其底层本质还是StringBuilder来实现的； $方式拼接字符串原理：是string.Format简化版，C#6.0新增操作；语法： string str = $\"my name is{name}, I'm {age} years old\"; 知识拓展多脚本文件.cs：源码文件.sln：解决方案入口文件.dll：编译文件 UML定义：统一建模语言，是面向对象设计的建模语言；理解：可以通过一些UML可视化软件(visio)就可以生成代码；","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"C#基础","slug":"02002-C#基础","date":"2019-07-02T13:00:00.000Z","updated":"2022-03-03T07:45:07.118Z","comments":true,"path":"posts/1026.html","link":"","permalink":"https://wwy.wwywy.com/posts/1026.html","excerpt":"","text":"将之前的笔记记录在博客上 复杂数据类型特点：数据(变量)集合、自定义； 枚举 枚举是一个被命名的整形常量集合,可以声明再命名空间、类和结构体中。 枚举声明enum 变量名{ 名1,//枚举中默认是0下面累加 名2=4,//可以赋值,下面数值接着从此开始 名3 } 枚举的类型转换1.枚举和int互转后是数值的转换2.枚举转换成string是枚举名3.string转换成枚举,必须有这个字符串名的枚举名,实例如下： Enum.Parse(typeof(声明枚举类型名),\"Other\"); 数组 数组是储存一组相同的数值集合,下标从0开始。 一维数组声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1,2,3,4……(第数组长度-1个) }；获取长度：数组名.length; 二维数组声明：变量类型【,】 二维数组名=new 变量类型【行,列】{ { 1,1,1… },{ 1,1,1…. },{ 1,1,1…. }… };获取长度:数组名.length(维度); 交叉数组 即数组的数组。 结构体public struct 结构体名{ 变量类型 变量名 构造函数(可选) 函数 } 结构体和类相同点：1.两者都拥有成员,包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。2.两者的成员都有其各自的存取范围。例如,可以将某一个成员声明为Public,而将另一个成员声明为Private。3.两者都可以实现接口。4.两者都可以公开一个默认属性,然而前提是这个属性至少要取得一个自变量。5.两者都可以声明和触发事件,而且两者都可以声明委托(Delegate)。6.两者都是container类型,这表示它们可以包含其他数据类型作为成员。 区别：1.结构是实值类型(Value Types),而类则是引用类型(Reference Types)。2.结构使用栈存储(Stack Allocation),而类使用堆存储(Heap Allocation)。3.所有结构成员默认都是Public,而类的变量和常量数则默认位Private,不过其他类成员默认都是Public。4.结构成员不能被声明位Protected,而类成员可以。5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化,但是类变量声明可以。6.结构不能声明默认的构造函数,也就是不拥有参数的非共享构造函数,但是类则无此限制。7.二者都可以拥有共享构造函数,结构的共享构造函数不能带有参数,但是类的共享构造函数则可以带或者不带参数。8.结构不允许声明析构函数(Destructor),类则无此限制。9.结构的实例(Instance)声明,不允许对包含的变量进行初始化设定,类则可以在声明类的实例时,同时进行变量初始化。1.结构是隐式继承自ValueType类,而且不能继承任何其他类型,类则可以继续自ValueType以外的任何类。11.结构是无法被继承的,类则可以。12.结构永远不会终止,因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止,当内存回收进程检测到没有任何作用的类时,它就会调用类的Finalize方法。13.结构不需要构造函数,类则需要构造函数。14.结构只能在一种情况下使用非共享构造函数,那就是非共享构造函数会接受参数。但是类则无此限制,它可以使用带参数或不带参数的非共享构造函数。15.每一个结构都具有无参数的隐含公共构造函数,此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上,由于结构是数值类型的,因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的,而且对象变量可引用不同的类实例,在此方面的区别,会对使用将结构和类造成如下的影响：16.结构变量会隐式的使用结构的无参数构造函数来初始化成员,这就意味语句 Struct S = new Struct()。17.当您将一个结构变量赋值给另一个,或者将结构实例传递到程序变量时,所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个,或者将对象变量传递给程序时,则只是复制指针。18.您可以将Null值赋值给结构变量,但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化,但是您还是可以调用变量的方法并访问其数据成员。相反的,如果您将对象变量设定为Null,您就会中断它与任何类型实例的关联,而且除非您再将另一个实例赋值给它,否则无法通过变量访问任何成员。19.您可以在不同时间将不同的类的实例赋值给同一个对象变量,而且在同一时间可有好几个对象变量引用相同的类实例,如果您对类成员值做了改变,则其他指向相同实例的对象变量也会发生改变。然而,结构成员则会封装在他们自己的实例中,变更结构成员值并不会对其他任何结构变量的成员造成影响,甚至也不会影响相同结构声明的其他实例。20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。 如何选择结构还是类:1.堆栈的空间有限,对于大量的逻辑的对象,创建类要比创建结构好一些2.结构表示如点、矩形和颜色这样的轻量对象,例如,如果声明一个含有 1000 个点对象的数组,则将为引用每个对象分配附加的内存。在此情况下,结构的成本较低。3.在表现抽象和多级别的对象层次时,类是最好的选择。4.大多数情况下该类型只是一些数据时,结构时最佳的选择。 值类型和引用类型值类型 其他类型、结构体；存储位置：栈空间–系统分配,自动回收,小而快特点：在赋值时,把内容拷贝给对方,它变我不变,内存地址不变。 引用类型 string、数组、类存储位置：手动申请和释放,大而慢特点：在赋值时,让俩者指向一个值,它变我也变,指向堆中相同内存地址。 特殊引用类型string string在赋值时也会再分配一个内存空间。 函数 函数可以写在类中和结构体中。 函数基础基本语法：static 返回类型 函数名(参数类型 参数名1….){ 代码逻辑；return 返回值 } ref和out 在函数内部传入,里面变了,外面也变了。声明：函数参数的修饰符；区别：ref传入的参数必须初始化,out传入的变量必须在内部赋值； 变长参数和参数默认值变长参数声明：params 变量类型[] 变量名；参数默认值：可选参数,在方法声明时就进行赋值,可选参数必须写在普通参数后面； 函数重载定义：重载和返回值无关,和参数类型、个数、顺序有关； 递归函数定义：就是让函数自己调用自己,但是需要留出出口,否则就是死循环","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"C#入门","slug":"02001-C#入门","date":"2019-06-18T13:00:00.000Z","updated":"2022-03-22T07:19:52.717Z","comments":true,"path":"posts/1025.html","link":"","permalink":"https://wwy.wwywy.com/posts/1025.html","excerpt":"","text":"将之前的笔记记录在博客上 C#基础知识主流语言的应用领域C: 嵌入式硬件开发C++: 游戏客户端、服务器、软件C#: 游戏客户端、服务器、软件、网站 Java: 安卓、服务器、软件、网站JavaScript: H5游戏、网站、服务器PHP: 网站、服务器Python: 网站、服务器、辅助开发 SQL: 数据库Go: 服务器Objective-C: 苹果(mac、ios)相关Swift: 苹果(mac、ios)相关 开发环境搭建IDE是什么IDE(Integrated Development Environment )集成开发环境它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代码命令，听从你的指令和你进行交流。 常用的IDE(集成开发环境)软件Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;Android Studio: 谷歌推出，主要用于开发安卓应用;Xcode:苹果推出，主要用于开发苹果应用; 第一个应用程序理解写代码这件事通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算机通过这些命令来执行一些行为，从而实现一些特定的需求。比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能够动起来 注释的三种方式1.两杠注释:用于注释一行信息2.星号注释:用于注释多行信息3.三杠注释:用于注释类、命名空间等 快捷注释的方法1.上方工具栏2.快捷键CTRL + K + C 注释CTRL + K + U 取消注释 折叠代码由#region #endregion配对出现 控制台输入打印语句Console.Write():输出 Console.WriteLine:换行输出 Console.ReadKey:检测用户按下 Console.ReadLine:用户输入回车 变量变量类型有符号的整形变量sbyte: -128-127(字节占1);short: -32768-32767(字节占2);int: -21亿-21亿多(字节占4);long: -9百万兆-9百万兆(字节占8); 无符号的整数变量byte:0-255(字节占1);ushort: 0-65535(字节占2);uint: 0-42亿多(字节占4);ulong: 0-18百万兆(字节占8); 浮点型float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;double:(字节占8) 存储15-17位有效数字;decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; 特殊类型bool:非真即假(字节占1);char:存储单个字符(字节占2);string:存储多个字符，没有上限(长度可变); 变量的本质 数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000通过sizeof获取变量占用的内存空间(例如:sizeof(int);;1byte=8bit;1kb=1024byte;1mb=1024kb;1gb=1024mb;1tb=1024gb; 进制转换(整数，左侧第一位表示符号)十进制转二进制:不停除2;二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0); 命名规则1.不能重名;2.不能以数字开头;3.不能是关键字;4.不能有特殊符号(下划线除外); 驼峰命名法(变量)、帕斯卡命名法(函数、类) 常量关键字const，必须初始化，不能被修改。 转义字符 是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行 固定写法常用的转义字符':单引号;\":双引号\\n:换行\\:斜杠 不常用的转义字符\\t:制表符(空一个tab键)\\b:光标退格\\0:空字符\\a:警告音 取消转义字符 在字符串前面加一个@(例如@”\\你好\") 类型转换 不同变量类型之间的相互转换 隐式转换 不同类型之间的自动转换，大范围转小范围 相同大类型之间的转换 特殊类型不存在隐式转换 不同大类型之间的转换无符号和有符号之间 有符号的变量不能隐式转换无符号的; 无符号的变量隐式转换有符号的前提是范围一定是涵盖的; 浮点数和整数之间 浮点数可以转任何类型整数; 整数不能转换浮点型(不能存小数); 特殊类型和其他类型 char类型可以隐式转换成整数和浮点型(ASCII码); bool和string不能和其他类型互相转换; 显示转换 手动转换。 括号强转 小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。 Parse法 把字符串类型转换成对应类型，前提能转换，否则报错。语法:变量类型.Parse(“字符串”) Convert法 更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。语法:Convert.To目标类型(变量或者常量) 其他类型转string作用:拼接打印;语法:变量.ToString(); 异常捕获 避免程序报错造成卡死 try{ }catch{ }finally{ } 运算符算数运算符赋值运算符:=算数运算符:+ - * / %复合运算符:+= -+ *= /= %=自增运算符:a++(先用再加) ++a(先加再用) 运算符的优先级1.乘除大于加减;2.括号优先; 字符串拼接方法一:+号拼接;方法二:string.Format(“{0}”，18);控制台打印拼接:支持类似方法二; 条件运算符 只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。条件运算符:&gt; &lt; == != &gt;= &lt;=; 逻辑运算符逻辑运算符:&amp;&amp; || ! 运算符优先级 ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。 位运算符位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)位或:|(有1则1)异或:^(对位运算，相同为0，不同为1)位取反:~(0变1，1变0，反码补码问题)左右移:&lt;&lt;(左移几位，右边加几个0) &gt;&gt;(右移几位，右边去几个数) 三目运算符语法:空位(bool类型)？空位:空位; 条件分支语句if语句if(){ }else if(){ }else{ } switch语句switch(){ case 变量: break; default: break; } 循环语句while循环while(循环跳出条件){ } do-while循环do{ }while(); for循环for(int i=1;i&lt;条件;i++){ } foreach循环foreach(var i in 集合需要继承自一个接口){ } 知识补充控制台相关1.Console.Readkey().Keycahr-可以保存输入的字符;2.Console.Clear()-清空控制台;3.Console.SetWindowSize(宽，高);4.Console.SetBufferSize(宽，高)-缓冲区大小;5.Console.SetCursorPosition(x，y)-设置光标的位置6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear8.Console.CursorVisiable=false-设置光标显隐9.Environment.Exit(0)-关闭控制台 随机数语法:Random 变量名=new Random();生成非负数:变量名.Next(最小到最大，范围不包括最大);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"}]},{"title":"Unity进阶-Timeline","slug":"03012-Unity进阶-Timeline","date":"2010-11-13T13:00:00.000Z","updated":"2022-07-09T16:16:59.859Z","comments":true,"path":"posts/1546.html","link":"","permalink":"https://wwy.wwywy.com/posts/1546.html","excerpt":"","text":"待写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Timeline","slug":"Timeline","permalink":"https://wwy.wwywy.com/tags/Timeline/"}]},{"title":"Unity进阶-Cinemachine","slug":"03017-Unity进阶-Cinemachine","date":"2010-11-13T13:00:00.000Z","updated":"2022-07-10T03:21:20.087Z","comments":true,"path":"posts/1551.html","link":"","permalink":"https://wwy.wwywy.com/posts/1551.html","excerpt":"","text":"Cinemachine介绍Cinemachine","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Cinemachine","slug":"Cinemachine","permalink":"https://wwy.wwywy.com/tags/Cinemachine/"}]},{"title":"Lua语言","slug":"02900-Lua语言","date":"2010-10-28T13:00:00.000Z","updated":"2022-07-09T16:15:19.934Z","comments":true,"path":"posts/02900.html","link":"","permalink":"https://wwy.wwywy.com/posts/02900.html","excerpt":"","text":"待写","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"编程语言/Lua","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"}],"tags":[{"name":"Lua","slug":"Lua","permalink":"https://wwy.wwywy.com/tags/Lua/"}]},{"title":"Unity插件-Odin","slug":"03052-Unity插件-Odin","date":"2010-10-28T13:00:00.000Z","updated":"2022-07-11T03:13:58.831Z","comments":true,"path":"posts/1578.html","link":"","permalink":"https://wwy.wwywy.com/posts/1578.html","excerpt":"","text":"待写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Odin","slug":"Odin","permalink":"https://wwy.wwywy.com/tags/Odin/"},{"name":"编辑器","slug":"编辑器","permalink":"https://wwy.wwywy.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"游戏同步方案","slug":"04201-游戏同步方案","date":"2010-10-12T13:00:00.000Z","updated":"2022-07-09T16:21:24.161Z","comments":true,"path":"posts/2177.html","link":"","permalink":"https://wwy.wwywy.com/posts/2177.html","excerpt":"","text":"帧同步方案","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"同步技术","slug":"Game-Play/同步技术","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"}]},{"title":"Huatuo热更新技术","slug":"04152-Huotuo热更新技术","date":"2010-07-13T13:00:00.000Z","updated":"2022-07-15T15:17:22.564Z","comments":true,"path":"posts/ab0725a2.html","link":"","permalink":"https://wwy.wwywy.com/posts/ab0725a2.html","excerpt":"","text":"待写","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"热更新","slug":"Game-Play/技术架构/热更新","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"热更新","slug":"热更新","permalink":"https://wwy.wwywy.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"Huatuo","slug":"Huatuo","permalink":"https://wwy.wwywy.com/tags/Huatuo/"}]},{"title":"定点数数学库","slug":"04202-定点数数学库","date":"2010-03-01T13:00:00.000Z","updated":"2022-07-10T03:23:59.200Z","comments":true,"path":"posts/2178.html","link":"","permalink":"https://wwy.wwywy.com/posts/2178.html","excerpt":"","text":"定点数FInt基本思路：解决浮点数的精度问题，基本想法是对数学库进行放大倍数，放大1000，这里可以对底层进行优化，使用位运算来直接操作二进制进行放大缩小，这里可以放大1024倍，也就是1&lt;&lt;10，使用完之后在缩小1024倍还原即可;乘法还原正负不同问题：按照上面的流程，乘法运算后绝对值相同的正负数值经过还原后会出现不对等的问题，比如500乘FInt(0.3f)的RawInt值是是14，但是500乘FInt(-0.3f)的RawInt值却是-15，这是因为二进制中，正数由原码表示，负数由补码表示，补码是在原码的反码上再加一得来的，要简单的解决这一个问题可以对值进行取反运算再取反，让已经实现好的底层去解决； 定点向量FVector3常用运算FCalc","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"第三方库","slug":"Game-Play/第三方库","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"第三方库","slug":"第三方库","permalink":"https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"定点数数学库","slug":"定点数数学库","permalink":"https://wwy.wwywy.com/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"}]},{"title":"确定性物理库","slug":"04203-确定性物理库","date":"2010-03-01T13:00:00.000Z","updated":"2022-07-10T03:23:04.435Z","comments":true,"path":"posts/2179.html","link":"","permalink":"https://wwy.wwywy.com/posts/2179.html","excerpt":"","text":"待写","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"第三方库","slug":"Game-Play/第三方库","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"}],"tags":[{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"第三方库","slug":"第三方库","permalink":"https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"确定性物理库","slug":"确定性物理库","permalink":"https://wwy.wwywy.com/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"}]},{"title":"Unity相关-角色换装","slug":"03100-Unity相关-角色换装","date":"2010-02-18T13:00:00.000Z","updated":"2022-07-09T16:19:52.129Z","comments":true,"path":"posts/1600.html","link":"","permalink":"https://wwy.wwywy.com/posts/1600.html","excerpt":"","text":"待写","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"换装","slug":"换装","permalink":"https://wwy.wwywy.com/tags/%E6%8D%A2%E8%A3%85/"}]},{"title":"Protobuf详解","slug":"02050-Protobuf详解","date":"2010-01-01T13:00:00.000Z","updated":"2022-07-10T03:25:38.799Z","comments":true,"path":"posts/1064.html","link":"","permalink":"https://wwy.wwywy.com/posts/1064.html","excerpt":"","text":"待写","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Protobuf","slug":"编程语言/C/Protobuf","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Protobuf/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"},{"name":"Protobuf","slug":"Protobuf","permalink":"https://wwy.wwywy.com/tags/Protobuf/"}]},{"title":"游戏架构设计","slug":"04003-游戏架构设计","date":"2010-01-01T13:00:00.000Z","updated":"2022-07-10T03:09:05.531Z","comments":true,"path":"posts/2051.html","link":"","permalink":"https://wwy.wwywy.com/posts/2051.html","excerpt":"","text":"待写","categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]}],"categories":[{"name":"Game-Play","slug":"Game-Play","permalink":"https://wwy.wwywy.com/categories/Game-Play/"},{"name":"技术架构","slug":"Game-Play/技术架构","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"工具链","slug":"Game-Play/技术架构/工具链","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E5%B7%A5%E5%85%B7%E9%93%BE/"},{"name":"热更新","slug":"Game-Play/技术架构/热更新","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"其他","slug":"其他","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"为人处世","slug":"其他/为人处世","permalink":"https://wwy.wwywy.com/categories/%E5%85%B6%E4%BB%96/%E4%B8%BA%E4%BA%BA%E5%A4%84%E4%B8%96/"},{"name":"大学知识","slug":"大学知识","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"CS基础","slug":"大学知识/CS基础","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/"},{"name":"编译原理","slug":"大学知识/CS基础/编译原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"其他","slug":"游戏引擎/Unity/其他","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E5%85%B6%E4%BB%96/"},{"name":"插件","slug":"游戏引擎/Unity/插件","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%8F%92%E4%BB%B6/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"UnityEditor","slug":"游戏引擎/Unity/UnityEditor","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/UnityEditor/"},{"name":"数据结构和算法","slug":"大学知识/CS基础/数据结构和算法","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"编程语言","slug":"编程语言","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"人工智能","slug":"大学知识/CS基础/人工智能","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"AI","slug":"Game-Play/AI","permalink":"https://wwy.wwywy.com/categories/Game-Play/AI/"},{"name":"C++","slug":"编程语言/C","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"计算机操作系统","slug":"大学知识/CS基础/计算机操作系统","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Python","slug":"编程语言/Python","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"https://wwy.wwywy.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"计算机网络技术","slug":"大学知识/CS基础/计算机网络技术","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"计算机组成原理","slug":"大学知识/CS基础/计算机组成原理","permalink":"https://wwy.wwywy.com/categories/%E5%A4%A7%E5%AD%A6%E7%9F%A5%E8%AF%86/CS%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"Lua","slug":"编程语言/Lua","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"同步技术","slug":"Game-Play/同步技术","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/"},{"name":"第三方库","slug":"Game-Play/第三方库","permalink":"https://wwy.wwywy.com/categories/Game-Play/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"Protobuf","slug":"编程语言/C/Protobuf","permalink":"https://wwy.wwywy.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Protobuf/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://wwy.wwywy.com/tags/Unity/"},{"name":"Json","slug":"Json","permalink":"https://wwy.wwywy.com/tags/Json/"},{"name":"Excel","slug":"Excel","permalink":"https://wwy.wwywy.com/tags/Excel/"},{"name":"Xml","slug":"Xml","permalink":"https://wwy.wwywy.com/tags/Xml/"},{"name":"Luban","slug":"Luban","permalink":"https://wwy.wwywy.com/tags/Luban/"},{"name":"热更新","slug":"热更新","permalink":"https://wwy.wwywy.com/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"ILRuntimes","slug":"ILRuntimes","permalink":"https://wwy.wwywy.com/tags/ILRuntimes/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"https://wwy.wwywy.com/tags/AssetBundle/"},{"name":"YooAsset","slug":"YooAsset","permalink":"https://wwy.wwywy.com/tags/YooAsset/"},{"name":"资源加载","slug":"资源加载","permalink":"https://wwy.wwywy.com/tags/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"},{"name":"情商","slug":"情商","permalink":"https://wwy.wwywy.com/tags/%E6%83%85%E5%95%86/"},{"name":"编译原理","slug":"编译原理","permalink":"https://wwy.wwywy.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"mono","slug":"mono","permalink":"https://wwy.wwywy.com/tags/mono/"},{"name":".Net","slug":"Net","permalink":"https://wwy.wwywy.com/tags/Net/"},{"name":"Animancer","slug":"Animancer","permalink":"https://wwy.wwywy.com/tags/Animancer/"},{"name":"Playable","slug":"Playable","permalink":"https://wwy.wwywy.com/tags/Playable/"},{"name":"游戏框架","slug":"游戏框架","permalink":"https://wwy.wwywy.com/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"ET","slug":"ET","permalink":"https://wwy.wwywy.com/tags/ET/"},{"name":"FairyGUI","slug":"FairyGUI","permalink":"https://wwy.wwywy.com/tags/FairyGUI/"},{"name":"UnityEditor","slug":"UnityEditor","permalink":"https://wwy.wwywy.com/tags/UnityEditor/"},{"name":"InputSystem","slug":"InputSystem","permalink":"https://wwy.wwywy.com/tags/InputSystem/"},{"name":"Lua","slug":"Lua","permalink":"https://wwy.wwywy.com/tags/Lua/"},{"name":"xLua","slug":"xLua","permalink":"https://wwy.wwywy.com/tags/xLua/"},{"name":"toLua","slug":"toLua","permalink":"https://wwy.wwywy.com/tags/toLua/"},{"name":"Markdown","slug":"Markdown","permalink":"https://wwy.wwywy.com/tags/Markdown/"},{"name":"Addressables","slug":"Addressables","permalink":"https://wwy.wwywy.com/tags/Addressables/"},{"name":"Git","slug":"Git","permalink":"https://wwy.wwywy.com/tags/Git/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"MVC","slug":"MVC","permalink":"https://wwy.wwywy.com/tags/MVC/"},{"name":"C#","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"},{"name":"ScriptableObject","slug":"ScriptableObject","permalink":"https://wwy.wwywy.com/tags/ScriptableObject/"},{"name":"人工智能","slug":"人工智能","permalink":"https://wwy.wwywy.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"AI","slug":"AI","permalink":"https://wwy.wwywy.com/tags/AI/"},{"name":"Behavior-Tree","slug":"Behavior-Tree","permalink":"https://wwy.wwywy.com/tags/Behavior-Tree/"},{"name":"C++","slug":"C","permalink":"https://wwy.wwywy.com/tags/C/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Python","slug":"Python","permalink":"https://wwy.wwywy.com/tags/Python/"},{"name":"数据持久化","slug":"数据持久化","permalink":"https://wwy.wwywy.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"二进制","slug":"二进制","permalink":"https://wwy.wwywy.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"XML","slug":"XML","permalink":"https://wwy.wwywy.com/tags/XML/"},{"name":"计算机网络技术","slug":"计算机网络技术","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"GUI","slug":"GUI","permalink":"https://wwy.wwywy.com/tags/GUI/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"https://wwy.wwywy.com/tags/PlayerPrefs/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://wwy.wwywy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"UGUI","slug":"UGUI","permalink":"https://wwy.wwywy.com/tags/UGUI/"},{"name":"Timeline","slug":"Timeline","permalink":"https://wwy.wwywy.com/tags/Timeline/"},{"name":"Cinemachine","slug":"Cinemachine","permalink":"https://wwy.wwywy.com/tags/Cinemachine/"},{"name":"Odin","slug":"Odin","permalink":"https://wwy.wwywy.com/tags/Odin/"},{"name":"编辑器","slug":"编辑器","permalink":"https://wwy.wwywy.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"帧同步","slug":"帧同步","permalink":"https://wwy.wwywy.com/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"name":"Huatuo","slug":"Huatuo","permalink":"https://wwy.wwywy.com/tags/Huatuo/"},{"name":"第三方库","slug":"第三方库","permalink":"https://wwy.wwywy.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"定点数数学库","slug":"定点数数学库","permalink":"https://wwy.wwywy.com/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E6%95%B0%E5%AD%A6%E5%BA%93/"},{"name":"确定性物理库","slug":"确定性物理库","permalink":"https://wwy.wwywy.com/tags/%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%89%A9%E7%90%86%E5%BA%93/"},{"name":"换装","slug":"换装","permalink":"https://wwy.wwywy.com/tags/%E6%8D%A2%E8%A3%85/"},{"name":"Protobuf","slug":"Protobuf","permalink":"https://wwy.wwywy.com/tags/Protobuf/"}]}