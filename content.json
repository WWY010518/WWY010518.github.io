{"meta":{"title":"憨憨","subtitle":"憨憨の博客","description":"故事总需要个起点","author":"憨憨","url":"http://wwy010518.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-01-22T04:07:31.290Z","comments":false,"path":"about/index.html","permalink":"http://wwy010518.github.io/about/index.html","excerpt":"","text":"憨憨“ 不要惧怕别人的偏见、认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：憨憨的个人空间 QQ：3179342661 座右铭：保持初心，漫步远方"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"http://wwy010518.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"http://wwy010518.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"http://wwy010518.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"http://wwy010518.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"http://wwy010518.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"http://wwy010518.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"http://wwy010518.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"相册","date":"2022-01-22T03:16:54.165Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"http://wwy010518.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2021-07-26T07:32:21.052Z","comments":false,"path":"List/music/index.html","permalink":"http://wwy010518.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2021-09-28T16:44:43.445Z","comments":false,"path":"List/gallery/ohmygirl/index.html","permalink":"http://wwy010518.github.io/List/gallery/ohmygirl/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://wwy010518.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"ET框架笔记","slug":"04001-ET框架笔记","date":"2022-01-24T13:00:00.000Z","updated":"2022-01-24T14:59:49.759Z","comments":true,"path":"posts/2049.html","link":"","permalink":"http://wwy010518.github.io/posts/2049.html","excerpt":"","text":"ET框架笔记","categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ET","slug":"ET","permalink":"http://wwy010518.github.io/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"计算机操作系统原理笔记","slug":"01001-计算机操作系统","date":"2022-01-08T13:00:00.000Z","updated":"2022-01-24T15:05:15.066Z","comments":true,"path":"posts/513.html","link":"","permalink":"http://wwy010518.github.io/posts/513.html","excerpt":"","text":"1 操作系统绪论1.1 操作系统概念定义：操作系统是计算机系统中的一个系统软件，操作系统是管理和控制计算机操作系统中的硬件和软件资源，利用这些资源来组织计算机的工作流程，为用户提供一个足够功能、使用方法、可扩展、可管理、安全的工作环境，是用户和计算机之间的一个接口。 特征：并发、共享、虚拟、异步。 1.2 操作系统发展历程手工操作(无操作系统)—单道批处理—多道批处理—分时系统—实时系统—微机操作系统的发展。 1.2.1单道批处理原理：计算机自动的一个接一个的处理作业，直到磁带上所有的作业都完成，虽然对作业的处理是成批的，但是内存中只有一个作业。 特征：内存中一道程序数目、独占CPU、没有作业和进程调度、程序次序严格对应。 1.2.2多道批处理原理：用户提交的作业存放在外存上，并排成一个队列，作业调度程序根据一定的算法，选择若干的作业调入内存，使它们共享CPU和内存资源。 特征：内存中多道程序、交替占用CPU、需要作业和进程调度、程序次序不严格对应。 1.2.3分时系统特征：多路性、独立性、及时性、交互性。 1.2.4实时系统特征：多路性、独立性、及时性、交互性、可靠性。 2 操作系统用户界面2.1 作业定义：分用户和系统角度去理解 a) 用户：在一次应用处理过程中，从输入到输出结束，用户要求计算机所作有关该次业务处理的全部工作称为一个作业； b) 系统：作业=程序+数据(作业体)+作业说明书(作业控制语言JCL) 2.2 一般用户输入输出方式2.2.1联机输入输出方式2.2.2脱机输入输出方式2.2.3直接耦合方式2.2.4Spooling系统原理：todo。 特点：系统把作业处理的全过程分为相对独立的三部分—输入流、处理流、输出流。 2.2.5网络联机方式2.3 系统调用定义：系统调用是操作系统留给编程人员的唯一接口。 原理：todo 2.3.1系统调用指令int和trap指令进行系统调用。 call和jmp指令进入普通过程调用(子调用)。 3 进程管理3.1 进程的概念组成：进程=程序+数据+进程控制块(进程状态信息PCB) 定义：进程是程序的一次执行活动，一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。 目的：对应的虚拟处理机、虚拟存储器和虚拟外设等资源的分配和回收；反映了系统中程序执行的并发性、随机性和共享性； 优缺点：引用了多线程，提高了对硬件资源的利用率，但又带来了额外的空间和时间开销，增加了os的复杂性。 3.2 进程和程序的区别a) 进程是动态的，程序是静态的； b) 进程是暂时的，程序是永久的； c) 组成不同，进程的组成包括程序； d) 对应关系不同，通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包含多个程序； e) 进程可以并行，具有独立性、异步性。 f) 进程是竞争计算机资源的基本单位。 3.3 进程控制块(PCB)进程控制块包含了有关进程的以下4个信息，是进程动态特征的集中反映。 3.3.1描述信息3.3.2控制信息3.3.3资源管理信息3.3.4CPU保护现场结构3.4 进程上下文切换原因：进程中断、超时、进程调用。 步骤： a) 保存被切换进程的正文部分到有关存储区。 b) 进程有关调度和资源分配程序执行，选取新的进程。 c) 新进程正文部分从存储区取出，激活选中进程执行。 3.5 进程的状态和进程转换3.5.1进程状态初始态、执行状态、等待状态、就绪状态、终止状态(例子转转火锅：想吃(创建)、流动的菜(就绪)、吃(执行)、拿太多(等待)，吃完(终止)) 3.5.2进程状态转换3.6 进程控制3.6.1进程创建和撤销3.6.2进程阻塞和唤醒3.6.3进程的挂起和激活3.7 进程互斥和同步3.7.1临界区和临界资源临界资源是一次仅允许一个进程使用的共享资源。 临界区是每个进程访问临界资源的那段代码。 3.7.2信号量和PV原语信号量是一种卓有成效的进程同步工具，可以用信号量实现互斥。 信号量的数值仅能由P、V原语操作改变。 3.7.3互斥的概念定义：不允许俩个以上的共享该资源的并发进程同时进入临界区称为互斥。 3.7.4同步的概念定义：对相关进程执行次序进行协调后，按照一定规则允许进程共享资源的并发进程称为同步。 3.8 进程通信Todo 3.9 死锁问题3.9.1死锁的概念定义： 如果一组进程中每个进程都在等待由该进程中的其他进程才能引发的事件，那么该组进程就是死锁的。 起因：并发进程的资源竞争 条件：同时具备互斥条件、不剥夺条件、部分分配、环路条件。 3.9.2死锁的解决方案3.9.2.1 死锁预防3.9.2.2 死锁避免最具代表性的避免算法-银行家算法 3.9.2.3 死锁的检测和恢复3.10 线程3.10.1 线程的基本概念定义：引入线程后，线程是操作系统调度和分配的基本单位。 组成：线程=？+线程控制块(TCB) 3.10.2 线程状态和线程控制块(TCB)线程状态：执行状态、就绪状态、阻塞(等待)状态 线程控制块数据结构包括： a) 线程标识符 b) 一组寄存器 c) 线程执行状态 d) 优先级 e) 线程专有存储区 f) 信号屏蔽 g) 堆栈指针 3.10.3 线程和进程的区别从以下六点讨论 a) 调度性：在传统OS中，拥有资源的基本单位，独立调度和分派的基本单位都是进程。在引入线程的OS中，把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位。 b) 并发性：在引入进程的OS中，不仅线程间可以并发执行，而且在一个进程内的多线程间，也可以并发执行。 c) 拥有资源：拥有资源的基本单位一直是进程，线程除了一点在运行中必不可少的资源，本身不拥有系统资源，但它可以共享其隶属进程的资源。 d) 独立性：每个进程都能独立申请资源和独立运行，但是同一进程的多个线程则共享进程的内存地址空间和其他资源，他们之间独立性要比进程之间独立性低。 e) 系统开销：在创建或者撤销进程时，系统都要为之分配和回收进程控制块（PCB）以及其他资源，进程切换时所要保存和设置的现场信息也要明显多于线程。由于隶属于一个进程的多个线程共享同一地址空间，线程间的同步与通讯也比进程简单。 f) 支持多处理机系统：传统的进程只能运行在一个处理机上，多线程的进程，则可以将进程中的多个线程分配到多个处理机上，从而获得更好的并发执行效果。 4 处理机调度4.1 调度层级一个作业提交后，往往会经历三种层级（加线程四种） 4.1.1作业调度又叫宏观调度或者高级调度，用于决定把外存后备队列中的哪些作业调入内存，为他们创建进程，同时作业调度根据他的周转时间等方式来衡量优劣。 4.1.1.1 周转时间相关周转时间=作业完成时间-作业提交时间=作业等待时间+作业执行时间 平均周转时间=所有作业周转时间之和/总作业数 带权周转时间=作业周转时间/作业执行时间 平均带权周转时间=所有带权作业周转时间之和/总作业数 4.1.1.2 响应时间，截止时间和系统吞吐量响应时间是提交请求和返回该请求的响应之间使用的时间截止时间是某任务必须开始执行或者必须完成的最迟时间吞吐量是对单位时间内完成的工作量的量度 4.1.2交换调度又称内存调度或中级调度，它按一定算法将外存中已具备运行条件的进程换入内存，将内存中处于阻塞状态的某些进程换至外存 4.1.3进程调度又叫微观调度或者低级调度，用来决定就绪列表哪个进程获得处理机，并将处理机分配给选择进程，具体有俩种方式 4.1.3.1 非抢占方式一旦进程获得CPU，它将一直执行，直到改进程完成或者发生阻塞时才会把CPU让出来。 4.1.3.2 抢占方式系统可以根据某种原则让一正在执行的进程暂停，并将已分配给他的处理机重新分配给另一个进程 a) 优先权原则：就绪的高优先权进程有权抢占低优先权进程的CPU b) 短作业优先原则：就绪的短进程有权抢占长进程的CPU c) 时间片原则：一个时间片用完后，系统重新进行进程调度 4.1.4线程调度Todo 4.2 作业和进程的关系系统必须为一个作业创建一个根进程；再根据任务要求，系统或者根进程创建相应的子进程；然后为子进程分配资源和任务。 4.3 调度算法宏观调度：先来先服务调度算法、最短作业优先算法、最高响应比优先法。 ​ 微观调度：轮转法、优先级法、多级反馈轮转法。 5 存储管理5.1 存储器结构由内存量由大到小、由访问速度由小到大分别是磁盘缓存、主存输器、高速缓存、寄存器，其中，除寄存器外，其他三者属于主存，而还有相应的辅存，固定磁盘、可移动存储介质。 5.1.1寄存器寄存器具有与处理机相同的速度，对寄存器的访问速度最快，完全能与CPU协作。寄存器主要用于存放处理机运行时数据，加速存储器访问速度。 5.1.2高速缓存它是介于寄存器和存储器之间的存储器，主要用于备份主存中比较常见的数据，减少处理机对主存储器的访问次数。 5.1.3主存输器简称内存或主存，用于保存进程运行时的程序和数据，也叫执行存储器，通常处理机都是从主存储器中取得指令和数据的，并将指令放入指令寄存器中，数据放入数据寄存器中。 5.1.4磁盘缓存目前磁盘I/O远低于对主存的访问速度，为了缓和两者之间在速度上不匹配，设置了磁盘缓存。主要用于暂时存放频繁使用的一部分磁盘数据和信息。 5.2 程序的处理阶段主要有编译，链接，装入，下面主要讲链接和装入。 5.2.1程序的链接源程序经过编译后，可得到一组目标模块。链接程序的功能是将这组目标模块以及它们所需要的库函数装配成一个完整的装入模块。链接又可分为静态链接，装入时动态链接，运行时动态链接。 5.2.2程序的装入分为绝对装入方式，可重定位装入方式，动态运行时的装入方式。 5.3 地址变换5.3.1静态地址重定向原理：Todo这里还没懂，但是静态地址重定向是程序执行之前完成的地址映射工作，静态重定位不需要硬件支持。 5.3.2动态地址重定位关系：MA(物理地址)=BR(基址地址)+VR(虚拟地址)。 原理：动态地址重定向是在程序执行过程中，在CPU访问内存之前，将程序或数据地址转换成内存地址，动态重定向依靠硬件地址变换机构完成。 5.4 分区存储管理分区管理把内存划分成若干大小不等的区域，除操作系统占用一个区域，其余由多道环境下的各并发进程共享，分区管理是满足多道程序设计的一种最简单的存储器方法。 5.4.1固态分区法原理：把内存固定地划分为若干个大小不一的区域，分区规则由系统操作员和操作系统决定，分区一旦划分，在整个执行过程中每个分区的长度和内存的总分区个数将保持不变。 优点:易于实现，开销小。 缺点：内碎片造成浪费；分区总数生成时确定，限制并发执行的程序数目。 5.4.2动态分区法原理：动态分区法在作业执行前不建立分区，在作业的处理过程中随作业或进程对内存的要求而改变。 优点：没有内碎片； 缺点：有外碎片； 算法：根据情况有以下俩种，着重介绍三种 a) 基于顺序搜索的动态分区分配：最先适应算法，最佳适应算法，最坏适应算法，循环最先适应算法 b) 基于索引搜索的动态分区分配：快速适应算法，伙伴系统，哈希算法 5.4.2.2 最先适应法5.4.2.3 最佳适应法5.4.2.4 最坏适应法5.4.3页式管理（离散分配）基本思想：各进程的虚拟空间被划分成若干长度相等的页，同时把内存空间也按页的大小划分为片或者页，大致分为静态页式管理和动态页式管理。 5.4.3.1 静态页式管理原理：在作业或者进程执行之前，把该作业或进程的程序段和数据全部装入各个也页面种，并通过页表和硬件地址变换机构实现虚拟地址到内存物理地址的地址映射。 5.4.3.2 动态页式管理5.4.4段式和段页式管理基本思想：todo 5.4.4.1 段式管理原理：todo 5.4.4.2 段页式管理原理：todo 5.4.5覆盖和交换技术5.5 虚拟存输器5.5.1虚拟存储的实现方式虚拟内存的实现都是建立在离散（动态）分配存储管理方式的基础上。主要有两种实现方式： 5.5.1.1 分页请求系统在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数界面的程序（及数据）即可启动运行，以后再通过调页功能及页面置换功能陆续将即将运行的页面调入内存，同时把不用的页面再换出到外存上。 硬件支持：请求分页的页表机制，缺页中断结构，地址变换机构实现请求分页的软件：包括用于实现请求调页的软件和实现页面置换的软件，在硬件支持下，将程序正在运行时所需的页面（尚未在内存中）调入内存，再将内存中暂时不用的页面从内存置换到磁盘上 5.5.1.2 请求分段系统在分段系统基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统，具体实现原理同分页请求系统，不过载体是“段”不是“页” 5.5.2页面置换算法5.5.2.1 随机淘汰算法随机地选择某个用户地页面并将其换出。 5.5.2.2 最佳置换算法（理想型淘汰算法OPT）其所选择被淘汰的页面将是以后永不使用的，或许是在最长（未来）时间内不再被访问的页面，但是因为未来不可预知，所以该算法不能实现。 5.5.2.3 先进先出置换算法（FIFO）总是先淘汰最先进入内存的页面。 5.5.2.4 最近最久未使用算法（LRU）选择最近最久未使用内存页面进行淘汰。需要较多硬件支持。 5.5.2.5 最少使用置换算法（LFU）在内存为每个页面设置一个移位寄存器记录该页面被访问频率，选择最近时期使用最少的页面作为淘汰页。 5.5.2.6 Clock置换算法是一种LRU算法每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面； 6 文件系统6.1 文件系统基本概念目的：文件系统地出现是为了更好地管理软件资源 文件系统的定义：操作系统中与管理文件有关的软件和数据称为文件系统 文件的定义：文件时一段程序和数据的集合 文件的分类：按文件性质分为系统文件、库文件、用户文件，按组织形式分普通文件、目录文件、特殊文件。 6.2 文件的逻辑结构和存取方式6.2.1逻辑结构字符流的无结构文件：管理简单，但是查找困难，对基本信息单位操作不多的使用于采用这种方式，例如源程序文件、目标代码文件。 记录式的有结构文件：把文件的记录按不同的方式排列，构成不同的逻辑结构，以便于增删改查和管理，常见的有以下四种。 6.2.1.1 连续结构6.2.1.2 多重结构6.2.1.3 转置结构6.2.1.4 顺序结构6.2.2逻辑存储方法6.2.2.1 顺序存输方法6.2.2.2 随机存输方法6.2.2.3 按关键字存输方法多用于复杂文件系统。 6.2.3逻辑搜索方式文件的获取是要找到文件内容所在的逻辑地址 6.2.3.1 线性搜索法6.2.3.2 散列法6.2.3.3 二分搜索法6.3 文件的物理结构和存储设备6.3.1文件物理结构6.3.1.1 连续文件连续文件采用连续分配方式： 特点：为每一个文件分配一组相邻接的盘块;把逻辑文件中的记录顺序地存储到邻接的各物理盘块中;这样形成的文件结构称为顺序文件结构,物理文件称为顺序文件。优点：顺序访问容易; 顺序访问速度快;缺点：要求有连续的存储空间; 必须事先知道文件的长度; 6.3.1.2 串联文件串联文件采用链接分配 特点：文件的信息存放在若干不连续的物理块中；各块之间通过指针连接，前一个物理块指向下一个物理块；可分为隐式链接和显式链接；优点：没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。缺点：存取速度慢，不适于随机存取;可靠性问题，如指针出错;更多的寻道次数和寻道时间;链接指针占用一定的空间; 6.3.1.3 索引文件索引文件采用索引分配 特点：每个文件都有自己的索引块，这是一个磁盘块地址的数组。 6.3.2文件存储设备存储设备有磁盘、光盘、磁带，磁盘分为硬盘和软盘，但近年软盘逐渐被光盘和优盘取代，下面介绍以磁带为代表的顺序存取存储设备和以磁盘为代表的直接存取存储设备。 6.3.2.1 顺序存取存储设备—磁带特点：只有前面的被存取，才能对后面的进行存取；访问时间与记录到磁头的距离成正比；随机存取、关键字存取效率低，但是顺序存储速度块；容量大。 影响因素：信息密度（字符数/英寸）、磁带带速（英寸/秒）、快间间隙。 6.3.2.2 直接存取存储设备—磁盘6.4 文件存储空间管理文件存储空间的管理实质是对空闲块的组织和管理问题，有以下三种空闲管理方式。 6.4.1空闲目录管理6.4.2空闲链块法6.4.3位示图6.5 文件目录管理从文件管理角度看，一个文件包括文件说明和文件体。 6.5.1文件目录的种类6.5.1.1 单级文件目录在整个文件系统中只建立一张目录表，每个文件占一个目录项，目录项中含有文件名、文件扩展名、文件长度、文件类型、文件物理地址以及其他文件属性。 6.5.1.2 两级文件目录目录分为两级：一级称为主文件目录MFD，每个用户目录文件都占有一个目录项，包含用户名和指向该用户子目录的指针；二级称为用户文件目录UFD(又称用户子目录)，给出该用户所有文件的FCB； 6.5.1.3 树形结构目录多级目录结构又称为树型目录结构；主目录称为根目录，数据文件称为树叶，其他目录均作为树的结点； 6.5.2文件目录的共享从系统管理的方式来看，有三种方法可以实现文件共享 6.5.2.1 绕道法6.5.2.2 链接法6.5.2.3 基本文件目录表（BFD）6.5.3目录管理文件目录管理应该存放在磁盘，其他的没理解todo 6.6 文件存取控制用户对文件的存取权限有读、写、执行的许可问题，而验证的方式有以下四种。 6.6.1存取控制矩阵6.6.2存取控制表6.6.3口令方式6.6.4密码方式密码方式是保密性最好的验证方式。 7 设备管理7.1 设备的分类在计算机系统中，除了CPU和内存，其他大部分称为外部设备，它们包括外存设备、输入输出设备、终端设备。 7.2 数据传输控制方式设备管理的主要任务之一是控制设备和内存或CPU之间进行数据传输,常用的数据传输方式有以下四种。 7.2.1程序直接控制方式由用户进程来直接控制内存或者CPU和外围设备之间的信息传送。 7.2.2中断方式I/O操作由程序发起，在操作完成时，由外设向CPU发起中断，通知该程序。数据每次读写通过CPU。 7.2.3DMA方式在外围设备和内存之间开辟直接的数据交换通道。 7.2.4通道控制方式以内存为中心，实现设备和内存直接交换数据的控制的方式。 7.3 中断技术原理：中断是指系统发生紧急事件使CPU暂时中断当前执行程序转而执行相应事件处理，处理完毕后又返回中断处或者调度新进行。 过程：判断中断响应条件—关中断—保存被中断现场—分析中断原因转中断处理子程序—执行中断和处理子程序—恢复现场—开中断—返回中断点 7.3.1中断技术的分类中断一般分为硬中断和软中断，而硬中断又分为外中断和内中断。 7.3.1.1 外中断一般是来自处理机和内存外部的中断 7.3.1.2 内中断（陷阱）一般是来自处理机和内存内部的中断 7.3.1.3 软中断是通信进程之间模拟硬中断的一种信号通信方式 7.4 缓冲技术目的：缓冲的引用时为了解决外围设备和处理机速度不匹配的问题。 分类：缓存技术分为单缓冲、双缓冲、多缓冲以及缓冲池。 7.4.1缓冲池的结构缓冲池由多个缓冲区组成，而一个缓冲区由俩部分组成，一部分用来标识该缓冲器和用来管理管冲首部，一部分用来存放数据的缓冲体。 7.4.2缓冲池管理Todo","categories":[{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Unity相关_FairyGUI","slug":"03006-Unity相关_FairyGUI ","date":"2021-12-12T13:00:00.000Z","updated":"2022-01-25T07:38:29.851Z","comments":true,"path":"posts/1542.html","link":"","permalink":"http://wwy010518.github.io/posts/1542.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity相关_基于Lua的热更新解决方案","slug":"03008-Unity相关_基于Lua的热更新解决方案","date":"2021-10-28T13:00:00.000Z","updated":"2022-01-25T07:38:56.752Z","comments":true,"path":"posts/03008.html","link":"","permalink":"http://wwy010518.github.io/posts/03008.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"http://wwy010518.github.io/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://wwy010518.github.io/tags/AssetBundle/"}]},{"title":"Markdown语法格式（.md后缀-使用typora）","slug":"00001-Markdown语法格式","date":"2021-09-28T13:00:00.000Z","updated":"2022-01-24T06:26:54.746Z","comments":true,"path":"posts/1.html","link":"","permalink":"http://wwy010518.github.io/posts/1.html","excerpt":"","text":"Markdown语法格式标题：#标题1 （大） ##标题2 ###标题3 ####标题4 （小） 以此类推 最高标题6 代码块：​```代码块名称(可以输入各种语言java、c++、html等) 加粗：//加粗 **加粗** //代码高亮显示 ==高亮== //删除线 ~~删除线~~ //斜体 *斜体内容* 引用：//引用语法 &gt;作者：泽 &gt;&gt;作者：泽 &gt;&gt;&gt;作者：泽 分割线：//分割线 --- *** 图片插入：//在线图片与本地图片 ![照片名子]（/image/me.png） 超链接：//超链接语法 [超链接名字]（https://gihub.com/yerenping） 列表：//无需列表 - 目录1 -后加空格 - 目录2 - 目录3 //有序列表 1+. +名称 表格：右键》插入》表格 用代码过于复杂不推荐使用","categories":[{"name":"其他","slug":"其他","permalink":"http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://wwy010518.github.io/tags/Markdown/"}]},{"title":"常用排序算法","slug":"01002-常用排序算法","date":"2021-06-30T13:00:00.000Z","updated":"2022-01-24T15:05:02.801Z","comments":true,"path":"posts/514.html","link":"","permalink":"http://wwy010518.github.io/posts/514.html","excerpt":"","text":"列举一些常用的排序算法 #冒泡排序 /// &lt;summary&gt; /// 冒泡排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void BubbleSort(int[] array, int count) { //设置标识符，如果为false意为当前数组为有序，不需要再排序了 bool shouldSorted = true; for (int i = 0; i &lt; count &amp;&amp; shouldSorted; i++) { shouldSorted = false; for (int j = count - 1; j &gt; i; j--) { if (array[j - 1] &gt; array[j]) { shouldSorted = true; Utilities.Swap(ref array[j - 1], ref array[j]); } } } } #选择排序 /// &lt;summary&gt; /// 选择排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void SelectSort(int[] array, int count) { int min; for (int i = 0; i &lt; count - 1; i++) { min = i; for (int j = i + 1; j &lt; count; j++) { if (array[min] &gt; array[j]) { min = j; } } if (min != i) { Utilities.Swap(ref array[min], ref array[i]); } } } #插入排序 /// &lt;summary&gt; /// 插入排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void InserSort(int[] array, int count) { int guard; //哨兵，用于暂存需要交换的值 for (int i = 0; i &lt; count - 1; i++) { if (array[i] &gt; array[i + 1]) { guard = array[i + 1]; int j; for (j = i; array[j] &gt; guard &amp;&amp; j &gt;= 0; j--) { array[j + 1] = array[j]; //赋值操作（依次后移） } array[j + 1] = guard; } } } #希尔排序 /// &lt;summary&gt; /// 希尔排序 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void ShellSort(int[] array, int count) { int i, j, guard; int increment = count; do { increment = increment / 3 + 1; //增量序列 for (i = increment + 1; i &lt; count; i++) { if (array[i] &lt; array[i - increment]) { guard = array[i]; //暂存在哨兵处 for (j = i - increment; j &gt;= 0 &amp;&amp; guard &lt; array[j]; j -= increment) { array[j + increment] = array[j]; //记录后移，查找插入位置 } array[j + increment] = guard; //插入 } } } while (increment &gt; 1); } #堆排序 /// &lt;summary&gt; /// 堆排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void HeapSort(int[] array, int count) { for (int i = count / 2 - 1; i &gt;= 0; i--) //把array构建成一个大顶堆 { HeapAdjust(array, i, count - 1); } for (int i = count - 1; i &gt; 0; i--) { Utilities.Swap(ref array[0], ref array[i]); //将堆顶记录和当前未经排序子序列的最后一个记录交换 HeapAdjust(array, 0, i - 1); //将array[0...i-1]重新调整为大顶堆 } } /// &lt;summary&gt; /// 堆排序_构造大顶堆函数 /// 已知array[startIndex...endIndex中]记录的关键字除array[endIndex]外均满足堆定义 /// 本函数调整array[endIndex]关键字，使array[startIndex...endIndex]成为一个大顶堆 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"startIndex\"&gt;起始位置&lt;/param&gt; /// &lt;param name=\"endIndex\"&gt;结束位置&lt;/param&gt; public static void HeapAdjust(int[] array, int startIndex, int endIndex) { int temp; temp = array[startIndex]; for (int i = 2 * startIndex + 1; i &lt;= endIndex; i = i * 2 + 1) //沿关键字较大的孩子结点向下筛选 { if (i &lt; endIndex &amp;&amp; array[i] &lt; array[i + 1]) { ++i; //i为关键字中较大记录的下标 } if (temp &gt; array[i]) { break; //rc应插入在位置s上 } array[startIndex] = array[i]; startIndex = i; } array[startIndex] = temp; //插入 } #归并排序 /// &lt;summary&gt; /// 归并排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void MergeSort(int[] array, int count) { int[] tempArray = new int[array.Length]; //申请额外空间，存放归并结果 int k = 1; while (k &lt; count) { MergePass(array, tempArray, k, count); //array归并到tempArray k = 2 * k; //子序列长度加倍 MergePass(tempArray, array, k, count); //tempArray归并到array k = 2 * k; //子序列长度加倍 } } /// &lt;summary&gt; /// 归并操作，把SR[]中相邻长度为s的子序列两两归并到TR[] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"srChildLength\"&gt;SR中子序列长度&lt;/param&gt; /// &lt;param name=\"arrayLength\"&gt;原数组长度&lt;/param&gt; public static void MergePass(int[] sr, int[] tr, int srChildLength, int arrayLength) { int hasMergeCount = 1; //hasMargeCount代表当前已经归并的元素个数 while (arrayLength - hasMergeCount + 1 &gt;= 2 * srChildLength) //确保此次两两归并可以完成 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, hasMergeCount + 2 * srChildLength - 2); //两两归并 hasMergeCount += 2 * srChildLength; } if (arrayLength - hasMergeCount + 1 &gt; srChildLength) //归并最后两个序列 { Merge(sr, tr, hasMergeCount - 1, hasMergeCount + srChildLength - 2, arrayLength - 1); } else //若最后只剩下单个子序列 { for (int j = hasMergeCount - 1; j &lt; arrayLength; j++) { tr[j] = sr[j]; } } } /// &lt;summary&gt; /// 归并操作，把SR[sr1StartIndex..sr1EndIndex]和SR[sr1EndIndex+1..sr2EndIndex]归并为有序的TR[sr1StartIndex..sr2EndIndex] /// &lt;/summary&gt; /// &lt;param name=\"sr\"&gt;SR数组&lt;/param&gt; /// &lt;param name=\"tr\"&gt;TR数组&lt;/param&gt; /// &lt;param name=\"sr1StartIndex\"&gt;SR数组子序列1起始位置&lt;/param&gt; /// &lt;param name=\"sr1EndIndex\"&gt;SR数组子序列1结束位置&lt;/param&gt; /// &lt;param name=\"sr2EndIndex\"&gt;SR数组子序列2结束位置&lt;/param&gt; private static void Merge(int[] sr, int[] tr, int sr1StartIndex, int sr1EndIndex, int sr2EndIndex) { int sr2StartIndex, currentProcess; //currentProcess为当前进度 for (sr2StartIndex = sr1EndIndex + 1, currentProcess = sr1StartIndex; sr1StartIndex &lt;= sr1EndIndex &amp;&amp; sr2StartIndex &lt;= sr2EndIndex; currentProcess++) //两个SR有一个被榨干后就要退出循环 { if (sr[sr1StartIndex] &lt; sr[sr2StartIndex]) { tr[currentProcess] = sr[sr1StartIndex++]; } else { tr[currentProcess] = sr[sr2StartIndex++]; } } if (sr1StartIndex &lt;= sr1EndIndex) { for (int l = 0; l &lt;= sr1EndIndex - sr1StartIndex; l++) { tr[currentProcess + l] = sr[sr1StartIndex + l]; //将剩余的SR[sr1StartIndex...sr1EndIndex]复制到TR } } if (sr2StartIndex &lt;= sr2EndIndex) { for (int l = 0; l &lt;= sr2EndIndex - sr2StartIndex; l++) { tr[currentProcess + l] = sr[sr2StartIndex + l]; //将剩余的SR[sr2StartIndex...sr2EndIndex]复制到TR } } } #快速排序 /// &lt;summary&gt; /// 快速排序_主函数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"count\"&gt;数组元素个数&lt;/param&gt; public static void QuickSort(int[] array, int count) { QSort(array, 0, count - 1); } /// &lt;summary&gt; /// 快速排序_递归调用 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; private static void QSort(int[] array, int low, int high) { int pivot; while (low &lt; high) { pivot = Partition(array, low, high); QSort(array, low, pivot - 1); //尾递归，可以减少一次递归堆栈深度 low = pivot + 1; } } /// &lt;summary&gt; /// 获取枢轴数 /// &lt;/summary&gt; /// &lt;param name=\"array\"&gt;数组&lt;/param&gt; /// &lt;param name=\"low\"&gt;低位索引&lt;/param&gt; /// &lt;param name=\"high\"&gt;高位索引&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static int Partition(int[] array, int low, int high) { int pivotkey; int m = low + (high - low) / 2; //下面是三数取中优化 //交换左端与右端数据，保证左端较小 if (array[low] &gt; array[high]) { Utilities.Swap(ref array[low],ref array[high]); } //交换中间与右端数据，保证中间较小 if (array[m] &gt; array[high]) { Utilities.Swap(ref array[m],ref array[high]); } //交换中间与左端数据，保证左端较小 if (array[m] &gt; array[low]) { Utilities.Swap(ref array[low],ref array[m]); } //默认选取当前数组的第一个值作为枢轴值 pivotkey = array[low]; //枢轴备份 int pivotkeyback = pivotkey; while (low &lt; high) { while (low &lt; high &amp;&amp; array[high] &gt;= pivotkey) { high--; } array[low] = array[high]; while (low &lt; high &amp;&amp; array[low] &lt;= pivotkey) { low++; } array[high] = array[low]; } //将枢轴数值替换回array[low] array[low] = pivotkeyback; //返回当前枢轴下标 return low; } #各种排序时空复杂度n: 数据规模k: “桶”的个数In-place: 占用常数内存，不占用额外内存Out-place: 占用额外内存","categories":[{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"},{"name":"数据结构和算法","slug":"CS基础/数据结构和算法","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"游戏MVC系列框架","slug":"04003-游戏MVC系列框架","date":"2020-12-15T13:00:00.000Z","updated":"2022-01-24T14:59:35.646Z","comments":true,"path":"posts/2051.html","link":"","permalink":"http://wwy010518.github.io/posts/2051.html","excerpt":"","text":"模板","categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"MVC","slug":"MVC","permalink":"http://wwy010518.github.io/tags/MVC/"}]},{"title":"游戏程序基础框架","slug":"04002-游戏程序基础框架","date":"2020-11-20T13:00:00.000Z","updated":"2022-01-24T14:59:43.342Z","comments":true,"path":"posts/2050.html","link":"","permalink":"http://wwy010518.github.io/posts/2050.html","excerpt":"","text":"模板","categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"}]},{"title":"Unity相关_数据持久化","slug":"03007-Unity相关_数据持久化","date":"2020-05-24T13:00:00.000Z","updated":"2022-01-25T07:38:47.011Z","comments":true,"path":"posts/1543.html","link":"","permalink":"http://wwy010518.github.io/posts/1543.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"}]},{"title":"Unity相关_UGUI","slug":"03005-Unity相关_UGUI","date":"2020-01-24T13:00:00.000Z","updated":"2022-01-25T07:37:17.604Z","comments":true,"path":"posts/1541.html","link":"","permalink":"http://wwy010518.github.io/posts/1541.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}]},{"title":"Unity进阶","slug":"03004-Unity进阶","date":"2019-11-13T13:00:00.000Z","updated":"2022-01-25T07:37:09.841Z","comments":true,"path":"posts/1540.html","link":"","permalink":"http://wwy010518.github.io/posts/1540.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity核心","slug":"03003-Unity核心","date":"2019-10-05T13:00:00.000Z","updated":"2022-01-25T07:36:58.398Z","comments":true,"path":"posts/1539.html","link":"","permalink":"http://wwy010518.github.io/posts/1539.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity基础","slug":"03002-Unity基础","date":"2019-09-25T13:00:00.000Z","updated":"2022-01-25T07:37:04.234Z","comments":true,"path":"posts/1538.html","link":"","permalink":"http://wwy010518.github.io/posts/1538.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"Unity入门","slug":"03001-Unity入门","date":"2019-08-30T13:00:00.000Z","updated":"2022-01-25T07:36:52.607Z","comments":true,"path":"posts/1537.html","link":"","permalink":"http://wwy010518.github.io/posts/1537.html","excerpt":"","text":"模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"}]},{"title":"C#进阶","slug":"02004-C#进阶","date":"2019-08-02T13:00:00.000Z","updated":"2022-01-25T14:31:33.892Z","comments":true,"path":"posts/1028.html","link":"","permalink":"http://wwy010518.github.io/posts/1028.html","excerpt":"","text":"CLR中简答数据结构类命名空间：System.Collections； ArrayList语法:new ArrayList();建议：本质是一个自动扩容的object数值，存在装箱拆箱，尽量少用；C# 动态数组(ArrayList) |菜鸟教程 (runoob.com) Stack(栈)语法：new Stack();建议：存在装箱拆箱；C# 堆栈(Stack) | 菜鸟教程 (runoob.com) Queue(队列)语法：new Queue();建议：存在装箱拆箱；C# 队列(队列) |菜鸟教程 (runoob.com) Hashtable(哈希表)定义：又叫散列表，是基于键的哈希代码组织起来的键值对，主要用来提高数据查询效率；语法：new Hashtable();迭代器遍历法: IDictionaryEnumerator me=哈希表对象名.GetEnumerator(); while(me.MoveNext()){ } 建议：存在装箱拆箱；C# 哈希表(Hashtable) |菜鸟教程 (runoob.com) CLR中的泛形命名空间：System.Collections.Generic 泛形定义：通过类型参数来实现代码操作多种类型；原理：相当于占位符，定义类或者方法是用替代符代替变量类型，当真正使用时再指定具体类型； 泛形约束关键字：where，可以多个使用;种类：6种如下：1.值类型 where 泛形字母:struct；2.引用类型 where 泛形字母:class；3.存在无参公共构造函数 where 泛形字母:new()；4.某个类本身或者派生类 where 泛形字母:类名；5.每个接口的派生 where 泛形字母:接口名；6.另一个泛形类型或者派生类型 where 泛形字母:另一个泛形字母； List定义：表示可通过索引访问的对象的强类型列表。 提供用于对列表进行搜索、排序和操作的方法。语法：new List&lt;&gt;();List 类 (System.Collections.Generic) | Microsoft Docs Dictionary定义：表示键和值的集合。语法：new Dictionart&lt;键,值&gt;();Dictionary 类 (System.Collections.Generic) | Microsoft Docs LinkedList定义：表示双重链接列表。语法：new LinkedList&lt;&gt;();LinkedList 类 (System.Collections.Generic) | Microsoft Docs 泛形队列定义：表示对象的先进先出泛形集合。语法：new Queue&lt;&gt;();Queue 类 (System.Collections.Generic) | Microsoft Docs 泛形栈定义：表示相同指定类型的实例可变大小的后进先出 (LIFO) 集合。语法：new Stack&lt;&gt;();Stack 类 (System.Collections.Generic) | Microsoft Docs 委托和事件委托定义：C# 中的委托(Delegate)类似于 C 或 C++ 中函数的指针,本质时一个类。委托(Delegate) 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变，专门用来装载函数的容器。语法： //定义 访问修饰符 delegate 返回值类型 委托名&lt;泛形类型&gt;(参数列表) //实例化 委托名 变量名=new 委托名(); //赋值,参数要一致 变量名[+或-]=方法名() //使用 委托变量名(对应参数): 系统自带的委托：Action&lt;泛形类型,……泛形类型&gt;和Func&lt;泛形类型,…..返回值&gt;;(d都支持16个泛形类型) 事件定义:让委托使用更加安全，事件是一种特殊的变量类型语法：访问修饰符 event 委托类型 事件名和委托区别：不能再类外部赋值(可以加减)，不能在类外部调用，只能在类内部封装调用； 匿名函数定义：没有名字的函数，要配合委托和事件使用；缺点：没有名字，无法通过+-移除；语法： Action a=delegate(参数列表){ } Lambad表达式定义：可以理解成是匿名函数的简写； (参数列表)=&gt;{ } 多线程和任务前台线程：主程序必须等待线程执行完毕后才可退出程序。Thread默认为前台线程，也可以设置为后台线程后台线程：主程序执行完毕后就退出，不管线程是否执行完毕。ThreadPool默认为后台线程线程消耗：开启一个新线程，线程不做任何操作，都要消耗1M左右的内存 多线程(Thread)命名空间：using System.Threading语法: //启动线程，将要执行的代码逻辑封装到一个函数语句块中 Thread 线程名=new Thread(委托方法); //启动线程 线程名.start(); //设置为后台线程,当进程结束后台线程结束 线程名.IsBackground=true; //关闭释放一个死循环进程，有俩中方法 //为线程死循环加一个标志变量 //通过线程提供的方法(在.net core版本会无法中止报错),可以加异常捕捉 线程名.Abort(); //线程休眠 线程名.Sleep(时间/ms); C# 多线程 | 菜鸟教程 (runoob.com) 共享数据问题：多线程操作同一内存区域可能出现问题，可以通过加锁的形式避免问题 lock(同一引用类型变量){ } 线程池(ThreadPoll)命名空间：using System.Threading定义:ThreadPoll是线程池(享元设计模式)，其目的是为了减少开启新线程消耗的资源(使用线程池中的空闲线程，不必在开启新线程，以及统一管理线程(线程池中的线程执行完毕后，回归到线程池里，等待新任务).优缺点：ThreadPoll性能优于Thread，但是Thread和ThreadPoll对线程的控制都不是很好，例如线程等待(线程执行一段时间无响应后，直接停止线程，释放资源 等 都没有直接的API来控制 只能通过硬编码来实现，同时ThreadPool使用的是线程池全局队列，全局队列中的线程依旧会存在竞争共享资源的情况，从而影响性能。语法： //快速启动 ThreadPool.QueueUserWorkItem(委托方法); //获取线程池中辅助线程的最大数量(workerThreadsMax)和线程池中异步I/O线程的最大数量(completionPortThreadsMax) ThreadPool.GetMaxThreads(out int workerThreadsMax, out int completionPortThreadsMax); //获取线程池中辅助线程的最小数量(workerThreadsMin)和线程池中异步I/O线程的最小数量(completionPortThreadsMin) ThreadPool.GetMinThreads(out int workerThreadsMin, out int completionPortThreadsMin); //设置最大线程数量 和 设置最小线程数量，在进程内是全局的。在一个地方设置了，后面所有的请求中都是这个数量了 //委托异步调用、Task、Parallel、async/await 都使用的是线程池的线程； new Thread()不受限制，但是会占用线程池的数量。 ThreadPool.SetMaxThreads(12, 12);//不能低于当前电脑的线程数；比如四核八线程，就不能低于8，否则无效 ThreadPool.SetMinThreads(1, 1); //线程等待，需要使用ManualResetEvent来完成 ManualResetEvent mre = new ManualResetEvent(false); ThreadPool.QueueUserWorkItem((obj) =&gt; { DoSomething(\"\"); mre.Set(); } ); mre.WaitOne()； 任务(Task)命名空间：using System.Threading.Tasks特点：Task是基于任务的异步编程模型,Task的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时Task提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。建议：使用Task的时候应该尽量结合async和await关键字来使用。避免使用.Result 和 .Wait()来阻塞等待;.Result 和 .Wait()会占用线程资源，直到任务完成；而await的基于异步回调的，不会浪费CPU资源；async和await是语法糖，本质上其实是ContinueWith()。基本语法： //Task使用方式1 Task task1 = new Task(() =&gt; { DoSomething(\"张三\"); }); task1.Start(); //Task使用方式2 var taskFactory = Task.Factory; Task&lt;int&gt; t1 = taskFactory.StartNew&lt;int&gt;(() =&gt; { DoSomething(\"王五\"); return 1; }); Task t2 = taskFactory.StartNew(() =&gt; { DoSomething(\"赵六\"); }); Task t3 = taskFactory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"所有线程都完成了，就会调用这个函数， 不会阻塞主线程\"); }); Task t4 = taskFactory.ContinueWhenAny(new Task[] { t1, t2 }, (t) =&gt; { Console.WriteLine(\"任意一个线程完成了，就会调用这个函数， 不会阻塞主线程\"); }); //Task使用方式3 Task&lt;int&gt; task = Task.Run&lt;int&gt;(() =&gt; { DoSomething(\"李四\"); return 1; }); int temp = task.Result; //阻塞执行完毕并获取结果，不建议使用这种方式 task.Wait(); //阻塞，直到子线程执行完毕，不建议使用这种方式 await task; //阻塞，直到子线程执行完毕。 但是主线程(调用方)将继续往下执行，await task后面的代码等同于封装在ContinueWith()里面 //Task其它使用方式 //Task.Delay(2000)不阻塞当前线程，一般配合ContinueWith使用，在ContinueWith里面的子线程将等待2秒之后执行 //Thread.Sleep(2000)是阻塞当前线程 Task task3 = Task.Delay(2000).ContinueWith((t) =&gt; { }); //等待所有线程完成 Task.WaitAll(new Task[] { task1, t1 }); //等待任意一个线程完成 Task.WaitAny(new Task[] { task1, t1 }); //线程回调 task1.ContinueWith((o) =&gt; { Console.WriteLine(\"线程回调，task1执行完毕之后执行这里。\"); } //Task取消任务 CancellationTokenSource tokenSource = new CancellationTokenSource(); CancellationToken token = tokenSource.Token; ManualResetEvent resetEvent = new ManualResetEvent(true); //定义任务 Task task = new Task(async () =&gt; { while (true) { if (token.IsCancellationRequested) { return; } // 初始化为true时执行WaitOne不阻塞 resetEvent.WaitOne(); // Doing something....... // 模拟等待100ms await Task.Delay(100); } }, token); //任务开始 task.Start(); //任务暂停 resetEvent.Reset(); //任务继续 resetEvent.Set(); //取消Task tokenSource.Cancel(); async/await语法使用案例： static void Main(string[] args) { string content = GetContentAsync(Environment.CurrentDirectory + @\"/test.txt\").Result; //调用同步方法 //string content = GetContent(Environment.CurrentDirectory + @\"/test.txt\"); Console.WriteLine(content); Console.ReadKey(); } //异步读取文件内容 async static Task&lt;string&gt; GetContentAsync(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //ReadAync方法异步读取内容，不阻塞线程 Console.WriteLine(\"开始读取文件\"); int len = await fs.ReadAsync(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } //同步读取文件内容 static string GetContent(string filename) { FileStream fs = new FileStream(filename, FileMode.Open); var bytes = new byte[fs.Length]; //Read方法同步读取内容，阻塞线程 int len = fs.Read(bytes, 0, bytes.Length); string result = Encoding.UTF8.GetString(bytes); return result; } 预处理器指令什么是编译器源语言程序：某种程序设计语言写的，像c#、c、c++、java等；目标语言程序：计算机可以识别的二进制数程序；编译器：是一种翻译程序(编译原理 )，将源语言程序翻译成目标语言程序； 什么是预处理器指令定义：指导编译器，在实际编译开始时对信息进行预处理，都是以#开始，不是指令，所以不以；结束； 常见的预处理器指令//写在脚本最前面，配合if指令或特性使用1.#define：定义一个符号，类似一个没有值的变量2.#undef：取消define定义的符号3.#if、#elif、#else、#endif：和if语法规则一样，用于告诉编译器进行编译代码的流程控制；4.#warning、#error：告诉编译器是报警告还是报错； 反射和特性程序集：由编译器编译(.exe或者.dll)，供编译执行的中间产物；元数据：数据的数据； 反射概念：程序正在运行时可以查看其他程序集或者自己的元数据这就叫反射；type定义：类的信息类，是访问元数据的主要方式，反射的技术；语法：获取的type指向的内存都是一样的 //1.通过object.GetType()获取对象的Type Type t1=object.GetType(); //2.通过typeof关键字获取类的Type Type t2=typeof(int); //3.通过类名获取，但是必须有命名空间 Type p3=Type.GetType(\"System.Int32\"); //程序集获取 t1.Assembly; //获取类的所有公共成员 MemberInfo[] infos=t1.GetMembers(); //获取类所有构造函数并调用 ConstructorInfo[] ctors=t1.GetConstructors(); //获取构造函数传入 Type数组 数组中按顺序是参数类型，执行构造函数传入 object数组 表示按顺序传入的参数； //得到无参构造 ConstructorInfo info =t1.GetConstructor(new Type[]); info.Invoke(null) as 类名; //得到有参构造 ConstructorInfo info =t1.GetConstructor(new Type[]{typeof(int)}); info.Invoke(new object[]{2}) as 类名; //得到所有成员变量 FieldInfo[] fieldINfos=t1.GetFields(); //得到指定名称的公共成员变量 FieldInfo infoj=t1.GetField(\"变量名\")； //通过反射获取变量值 infoj.GetValue(类实例); //通过反射设置变量值 infoj.SetValue(类实例,要赋的值)； //获得类的公共成员方法 MethodInfo[] methods=t1.GetMethods(); //获取指定方法 MethodInfo method=t1.GetMethod(\"方法名\"，new Type[]{反射参数类型同上}); method.Invoke(参数)； 特性定义：本质是个类，可以利用特性类为元数据添加额外信息，之后可以用反射获取这些额外信息，类、变量、函数前都可以添加；自定义特性：继承特性基类 Attribute(使用自定义特性时类名后面会省略Attribute这几个字);语法 //1.定义特性 class 特性类名：Attribute{ } //2.特性使用 [特性名(参数列表)] //类、函数、变量上一行 //3.判断是否使用了某个特性 //参数一：特性的类型 参数二：是否搜索继承链(属性和时间忽略) if(类type类型.IsDefind(typeof(特性类型)，false)){} //4.获取Type元数据中的所有特性 t.GetCustomAttributes(ture); //5.为特性类加特性，限制自定义特性 //参数一：AttributeTargets--特性可以用在哪里 //参数二：AllowMultiple--是否允许多个特性在同一个目标上 //参数三：Inherited--特性是否能被派生类和重写成员继承 [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct,AllowMultiple=true,Inherited=true)] //6.系统自带特性 //6.1过时特性 [Obsolete(\"过时特性，后面是ture直接报错，否则警告\"，false)] //6.2调用者信息特性 用处不大，省略，用工具就可以了 //6.3条件编译特性 //和#define配套使用，必须有该参数名的预指令符号才会执行修饰成员 using System.Runtime.CompilerServices [Conditional(\"Fun\")] //6.4外部Dll包函数特性 //用来标记非.Net的函数，表明在一个外部的DLL中定义，用来调用c或者c++得DLL包写好的方法 using System.Runtime.InteropServices [DllImport(\"程序集全名\")] public static extern int 外部DLL元数据函数名() 其他补充协变逆变协变：out逆变：in作用一：用out修饰的泛形只能作为返回值，用in修饰的泛形只能作为参数作用二：用out和in修饰的泛形委托可以i互相装载(有父子关系的委托) //结合里氏替换原则理解 //协变 父类总是能被子类替代 TestOut&lt;Son&gt; os=()=&gt;{ } TestOut&lt;Father&gt; of=os;//参数必须声明out of();//实际上os装的函数返回的是Son的 //逆变 子类装父类委托 TestIn&lt;Father&gt; of=()=&gt;{ } TestIn&lt;Son&gt; os=of;//参数必须声明in os();//实际上os装的函数返回的是Father的 迭代器(iterator)概念：又称为光标(cursor)，是程序设计的软件设计模式，是可以在遍历访问的接口，设计人员无需关心容器的内存细节，能用foreach遍历的类，都实现了迭代器；关键接口：IEnumerator(迭代器实现),IEnumerable(foreach实现，有方法即可);命名空间：using System.Collections;yield return：是c#提供的语法糖(糖衣语法)，可以将复杂逻辑简单化，增加程序可读性，yield关键字可以理解为暂时返回，保留当前状态； 特殊语法# 隐藏类型var 可以用来表示任何类型的变量，一般用来临时变量，但是不能再更改类型。 # 设置对象初始值 可以直接通过大括号来进行赋值。 # 设置集合初始值 可以直接通过大括号来进行赋值。 # 匿名类型 var变量可声明为自定义的匿名类型，但是只能有变量。语法 var v=new {age=10,name=\"小明}; # 可空类型//1.数值类型使用，声明时再值类型后面加？可以赋值为空 int?lue=null; //又如 int[] os=null; int? x=os?[0]; //2.引用类型使用，相当于一种语法糖，自动判断是否为空,例如判断委托是否为不为空才执行 o?Invoke(); //3.判断值类型是否为空 值变量名.HasValue； //4.安全获取值类型默认值(可以指定默认值) 值变量名.GetValueOrDefault(默认值); # 空和并操作符定义：左边值？？右边值，左边为null返回右边值，否则左边； # 内插字符串 用关键字$，类似于Format拼接字符串。语法 Console.WriteLine($\"你好，{name}”); # 单句逻辑简略写法 逻辑语句只有一句代码的话可以省略{}，而属性只有一句getset可以写成get=&gt;返回值;set=&gt;变量名=要赋的值，方法同理。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#核心","slug":"02003-C#核心","date":"2019-07-15T13:00:00.000Z","updated":"2022-01-25T07:47:52.980Z","comments":true,"path":"posts/1027.html","link":"","permalink":"http://wwy010518.github.io/posts/1027.html","excerpt":"","text":"面向对象基本概念其他编程方式：面向过程编程；三大特征：封装+继承+多态；七大原则：1.单一原则：一个类只处理自己应该处理的。应该各司其职，例如把每个移动技能都尽量写出一个类，方便修改。2.开闭原则：新功能尽量是加处理而不是改代码。继承就是最明显的开闭原则，不要修改模板的内容，例如定义属性要用方法定义， getset，方便修改，修改类时或者改别人的方法，不清楚逻辑的就再写一个类。3.依赖倒置原则：不依赖于具体实现，要依赖抽象(接口)。要依赖于抽象，不要依赖于具体实现，可以先了解需求，再画图，最后变成代码。4.接口隔离原则：一个接口一个行为。接口里的单一原则，需要分的事件要分清楚。5.里氏替换原则：用父类容器装载子类，任何地方子类都能替换父类。不要修改别人的代码，可以继承他的代码去重写(注：多态：父类的指针指向子类，而调用子类的方法)6.合成复用原则：尽量用组合复用的形式。继承关系中，父类要可以解决子类共同的问题，子类时解决特与的问题，能用现有的类，就别再自己创建类。7.迪米特法则：一个类尽量减少对别的类引用。又叫最少知识原则，减少耦合性，类自己能解决的，尽量不要牵扯别的类，比如A类引用B类的方法，但是B类方法参数改了，A类也要改。 面向对象三特征-封装一般类定义： 类和对象class 类名{ 类名 对象名=new 类名; } 类一般成员和封装成员变量：成员变量是声明在类中的变量，可以是任意类型；成员方法(函数)：类的成员函数是一个在类定义中有它的定义或原型的函数;访问修饰符种类：public(接口成员、命名空间、枚举默认)、private(类成员)、protected、internal(类、结构、接口、委托默认)； 构造函数构造函数：类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行，构造函数的名称与类的名称完全相同，它没有任何返回类型默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做参数化构造函数。这种技术可以帮助你在创建对象的同时给对象赋初始值，以下是它的特殊写法： public 类名(参数1，参数2):this(参数1){ //默认会先调用无参构造(this)或者父类构造函数(换成base) } ##析构函数析构函数：类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行，析构函数的名称是在类的名称前加上一个波浪形(~)作为前缀，它不返回值，也不带任何参数，析构函数用于在结束程序(比如关闭文件、释放内存等)之前释放资源，就是当引用类型的堆被回收时被调用，析构函数不能继承或重载。 垃圾回收机制定义:简称GC，当堆(Heap)中的变量没有被任何对象引用时，就会被自动回收；算法：引用计数、标记清除、标记整理、复制集合；注意事项：GC只负责堆的垃圾回收,而栈(stack)的内存时系统自动管理的，值类型有自己的生命周期，会自动分配和释放；原理：C#会把堆中的内存分为0代内存、1代内存、2代内存(代是分代算法，代系数越大速度越慢，内存越大)，新分配的对象会配置在0代内存，每次分配都可能会进行垃圾回收释放内存(0代内存或者1代内存满时)，垃圾回收机制确认堆中的垃圾，首先会标记对象，发现是否有引用，标记后可达对象，未标记未不可达对象(垃圾)，然后就将对象压缩堆(挂起执行托管代码线程)释放垃圾，搬迁可达对象地址到下一代内存(到第二代内存不会在搬迁)，大对象(83kb以上)总认为是第二代内存。手动触发代码：GC.Collect();一般Loading过场景调用 成员属性语法： 访问修饰符 属性类型 属性名{ 访问修饰符 get{}//自动属性可以省略{} 访问修饰符 set{}//自动属性可以省略{} } 索引器概念:让对象可以像数组一样通过索引访问元素，索引器可以重载；语法： 访问修饰符 返回值 this[参数1、参数2]{ get{} set{} } 静态类和静态成员static静态类：不能被实例化，只能有静态成员；静态变量：当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本；静态函数：这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在；静态构造函数：不能使用访问修饰符，不能有参数，使用静态类或者普通类的成员时会自动且仅调用一次； 拓展方法特点：一定是写在静态类，一定是静态函数，第一个参数为拓展目标，第一个参数用this修饰；语法： 访问修饰符 static 返回值 函数名(this 拓展类名 参数名，参数1，参数2){ } 运算符重载概念：使用operator关键字让自定义类和结构体可以使用运算符；特点：一定是公告静态方法，返回值在operator前(条件运算要成对出现，一个符号可以多个重载，不能使用ref和out);语法： public static 返回类型 operator 运算符(参数列表){ } 不可重载的运算符:逻辑与&amp;&amp; 、逻辑非||、索引符[]、强转符号()、点.、三目运算符?:、赋值符号=； 内部类和分部类内部类定义:在一个类中再声明一个类，使用时要外部类点出自己；分部类：用partial把类分成几部分,注意访问修饰符要一样;分部方法:用partial将方法声明和实现分离，强制私有，只能在分部类声明，不能有返回值，不能用out关键字； 面向对象三特征-继承继承基本规则语法： class 类名 ：被继承的类{ } 里氏替换原则概念:任何父类出现的地方，子类都可以替代语法: 父类 变量名=new 子类()； ###is关键字定义:判断一个对象是否为指定类对象，返回bool值语法:对象 is 类名 ###as关键字定义:将一个对象转换为指定类对象，没有返回null语法:对象 as 类名 继承中的构造函数特点:实例化时先执行父类构造函数,再执行子类构造函数； 万物之父和装箱拆箱万物之父关键字:object装箱:例如object存储值类型发生，把值类型从栈中迁移到堆中，变成引用类型；拆箱:例如把object转为值类型发生，把引用类型从堆中迁移到栈中，变成值类型； 密封类概念:使用sealed关键字使类无法再被继承； 面向对象三特征-多态vob关键字：virtual(虚函数)和override(重写); 抽象类和抽象方法关键字：abstract(抽象函数)；特点：抽象类不能被实例化，但是遵守里氏替换原则，抽象方法没有方法体； 接口关键字:interface；特点：不包含成员变量，只有抽象方法、属性、索引器、事件，成员不能被实现，不能是私有成员，类可以继承多个接口，接口也遵守里氏替换原则；作用：不作为实体基类,但是可以作为一个行为基类;命名规则:帕斯卡命名法前面加I; ###显示实现接口作用：当实现俩个接口后，其中有相同方法时；语法：用接口名点出方法名; 密封方法关键字:sealed修饰不能再被重写； 面向对象相关知识点命名空间特点：命名空间可以包裹命名空间;语法： namespace 命名空间名{ } 万物之父中的方法静态方法Equals:判断俩个对象是否相等,值类型比较数值，引用类型比较地址;静态方法RefereceEquals：判断俩个对象引用是否相等，主要用于应用类型，值类型返回始终false;普通方法GetType():获取对象运行时的类型(反射相关);普通方法MemberwiseClone：拷贝对象,引用对象指向相同地址;虚方法Equals:相当于RefereceEquals,但是在种类中ValueType中重写了,可以用来比较值相等；虚方法GetHashCode：获取对象哈希值(对象唯一编码，但是也可能u不同对象哈希码一样)；虚方法ToString：返回对象代表的字符串; string注意事项：string大部分方法需要赋值再使用，因为会实例化一个新的字符串；字符串名[]：字符串索引器;(静态)string.Format()：字符串拼接(替代);字符串名.IndexOf()：正向查找字符位置;字符串名.LastIndexOf()：反向查找字符位置;字符串名.Remove()：移除指定位置的字符;字符串名.Replace()：替换指定字符串;字符串名.ToUpper()：字符串全部大写；字符串名.ToLower()：字符串全部小写;字符串名.Substring()：字符串截取；字符串名.Split()：字符串切割； StringBuilder作用：修改字符串而不创建新的对象字符串.Capacity:获取容量；字符串.Append:增；字符串.AppendFormat():拼接；字符串.Insert():插入；字符串.Remove():删；字符串.Clear():清空；索引-字符串[]:用来查和改；str.Replace():替换； 字符串拼接的方式直接通过+拼接 会有性能问题，字符串少还好，越多GC越严重。 通过StringBuilder拼接字符串 字符串数量越多性能相对直接+拼接方法越高。 通过StringBuffer拼接字符串 区别：线程安全版的StringBuilder，但是性能不如StringBuilder; string.Format原理：其底层本质还是StringBuilder来实现的； $方式拼接字符串原理：是string.Format简化版，C#6.0新增操作；语法： string str = $\"my name is{name}, I'm {age} years old\"; 知识拓展多脚本文件.cs：源码文件.sln：解决方案入口文件.dll：编译文件 UML定义：统一建模语言，是面向对象设计的建模语言；理解：可以通过一些UML可视化软件(visio)就可以生成代码；","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#基础","slug":"02002-C#基础","date":"2019-07-02T13:00:00.000Z","updated":"2022-01-25T04:23:57.493Z","comments":true,"path":"posts/1026.html","link":"","permalink":"http://wwy010518.github.io/posts/1026.html","excerpt":"","text":"将之前的笔记记录在博客上 复杂数据类型特点：数据(变量)集合、自定义； 枚举 枚举是一个被命名的整形常量集合,可以声明再命名空间、类和结构体中。 枚举声明enum 变量名{ 名1,//枚举中默认是0下面累加 名2=4,//可以赋值,下面数值接着从此开始 名3 } 枚举的类型转换1.枚举和int互转后是数值的转换2.枚举转换成string是枚举名3.string转换成枚举,必须有这个字符串名的枚举名,实例如下： Enum.Parse(typeof(声明枚举类型名),\"Other\"); 数组 数组是储存一组相同的数值集合,下标从0开始。 一维数组声明：变量类型【】 数组名=new 变量类型【数组长度】{ 1,2,3,4……(第数组长度-1个) }；获取长度：数组名.length; 二维数组声明：变量类型【,】 二维数组名=new 变量类型【行,列】{ { 1,1,1… },{ 1,1,1…. },{ 1,1,1…. }… };获取长度:数组名.length(维度); 交叉数组 即数组的数组。 结构体public struct 结构体名{ 变量类型 变量名 构造函数(可选) 函数 } 结构体和类相同点：1.两者都拥有成员,包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。2.两者的成员都有其各自的存取范围。例如,可以将某一个成员声明为Public,而将另一个成员声明为Private。3.两者都可以实现接口。4.两者都可以公开一个默认属性,然而前提是这个属性至少要取得一个自变量。5.两者都可以声明和触发事件,而且两者都可以声明委托(Delegate)。6.两者都是container类型,这表示它们可以包含其他数据类型作为成员。 区别：1.结构是实值类型(Value Types),而类则是引用类型(Reference Types)。2.结构使用栈存储(Stack Allocation),而类使用堆存储(Heap Allocation)。3.所有结构成员默认都是Public,而类的变量和常量数则默认位Private,不过其他类成员默认都是Public。4.结构成员不能被声明位Protected,而类成员可以。5.结构变量声明不能指定初始值、使用New关键字货对数组进行初始化,但是类变量声明可以。6.结构不能声明默认的构造函数,也就是不拥有参数的非共享构造函数,但是类则无此限制。7.二者都可以拥有共享构造函数,结构的共享构造函数不能带有参数,但是类的共享构造函数则可以带或者不带参数。8.结构不允许声明析构函数(Destructor),类则无此限制。9.结构的实例(Instance)声明,不允许对包含的变量进行初始化设定,类则可以在声明类的实例时,同时进行变量初始化。1.结构是隐式继承自ValueType类,而且不能继承任何其他类型,类则可以继续自ValueType以外的任何类。11.结构是无法被继承的,类则可以。12.结构永远不会终止,因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止,当内存回收进程检测到没有任何作用的类时,它就会调用类的Finalize方法。13.结构不需要构造函数,类则需要构造函数。14.结构只能在一种情况下使用非共享构造函数,那就是非共享构造函数会接受参数。但是类则无此限制,它可以使用带参数或不带参数的非共享构造函数。15.每一个结构都具有无参数的隐含公共构造函数,此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。在“实例和变量”层面上,由于结构是数值类型的,因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的,而且对象变量可引用不同的类实例,在此方面的区别,会对使用将结构和类造成如下的影响：16.结构变量会隐式的使用结构的无参数构造函数来初始化成员,这就意味语句 Struct S = new Struct()。17.当您将一个结构变量赋值给另一个,或者将结构实例传递到程序变量时,所有变量成员的值会复制到新的结构中。当您将一个对象变量赋值给另一个,或者将对象变量传递给程序时,则只是复制指针。18.您可以将Null值赋值给结构变量,但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化,但是您还是可以调用变量的方法并访问其数据成员。相反的,如果您将对象变量设定为Null,您就会中断它与任何类型实例的关联,而且除非您再将另一个实例赋值给它,否则无法通过变量访问任何成员。19.您可以在不同时间将不同的类的实例赋值给同一个对象变量,而且在同一时间可有好几个对象变量引用相同的类实例,如果您对类成员值做了改变,则其他指向相同实例的对象变量也会发生改变。然而,结构成员则会封装在他们自己的实例中,变更结构成员值并不会对其他任何结构变量的成员造成影响,甚至也不会影响相同结构声明的其他实例。20.两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。Equals会判断两个变量是否指向相同的实例。 如何选择结构还是类:1.堆栈的空间有限,对于大量的逻辑的对象,创建类要比创建结构好一些2.结构表示如点、矩形和颜色这样的轻量对象,例如,如果声明一个含有 1000 个点对象的数组,则将为引用每个对象分配附加的内存。在此情况下,结构的成本较低。3.在表现抽象和多级别的对象层次时,类是最好的选择。4.大多数情况下该类型只是一些数据时,结构时最佳的选择。 值类型和引用类型值类型 其他类型、结构体；存储位置：栈空间–系统分配,自动回收,小而快特点：在赋值时,把内容拷贝给对方,它变我不变,内存地址不变。 引用类型 string、数组、类存储位置：手动申请和释放,大而慢特点：在赋值时,让俩者指向一个值,它变我也变,指向堆中相同内存地址。 特殊引用类型string string在赋值时也会再分配一个内存空间。 函数 函数可以写在类中和结构体中。 函数基础基本语法：static 返回类型 函数名(参数类型 参数名1….){ 代码逻辑；return 返回值 } ref和out 在函数内部传入,里面变了,外面也变了。声明：函数参数的修饰符；区别：ref传入的参数必须初始化,out传入的变量必须在内部赋值； 变长参数和参数默认值变长参数声明：params 变量类型[] 变量名；参数默认值：可选参数,在方法声明时就进行赋值,可选参数必须写在普通参数后面； 函数重载定义：重载和返回值无关,和参数类型、个数、顺序有关； 递归函数定义：就是让函数自己调用自己,但是需要留出出口,否则就是死循环","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]},{"title":"C#入门","slug":"02001-C#入门","date":"2019-06-18T13:00:00.000Z","updated":"2022-01-24T15:04:28.242Z","comments":true,"path":"posts/1025.html","link":"","permalink":"http://wwy010518.github.io/posts/1025.html","excerpt":"","text":"将之前的笔记记录在博客上 C#基础知识主流语言的应用领域C: 嵌入式硬件开发C++: 游戏客户端、服务器、软件C#: 游戏客户端、服务器、软件、网站 Java: 安卓、服务器、软件、网站JavaScript: H5游戏、网站、服务器PHP: 网站、服务器Python: 网站、服务器、辅助开发 SQL: 数据库Go: 服务器Objective-C: 苹果(mac、ios)相关Swift: 苹果(mac、ios)相关 开发环境搭建IDE是什么IDE(Integrated Development Environment )集成开发环境它就是一类用于程序开发的软件，这一类软件一般包括了代码编辑、编译器、调试器、图形用户界面等等工具，只要安装了这种软件我们就可以进行程序开发了。它的主要作用简单讲就是让计算机能识别你写的程序代码，能够响应你输入的代码命令，听从你的指令和你进行交流。 常用的IDE(集成开发环境)软件Visual Studio:一般Windows操作系统使用的软件都由它来进行开发，可用于开发基于C、C++、C#等等语言的软件;Eclipse和IntelliJ IDEA:一般主要用于开发Java语言的相关软件;Android Studio: 谷歌推出，主要用于开发安卓应用;Xcode:苹果推出，主要用于开发苹果应用; 第一个应用程序理解写代码这件事通过写代码命令，不停的相互调用系统的或者自定义的一些API，让计算机通过这些命令来执行一些行为，从而实现一些特定的需求。比如说做游戏，通过代码相互调用，让图片能够显示在屏幕上，让图片能够动起来 注释的三种方式1.两杠注释:用于注释一行信息2.星号注释:用于注释多行信息3.三杠注释:用于注释类、命名空间等 快捷注释的方法1.上方工具栏2.快捷键CTRL + K + C 注释CTRL + K + U 取消注释 折叠代码由#region #endregion配对出现 控制台输入打印语句Console.Write():输出 Console.WriteLine:换行输出 Console.ReadKey:检测用户按下 Console.ReadLine:用户输入回车 变量变量类型有符号的整形变量sbyte: -128-127(字节占1);short: -32768-32767(字节占2);int: -21亿-21亿多(字节占4);long: -9百万兆-9百万兆(字节占8); 无符号的整数变量byte:0-255(字节占1);ushort: 0-65535(字节占2);uint: 0-42亿多(字节占4);ulong: 0-18百万兆(字节占8); 浮点型float: (字节占4)存储7-8位有效数字，根据编译器不同，有效数字不一样，会四舍五入，后面加f;double:(字节占8) 存储15-17位有效数字;decimal:(字节占16)存输27-2位有效数字，不建议使用，后面加m; 特殊类型bool:非真即假(字节占1);char:存储单个字符(字节占2);string:存储多个字符，没有上限(长度可变); 变量的本质 数据传递只能通过电信号，变量的本质是二进制，都是0和1，1bit(一位或者一个数)要不就是0又不就是1，而一个字节(byte)占8位，1byte=0000 0000通过sizeof获取变量占用的内存空间(例如:sizeof(int);;1byte=8bit;1kb=1024byte;1mb=1024kb;1gb=1024mb;1tb=1024gb; 进制转换(整数，左侧第一位表示符号)十进制转二进制:不停除2;二进制转十进制:从右往左看，该位不为0，则加上2的n次方(第一位为0); 命名规则1.不能重名;2.不能以数字开头;3.不能是关键字;4.不能有特殊符号(下划线除外); 驼峰命名法(变量)、帕斯卡命名法(函数、类) 常量关键字const，必须初始化，不能被修改。 转义字符 是字符串的一部分，用来表示一些特殊含义，如单引号、引号、空行 固定写法常用的转义字符':单引号;\":双引号\\n:换行\\:斜杠 不常用的转义字符\\t:制表符(空一个tab键)\\b:光标退格\\0:空字符\\a:警告音 取消转义字符 在字符串前面加一个@(例如@”\\你好\") 类型转换 不同变量类型之间的相互转换 隐式转换 不同类型之间的自动转换，大范围转小范围 相同大类型之间的转换 特殊类型不存在隐式转换 不同大类型之间的转换无符号和有符号之间 有符号的变量不能隐式转换无符号的; 无符号的变量隐式转换有符号的前提是范围一定是涵盖的; 浮点数和整数之间 浮点数可以转任何类型整数; 整数不能转换浮点型(不能存小数); 特殊类型和其他类型 char类型可以隐式转换成整数和浮点型(ASCII码); bool和string不能和其他类型互相转换; 显示转换 手动转换。 括号强转 小范围转大范围，在前面加(),括号强转会出现问题和损失精度，bool和string不能用此转换。 Parse法 把字符串类型转换成对应类型，前提能转换，否则报错。语法:变量类型.Parse(“字符串”) Convert法 更准确的把各个类型之间转换，精度比括号转好，会四舍五入，前提是变量和常量必须正确。语法:Convert.To目标类型(变量或者常量) 其他类型转string作用:拼接打印;语法:变量.ToString(); 异常捕获 避免程序报错造成卡死 try{ }catch{ }finally{ } 运算符算数运算符赋值运算符:=算数运算符:+ - * / %复合运算符:+= -+ *= /= %=自增运算符:a++(先用再加) ++a(先加再用) 运算符的优先级1.乘除大于加减;2.括号优先; 字符串拼接方法一:+号拼接;方法二:string.Format(“{0}”，18);控制台打印拼接:支持类似方法二; 条件运算符 只要是数值就可以进行条件运算符比较大小等等，特殊类型只能与同类型进行==和！=比较(char不一样)。条件运算符:&gt; &lt; == != &gt;= &lt;=; 逻辑运算符逻辑运算符:&amp;&amp; || ! 运算符优先级 ！优先级最高，&amp;&amp;优先级高于||，逻辑运算符优先级低于算数运算符和条件运算符。 位运算符位与:&amp;(连接俩个数值进行位计算，转换成2进制计算，有0则0)位或:|(有1则1)异或:^(对位运算，相同为0，不同为1)位取反:~(0变1，1变0，反码补码问题)左右移:&lt;&lt;(左移几位，右边加几个0) &gt;&gt;(右移几位，右边去几个数) 三目运算符语法:空位(bool类型)？空位:空位; 条件分支语句if语句if(){ }else if(){ }else{ } switch语句switch(){ case 变量: break; default: break; } 循环语句while循环while(循环跳出条件){ } do-while循环do{ }while(); for循环for(int i=1;i&lt;条件;i++){ } foreach循环foreach(var i in 集合需要继承自一个接口){ } 知识补充控制台相关1.Console.Readkey().Keycahr-可以保存输入的字符;2.Console.Clear()-清空控制台;3.Console.SetWindowSize(宽，高);4.Console.SetBufferSize(宽，高)-缓冲区大小;5.Console.SetCursorPosition(x，y)-设置光标的位置6.Console.ForegroundColor=ConsoleColor.颜色-设置文件颜色7.Console.BackgroundColor=ConsoleColor.颜色–设置背景颜色，想立马改变用clear8.Console.CursorVisiable=false-设置光标显隐9.Environment.Exit(0)-关闭控制台 随机数语法:Random 变量名=new Random();生成非负数:变量名.Next(最小到最大，范围不包括最大);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]}],"categories":[{"name":"技术架构","slug":"技术架构","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"},{"name":"Unity框架","slug":"技术架构/Unity框架","permalink":"http://wwy010518.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/Unity%E6%A1%86%E6%9E%B6/"},{"name":"CS基础","slug":"CS基础","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"Unity","slug":"游戏引擎/Unity","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/"},{"name":"GUI解决方案","slug":"游戏引擎/Unity/GUI解决方案","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"热更新","slug":"游戏引擎/Unity/热更新","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"其他","slug":"其他","permalink":"http://wwy010518.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构和算法","slug":"CS基础/数据结构和算法","permalink":"http://wwy010518.github.io/categories/CS%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"数据持久化","slug":"游戏引擎/Unity/数据持久化","permalink":"http://wwy010518.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"编程语言","slug":"编程语言","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://wwy010518.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"ET","slug":"ET","permalink":"http://wwy010518.github.io/tags/ET/"},{"name":"游戏框架","slug":"游戏框架","permalink":"http://wwy010518.github.io/tags/%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://wwy010518.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Unity","slug":"Unity","permalink":"http://wwy010518.github.io/tags/Unity/"},{"name":"GUI解决方案","slug":"GUI解决方案","permalink":"http://wwy010518.github.io/tags/GUI%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Lua","slug":"Lua","permalink":"http://wwy010518.github.io/tags/Lua/"},{"name":"AssetBundle","slug":"AssetBundle","permalink":"http://wwy010518.github.io/tags/AssetBundle/"},{"name":"Markdown","slug":"Markdown","permalink":"http://wwy010518.github.io/tags/Markdown/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"MVC","slug":"MVC","permalink":"http://wwy010518.github.io/tags/MVC/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://wwy010518.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"C#","slug":"C","permalink":"http://wwy010518.github.io/tags/C/"}]}